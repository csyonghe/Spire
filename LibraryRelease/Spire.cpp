/***********************************************************************

Spire - The MIT License (MIT)
Copyright (c) 2016, Carnegie Mellon University

Developers: Yong He, Haomin Long

Permission is hereby granted, free of charge, to any person obtaining a 
copy of this software and associated documentation files (the "Software"), 
to deal in the Software without restriction, including without limitation 
the rights to use, copy, modify, merge, publish, distribute, sublicense, 
and/or sell copies of the Software, and to permit persons to whom the 
Software is furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in 
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR 
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, 
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL 
THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER 
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING 
FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER 
DEALINGS IN THE SOFTWARE.


========================================================================
WARNING: THIS FILE IS AUTOMATICALLY GENERATED. DO NOT MODIFY
***********************************************************************/

/***********************************************************************
CORELIB\COMMON.H
***********************************************************************/
#ifndef CORE_LIB_COMMON_H
#define CORE_LIB_COMMON_H

#include <cstdint>

#ifdef __GNUC__
#define CORE_LIB_ALIGN_16(x) x __attribute__((aligned(16)))
#else
#define CORE_LIB_ALIGN_16(x) __declspec(align(16)) x
#endif

#define VARIADIC_TEMPLATE

namespace CoreLib
{
	typedef int64_t Int64;
	typedef unsigned short Word;
#ifdef _M_X64
	typedef int64_t PtrInt;
#else
	typedef int PtrInt;
#endif
	namespace Basic
	{
		class Object
		{
		public:
			virtual ~Object()
			{}
		};

		template <typename T>
		inline T&& _Move(T & obj)
		{
			return static_cast<T&&>(obj);
		}

		template <typename T>
		inline void Swap(T & v0, T & v1)
		{
			T tmp = _Move(v0);
			v0 = _Move(v1);
			v1 = _Move(tmp);
		}
	}
}

#endif

/***********************************************************************
CORELIB\LIBMATH.H
***********************************************************************/
#ifndef CORE_LIB_MATH_H
#define CORE_LIB_MATH_H

#include <math.h>

namespace CoreLib
{
	namespace Basic
	{
		class Math
		{
		public:
			static const float Pi;
			template<typename T>
			static T Min(const T& v1, const T&v2)
			{
				return v1<v2?v1:v2;
			}
			template<typename T>
			static T Max(const T& v1, const T&v2)
			{
				return v1>v2?v1:v2;
			}
			template<typename T>
			static T Min(const T& v1, const T&v2, const T&v3)
			{
				return Min(v1, Min(v2, v3));
			}
			template<typename T>
			static T Max(const T& v1, const T&v2, const T&v3)
			{
				return Max(v1, Max(v2, v3));
			}
			template<typename T>
			static T Clamp(const T& val, const T& vmin, const T&vmax)
			{
				if (val < vmin) return vmin;
				else if (val > vmax) return vmax;
				else return val;
			}

			static inline int FastFloor(float x)
			{
				int i = (int)x;
				return i - (i > x);
			}

			static inline int FastFloor(double x)
			{
				int i = (int)x;
				return i - (i > x);
			}

			static inline int IsNaN(float x)
			{
#ifdef _M_X64
				return _isnanf(x);
#else
				return isnan(x);
#endif
			}

			static inline int IsInf(float x)
			{
				return isinf(x);
			}

			static inline unsigned int Ones32(register unsigned int x)
			{
				/* 32-bit recursive reduction using SWAR...
					but first step is mapping 2-bit values
					into sum of 2 1-bit values in sneaky way
				*/
				x -= ((x >> 1) & 0x55555555);
				x = (((x >> 2) & 0x33333333) + (x & 0x33333333));
				x = (((x >> 4) + x) & 0x0f0f0f0f);
				x += (x >> 8);
				x += (x >> 16);
				return(x & 0x0000003f);
			}

			static inline unsigned int Log2Floor(register unsigned int x)
			{
				x |= (x >> 1);
				x |= (x >> 2);
				x |= (x >> 4);
				x |= (x >> 8);
				x |= (x >> 16);
				return(Ones32(x >> 1));
			}

			static inline unsigned int Log2Ceil(register unsigned int x)
			{
				int y = (x & (x - 1));
				y |= -y;
				y >>= (32 - 1);
				x |= (x >> 1);
				x |= (x >> 2);
				x |= (x >> 4);
				x |= (x >> 8);
				x |= (x >> 16);
				return(Ones32(x >> 1) - y);
			}
			/*
			static inline int Log2(float x)
			{
				unsigned int ix = (unsigned int&)x;
				unsigned int exp = (ix >> 23) & 0xFF;
				int log2 = (unsigned int)(exp) - 127;

				return log2;
			}
			*/
		};
		inline int FloatAsInt(float val)
		{
			union InterCast
			{
				float fvalue;
				int ivalue;
			} cast;
			cast.fvalue = val;
			return cast.ivalue;
		}
		inline float IntAsFloat(int val)
		{
			union InterCast
			{
				float fvalue;
				int ivalue;
			} cast;
			cast.ivalue = val;
			return cast.fvalue;
		}

		inline unsigned short FloatToHalf(float val)
		{
			int x = *(int*)&val;
			unsigned short bits = (x >> 16) & 0x8000;
			unsigned short m = (x >> 12) & 0x07ff;
			unsigned int e = (x >> 23) & 0xff;
			if (e < 103)
				return bits;
			if (e > 142)
			{
				bits |= 0x7c00u;
				bits |= e == 255 && (x & 0x007fffffu);
				return bits;
			}
			if (e < 113)
			{
				m |= 0x0800u;
				bits |= (m >> (114 - e)) + ((m >> (113 - e)) & 1);
				return bits;
			}
			bits |= ((e - 112) << 10) | (m >> 1);
			bits += m & 1;
			return bits;
		}

		inline float HalfToFloat(unsigned short input)
		{
			union InterCast
			{
				float fvalue;
				int ivalue;
				InterCast() = default;
				InterCast(int ival)
				{
					ivalue = ival;
				}
			};
			static const InterCast magic = InterCast((127 + (127 - 15)) << 23);
			static const InterCast was_infnan = InterCast((127 + 16) << 23);
			InterCast o;
			o.ivalue = (input & 0x7fff) << 13;     // exponent/mantissa bits
			o.fvalue *= magic.fvalue;                 // exponent adjust
			if (o.fvalue >= was_infnan.fvalue)        // make sure Inf/NaN survive
				o.ivalue |= 255 << 23;
			o.ivalue |= (input & 0x8000) << 16;    // sign bit
			return o.fvalue;
		}

		class Random
		{
		private:
			unsigned int seed;
		public:
			Random(int seed)
			{
				this->seed = seed;
			}
			int Next() // random between 0 and RandMax (currently 0x7fff)
			{
				return (((seed = seed * 214013L + 2531011L) >> 16) & 0x7fff);
			}
			int Next(int min, int max) // inclusive min, exclusive max
			{
				unsigned int a = ((seed = seed * 214013L + 2531011L) & 0xFFFF0000);
				unsigned int b = ((seed = seed * 214013L + 2531011L) >> 16);
				unsigned int r = a + b;
				return min + r % (max - min);
			}
			float NextFloat()
			{
				return ((Next() << 15) + Next()) / ((float)(1 << 30));
			}
			float NextFloat(float valMin, float valMax)
			{
				return valMin + (valMax - valMin) * NextFloat();
			}
			static int RandMax()
			{
				return 0x7fff;
			}
		};
	}
}

#endif 

/***********************************************************************
CORELIB\WIDECHAR.H
***********************************************************************/
#ifndef WIDE_CHAR_H
#define WIDE_CHAR_H

void MByteToWideChar(wchar_t * buffer, int bufferSize, const char * str, int length);
char * WideCharToMByte(const wchar_t * buffer, int length);
wchar_t * MByteToWideChar(const char * buffer, int length);

#endif

/***********************************************************************
CORELIB\TYPETRAITS.H
***********************************************************************/
#ifndef CORELIB_TYPETRAITS_H
#define CORELIB_TYPETRAITS_H

namespace CoreLib
{
	namespace Basic
	{
		struct TraitResultYes
		{
			char x;
		};
		struct TraitResultNo
		{
			char x[2];
		};

		template <typename B, typename D>
		struct IsBaseOfTraitHost
		{
			operator B*() const { return nullptr; }
			operator D*() { return nullptr; }
		};

		template <typename B, typename D>
		struct IsBaseOf
		{
			template <typename T>
			static TraitResultYes Check(D*, T) { return TraitResultYes(); }
			static TraitResultNo Check(B*, int) { return TraitResultNo(); }
			static constexpr bool Value = sizeof(Check(IsBaseOfTraitHost<B, D>(), int())) == sizeof(TraitResultYes);
		};

		template<bool B, class T = void>
		struct EnableIf {};

		template<class T>
		struct EnableIf<true, T> { typedef T type; };

		template <typename B, typename D>
		struct IsConvertible
		{
			static TraitResultYes Use(B) {};
			static TraitResultNo Use(...) {};
			static constexpr bool Value = sizeof(Use(*(D*)(nullptr))) == sizeof(TraitResultYes);
		};
	}
}

#endif

/***********************************************************************
CORELIB\SMARTPOINTER.H
***********************************************************************/
#ifndef FUNDAMENTAL_LIB_SMART_POINTER_H
#define FUNDAMENTAL_LIB_SMART_POINTER_H


namespace CoreLib
{
	namespace Basic
	{
		class RefPtrDefaultDestructor
		{
		public:
			template<typename T>
			void operator ()(T * ptr)
			{
				delete ptr;
			}
		};

		class RefPtrArrayDestructor
		{
		public:
			template<typename T>
			void operator() (T * ptr)
			{
				delete [] ptr;
			}
		};

		class ReferenceCounted
		{
			template<typename T, bool b, typename Destructor>
			friend class RefPtrImpl;
		private:
			int _refCount = 0;
		public:
			ReferenceCounted() {}
			ReferenceCounted(const ReferenceCounted &)
			{
				_refCount = 0;
			}
		};


		class RefObject : public ReferenceCounted
		{
		public:
			virtual ~RefObject()
			{}
		};

		template<typename T, bool HasBuiltInCounter, typename Destructor>
		class RefPtrImpl
		{
		};

		template<typename T, typename Destructor = RefPtrDefaultDestructor>
		using RefPtr = RefPtrImpl<T, IsBaseOf<ReferenceCounted, T>::Value, Destructor>;

		template<typename T, typename Destructor>
		class RefPtrImpl<T, 0, Destructor>
		{
			template<typename T1, bool b, typename Destructor1>
			friend class RefPtrImpl;
		private:
			T * pointer;
			int * refCount;
			
		public:
			RefPtrImpl()
			{
				pointer = 0;
				refCount = 0;
			}
			RefPtrImpl(T * ptr)
				: pointer(0), refCount(0)
			{
				this->operator=(ptr);
			}
			RefPtrImpl(const RefPtrImpl<T, 0, Destructor> & ptr)
				: pointer(0), refCount(0)
			{
				this->operator=(ptr);
			}
			RefPtrImpl(RefPtrImpl<T, 0, Destructor> && str)
				: pointer(0), refCount(0)
			{
				this->operator=(static_cast<RefPtrImpl<T, 0, Destructor> &&>(str));
			}

			template <typename U>
			RefPtrImpl(const RefPtrImpl<U, 0, Destructor>& ptr,
				typename EnableIf<IsConvertible<T*, U*>::Value, void>::type * = 0)
				: pointer(0), refCount(0)
			{
				pointer = ptr.pointer;
				if (ptr)
				{
					refCount = ptr.refCount;
					(*refCount)++;
				}
				else
					refCount = 0;
			}

			template <typename U>
			typename EnableIf<IsConvertible<T*, U*>::value, RefPtrImpl<T, 0, Destructor>>::type&
				operator=(const RefPtrImpl<U,0,Destructor> & ptr)
			{
				Unreference();

				pointer = ptr;
				if (ptr)
				{
					refCount = ptr.refCount;
					(*refCount)++;
				}
				else
					refCount = 0;
				return *this;
			}

			RefPtrImpl<T, 0, Destructor>& operator=(const RefPtrImpl<T, 0, Destructor> & ptr)
			{
				Unreference();
				pointer = ptr.pointer;
				if (ptr)
				{
					refCount = ptr.refCount;
					(*refCount)++;
				}
				else
					refCount = 0;
				return *this;
			}

			RefPtrImpl<T, 0, Destructor>& operator=(T * ptr)
			{
				if (ptr != pointer)
				{
					Unreference();

					pointer = ptr;
					if (ptr)
					{
						refCount = new int;
						(*refCount) = 1;
					}
					else
						refCount = 0;
				}
				return *this;
			}
			int GetHashCode()
			{
				return (int)(long long)(void*)pointer;
			}
			bool operator == (const T * ptr) const
			{
				return pointer == ptr;
			}
			bool operator != (const T * ptr) const
			{
				return pointer != ptr;
			}
			template<typename U>
			bool operator == (const RefPtr<U, Destructor> & ptr) const
			{
				return pointer == ptr.pointer;
			}
			template<typename U>
			bool operator != (const RefPtr<U, Destructor> & ptr) const
			{
				return pointer != ptr.pointer;
			}
			template<typename U>
			RefPtrImpl<U, 0, Destructor> As() const
			{
				RefPtrImpl<U, 0, Destructor> result;
				if (pointer)
				{
					result.pointer = dynamic_cast<U*>(pointer);
					if (result.pointer)
					{
						result.refCount = refCount;
						(*refCount)++;
					}
				}
				return result;
			}

			T* operator +(int offset) const
			{
				return pointer+offset;
			}
			T& operator [](int idx) const
			{
				return *(pointer + idx);
			}
			RefPtrImpl<T, 0, Destructor>& operator=(RefPtrImpl<T, 0, Destructor> && ptr)
			{
				if(ptr.pointer != pointer)
				{
					Unreference();
					pointer = ptr.pointer;
					refCount = ptr.refCount;
					ptr.pointer = 0;
					ptr.refCount = 0;
				}
				return *this;
			}
			T* Release()
			{
				if(pointer)
				{
					if((*refCount) > 1)
					{
						(*refCount)--;
					}
					else
					{
						delete refCount;
					}
				}
				auto rs = pointer;
				refCount = 0;
				pointer = 0;
				return rs;
			}
			~RefPtrImpl()
			{
				Unreference();
			}

			void Unreference()
			{
				if(pointer)
				{
					if((*refCount) > 1)
					{
						(*refCount)--;
					}
					else
					{
						Destructor destructor;
						destructor(pointer);
						delete refCount;
					}
				}
			}
			T & operator *() const
			{
				return *pointer;
			}
			T * operator->() const
			{
				return pointer;
			}
			T * Ptr() const
			{
				return pointer;
			}
		public:
			explicit operator bool() const 
			{
				if (pointer)
					return true;
				else
					return false;
			}
		};


		template<typename T, typename Destructor>
		class RefPtrImpl<T, 1, Destructor>
		{
			template<typename T1, bool b, typename Destructor1>
			friend class RefPtrImpl;
			
		private:
			T * pointer;
		public:
			RefPtrImpl()
			{
				pointer = 0;
			}
			RefPtrImpl(T * ptr)
				: pointer(0)
			{
				this->operator=(ptr);
			}
			RefPtrImpl(const RefPtrImpl<T, 1, Destructor> & ptr)
				: pointer(0)
			{
				this->operator=(ptr);
			}
			RefPtrImpl(RefPtrImpl<T, 1, Destructor> && str)
				: pointer(0)
			{
				this->operator=(static_cast<RefPtrImpl<T, 1, Destructor> &&>(str));
			}
			template <typename U>
				RefPtrImpl(const RefPtrImpl<U, 1, Destructor>& ptr,
					typename EnableIf<IsConvertible<T*, U*>::Value, void>::type * = 0)
				: pointer(0)
			{
				pointer = ptr.pointer;
				if (ptr)
				{
					ptr->_refCount++;
				}
			}

			template <typename U>
			typename EnableIf<IsConvertible<T*, U*>::value, RefPtrImpl<T, 1, Destructor>&>::type
				operator=(const RefPtrImpl<U, 1, Destructor> & ptr)
			{
				Unreference();

				pointer = ptr.pointer;
				if (ptr)
				{
					ptr->_refCount++;
				}
				return *this;
			}
			RefPtrImpl<T, 1, Destructor>& operator=(T * ptr)
			{
				if (ptr != pointer)
				{
					Unreference();

					pointer = ptr;
					if (ptr)
					{
						ptr->_refCount++;
					}
				}
				return *this;
			}
			RefPtrImpl<T, 1, Destructor>& operator=(const RefPtrImpl<T, 1, Destructor> & ptr)
			{
				if (ptr.pointer != pointer)
				{
					Unreference();
					pointer = ptr.pointer;
					if (pointer)
						pointer->_refCount++;
				}
				return *this;
			}
			int GetHashCode()
			{
				return (int)(long long)(void*)pointer;
			}
			bool operator == (const T * ptr) const
			{
				return pointer == ptr;
			}
			bool operator != (const T * ptr) const
			{
				return pointer != ptr;
			}
			template<typename U>
			bool operator == (const RefPtr<U, Destructor> & ptr) const
			{
				return pointer == ptr.pointer;
			}
			template<typename U>
			bool operator != (const RefPtr<U, Destructor> & ptr) const
			{
				return pointer != ptr.pointer;
			}
			template<typename U>
			RefPtrImpl<U, 1, Destructor> As() const
			{
				RefPtrImpl<U, 1, Destructor> result;
				if (pointer)
				{
					result.pointer = dynamic_cast<U*>(pointer);
					if (result.pointer)
					{
						result.pointer->_refCount++;
					}
				}
				return result;
			}
			T* operator +(int offset) const
			{
				return pointer + offset;
			}
			T& operator [](int idx) const
			{
				return *(pointer + idx);
			}
			RefPtrImpl<T, 1, Destructor>& operator=(RefPtrImpl<T, 1, Destructor> && ptr)
			{
				if (ptr.pointer != pointer)
				{
					Unreference();
					pointer = ptr.pointer;
					ptr.pointer = nullptr;
				}
				return *this;
			}
			T* Release()
			{
				if (pointer)
				{
					pointer->_refCount--;
				}
				auto rs = pointer;
				pointer = 0;
				return rs;
			}
			~RefPtrImpl()
			{
				Unreference();
			}

			void Unreference()
			{
				if (pointer)
				{
					if (pointer->_refCount > 1)
					{
						pointer->_refCount--;
					}
					else
					{
						Destructor destructor;
						destructor(pointer);
					}
				}
			}
			T & operator *() const
			{
				return *pointer;
			}
			T * operator->() const
			{
				return pointer;
			}
			T * Ptr() const
			{
				return pointer;
			}
		public:
			explicit operator bool() const
			{
				if (pointer)
					return true;
				else
					return false;
			}
		};
	}
}

#endif

/***********************************************************************
CORELIB\SECURECRT.H
***********************************************************************/
#ifndef _MSC_VER
#ifndef CORE_LIB_SECURE_CRT_H
#define CORE_LIB_SECURE_CRT_H
#include <stdarg.h>
#include <stdlib.h>
#include <sstream>
#include <cstring>
#ifndef _ismbblead

inline bool _ismbblead(char c)
{
	return (0x80<= c) && (c < 0xa0 || 0xe0 <= c);
}

#endif

inline void memcpy_s(void *dest, size_t numberOfElements, const void * src, size_t count)
{
	memcpy(dest, src, count);
}

#define _TRUNCATE ((size_t)-1)
#define _stricmp strcasecmp

inline void fopen_s(FILE**f, const char * fileName, const char * mode)
{
	*f = fopen(fileName, mode);
}

inline void wcstombs_s(size_t * pReturnValue, char *mbstr, size_t sizeInWords, const wchar_t *wcstr, size_t count)
{
	if (count == _TRUNCATE)
		count = sizeInWords;
	*pReturnValue = wcstombs(mbstr, wcstr, count);
}

inline void mbstowcs_s(size_t * pReturnValue, wchar_t *wcstr, size_t sizeInWords, const char *mbstr, size_t count)
{
	if (count == _TRUNCATE)
		count = sizeInWords;
	*pReturnValue = mbstowcs(wcstr, mbstr, count);
}

inline size_t fread_s(void * buffer, size_t bufferSize, size_t elementSize, size_t count, FILE * stream)
{
	return fread(buffer, elementSize, count, stream);
}

inline int _itow_s(int value, wchar_t * buffer, size_t sizeInCharacters, int radix)
{
	std::wstringstream s;
	s<<value;
	auto str = s.str();
	memset(buffer, 0, sizeInCharacters * sizeof(wchar_t));
	memcpy(buffer, str.c_str(), str.length() * sizeof(wchar_t));
	return 0;
}

inline int _i64tow_s(long long value, wchar_t * buffer, size_t sizeInCharacters, int radix)
{
	std::wstringstream s;
	s<<value;
	auto str = s.str();
	memset(buffer, 0, sizeInCharacters * sizeof(wchar_t));
	memcpy(buffer, str.c_str(), str.length() * sizeof(wchar_t));
	return 0;
}

inline size_t wcsnlen_s(const wchar_t * str, size_t numberofElements)
{
	return wcsnlen(str, numberofElements);
}

inline size_t strnlen_s(const char * str, size_t numberofElements)
{
	return strnlen(str, numberofElements);
}

inline int swprintf_s(wchar_t * buffer, size_t sizeOfBuffer, const wchar_t * format, ...)
{
	va_list argptr;
	va_start(argptr, format);
	int rs = swprintf(buffer, sizeOfBuffer, format, argptr);
	va_end(argptr);
	return rs;
}

inline void wcscpy_s(wchar_t * strDestination, size_t numberOfElements, const wchar_t * strSource)
{
	wcscpy(strDestination, strSource);
}

inline void wcsncpy_s(wchar_t * strDestination, size_t numberOfElements, const wchar_t * strSource, size_t count)
{
	wcsncpy(strDestination, strSource, count);
	//wcsncpy(strDestination, strSource, count);
}

#endif
#endif

/***********************************************************************
CORELIB\LIBSTRING.H
***********************************************************************/
#ifndef FUNDAMENTAL_LIB_STRING_H
#define FUNDAMENTAL_LIB_STRING_H
#include <string.h>
#include <cstdlib>
#include <stdio.h>

namespace CoreLib
{
	namespace Basic
	{
		class _EndLine
		{};
		extern _EndLine EndLine;
		class String
		{
			friend class StringBuilder;
		private:
			RefPtr<wchar_t, RefPtrArrayDestructor> buffer;
			char * multiByteBuffer;
			int length;
			void Free()
			{
				if (buffer)
					buffer = 0;
				if (multiByteBuffer)
					delete [] multiByteBuffer;
				buffer = 0;
				multiByteBuffer = 0;
				length = 0;
			}
		public:
			static String FromBuffer(RefPtr<wchar_t, RefPtrArrayDestructor> buffer, int len)
			{
				String rs;
				rs.buffer = buffer;
				rs.length = len;
				return rs;
			}
			String()
				:buffer(0), multiByteBuffer(0), length(0)
			{
			}
			String(const wchar_t * str) :buffer(0), multiByteBuffer(0), length(0)
			{
				this->operator=(str);
			}
			String(const wchar_t ch)
				:buffer(0), multiByteBuffer(0), length(0)
			{
				wchar_t arr[] = {ch, 0};
				*this = String(arr);
			}
			const wchar_t * begin() const
			{
				return buffer.Ptr();
			}
			const wchar_t * end() const
			{
				return buffer.Ptr() + length;
			}
			String(int val, int radix = 10)
				:buffer(0), multiByteBuffer(0), length(0)
			{
				buffer = new wchar_t[33];
				_itow_s(val, buffer.Ptr(), 33, radix);
				length = (int)wcsnlen_s(buffer.Ptr(), 33);
			}
			String(long long val, int radix = 10)
				:buffer(0), multiByteBuffer(0), length(0)
			{
				buffer = new wchar_t[65];
				_i64tow_s(val, buffer.Ptr(), 65, radix);
				length = (int)wcsnlen_s(buffer.Ptr(), 65);
			}
			String(float val, const wchar_t * format = L"%g")
				:buffer(0), multiByteBuffer(0), length(0)
			{
				buffer = new wchar_t[128];
				swprintf_s(buffer.Ptr(), 128, format, val);
				length = (int)wcsnlen_s(buffer.Ptr(), 128);
			}
			String(double val, const wchar_t * format = L"%g")
				:buffer(0), multiByteBuffer(0), length(0)
			{
				buffer = new wchar_t[128];
				swprintf_s(buffer.Ptr(), 128, format, val);
				length = (int)wcsnlen_s(buffer.Ptr(), 128);
			}
			String(const char * str)
				:buffer(0), multiByteBuffer(0), length(0)
			{
				if (str)
				{
					buffer = MByteToWideChar(str, (int)strlen(str));
					if (buffer)
						length = (int)wcslen(buffer.Ptr());
					else
						length = 0;
				}
			}
			String(const String & str)
				:buffer(0), multiByteBuffer(0), length(0)
			{				
				this->operator=(str);
			}
			String(String&& other)
				:buffer(0), multiByteBuffer(0), length(0)
			{
				this->operator=(static_cast<String&&>(other));
			}
			~String()
			{
				Free();
			}
			String & operator=(const wchar_t * str)
			{
				Free();
				if (str)
				{
					length = (int)wcslen(str);
					buffer = new wchar_t[length + 1];
					wcscpy_s(buffer.Ptr(), length + 1, str);
				}
				return *this;
			}
			String & operator=(const String & str)
			{
				if (str.buffer == buffer)
					return *this;
				Free();
				if (str.buffer)
				{
					length = str.length;
					buffer = str.buffer;
					multiByteBuffer = 0;
				}
				return *this;
			}
			String & operator=(String&& other)
			{
				if (this != &other)
				{
					Free();
					buffer = _Move(other.buffer);
					length = other.length;
					multiByteBuffer = other.multiByteBuffer;
					other.buffer = 0;
					other.length = 0;
					other.multiByteBuffer = 0;
				}
				return *this;
			}
			wchar_t operator[](int id) const
			{
#if _DEBUG
				if (id < 0 || id >= length)
					throw "Operator[]: index out of range.";
#endif
				return buffer.Ptr()[id];
			}

			friend String StringConcat(const wchar_t * lhs, int leftLen, const wchar_t * rhs, int rightLen);
			friend String operator+(const wchar_t*op1, const String & op2);
			friend String operator+(const String & op1, const wchar_t * op2);
			friend String operator+(const String & op1, const String & op2);

			String TrimStart() const
			{
				if(!buffer)
					return *this;
				int startIndex = 0;
				while (startIndex < length && 
					(buffer[startIndex] == L' ' || buffer[startIndex] == L'\t' || buffer[startIndex] == L'\r' || buffer[startIndex] == L'\n'))
						startIndex++;
				return String(buffer + startIndex);
			}

			String TrimEnd() const
			{
				if(!buffer)
					return *this;

				int endIndex = length - 1;
				while (endIndex >= 0 &&
					(buffer[endIndex] == L' ' || buffer[endIndex] == L'\t' || buffer[endIndex] == L'\r' || buffer[endIndex] == L'\n'))
					endIndex--;
				String res;
				res.length = endIndex + 1;
				res.buffer = new wchar_t[endIndex + 2];
				wcsncpy_s(res.buffer.Ptr(), endIndex + 2, buffer.Ptr(), endIndex + 1);
				return res;
			}

			String Trim() const
			{
				if(!buffer)
					return *this;

				int startIndex = 0;
				while (startIndex < length && 
					(buffer[startIndex] == L' ' || buffer[startIndex] == L'\t'))
						startIndex++;
				int endIndex = length - 1;
				while (endIndex >= startIndex &&
					(buffer[endIndex] == L' ' || buffer[endIndex] == L'\t'))
					endIndex--;

				String res;
				res.length = endIndex - startIndex + 1;
				res.buffer = new wchar_t[res.length + 1];
				memcpy(res.buffer.Ptr(), buffer + startIndex, sizeof(wchar_t) * res.length);
				res.buffer[res.length] = L'\0';
				return res;
			}

			String SubString(int id, int len) const
			{
				if (len == 0)
					return L"";
				if (id + len > length)
					len = length - id;
#if _DEBUG
				if (id < 0 || id >= length || (id + len) > length)
					throw "SubString: index out of range.";
				if (len < 0)
					throw "SubString: length less than zero.";
#endif
				String res;
				res.buffer = new wchar_t[len + 1];
				res.length = len;
				wcsncpy_s(res.buffer.Ptr(), len + 1, buffer + id, len);
				res.buffer[len] = 0;
				return res;
			}

			wchar_t * Buffer() const
			{
				if (buffer)
					return buffer.Ptr();
				else
					return (wchar_t*)L"";
			}

			char * ToMultiByteString(int * len = 0) const
			{
				if (!buffer)
					return (char*)"";
				else
				{
					if (multiByteBuffer)
						return multiByteBuffer;
					((String*)this)->multiByteBuffer = WideCharToMByte(buffer.Ptr(), length);
					if (len)
						*len = (int)strnlen_s(multiByteBuffer, length*2);
					return multiByteBuffer;
					/*if (multiByteBuffer)
						return multiByteBuffer;
					size_t requiredBufferSize;
					requiredBufferSize = WideCharToMultiByte(CP_OEMCP, NULL, buffer.Ptr(), length, 0, 0, NULL, NULL)+1;
					if (len)
						*len = requiredBufferSize-1;
					if (requiredBufferSize)
					{
						multiByteBuffer = new char[requiredBufferSize];
						WideCharToMultiByte(CP_OEMCP, NULL, buffer.Ptr(), length, multiByteBuffer, requiredBufferSize, NULL, NULL);
						multiByteBuffer[requiredBufferSize-1] = 0;
						return multiByteBuffer;
					}
					else
						return "";*/
				}
			}

			bool Equals(const String & str, bool caseSensitive = true)
			{
				if (!buffer)
					return (str.buffer == 0);
				if (caseSensitive)
					return (wcscmp(buffer.Ptr(), str.buffer.Ptr()) == 0);
				else
				{
#ifdef _MSC_VER
					return (_wcsicmp(buffer.Ptr(), str.buffer.Ptr()) == 0);
#else
					return (wcscasecmp(buffer.Ptr(), str.buffer.Ptr()) == 0);
#endif
				}
			}

			bool operator==(const String & str) const
			{
				if (!buffer)
					return (str.buffer == 0 || wcscmp(str.buffer.Ptr(), L"")==0);
				if (!str.buffer)
					return buffer == nullptr || wcscmp(buffer.Ptr(), L"") == 0;
				return (wcscmp(buffer.Ptr(), str.buffer.Ptr()) == 0);
			}
			bool operator!=(const String & str) const
			{
				if (!buffer)
					return (str.buffer != 0 && wcscmp(str.buffer.Ptr(), L"") != 0);
				if (str.buffer.Ptr() == 0)
					return length != 0;
				return (wcscmp(buffer.Ptr(), str.buffer.Ptr()) != 0);
			}
			bool operator>(const String & str) const
			{
				if (!buffer)
					return false;
				if (!str.buffer)
					return buffer.Ptr() != nullptr && length != 0;
				return (wcscmp(buffer.Ptr(), str.buffer.Ptr()) > 0);
			}
			bool operator<(const String & str) const
			{
				if (!buffer)
					return (str.buffer != 0);
				if (!str.buffer)
					return false;
				return (wcscmp(buffer.Ptr(), str.buffer.Ptr()) < 0);
			}
			bool operator>=(const String & str) const
			{
				if (!buffer)
					return (str.buffer == 0);
				if (!str.buffer)
					return length == 0;
				int res = wcscmp(buffer.Ptr(), str.buffer.Ptr());
				return (res > 0 || res == 0);
			}
			bool operator<=(const String & str) const
			{
				if (!buffer)
					return true;
				if (!str.buffer)
					return length > 0;
				int res = wcscmp(buffer.Ptr(), str.buffer.Ptr());
				return (res < 0 || res == 0);
			}

			String ToUpper() const
			{
				if(!buffer)
					return *this;
				String res;
				res.length = length;
				res.buffer = new wchar_t[length + 1];
				for (int i = 0; i <= length; i++)
					res.buffer[i] = (buffer[i] >= L'a' && buffer[i] <= L'z')? 
									(buffer[i] - L'a' + L'A') : buffer[i];
				return res;
			}

			String ToLower() const
			{
				if(!buffer)
					return *this;
				String res;
				res.length = length;
				res.buffer = new wchar_t[length + 1];
				for (int i = 0; i <= length; i++)
					res.buffer[i] = (buffer[i] >= L'A' && buffer[i] <= L'Z')? 
									(buffer[i] - L'A' + L'a') : buffer[i];
				return res;
			}
			
			int Length() const
			{
				return length;
			}

			int IndexOf(const wchar_t * str, int id) const // String str
			{
				if(!buffer)
					return -1;
				if (id < 0 || id >= length)
					return -1;
				auto findRs = wcsstr(buffer + id, str);
				int res = findRs ? (int)(findRs - buffer.Ptr()) : -1;
				if (res >= 0)
					return res;
				else
					 return -1;
			}
			
			int IndexOf(const String & str, int id) const
			{
				return IndexOf(str.buffer.Ptr(), id);
			}

			int IndexOf(const wchar_t * str) const
			{
				return IndexOf(str, 0);
			}

			int IndexOf(const String & str) const
			{
				return IndexOf(str.buffer.Ptr(), 0);
			}

			int IndexOf(wchar_t ch, int id) const
			{
#if _DEBUG
				if (id < 0 || id >= length)
					throw "SubString: index out of range.";
#endif
				if(!buffer)
					return -1;
				for (int i = id; i < length; i++)
					if (buffer[i] == ch)
						return i;
				return -1;
			}

			int IndexOf(wchar_t ch) const
			{
				return IndexOf(ch, 0);
			}

			int LastIndexOf(wchar_t ch) const
			{
				for (int i = length-1; i>=0; i--)
					if (buffer[i] == ch)
						return i;
				return -1;
			}

			bool StartsWith(const wchar_t * str) const // String str
			{
				if(!buffer)
					return false;
				int strLen =(int) wcslen(str);
				if (strLen > length)
					return false;
				for (int i = 0; i < strLen; i++)
					if (str[i] != buffer[i])
						return false;
				return true;
			}

			bool StartsWith(const String & str) const
			{
				return StartsWith((const wchar_t*)str.buffer.Ptr());
			}

			bool EndsWith(wchar_t * str)  const // String str
			{
				if(!buffer)
					return false;
				int strLen = (int)wcslen(str);
				if (strLen > length)
					return false;
				for (int i = strLen - 1; i >= 0; i--)
					if (str[i] != buffer[length - strLen + i])
						return false;
				return true;
			}

			bool EndsWith(const String & str) const
			{
				return EndsWith(str.buffer.Ptr());
			}

			bool Contains(const wchar_t * str) const // String str
			{
				if(!buffer)
					return false;
				return (IndexOf(str) >= 0)? true : false;
			}

			bool Contains(const String & str) const
			{
				return Contains(str.buffer.Ptr());
			}

			int GetHashCode() const
			{
				if (!buffer)
					return 0;
				int hash = 0;
				int c;
				wchar_t * str = buffer.Ptr();
				c = *str++;
				while (c)
				{
					hash = c + (hash << 6) + (hash << 16) - hash;
					c = *str++;
				}
				return hash;
			}
			String PadLeft(wchar_t ch, int length);
			String PadRight(wchar_t ch, int length);
			String MD5() const;
			String ReplaceAll(String src, String dst) const;
		};

		class StringBuilder
		{
		private:
			wchar_t * buffer;
			int length;
			int bufferSize;
			static const int InitialSize = 512;
		public:
			StringBuilder(int bufferSize = 1024)
				:buffer(0), length(0), bufferSize(0)
			{
				buffer = new wchar_t[InitialSize]; // new a larger buffer 
				buffer[0] = L'\0';
				length = 0;
				bufferSize = InitialSize;
			}
			~StringBuilder()
			{
				if(buffer)
					delete [] buffer;
			}
			void EnsureCapacity(int size)
			{
				if(bufferSize < size)
				{
					wchar_t * newBuffer = new wchar_t[size + 1];
					if(buffer)
					{
						wcscpy_s(newBuffer, size + 1, buffer);
						delete [] buffer;
					}
					buffer = newBuffer;
					bufferSize = size;
				}
			}

			//void Append(wchar_t * str)
			//{
			//	length += wcslen(str);
			//	if(bufferSize < length + 1)
			//	{
			//		int newBufferSize = InitialSize;
			//		while(newBufferSize < length + 1)
			//			newBufferSize <<= 1;
			//		wchar_t * newBuffer = new wchar_t[newBufferSize];
			//		if (buffer)
			//		{
			//			wcscpy_s(newBuffer, newBufferSize, buffer);
			//			delete [] buffer;
			//		}
			//		wcscat_s(newBuffer, newBufferSize, str); // use memcpy, manually deal with zero terminator
			//		buffer = newBuffer;
			//		bufferSize = newBufferSize;
			//	}
			//	else
			//	{
			//		wcscat_s(buffer, bufferSize, str); // use memcpy, manually deal with zero terminator
			//	}
			//}
			StringBuilder & operator << (const wchar_t * str)
			{
				Append(str, (int)wcslen(str));
				return *this;
			}
			StringBuilder & operator << (const String & str)
			{
				Append(str);
				return *this;
			}
			StringBuilder & operator << (const _EndLine)
			{
				Append(L'\n');
				return *this;
			}
			void Append(wchar_t ch)
			{
				Append(&ch, 1);
			}
			void Append(int value, int radix = 10)
			{
				wchar_t vBuffer[33];
				_itow_s(value, vBuffer, 33, radix);
				Append(vBuffer);
			}
			void Append(const String & str)
			{
				Append(str.Buffer(), str.Length());
			}
			void Append(const wchar_t * str)
			{
				Append(str, (int)wcslen(str));
			}
			void Append(const wchar_t * str, int strLen)
			{
				int newLength = length + strLen;
				if(bufferSize < newLength + 1)
				{
					int newBufferSize = InitialSize;
					while(newBufferSize < newLength + 1)
						newBufferSize <<= 1;
					wchar_t * newBuffer = new wchar_t[newBufferSize];
					if (buffer)
					{
						//wcscpy_s(newBuffer, newBufferSize, buffer);
						memcpy(newBuffer, buffer, sizeof(wchar_t) * length);
						delete [] buffer;
					}
					//wcscat_s(newBuffer, newBufferSize, str);
					memcpy(newBuffer + length, str, sizeof(wchar_t) * strLen);
					newBuffer[newLength] = L'\0';
					buffer = newBuffer;
					bufferSize = newBufferSize;
				}
				else
				{
					memcpy(buffer + length, str, sizeof(wchar_t) * strLen);
					buffer[newLength] = L'\0';
					//wcscat_s(buffer, bufferSize, str); // use memcpy, manually deal with zero terminator
				}
				length = newLength;
			}

			int Capacity()
			{
				return bufferSize;
			}

			wchar_t * Buffer()
			{
				return buffer;
			}

			int Length()
			{
				return length;
			}

			String ToString()
			{
				return String(buffer);
			}

			String ProduceString()
			{
				String rs;
				rs.buffer = buffer;
				rs.length = length;
				buffer = 0;
				length = 0;
				return rs;

			}

			String GetSubString(int start, int count)
			{
				String rs;
				rs.buffer = new wchar_t[count+1];
				rs.length = count;
				wcsncpy_s(rs.buffer.Ptr(), count+1, buffer+start, count);
				rs.buffer[count] = 0;
				return rs;
			}

			void Remove(int id, int len)
			{
#if _DEBUG
				if (id >= length || id < 0)
					throw "Remove: Index out of range.";
				if(len < 0)
					throw "Remove: remove length smaller than zero.";
#endif
				int actualDelLength = ((id + len) >= length)? (length - id) : len;
				for (int i = id + actualDelLength; i <= length; i++)
					buffer[i - actualDelLength] = buffer[i];
				length -= actualDelLength;
			}

			void Clear()
			{
				length = 0;
				if (buffer)
					buffer[0] = 0;
			}
		};

		int StringToInt(const String & str, int radix = 10);
		unsigned int StringToUInt(const String & str, int radix = 10);
		double StringToDouble(const String & str);

		
	}
}

#endif

/***********************************************************************
CORELIB\EXCEPTION.H
***********************************************************************/
#ifndef CORE_LIB_EXCEPTION_H
#define CORE_LIB_EXCEPTION_H


namespace CoreLib
{
	namespace Basic
	{
		class Exception : public Object
		{
		public:
			String Message;
			Exception()
			{}
			Exception(const String & message)
				: Message(message)
			{
			}
		};

		class IndexOutofRangeException : public Exception
		{
		public:
			IndexOutofRangeException()
			{}
			IndexOutofRangeException(const String & message)
				: Exception(message)
			{
			}

		};

		class InvalidOperationException : public Exception
		{
		public:
			InvalidOperationException()
			{}
			InvalidOperationException(const String & message)
				: Exception(message)
			{
			}

		};
		
		class ArgumentException : public Exception
		{
		public:
			ArgumentException()
			{}
			ArgumentException(const String & message)
				: Exception(message)
			{
			}

		};

		class KeyNotFoundException : public Exception
		{
		public:
			KeyNotFoundException()
			{}
			KeyNotFoundException(const String & message)
				: Exception(message)
			{
			}
		};
		class KeyExistsException : public Exception
		{
		public:
			KeyExistsException()
			{}
			KeyExistsException(const String & message)
				: Exception(message)
			{
			}
		};

		class NotSupportedException : public Exception
		{
		public:
			NotSupportedException()
			{}
			NotSupportedException(const String & message)
				: Exception(message)
			{
			}
		};

		class NotImplementedException : public Exception
		{
		public:
			NotImplementedException()
			{}
			NotImplementedException(const String & message)
				: Exception(message)
			{
			}
		};

		class InvalidProgramException : public Exception
		{
		public:
			InvalidProgramException()
			{}
			InvalidProgramException(const String & message)
				: Exception(message)
			{
			}
		};
	}
}

#endif

/***********************************************************************
CORELIB\ARRAYVIEW.H
***********************************************************************/
#ifndef CORE_LIB_ARRAY_VIEW_H
#define CORE_LIB_ARRAY_VIEW_H


namespace CoreLib
{
	namespace Basic
	{
		template<typename T>
		class ArrayView
		{
		private:
			T * _buffer;
			int _count;
			int stride;
		public:
			T* begin() const
			{
				return _buffer;
			}
			T* end() const
			{
				return (T*)((char*)_buffer + _count*stride);
			}
		public:
			ArrayView()
			{
				_buffer = 0;
				_count = 0;
			}
			ArrayView(const T & singleObj)
			{
				SetData((T*)&singleObj, 1, sizeof(T));
			}
			ArrayView(T * buffer, int count)
			{
				SetData(buffer, count, sizeof(T));
			}
			ArrayView(void * buffer, int count, int _stride)
			{
				SetData(buffer, count, _stride);
			}
			void SetData(void * buffer, int count, int _stride)
			{
				this->_buffer = (T*)buffer;
				this->_count = count;
				this->stride = _stride;
			}
			inline int GetCapacity() const
			{
				return _count;
			}
			inline int Count() const
			{
				return _count;
			}

			inline T & operator [](int id) const
			{
#if _DEBUG
				if (id >= _count || id < 0)
					throw IndexOutofRangeException(L"Operator[]: Index out of Range.");
#endif
				return *(T*)((char*)_buffer+id*stride);
			}

			inline T* Buffer() const
			{
				return _buffer;
			}

			template<typename T2>
			int IndexOf(const T2 & val) const
			{
				for (int i = 0; i < _count; i++)
				{
					if (*(T*)((char*)_buffer + i*stride) == val)
						return i;
				}
				return -1;
			}

			template<typename T2>
			int LastIndexOf(const T2 & val) const
			{
				for (int i = _count - 1; i >= 0; i--)
				{
					if (*(T*)((char*)_buffer + i*stride) == val)
						return i;
				}
				return -1;
			}

			template<typename Func>
			int FindFirst(const Func & predicate) const
			{
				for (int i = 0; i < _count; i++)
				{
					if (predicate(_buffer[i]))
						return i;
				}
				return -1;
			}

			template<typename Func>
			int FindLast(const Func & predicate) const
			{
				for (int i = _count - 1; i >= 0; i--)
				{
					if (predicate(_buffer[i]))
						return i;
				}
				return -1;
			}
		};

		template<typename T>
		ArrayView<T> MakeArrayView(const T & obj)
		{
			return ArrayView<T>(obj);
		}
		template<typename T>
		ArrayView<T> MakeArrayView(T * buffer, int count)
		{
			return ArrayView<T>(buffer, count);
		}
	}
}
#endif

/***********************************************************************
CORELIB\ARRAY.H
***********************************************************************/
#ifndef CORE_LIB_ARRAY_H
#define CORE_LIB_ARRAY_H


namespace CoreLib
{
	namespace Basic
	{
		template<typename T, int size>
		class Array
		{
		private:
			T _buffer[size];
			int _count;
		public:
			T* begin() const
			{
				return (T*)_buffer;
			}
			T* end() const
			{
				return (T*)_buffer+_count;
			}
		public:
			Array()
			{
				_count = 0;
			}
			inline int GetCapacity() const
			{
				return size;
			}
			inline int Count() const
			{
				return _count;
			}
			inline void SetSize(int newSize)
			{
#ifdef _DEBUG
				if (newSize > size)
					throw IndexOutofRangeException(L"size too large.");
#endif
				_count = newSize;
			}
			inline void Add(const T & item)
			{
#ifdef _DEBUG
				if (_count == size)
					throw IndexOutofRangeException(L"out of range access to static array.");
#endif
				_buffer[_count++] = item;
			}
			inline void Add(T && item)
			{
#ifdef _DEBUG
				if (_count == size)
					throw IndexOutofRangeException(L"out of range access to static array.");
#endif
				_buffer[_count++] = _Move(item);
			}

			inline T & operator [](int id) const
			{
#if _DEBUG
				if(id >= _count || id < 0)
					throw IndexOutofRangeException(L"Operator[]: Index out of Range.");
#endif
				return ((T*)_buffer)[id];
			}

			inline T* Buffer() const
			{
				return (T*)_buffer;
			}

			inline void Clear()
			{
				_count = 0;
			}

			template<typename T2>
			int IndexOf(const T2 & val) const
			{
				for (int i = 0; i < _count; i++)
				{
					if (_buffer[i] == val)
						return i;
				}
				return -1;
			}

			template<typename T2>
			int LastIndexOf(const T2 & val) const
			{
				for (int i = _count - 1; i >= 0; i--)
				{
					if(_buffer[i] == val)
						return i;
				}
				return -1;
			}

			inline ArrayView<T> GetArrayView() const
			{
				return ArrayView<T>((T*)_buffer, _count);
			}
			inline ArrayView<T> GetArrayView(int start, int count) const
			{
				return ArrayView<T>((T*)_buffer + start, count);
			}
		};
	}
}

#endif

/***********************************************************************
CORELIB\ALLOCATOR.H
***********************************************************************/
#ifndef CORE_LIB_ALLOCATOR_H
#define CORE_LIB_ALLOCATOR_H


namespace CoreLib
{
	namespace Basic
	{
		inline void * AlignedAlloc(size_t size, size_t alignment)
		{
#ifdef _MSC_VER
			return _aligned_malloc(size, alignment);
#else
			void * rs = 0;
			int succ = posix_memalign(&rs, alignment, size);
			if (succ!=0)
				rs = 0;
			return rs;
#endif
		}

		inline void AlignedFree(void * ptr)
		{
#ifdef _MSC_VER
			_aligned_free(ptr);
#else
			free(ptr);
#endif
		}

		class StandardAllocator
		{
		public:
			// not really called
			void * Alloc(size_t size)
			{
				return malloc(size);
			}
			void Free(void * ptr)
			{
				return free(ptr);
			}
		};

		template<int alignment>
		class AlignedAllocator
		{
		public:
			void * Alloc(size_t size)
			{
				return AlignedAlloc(size, alignment);
			}
			void Free(void * ptr)
			{
				return AlignedFree(ptr);
			}
		};
	}
}

#endif

/***********************************************************************
CORELIB\LIST.H
***********************************************************************/
#ifndef FUNDAMENTAL_LIB_LIST_H
#define FUNDAMENTAL_LIB_LIST_H

#include <type_traits>
#include <new>
#include <algorithm>

const int MIN_QSORT_SIZE = 32;

namespace CoreLib
{
	namespace Basic
	{
		template<typename T, int isPOD>
		class Initializer
		{

		};

		template<typename T>
		class Initializer<T, 0>
		{
		public:
			static void Initialize(T * buffer, int size)
			{
				for (int i = 0; i<size; i++)
					new (buffer + i) T();
			}
		};

		template<typename T, typename TAllocator>
		class AllocateMethod
		{
		public:
			static inline T* Alloc(int size)
			{
				TAllocator allocator;
				T * rs = (T*)allocator.Alloc(size*sizeof(T));
				Initializer<T, std::is_pod<T>::value>::Initialize(rs, size);
				return rs;
			}
			static inline void Free(T * ptr, int bufferSize)
			{
				TAllocator allocator;
				if (!std::is_trivially_destructible<T>::value)
				{
					for (int i = 0; i<bufferSize; i++)
						ptr[i].~T();
				}
				allocator.Free(ptr);
			}
		};

		template<typename T>
		class AllocateMethod<T, StandardAllocator>
		{
		public:
			static inline T* Alloc(int size)
			{
				return new T[size];
			}
			static inline void Free(T* ptr, int /*bufferSize*/)
			{
				delete [] ptr;
			}
		};

		template<typename T>
		class Initializer<T, 1>
		{
		public:
			static void Initialize(T * buffer, int size)
			{
				for (int i = 0; i<size; i++)
					new (buffer + i) T;
			}
		};

		template<typename T, typename TAllocator = StandardAllocator>
		class List
		{
		private:

			inline T * Allocate(int size)
			{
				return AllocateMethod<T, TAllocator>::Alloc(size);
				
			}
		private:
			static const int InitialSize = 16;
			TAllocator allocator;
		private:
			T * buffer;
			int _count;
			int bufferSize;
			void FreeBuffer()
			{
				AllocateMethod<T, TAllocator>::Free(buffer, bufferSize);
				buffer = 0;
			}
			void Free()
			{
				if (buffer)
				{
					FreeBuffer();
				}
				buffer = 0;
				_count = bufferSize = 0;
			}
		public:
			T* begin() const
			{
				return buffer;
			}
			T* end() const
			{
				return buffer+_count;
			}
		public:
			List()
				: buffer(0), _count(0), bufferSize(0)
			{
			}
			List(const List<T> & list)
				: buffer(0), _count(0), bufferSize(0)
			{
				this->operator=(list);
			}
			List(List<T> && list)
				: buffer(0), _count(0), bufferSize(0)
			{
				//int t = static_cast<int>(1.0f); reinterpret_cast<double*>(&t), dynamic_cast<> 
				this->operator=(static_cast<List<T>&&>(list));
			}
			~List()
			{
				Free();
			}
			List<T> & operator=(const List<T> & list)
			{
				Free();
				AddRange(list);

				return *this;
			}

			List<T> & operator=(List<T> && list)
			{
				Free();
				_count = list._count;
				bufferSize = list.bufferSize;
				buffer = list.buffer;

				list.buffer = 0;
				list._count = 0;
				list.bufferSize = 0;
				return *this;
			}

			T & First() const
			{
#ifdef _DEBUG
				if (_count == 0)
					throw "Index out of range.";
#endif
				return buffer[0];
			}

			T & Last() const
			{
#ifdef _DEBUG
				if (_count == 0)
					throw "Index out of range.";
#endif
				return buffer[_count-1];
			}

			inline void SwapWith(List<T, TAllocator> & other)
			{
				T* tmpBuffer = this->buffer;
				this->buffer = other.buffer;
				other.buffer = tmpBuffer;
				int tmpBufferSize = this->bufferSize;
				this->bufferSize = other.bufferSize;
				other.bufferSize = tmpBufferSize;
				int tmpCount = this->_count;
				this->_count = other._count;
				other._count = tmpCount;
				TAllocator tmpAlloc = _Move(this->allocator);
				this->allocator = _Move(other.allocator);
				other.allocator = _Move(tmpAlloc);
			}

			inline ArrayView<T> GetArrayView() const
			{
				return ArrayView<T>(buffer, _count);
			}

			inline ArrayView<T> GetArrayView(int start, int count) const
			{
#ifdef _DEBUG
				if (start + count > _count || start < 0 || count < 0)
					throw "Index out of range.";
#endif
				return ArrayView<T>(buffer + start, count);
			}

			void Add(T && obj)
			{
				if (bufferSize < _count + 1)
				{
					int newBufferSize = InitialSize;
					if (bufferSize)
						newBufferSize = (bufferSize << 1);

					Reserve(newBufferSize);
				}
				buffer[_count++] = static_cast<T&&>(obj);
			}

			void Add(const T & obj)
			{
				if (bufferSize < _count + 1)
				{
					int newBufferSize = InitialSize;
					if (bufferSize)
						newBufferSize = (bufferSize << 1);

					Reserve(newBufferSize);
				}
				buffer[_count++] = obj;

			}

			int Count() const
			{
				return _count;
			}

			T * Buffer() const
			{
				return buffer;
			}

			int Capacity() const
			{
				return bufferSize;
			}

			void Insert(int id, const T & val)
			{
				InsertRange(id, &val, 1);
			}

			void InsertRange(int id, const T * vals, int n)
			{
				if (bufferSize < _count + n)
				{
					int newBufferSize = InitialSize;
					while (newBufferSize < _count + n)
						newBufferSize = newBufferSize << 1;

					T * newBuffer = Allocate(newBufferSize);
					if (bufferSize)
					{
						/*if (std::has_trivial_copy_assign<T>::value && std::has_trivial_destructor<T>::value)
						{
							memcpy(newBuffer, buffer, sizeof(T) * id);
							memcpy(newBuffer + id + n, buffer + id, sizeof(T) * (_count - id));
						}
						else*/
						{
							for (int i = 0; i < id; i++)
								newBuffer[i] = buffer[i];
							for (int i = id; i < _count; i++)
								newBuffer[i + n] = T(static_cast<T&&>(buffer[i]));
						}
						FreeBuffer();
					}
					buffer = newBuffer;
					bufferSize = newBufferSize;
				}
				else
				{
					/*if (std::has_trivial_copy_assign<T>::value && std::has_trivial_destructor<T>::value)
						memmove(buffer + id + n, buffer + id, sizeof(T) * (_count - id));
					else*/
					{
						for (int i = _count - 1; i >= id; i--)
							buffer[i + n] = static_cast<T&&>(buffer[i]);
					}
				}
				/*if (std::has_trivial_copy_assign<T>::value && std::has_trivial_destructor<T>::value)
					memcpy(buffer + id, vals, sizeof(T) * n);
				else*/
					for (int i = 0; i < n; i++)
						buffer[id + i] = vals[i];

				_count += n;
			}

			//slower than original edition
			//void Add(const T & val)
			//{
			//	InsertRange(_count, &val, 1);
			//}

			void InsertRange(int id, const List<T> & list)
			{
				InsertRange(id, list.buffer, list._count);
			}

			void AddRange(const T * vals, int n)
			{
				InsertRange(_count, vals, n);
			}

			void AddRange(const List<T> & list)
			{
				InsertRange(_count, list.buffer, list._count);
			}

			void RemoveRange(int id, int deleteCount)
			{
#if _DEBUG
				if (id >= _count || id < 0)
					throw "Remove: Index out of range.";
				if(deleteCount < 0)
					throw "Remove: deleteCount smaller than zero.";
#endif
				int actualDeleteCount = ((id + deleteCount) >= _count)? (_count - id) : deleteCount;
				for (int i = id + actualDeleteCount; i < _count; i++)
					buffer[i - actualDeleteCount] = static_cast<T&&>(buffer[i]);
				_count -= actualDeleteCount;
			}

			void RemoveAt(int id)
			{
				RemoveRange(id, 1);
			}

			void Remove(const T & val)
			{
				int idx = IndexOf(val);
				if (idx != -1)
					RemoveAt(idx);
			}

			void Reverse()
			{
				for (int i = 0; i < (_count >> 1); i++)
				{
					Swap(buffer, i, _count - i - 1);
				}
			}

			void FastRemove(const T & val)
			{
				int idx = IndexOf(val);
				if (idx != -1 && _count-1 != idx)
				{
					buffer[idx] = _Move(buffer[_count-1]);
				}
				_count--;
			}

			void Clear()
			{
				_count = 0;
			}

			void Reserve(int size)
			{
				if(size > bufferSize)
				{
					T * newBuffer = Allocate(size);
					if (bufferSize)
					{
						/*if (std::has_trivial_copy_assign<T>::value && std::has_trivial_destructor<T>::value)
							memcpy(newBuffer, buffer, _count * sizeof(T));
						else*/
						{
							for (int i = 0; i < _count; i++)
								newBuffer[i] = static_cast<T&&>(buffer[i]);
						}
						FreeBuffer();
					}
					buffer = newBuffer;
					bufferSize = size;
				}
			}

			void GrowToSize(int size)
			{
				int newBufferSize = 1<<Math::Log2Ceil(size);
				if (bufferSize < newBufferSize)
				{
					Reserve(newBufferSize);
				}
				this->_count = size;
			}

			void SetSize(int size)
			{
				Reserve(size);
				_count = size;
			}

			void UnsafeShrinkToSize(int size)
			{
				_count = size;
			}

			void Compress()
			{
				if (bufferSize > _count && _count > 0)
				{
					T * newBuffer = Allocate(_count);
					for (int i = 0; i < _count; i++)
						newBuffer[i] = static_cast<T&&>(buffer[i]);
					FreeBuffer();
					buffer = newBuffer;
					bufferSize = _count;
				}
			}

#ifndef FORCE_INLINE
#ifdef _MSC_VER
#define FORCE_INLINE __forceinline
#else
#define FORCE_INLINE inline
#endif
#endif

			FORCE_INLINE T & operator [](int id) const
			{
#if _DEBUG
				if(id >= _count || id < 0)
					throw IndexOutofRangeException(L"Operator[]: Index out of Range.");
#endif
				return buffer[id];
			}

			template<typename Func>
			int FindFirst(const Func & predicate) const
			{
				for (int i = 0; i < _count; i++)
				{
					if (predicate(buffer[i]))
						return i;
				}
				return -1;
			}

			template<typename Func>
			int FindLast(const Func & predicate) const
			{
				for (int i = _count - 1; i >= 0; i--)
				{
					if (predicate(buffer[i]))
						return i;
				}
				return -1;
			}

			template<typename T2>
			int IndexOf(const T2 & val) const
			{
				for (int i = 0; i < _count; i++)
				{
					if (buffer[i] == val)
						return i;
				}
				return -1;
			}

			template<typename T2>
			int LastIndexOf(const T2 & val) const
			{
				for (int i = _count - 1; i >= 0; i--)
				{
					if(buffer[i] == val)
						return i;
				}
				return -1;
			}

			void Sort()
			{
				Sort([](T& t1, T& t2){return t1<t2;});
			}

			bool Contains(const T & val)
			{
				for (int i = 0; i<_count; i++)
					if (buffer[i] == val)
						return true;
				return false;
			}

			template<typename Comparer>
			void Sort(Comparer compare)
			{
				//InsertionSort(buffer, 0, _count - 1);
				//QuickSort(buffer, 0, _count - 1, compare);
				std::sort(buffer, buffer + _count, compare);
			}

			template <typename IterateFunc>
			void ForEach(IterateFunc f) const
			{
				for (int i = 0; i<_count; i++)
					f(buffer[i]);
			}

			template<typename Comparer>
			void QuickSort(T * vals, int startIndex, int endIndex, Comparer comparer)
			{
				if(startIndex < endIndex)
				{
					if (endIndex - startIndex < MIN_QSORT_SIZE)
						InsertionSort(vals, startIndex, endIndex, comparer);
					else
					{
						int pivotIndex = (startIndex + endIndex) >> 1;
						int pivotNewIndex = Partition(vals, startIndex, endIndex, pivotIndex, comparer);
						QuickSort(vals, startIndex, pivotNewIndex - 1, comparer);
						QuickSort(vals, pivotNewIndex + 1, endIndex, comparer);
					}
				}

			}
			template<typename Comparer>
			int Partition(T * vals, int left, int right, int pivotIndex, Comparer comparer)
			{
				T pivotValue = vals[pivotIndex];
				Swap(vals, right, pivotIndex);
				int storeIndex = left;
				for (int i = left; i < right; i++)
				{
					if (comparer(vals[i], pivotValue))
					{
						Swap(vals, i, storeIndex);
						storeIndex++;
					}
				}
				Swap(vals, storeIndex, right);
				return storeIndex;
			}
			template<typename Comparer>
			void InsertionSort(T * vals, int startIndex, int endIndex, Comparer comparer)
			{
				for (int i = startIndex  + 1; i <= endIndex; i++)
				{
					T insertValue = static_cast<T&&>(vals[i]);
					int insertIndex = i - 1;
					while (insertIndex >= startIndex && comparer(insertValue, vals[insertIndex]))
					{
						vals[insertIndex + 1] = static_cast<T&&>(vals[insertIndex]);
						insertIndex--;
					}
					vals[insertIndex + 1] = static_cast<T&&>(insertValue);
				}
			}

			inline void Swap(T * vals, int index1, int index2)
			{
				if (index1 != index2)
				{
					T tmp = static_cast<T&&>(vals[index1]);
					vals[index1] = static_cast<T&&>(vals[index2]);
					vals[index2] = static_cast<T&&>(tmp);
				}
			}

			template<typename T2, typename Comparer>
			int BinarySearch(const T2 & obj, Comparer comparer)
			{
				int imin = 0, imax = _count - 1;
				while (imax >= imin)
				{
					int imid = (imin + imax) >> 1;
					int compareResult = comparer(buffer[imid], obj);
					if (compareResult == 0)
						return imid;
					else if (compareResult < 0)
						imin = imid + 1;
					else
						imax = imid - 1;
				}
				return -1;
			}

			template<typename T2>
			int BinarySearch(const T2 & obj)
			{
				return BinarySearch(obj, 
					[](T & curObj, const T2 & thatObj)->int
					{
						if (curObj < thatObj)
							return -1;
						else if (curObj == thatObj)
							return 0;
						else
							return 1;
					});
			}
		};

		template<typename T>
		T Min(const List<T> & list)
		{
			T minVal = list.First();
			for (int i = 1; i<list.Count(); i++)
				if (list[i] < minVal)
					minVal = list[i];
			return minVal;
		}

		template<typename T>
		T Max(const List<T> & list)
		{
			T maxVal = list.First();
			for (int i = 1; i<list.Count(); i++)
				if (list[i] > maxVal)
					maxVal = list[i];
			return maxVal;
		}
	}
}

#endif

/***********************************************************************
CORELIB\LINK.H
***********************************************************************/
#ifndef CORE_LIB_LINK_H
#define CORE_LIB_LINK_H


namespace CoreLib
{
	namespace Basic
	{
		template<typename T>
		class LinkedList;

		template<typename T>
		class LinkedNode
		{
			template<typename T1>
			friend class LinkedList;
		private:
			LinkedNode<T> *pPrev, *pNext;
			LinkedList<T> * FLink;
		public:
			T Value;
			LinkedNode (LinkedList<T> * lnk):FLink(lnk)
			{
				pPrev = pNext = 0;
			};
			LinkedNode<T> * GetPrevious()
			{
				return pPrev;
			};
			LinkedNode<T> * GetNext()
			{
				return pNext;
			};
			LinkedNode<T> * InsertAfter(const T & nData)
			{
				LinkedNode<T> * n = new LinkedNode<T>(FLink);
				n->Value = nData;
				n->pPrev = this;
				n->pNext = this->pNext;
				LinkedNode<T> *npp = n->pNext;
				if (npp)
				{
					npp->pPrev = n;
				}
				pNext = n;
				if (!n->pNext)
					FLink->FTail = n;
				FLink->FCount ++;
				return n;
			};
			LinkedNode<T> * InsertBefore(const T & nData)
			{
				LinkedNode<T> * n = new LinkedNode<T>(FLink);
				n->Value = nData;
				n->pPrev = pPrev;
				n->pNext = this;
				pPrev = n;
				LinkedNode<T> *npp = n->pPrev;
				if (npp)
					npp->pNext = n;
				if (!n->pPrev)
					FLink->FHead = n;
				FLink->FCount ++;
				return n;
			};
			void Delete()
			{
				if (pPrev)
					pPrev->pNext = pNext;
				if (pNext)
					pNext->pPrev = pPrev;
				FLink->FCount --;
				if (FLink->FHead == this)
				{
					FLink->FHead = pNext;
				}
				if (FLink->FTail == this)
				{
					FLink->FTail = pPrev;
				}
				delete this;
			}
		};
		template<typename T>
		class LinkedList
		{
			template<typename T1>
			friend class LinkedNode;
		private:
			LinkedNode<T> * FHead, *FTail;
			int FCount;
		public:
			class Iterator
			{
			public:
				LinkedNode<T> * Current, *Next;
				void SetCurrent(LinkedNode<T> * cur)
				{
					Current = cur;
					if (Current)
						Next = Current->GetNext();
					else
						Next = 0;
				}
				Iterator()
				{
					Current = Next = 0;
				}
				Iterator(LinkedNode<T> * cur)
				{
					SetCurrent(cur);
				}
				T & operator *() const
				{
					return Current->Value;
				}
				Iterator& operator ++()
				{
					SetCurrent(Next);
					return *this;
				}
				Iterator operator ++(int)
				{
					Iterator rs = *this;
					SetCurrent(Next);
					return rs;
				}
				bool operator != (const Iterator & iter) const
				{
					return Current != iter.Current;
				}
				bool operator == (const Iterator & iter) const
				{
					return Current == iter.Current;
				}
			};
			Iterator begin() const
			{
				return Iterator(FHead);
			}
			Iterator end() const
			{
				return Iterator(0);
			}
		public:
			LinkedList() : FHead(0), FTail(0), FCount(0)
			{
			}
			~LinkedList()
			{
				Clear();
			}
			LinkedList(const LinkedList<T> & link) : FHead(0), FTail(0), FCount(0)
			{
				this->operator=(link);
			}
			LinkedList(LinkedList<T> && link) : FHead(0), FTail(0), FCount(0)
			{
				this->operator=(_Move(link));
			}
			LinkedList<T> & operator = (LinkedList<T> && link)
			{
				if (FHead != 0)
					Clear();
				FHead = link.FHead;
				FTail = link.FTail;
				FCount = link.FCount;
				link.FHead = 0;
				link.FTail = 0;
				link.FCount = 0;
				for (auto node = FHead; node; node = node->GetNext())
					node->FLink = this;
				return *this;
			}
			LinkedList<T> & operator = (const LinkedList<T> & link)
			{
				if (FHead != 0)
					Clear();
				auto p = link.FHead;
				while (p)
				{
					AddLast(p->Value);
					p = p->GetNext();
				}
				return *this;
			}
			template<typename IteratorFunc>
			void ForEach(const IteratorFunc & f)
			{
				auto p = FHead;
				while (p)
				{
					f(p->Value);
					p = p->GetNext();
				}
			}
			LinkedNode<T> * GetNode(int x)
			{
				LinkedNode<T> *pCur = FHead;
				for (int i=0;i<x;i++)
				{
					if (pCur)
						pCur = pCur->pNext;
					else
						throw "Index out of range";
				}
				return pCur;
			};
			LinkedNode<T> * Find(const T& fData)
			{
				for (LinkedNode<T> * pCur = FHead; pCur; pCur = pCur->pNext)
				{
					if (pCur->Value == fData)
						return pCur;
				}
				return 0;
			};
			LinkedNode<T> * FirstNode() const
			{
				return FHead;
			};
			T & First() const
			{
				if (!FHead)
					throw IndexOutofRangeException("LinkedList: index out of range.");
				return FHead->Value;
			}
			T & Last() const
			{
				if (!FTail)
					throw IndexOutofRangeException("LinkedList: index out of range.");
				return FTail->Value;
			}
			LinkedNode<T> * LastNode() const
			{
				return FTail;
			};
			LinkedNode<T> * AddLast(const T & nData)
			{
				LinkedNode<T> * n = new LinkedNode<T>(this);
				n->Value = nData;
				n->pPrev = FTail;
				if (FTail)
					FTail->pNext = n;
				n->pNext = 0;
				FTail = n;
				if (!FHead)
					FHead = n;
				FCount ++;
				return n;
			};
			// Insert a blank node
			LinkedNode<T> * AddLast()
			{
				LinkedNode<T> * n = new LinkedNode<T>(this);
				n->pPrev = FTail;
				if (FTail)
					FTail->pNext = n;
				n->pNext = 0;
				FTail = n;
				if (!FHead)
					FHead = n;
				FCount ++;
				return n;
			};
			LinkedNode<T> * AddFirst(const T& nData)
			{
				LinkedNode<T> *n = new LinkedNode<T>(this);
				n->Value = nData;
				n->pPrev = 0;
				n->pNext = FHead;
				if (FHead)
					FHead->pPrev = n;
				FHead = n;
				if (!FTail)
					FTail = n;
				FCount ++;
				return n;
			};
			void Delete(LinkedNode<T>*n, int Count = 1)
			{
				LinkedNode<T> *n1,*n2 = 0, *tn;
				n1 = n->pPrev;
				tn = n;
				int numDeleted = 0;
				for (int i=0; i<Count; i++)
				{
					n2 = tn->pNext;
					delete tn;
					tn = n2;
					numDeleted++;
					if (tn == 0)
						break;
				}
				if (n1)
					n1->pNext = n2;
				else
					FHead = n2;
				if (n2)
					n2->pPrev = n1;
				else
					FTail = n1;
				FCount -= numDeleted;
			}
			void Clear()
			{
				for (LinkedNode<T> *n = FHead; n; )
				{
					LinkedNode<T> * tmp = n->pNext;
					delete n;
					n = tmp;
				}
				FHead = 0;
				FTail = 0;
				FCount = 0;
			}
			List<T> ToList() const
			{
				List<T> rs;
				rs.Reserve(FCount);
				for (auto & item : *this)
				{
					rs.Add(item);
				}
				return rs;
			}
			int Count()
			{
				return FCount;
			}
		};
	}
}
#endif

/***********************************************************************
CORELIB\INTSET.H
***********************************************************************/
#ifndef BIT_VECTOR_INT_SET_H
#define BIT_VECTOR_INT_SET_H

#include <memory.h>

namespace CoreLib
{
	namespace Basic
	{
		class IntSet
		{
		private:
			List<int> buffer;
		public:
			IntSet()
			{}
			IntSet(const IntSet & other)
			{
				buffer = other.buffer;
			}
			IntSet(IntSet && other)
			{
				*this = (_Move(other));
			}
			IntSet & operator = (IntSet && other)
			{
				buffer = _Move(other.buffer);
				return *this;
			}
			IntSet & operator = (const IntSet & other)
			{
				buffer = other.buffer;
				return *this;
			}
			int GetHashCode()
			{
				int rs = 0;
				for (auto val : buffer)
					rs ^= val;
				return rs;
			}
			IntSet(int maxVal)
			{
				SetMax(maxVal);
			}
			int Size() const
			{
				return buffer.Count()*32;
			}
			void SetMax(int val)
			{
				Resize(val);
				Clear();
			}
			void SetAll()
			{
				for (int i = 0; i<buffer.Count(); i++)
					buffer[i] = 0xFFFFFFFF;
			}
			void Resize(int size)
			{
				int oldBufferSize = buffer.Count();
				buffer.SetSize((size+31)>>5);
				if (buffer.Count() > oldBufferSize)
					memset(buffer.Buffer()+oldBufferSize, 0, (buffer.Count()-oldBufferSize) * sizeof(int));
			}
			void Clear()
			{
				for (int i = 0; i<buffer.Count(); i++)
					buffer[i] = 0;
			}
			void Add(int val)
			{
				int id = val>>5;
				if (id < buffer.Count())
					buffer[id] |= (1<<(val&31));
				else
				{
					int oldSize = buffer.Count();
					buffer.SetSize(id+1);
					memset(buffer.Buffer() + oldSize, 0, (buffer.Count()-oldSize)*sizeof(int));
					buffer[id] |= (1<<(val&31));
				}
			}
			void Remove(int val)
			{
				if ((val>>5) < buffer.Count())
					buffer[(val>>5)] &= ~(1<<(val&31));
			}
			bool Contains(int val) const
			{
				if ((val>>5) >= buffer.Count())
					return false;
				return (buffer[(val>>5)] & (1<<(val&31))) != 0;
			}
			void UnionWith(const IntSet & set)
			{
				for (int i = 0; i<Math::Min(set.buffer.Count(), buffer.Count()); i++)
				{
					buffer[i] |= set.buffer[i];
				}
				if (set.buffer.Count() > buffer.Count())
					buffer.AddRange(set.buffer.Buffer()+buffer.Count(), set.buffer.Count()-buffer.Count());
			}
			bool operator == (const IntSet & set)
			{
				if (buffer.Count() != set.buffer.Count())
					return false;
				for (int i = 0; i<buffer.Count(); i++)
					if (buffer[i] != set.buffer[i])
						return false;
				return true;
			}
			bool operator != (const IntSet & set)
			{
				return !(*this == set);
			}
			void IntersectWith(const IntSet & set)
			{
				if (set.buffer.Count() < buffer.Count())
					memset(buffer.Buffer() + set.buffer.Count(), 0, (buffer.Count()-set.buffer.Count())*sizeof(int));
				for (int i = 0; i<Math::Min(set.buffer.Count(), buffer.Count()); i++)
				{
					buffer[i] &= set.buffer[i];
				}
			}
			static void Union(IntSet & rs, const IntSet & set1, const IntSet & set2)
			{
				rs.buffer.SetSize(Math::Max(set1.buffer.Count(), set2.buffer.Count()));
				rs.Clear();
				for (int i = 0; i<set1.buffer.Count(); i++)
					rs.buffer[i] |= set1.buffer[i];
				for (int i = 0; i<set2.buffer.Count(); i++)
					rs.buffer[i] |= set2.buffer[i];
			}
			static void Intersect(IntSet & rs, const IntSet & set1, const IntSet & set2)
			{
				rs.buffer.SetSize(Math::Min(set1.buffer.Count(), set2.buffer.Count()));
				for (int i = 0; i<rs.buffer.Count(); i++)
					rs.buffer[i] = set1.buffer[i] & set2.buffer[i];
			}
			static void Subtract(IntSet & rs, const IntSet & set1, const IntSet & set2)
			{
				rs.buffer.SetSize(set1.buffer.Count());
				for (int i = 0; i<Math::Min(set1.buffer.Count(), set2.buffer.Count()); i++)
					rs.buffer[i] = set1.buffer[i] & (~set2.buffer[i]);
			}
			static bool HasIntersection(const IntSet & set1, const IntSet & set2)
			{
				for (int i = 0; i<Math::Min(set1.buffer.Count(), set2.buffer.Count()); i++)
				{
					if (set1.buffer[i] & set2.buffer[i])
						return true;
				}
				return false;
			}
		};
	}
}

#endif

/***********************************************************************
CORELIB\DICTIONARY.H
***********************************************************************/
#ifndef CORE_LIB_DICTIONARY_H
#define CORE_LIB_DICTIONARY_H
namespace CoreLib
{
	namespace Basic
	{
		template<int IsInt>
		class Hash
		{
		public:
		};
		template<>
		class Hash<1>
		{
		public:
			template<typename TKey>
			static int GetHashCode(TKey & key)
			{
				return (int)key;
			}
		};
		template<>
		class Hash<0>
		{
		public:
			template<typename TKey>
			static int GetHashCode(TKey & key)
			{
				return key.GetHashCode();
			}
		};
		template<int IsPointer>
		class PointerHash
		{};
		template<>
		class PointerHash<1>
		{
		public:
			template<typename TKey>
			static int GetHashCode(TKey & key)
			{
				return (int)((CoreLib::PtrInt)key)/sizeof(typename std::remove_pointer<TKey>::type);
			}
		};
		template<>
		class PointerHash<0>
		{
		public:
			template<typename TKey>
			static int GetHashCode(TKey & key)
			{
				return Hash<std::is_integral<TKey>::value || std::is_enum<TKey>::value>::GetHashCode(key);
			}
		};

		template<typename TKey>
		int GetHashCode(const TKey & key)
		{
			return PointerHash<std::is_pointer<TKey>::value>::GetHashCode(key);
		}

		template<typename TKey>
		int GetHashCode(TKey & key)
		{
			return PointerHash<std::is_pointer<TKey>::value>::GetHashCode(key);
		}
		
		
		inline int GetHashCode(double key)
		{
			return FloatAsInt((float)key);
		}
		inline int GetHashCode(float key)
		{
			return FloatAsInt(key);
		}

		template<typename TKey, typename TValue>
		class KeyValuePair
		{
		public:
			TKey Key;
			TValue Value;
			KeyValuePair()
			{}
			KeyValuePair(const TKey & key, const TValue & value)
			{
				Key = key;
				Value = value;
			}
			KeyValuePair(TKey && key, TValue && value)
			{
				Key = _Move(key);
				Value = _Move(value);
			}
			KeyValuePair(TKey && key, const TValue & value)
			{
				Key = _Move(key);
				Value = value;
			}
			KeyValuePair(const KeyValuePair<TKey, TValue> & _that)
			{
				Key = _that.Key;
				Value = _that.Value;
			}
			KeyValuePair(KeyValuePair<TKey, TValue> && _that)
			{
				operator=(_Move(_that));
			}
			KeyValuePair & operator=(KeyValuePair<TKey, TValue> && that)
			{
				Key = _Move(that.Key);
				Value = _Move(that.Value);
				return *this;
			}
			KeyValuePair & operator=(const KeyValuePair<TKey, TValue> & that)
			{
				Key = that.Key;
				Value = that.Value;
				return *this;
			}
			int GetHashCode()
			{
				return GetHashCode(Key);
			}
		};

		const float MaxLoadFactor = 0.7f;

		template<typename TKey, typename TValue>
		class Dictionary
		{
			friend class Iterator;
			friend class ItemProxy;
		private:
			inline int GetProbeOffset(int /*probeId*/) const
			{
				// quadratic probing
				return 1;
			}
		private:
			int bucketSizeMinusOne, shiftBits;
			int _count;
			IntSet marks;
			KeyValuePair<TKey, TValue>* hashMap;
			void Free()
			{
				if (hashMap)
					delete [] hashMap;
				hashMap = 0;
			}
			inline bool IsDeleted(int pos) const
			{
				return marks.Contains((pos<<1) + 1);
			}
			inline bool IsEmpty(int pos) const
			{
				return !marks.Contains((pos<<1));
			}
			inline void SetDeleted(int pos, bool val)
			{
				if (val)
					marks.Add((pos<<1)+1);
				else
					marks.Remove((pos<<1)+1);
			}
			inline void SetEmpty(int pos, bool val)
			{
				if (val)
					marks.Remove((pos<<1));
				else
					marks.Add((pos<<1));
			}
			struct FindPositionResult
			{
				int ObjectPosition;
				int InsertionPosition;
				FindPositionResult()
				{
					ObjectPosition = -1;
					InsertionPosition = -1;
				}
				FindPositionResult(int objPos, int insertPos)
				{
					ObjectPosition = objPos;
					InsertionPosition = insertPos;
				}

			};
			inline int GetHashPos(TKey & key) const
			{
				return ((unsigned int)(GetHashCode(key)*2654435761)) >> shiftBits;
			}
			FindPositionResult FindPosition(const TKey & key) const
			{
				int hashPos = GetHashPos((TKey&)key);
				int insertPos = -1;
				int numProbes = 0;
				while (numProbes <= bucketSizeMinusOne)
				{
					if (IsEmpty(hashPos))
					{
						if (insertPos == -1)
							return FindPositionResult(-1, hashPos);
						else
							return FindPositionResult(-1, insertPos);
					}
					else if (IsDeleted(hashPos))
					{
						if (insertPos == -1)
							insertPos = hashPos;
					}
					else if (hashMap[hashPos].Key == key)
					{
						return FindPositionResult(hashPos, -1);
					}
					numProbes++;
					hashPos = (hashPos+GetProbeOffset(numProbes)) & bucketSizeMinusOne;
				}
				if (insertPos != -1)
					return FindPositionResult(-1, insertPos);
				throw InvalidOperationException(L"Hash map is full. This indicates an error in Key::Equal or Key::GetHashCode.");
			}
			TValue & _Insert(KeyValuePair<TKey, TValue> && kvPair, int pos)
			{
				hashMap[pos] = _Move(kvPair);
				SetEmpty(pos, false);
				SetDeleted(pos, false);
				return hashMap[pos].Value;
			}
			void Rehash()
			{
				if (bucketSizeMinusOne == -1 || _count/(float)bucketSizeMinusOne >= MaxLoadFactor)
				{
					int newSize = (bucketSizeMinusOne+1) * 2;
					int newShiftBits = shiftBits - 1;
					if (newSize == 0)
					{
						newSize = 16;
						newShiftBits = 28;
					}
					Dictionary<TKey, TValue> newDict;
					newDict.shiftBits = newShiftBits;
					newDict.bucketSizeMinusOne = newSize - 1;
					newDict.hashMap = new KeyValuePair<TKey, TValue>[newSize];
					newDict.marks.SetMax(newSize*2);
					if (hashMap)
					{
						for (auto & kvPair : *this)
						{
							newDict.Add(_Move(kvPair));
						}
					}
					*this = _Move(newDict);
				}
			}
			
			bool AddIfNotExists(KeyValuePair<TKey, TValue> && kvPair)
			{
				Rehash();
				auto pos = FindPosition(kvPair.Key);
				if (pos.ObjectPosition != -1)
					return false;
				else if (pos.InsertionPosition != -1)
				{
					_count++;
					_Insert(_Move(kvPair), pos.InsertionPosition);
					return true;
				}
				else
					throw InvalidOperationException(L"Inconsistent find result returned. This is a bug in Dictionary implementation.");
			}
			void Add(KeyValuePair<TKey, TValue> && kvPair)
			{
				if (!AddIfNotExists(_Move(kvPair)))
					throw KeyExistsException(L"The key already exists in Dictionary.");
			}
			TValue & Set(KeyValuePair<TKey, TValue> && kvPair)
			{
				Rehash();
				auto pos = FindPosition(kvPair.Key);
				if (pos.ObjectPosition != -1)
					return _Insert(_Move(kvPair), pos.ObjectPosition);
				else if (pos.InsertionPosition != -1)
				{
					_count++;
					return _Insert(_Move(kvPair), pos.InsertionPosition);
				}
				else
					throw InvalidOperationException(L"Inconsistent find result returned. This is a bug in Dictionary implementation.");
			}
		public:
			class Iterator
			{
			private:
				const Dictionary<TKey, TValue> * dict;
				int pos;
			public:
				KeyValuePair<TKey, TValue> & operator *() const
				{
					return dict->hashMap[pos];
				}
				KeyValuePair<TKey, TValue> * operator ->() const
				{
					return dict->hashMap + pos;
				}
				Iterator & operator ++()
				{
					if (pos > dict->bucketSizeMinusOne)
						return *this;
					pos++;
					while (pos <= dict->bucketSizeMinusOne && (dict->IsDeleted(pos) || dict->IsEmpty(pos)))
					{
						pos++;
					}
					return *this;
				}
				Iterator operator ++(int)
				{
					Iterator rs = * this;
					operator++( );
					return rs;
				}
				bool operator != (const Iterator & _that) const
				{
					return pos != _that.pos || dict != _that.dict;
				}
				bool operator == (const Iterator & _that) const
				{
					return pos == _that.pos && dict == _that.dict;
				}
				Iterator(const Dictionary<TKey, TValue> * _dict, int _pos)
				{
					this->dict = _dict;
					this->pos = _pos;
				}
				Iterator()
				{
					this->dict = 0;
					this->pos = 0;
				}
			};

			Iterator begin() const
			{
				int pos = 0;
				while (pos < bucketSizeMinusOne + 1)
				{
					if (IsEmpty(pos) || IsDeleted(pos))
						pos++;
					else
						break;
				}
				return Iterator(this, pos);
			}
			Iterator end() const
			{
				return Iterator(this, bucketSizeMinusOne + 1);
			}
		public:
			void Add(const TKey & key, const TValue & value)
			{
				Add(KeyValuePair<TKey, TValue>(key, value));
			}
			void Add(TKey && key, TValue && value)
			{
				Add(KeyValuePair<TKey, TValue>(_Move(key), _Move(value)));
			}
			bool AddIfNotExists(const TKey & key, const TValue & value)
			{
				return AddIfNotExists(KeyValuePair<TKey, TValue>(key, value));
			}
			bool AddIfNotExists(TKey && key, TValue && value)
			{
				return AddIfNotExists(KeyValuePair<TKey, TValue>(_Move(key), _Move(value)));
			}
			void Remove(const TKey & key)
			{
				if (_count == 0)
					return;
				auto pos = FindPosition(key);
				if (pos.ObjectPosition != -1)
				{
					SetDeleted(pos.ObjectPosition, true);
					_count--;
				}
			}
			void Clear()
			{
				_count = 0;

				marks.Clear();
			}
			bool ContainsKey(const TKey & key) const
			{
				if (bucketSizeMinusOne == -1)
					return false;
				auto pos = FindPosition(key);
				return pos.ObjectPosition != -1;
			}
			bool TryGetValue(const TKey & key, TValue & value) const
			{
				if (bucketSizeMinusOne == -1)
					return false;
				auto pos = FindPosition(key);
				if (pos.ObjectPosition != -1)
				{
					value = hashMap[pos.ObjectPosition].Value;
					return true;
				}
				return false;
			}
			TValue * TryGetValue(const TKey & key) const
			{
				if (bucketSizeMinusOne == -1)
					return nullptr;
				auto pos = FindPosition(key);
				if (pos.ObjectPosition != -1)
				{
					return &hashMap[pos.ObjectPosition].Value;
				}
				return nullptr;
			}
			class ItemProxy
			{
			private:
				const Dictionary<TKey, TValue> * dict;
				TKey key;
			public:
				ItemProxy(const TKey & _key, const Dictionary<TKey, TValue> * _dict)
				{
					this->dict = _dict;
					this->key = _key;
				}
				ItemProxy(TKey && _key, const Dictionary<TKey, TValue> * _dict)
				{
					this->dict = _dict;
					this->key = _Move(_key);
				}
				TValue & GetValue() const
				{
					auto pos = dict->FindPosition(key);
					if (pos.ObjectPosition != -1)
					{
						return dict->hashMap[pos.ObjectPosition].Value;
					}
					else
						throw KeyNotFoundException(L"The key does not exists in dictionary.");
				}
				inline TValue & operator()() const
				{
					return GetValue();
				}
				operator TValue&() const
				{
					return GetValue();
				}
				TValue & operator = (const TValue & val) const
				{
					return ((Dictionary<TKey,TValue>*)dict)->Set(KeyValuePair<TKey, TValue>(_Move(key), val));
				}
				TValue & operator = (TValue && val) const
				{
					return ((Dictionary<TKey,TValue>*)dict)->Set(KeyValuePair<TKey, TValue>(_Move(key), _Move(val)));
				}
			};
			ItemProxy operator [](const TKey & key) const
			{
				return ItemProxy(key, this);
			}
			ItemProxy operator [](TKey && key) const
			{
				return ItemProxy(_Move(key), this);
			}
			int Count() const
			{
				return _count;
			}
		public:
			Dictionary()
			{
				bucketSizeMinusOne = -1;
				shiftBits = 32;
				_count = 0;
				hashMap = 0;
			}
			Dictionary(const Dictionary<TKey, TValue> & other)
				: bucketSizeMinusOne(-1), _count(0), hashMap(0)
			{
				*this = other;
			}
			Dictionary(Dictionary<TKey, TValue> && other)
				: bucketSizeMinusOne(-1), _count(0), hashMap(0)
			{
				*this = (_Move(other));
			}
			Dictionary<TKey, TValue> & operator = (const Dictionary<TKey, TValue> & other)
			{
				if (this == &other)
					return *this;
				Free();
				bucketSizeMinusOne = other.bucketSizeMinusOne;
				_count = other._count;
				shiftBits = other.shiftBits;
				hashMap = new KeyValuePair<TKey, TValue>[other.bucketSizeMinusOne+1];
				marks = other.marks;
				for (int i = 0; i<= bucketSizeMinusOne; i++)
					hashMap[i] = other.hashMap[i];
				return *this;
			}
			Dictionary<TKey, TValue> & operator = (Dictionary<TKey, TValue> && other)
			{
				if (this == &other)
					return *this;
				Free();
				bucketSizeMinusOne = other.bucketSizeMinusOne;
				_count = other._count;
				hashMap = other.hashMap;
				shiftBits = other.shiftBits;
				marks = _Move(other.marks);
				other.hashMap = 0;
				other._count = 0;
				other.bucketSizeMinusOne = -1;
				return *this;
			}
			~Dictionary()
			{
				Free();
			}
		};

		template<typename TKey, typename TValue>
		class EnumerableDictionary
		{
			friend class Iterator;
			friend class ItemProxy;
		private:
			inline int GetProbeOffset(int /*probeIdx*/) const
			{
				// quadratic probing
				return 1;
			}
		private:
			int bucketSizeMinusOne, shiftBits;
			int _count;
			IntSet marks;

			// debug op
			struct Op
			{
				TKey key;
				int opType;
				Op()
				{}
				Op(const TKey & key, int t)
				{
					this->key = key;
					opType = t;
				}
			};
			LinkedList<KeyValuePair<TKey, TValue>> kvPairs;
			LinkedNode<KeyValuePair<TKey, TValue>>** hashMap;
			void Free()
			{
				if (hashMap)
					delete[] hashMap;
				hashMap = 0;
				kvPairs.Clear();
			}
			inline bool IsDeleted(int pos) const
			{
				return marks.Contains((pos << 1) + 1);
			}
			inline bool IsEmpty(int pos) const
			{
				return !marks.Contains((pos << 1));
			}
			inline void SetDeleted(int pos, bool val)
			{
				if (val)
					marks.Add((pos << 1) + 1);
				else
					marks.Remove((pos << 1) + 1);
			}
			inline void SetEmpty(int pos, bool val)
			{
				if (val)
					marks.Remove((pos << 1));
				else
					marks.Add((pos << 1));
			}
			struct FindPositionResult
			{
				int ObjectPosition;
				int InsertionPosition;
				FindPositionResult()
				{
					ObjectPosition = -1;
					InsertionPosition = -1;
				}
				FindPositionResult(int objPos, int insertPos)
				{
					ObjectPosition = objPos;
					InsertionPosition = insertPos;
				}

			};
			inline int GetHashPos(TKey & key) const
			{
				return ((unsigned int)(GetHashCode(key) * 2654435761)) >> shiftBits;
			}
			FindPositionResult FindPosition(const TKey & key) const
			{
				int hashPos = GetHashPos((TKey&)key);
				int insertPos = -1;
				int numProbes = 0;
				while (numProbes <= bucketSizeMinusOne)
				{
					if (IsEmpty(hashPos))
					{
						if (insertPos == -1)
							return FindPositionResult(-1, hashPos);
						else
							return FindPositionResult(-1, insertPos);
					}
					else if (IsDeleted(hashPos))
					{
						if (insertPos == -1)
							insertPos = hashPos;
					}
					else if (hashMap[hashPos]->Value.Key == key)
					{
						return FindPositionResult(hashPos, -1);
					}
					numProbes++;
					hashPos = (hashPos + GetProbeOffset(numProbes)) & bucketSizeMinusOne;
				}
				if (insertPos != -1)
					return FindPositionResult(-1, insertPos);
				throw InvalidOperationException(L"Hash map is full. This indicates an error in Key::Equal or Key::GetHashCode.");
			}
			TValue & _Insert(KeyValuePair<TKey, TValue> && kvPair, int pos)
			{
				auto node = kvPairs.AddLast();
				node->Value = _Move(kvPair);
				hashMap[pos] = node;
				SetEmpty(pos, false);
				SetDeleted(pos, false);
				return node->Value.Value;
			}
			void Rehash()
			{
				if (bucketSizeMinusOne == -1 || _count / (float)bucketSizeMinusOne >= MaxLoadFactor)
				{
					int newSize = (bucketSizeMinusOne + 1) * 2;
					int newShiftBits = shiftBits - 1;
					if (newSize == 0)
					{
						newSize = 16;
						newShiftBits = 28;
					}
					EnumerableDictionary<TKey, TValue> newDict;
					newDict.shiftBits = newShiftBits;
					newDict.bucketSizeMinusOne = newSize - 1;
					newDict.hashMap = new LinkedNode<KeyValuePair<TKey, TValue>>*[newSize];
					newDict.marks.SetMax(newSize * 2);
					if (hashMap)
					{
						for (auto & kvPair : *this)
						{
							newDict.Add(_Move(kvPair));
						}
					}
					*this = _Move(newDict);
				}
			}

			bool AddIfNotExists(KeyValuePair<TKey, TValue> && kvPair)
			{
				Rehash();
				auto pos = FindPosition(kvPair.Key);
				if (pos.ObjectPosition != -1)
					return false;
				else if (pos.InsertionPosition != -1)
				{
					_count++;
					_Insert(_Move(kvPair), pos.InsertionPosition);
					return true;
				}
				else
					throw InvalidOperationException(L"Inconsistent find result returned. This is a bug in Dictionary implementation.");
			}
			void Add(KeyValuePair<TKey, TValue> && kvPair)
			{
				if (!AddIfNotExists(_Move(kvPair)))
					throw KeyExistsException(L"The key already exists in Dictionary.");
			}
			TValue & Set(KeyValuePair<TKey, TValue> && kvPair)
			{
				Rehash();
				auto pos = FindPosition(kvPair.Key);
				if (pos.ObjectPosition != -1)
				{
					hashMap[pos.ObjectPosition]->Delete();
					return _Insert(_Move(kvPair), pos.ObjectPosition);
				}
				else if (pos.InsertionPosition != -1)
				{
					_count++;
					return _Insert(_Move(kvPair), pos.InsertionPosition);
				}
				else
					throw InvalidOperationException(L"Inconsistent find result returned. This is a bug in Dictionary implementation.");
			}
		public:
			typedef typename LinkedList<KeyValuePair<TKey, TValue>>::Iterator Iterator;

			typename LinkedList<KeyValuePair<TKey, TValue>>::Iterator begin() const
			{
				return kvPairs.begin();
			}
			typename LinkedList<KeyValuePair<TKey, TValue>>::Iterator end() const
			{
				return kvPairs.end();
			}
		public:
			void Add(const TKey & key, const TValue & value)
			{
				Add(KeyValuePair<TKey, TValue>(key, value));
			}
			void Add(TKey && key, TValue && value)
			{
				Add(KeyValuePair<TKey, TValue>(_Move(key), _Move(value)));
			}
			bool AddIfNotExists(const TKey & key, const TValue & value)
			{
				return AddIfNotExists(KeyValuePair<TKey, TValue>(key, value));
			}
			bool AddIfNotExists(TKey && key, TValue && value)
			{
				return AddIfNotExists(KeyValuePair<TKey, TValue>(_Move(key), _Move(value)));
			}
			void Remove(const TKey & key)
			{
				if (_count > 0)
				{
					auto pos = FindPosition(key);
					if (pos.ObjectPosition != -1)
					{
						kvPairs.Delete(hashMap[pos.ObjectPosition]);
						hashMap[pos.ObjectPosition] = 0;
						SetDeleted(pos.ObjectPosition, true);
						_count--;
					}
				}
			}
			void Clear()
			{
				_count = 0;
				kvPairs.Clear();
				marks.Clear();
			}
			bool ContainsKey(const TKey & key) const
			{
				if (bucketSizeMinusOne == -1)
					return false;
				auto pos = FindPosition(key);
				return pos.ObjectPosition != -1;
			}
			TValue * TryGetValue(const TKey & key) const
			{
				if (bucketSizeMinusOne == -1)
					return nullptr;
				auto pos = FindPosition(key);
				if (pos.ObjectPosition != -1)
				{
					return &(hashMap[pos.ObjectPosition]->Value.Value);
				}
				return nullptr;
			}
			bool TryGetValue(const TKey & key, TValue & value) const
			{
				if (bucketSizeMinusOne == -1)
					return false;
				auto pos = FindPosition(key);
				if (pos.ObjectPosition != -1)
				{
					value = hashMap[pos.ObjectPosition]->Value.Value;
					return true;
				}
				return false;
			}
			class ItemProxy
			{
			private:
				const EnumerableDictionary<TKey, TValue> * dict;
				TKey key;
			public:
				ItemProxy(const TKey & _key, const EnumerableDictionary<TKey, TValue> * _dict)
				{
					this->dict = _dict;
					this->key = _key;
				}
				ItemProxy(TKey && _key, const EnumerableDictionary<TKey, TValue> * _dict)
				{
					this->dict = _dict;
					this->key = _Move(_key);
				}
				TValue & GetValue() const
				{
					auto pos = dict->FindPosition(key);
					if (pos.ObjectPosition != -1)
					{
						return dict->hashMap[pos.ObjectPosition]->Value.Value;
					}
					else
					{
						throw KeyNotFoundException(L"The key does not exists in dictionary.");
					}
				}
				inline TValue & operator()() const
				{
					return GetValue();
				}
				operator TValue&() const
				{
					return GetValue();
				}
				TValue & operator = (const TValue & val)
				{
					return ((EnumerableDictionary<TKey, TValue>*)dict)->Set(KeyValuePair<TKey, TValue>(_Move(key), val));
				}
				TValue & operator = (TValue && val)
				{
					return ((EnumerableDictionary<TKey, TValue>*)dict)->Set(KeyValuePair<TKey, TValue>(_Move(key), _Move(val)));
				}
			};
			ItemProxy operator [](const TKey & key) const
			{
				return ItemProxy(key, this);
			}
			ItemProxy operator [](TKey && key) const
			{
				return ItemProxy(_Move(key), this);
			}
			int Count() const
			{
				return _count;
			}
			KeyValuePair<TKey, TValue> & First() const
			{
				return kvPairs.First();
			}
			KeyValuePair<TKey, TValue> & Last() const
			{
				return kvPairs.Last();
			}
		public:
			EnumerableDictionary()
			{
				bucketSizeMinusOne = -1;
				shiftBits = 32;
				_count = 0;
				hashMap = 0;
			}
			EnumerableDictionary(const EnumerableDictionary<TKey, TValue> & other)
				: bucketSizeMinusOne(-1), _count(0), hashMap(0)
			{
				*this = other;
			}
			EnumerableDictionary(EnumerableDictionary<TKey, TValue> && other)
				: bucketSizeMinusOne(-1), _count(0), hashMap(0)
			{
				*this = (_Move(other));
			}
			EnumerableDictionary<TKey, TValue> & operator = (const EnumerableDictionary<TKey, TValue> & other)
			{
				if (this == &other)
					return *this;
				Clear();
				for (auto & item : other)
					Add(item.Key, item.Value);
				return *this;
			}
			EnumerableDictionary<TKey, TValue> & operator = (EnumerableDictionary<TKey, TValue> && other)
			{
				if (this == &other)
					return *this;
				Free();
				bucketSizeMinusOne = other.bucketSizeMinusOne;
				_count = other._count;
				hashMap = other.hashMap;
				shiftBits = other.shiftBits;
				marks = _Move(other.marks);
				other.hashMap = 0;
				other._count = 0;
				other.bucketSizeMinusOne = -1;
				kvPairs = _Move(other.kvPairs);
				return *this;
			}
			~EnumerableDictionary()
			{
				Free();
			}
		};
		
		class _DummyClass
		{};

		template<typename T, typename DictionaryType>
		class HashSetBase
		{
		protected:
			DictionaryType dict;
		public:
			HashSetBase()
			{}
			HashSetBase(const HashSetBase & set)
			{
				operator=(set);
			}
			HashSetBase(HashSetBase && set)
			{
				operator=(_Move(set));
			}
			HashSetBase & operator = (const HashSetBase & set)
			{
				dict = set.dict;
				return *this;
			}
			HashSetBase & operator = (HashSetBase && set)
			{
				dict = _Move(set.dict);
				return *this;
			}
		public:
			class Iterator
			{
			private:
				typename DictionaryType::Iterator iter;
			public:
				Iterator() = default;
				T & operator *() const
				{
					return (*iter).Key;
				}
				T * operator ->() const
				{
					return &(*iter).Key;
				}
				Iterator & operator ++()
				{
					++iter;
					return *this;
				}
				Iterator operator ++(int)
				{
					Iterator rs = * this;
					operator++( );
					return rs;
				}
				bool operator != (const Iterator & _that) const
				{
					return iter != _that.iter;
				}
				bool operator == (const Iterator & _that) const
				{
					return iter == _that.iter;
				}
				Iterator(const typename DictionaryType::Iterator & _iter)
				{
					this->iter = _iter;
				}
			};
			Iterator begin() const
			{
				return Iterator(dict.begin());
			}
			Iterator end() const
			{
				return Iterator(dict.end());
			}
		public:
			int Count() const
			{
				return dict.Count();
			}
			void Clear()
			{
				dict.Clear();
			}
			bool Add(const T& obj)
			{
				return dict.AddIfNotExists(obj, _DummyClass());
			}
			bool Add(T && obj)
			{
				return dict.AddIfNotExists(_Move(obj), _DummyClass());
			}
			void Remove(const T & obj)
			{
				dict.Remove(obj);
			}
			bool Contains(const T & obj) const
			{
				return dict.ContainsKey(obj);
			}
		};
		template <typename T>
		class HashSet : public HashSetBase<T, Dictionary<T, _DummyClass>>
		{};

		template <typename T>
		class EnumerableHashSet : public HashSetBase<T, EnumerableDictionary<T, _DummyClass>>
		{
		public:
			T & First() const
			{
				return dict.First().Key;
			}
			T & Last() const
			{
				return dict.Last().Key;
			}
		};
	}
}

#endif

/***********************************************************************
CORELIB\FUNC.H
***********************************************************************/
#ifndef CORELIB_FUNC_H
#define CORELIB_FUNC_H


namespace CoreLib
{
	namespace Basic
	{
		template<typename TResult, typename... Arguments>
		class FuncPtr
		{
		public:
			virtual TResult operator()(Arguments...) = 0;
			virtual bool operator == (const FuncPtr<TResult, Arguments...> *)
			{
				return false;
			}
			virtual ~FuncPtr() {}
		};

		template<typename TResult, typename... Arguments>
		class CdeclFuncPtr : public FuncPtr<TResult, Arguments...>
		{
		public:
			typedef TResult (*FuncType)(Arguments...);
		private:
			FuncType funcPtr;
		public:
			CdeclFuncPtr(FuncType func)
				:funcPtr(func)
			{
			}

			virtual TResult operator()(Arguments... params) override
			{
				return funcPtr(params...);
			}

			virtual bool operator == (const FuncPtr<TResult, Arguments...> * ptr) override
			{
				auto cptr = dynamic_cast<const CdeclFuncPtr<TResult, Arguments...>*>(ptr);
				if (cptr)
					return funcPtr == cptr->funcPtr;
				else
					return false;
			}
		};

		template<typename Class, typename TResult, typename... Arguments>
		class MemberFuncPtr : public FuncPtr<TResult, Arguments...>
		{
		public:
			typedef TResult (Class::*FuncType)(Arguments...);
		private:
			FuncType funcPtr;
			Class * object;
		public:
			MemberFuncPtr(Class * obj, FuncType func)
				: funcPtr(func), object(obj)
			{
			}

			virtual TResult operator()(Arguments... params) override
			{
				return (object->*funcPtr)(params...);
			}

			virtual bool operator == (const FuncPtr<TResult, Arguments...> * ptr) override
			{
				auto cptr = dynamic_cast<const MemberFuncPtr<Class, TResult, Arguments...>*>(ptr);
				if (cptr)
					return funcPtr == cptr->funcPtr && object == cptr->object;
				else
					return false;
			}
		};

		template<typename F, typename TResult, typename... Arguments>
		class LambdaFuncPtr : public FuncPtr<TResult, Arguments...>
		{
		private:
			F func;
		public:
			LambdaFuncPtr(const F & _func)
				: func(_func)
			{}
			virtual TResult operator()(Arguments... params) override
			{
				return func(params...);
			}
			virtual bool operator == (const FuncPtr<TResult, Arguments...> * /*ptr*/) override
			{
				return false;
			}
		};

		template<typename TResult, typename... Arguments>
		class Func
		{
		private:
			RefPtr<FuncPtr<TResult, Arguments...>> funcPtr;
		public:
			Func(){}
			Func(typename CdeclFuncPtr<TResult, Arguments...>::FuncType func)
			{
				funcPtr = new CdeclFuncPtr<TResult, Arguments...>(func);
			}
			template<typename Class>
			Func(Class * object, typename MemberFuncPtr<Class, TResult, Arguments...>::FuncType func)
			{
				funcPtr = new MemberFuncPtr<Class, TResult, Arguments...>(object, func);
			}
			template<typename TFuncObj>
			Func(const TFuncObj & func)
			{
				funcPtr = new LambdaFuncPtr<TFuncObj, TResult, Arguments...>(func);
			}
			Func & operator = (typename CdeclFuncPtr<TResult, Arguments...>::FuncType func)
			{
				funcPtr = new CdeclFuncPtr<TResult, Arguments...>(func);
				return *this;
			}
			template<typename Class>
			Func & operator = (const MemberFuncPtr<Class, TResult, Arguments...> & func)
			{
				funcPtr = new MemberFuncPtr<Class, TResult, Arguments...>(func);
				return *this;
			}
			template<typename TFuncObj>
			Func & operator = (const TFuncObj & func)
			{
				funcPtr = new LambdaFuncPtr<TFuncObj, TResult, Arguments...>(func);
				return *this;
			}
			TResult operator()(Arguments... params)
			{
				return (*funcPtr)(params...);
			}
		};

		// template<typename... Arguments>
		// using Procedure = Func<void, Arguments...>;

		template<typename... Arguments>
		class Procedure : public Func<void, Arguments...>
		{
		private:
			RefPtr<FuncPtr<void, Arguments...>> funcPtr;
		public:
			Procedure(){}
			Procedure(const Procedure & proc)
			{
				funcPtr = proc;
			}
			Procedure(typename CdeclFuncPtr<void, Arguments...>::FuncType func)
			{
				funcPtr = new CdeclFuncPtr<void, Arguments...>(func);
			}
			template<typename Class>
			Procedure(Class * object, typename MemberFuncPtr<Class, void, Arguments...>::FuncType func)
			{
				funcPtr = new MemberFuncPtr<Class, void, Arguments...>(object, func);
			}
			template<typename TFuncObj>
			Procedure(const TFuncObj & func)
			{
				funcPtr = new LambdaFuncPtr<TFuncObj, void, Arguments...>(func);
			}
			Procedure & operator = (typename CdeclFuncPtr<void, Arguments...>::FuncType func)
			{
				funcPtr = new CdeclFuncPtr<void, Arguments...>(func);
				return *this;
			}
			template<typename Class>
			Procedure & operator = (const MemberFuncPtr<Class, void, Arguments...> & func)
			{
				funcPtr = new MemberFuncPtr<Class, void, Arguments...>(func);
				return *this;
			}
			template<typename TFuncObj>
			Procedure & operator = (const TFuncObj & func)
			{
				funcPtr = new LambdaFuncPtr<TFuncObj, void, Arguments...>(func);
				return *this;
			}
			Procedure & operator = (const Procedure & proc)
			{
				funcPtr = proc.funcPtr;
			}
			void Clear()
			{
				funcPtr = nullptr;
			}
			void operator()(Arguments... params)
			{
				if (funcPtr)
					(*funcPtr)(params...);
			}
		};
	}
}

#endif

/***********************************************************************
CORELIB\LINQ.H
***********************************************************************/
#ifndef FUNDAMENTAL_LIB_LINQ_H
#define FUNDAMENTAL_LIB_LINQ_H


namespace CoreLib
{
	namespace Basic
	{

		template <typename T>
		T ConstructT();

		template <typename T>
		class RemoveReference
		{
		public:
			typedef T Type;
		};

		template <typename T>
		class RemoveReference<T&>
		{
		public:
			typedef T Type;
		};

		template <typename T>
		class RemoveReference<T&&>
		{
		public:
			typedef T Type;
		};

		template<typename T>
		struct RemovePointer
		{
			typedef T Type;
		};

		template<typename T>
		struct RemovePointer<T*>
		{
			typedef T Type;
		};

		template <typename TQueryable, typename TEnumerator, typename T, typename TFunc>
		class WhereQuery
		{
		private:
			TQueryable items;
			const TFunc & func;
		public:
			WhereQuery(const TQueryable & queryable, const TFunc & f)
				: items(queryable), func(f)
			{}
			class Enumerator
			{
			private:
				TEnumerator ptr;
				TEnumerator end;
				const TFunc & func;
			public:
				Enumerator(const Enumerator &) = default;
				Enumerator(TEnumerator ptr, TEnumerator end, const TFunc & f)
					: ptr(ptr), end(end), func(f)
				{}
				T operator *() const
				{
					return *(ptr);
				}
				Enumerator& operator ++()
				{
					++ptr;
					while (ptr != end)
					{
						if (func(*ptr))
							break;
						else
							++ptr;
					}
					return *this;
				}
				Enumerator operator ++(int)
				{
					Enumerator rs = *this;
					while (rs.ptr != end)
					{
						if (func(*rs.ptr))
							break;
						++rs.ptr;
					}
					return rs;
				}
				bool operator != (const Enumerator & iter) const
				{
					return ptr != iter.ptr;
				}
				bool operator == (const Enumerator & iter) const
				{
					return ptr == iter.ptr;
				}
			};
			Enumerator begin() const
			{
				auto ptr = items.begin();
				auto end = items.end();
				while (ptr != end)
				{
					if (func(*ptr))
						break;
					++ptr;
				}
				return Enumerator(ptr, end, func);
			}
			Enumerator end() const
			{
				return Enumerator(items.end(), items.end(), func);
			}
		};

		template <typename TQueryable, typename TEnumerator, typename T>
		class SkipQuery
		{
		private:
			TQueryable items;
			int count = 0;
		public:
			SkipQuery(const TQueryable & queryable, int pCount)
				: items(queryable), count(pCount)
			{}
			class Enumerator
			{
			private:
				TEnumerator ptr;
				TEnumerator end;
			public:
				Enumerator(const Enumerator &) = default;
				Enumerator(TEnumerator pptr, TEnumerator pend)
					: ptr(pptr), end(pend)
				{
				}
				T operator *() const
				{
					return *(ptr);
				}
				Enumerator& operator ++()
				{
					++ptr;
					return *this;
				}
				Enumerator operator ++(int)
				{
					Enumerator rs = *this;
					++ptr;
					return rs;
				}
				bool operator != (const Enumerator & iter) const
				{
					return ptr != iter.ptr;
				}
				bool operator == (const Enumerator & iter) const
				{
					return ptr == iter.ptr;
				}
			};
			Enumerator begin() const
			{
				auto ptr = items.begin();
				auto end = items.end();
				for (int i = 0; i < count; i++)
					if (ptr != end)
						++ptr;
				return Enumerator(ptr, end);
			}
			Enumerator end() const
			{
				return Enumerator(items.end(), items.end());
			}
		};

		template <typename TQueryable, typename TEnumerator, typename T, typename TFunc>
		class SelectQuery
		{
		private:
			TQueryable items;
			const TFunc & func;
		public:
			SelectQuery(const TQueryable & queryable, const TFunc & f)
				: items(queryable), func(f)
			{}
			class Enumerator
			{
			private:
				TEnumerator ptr;
				TEnumerator end;
				const TFunc &func;
			public:
				Enumerator(const Enumerator &) = default;
				Enumerator(TEnumerator ptr, TEnumerator end, const TFunc & f)
					: ptr(ptr), end(end), func(f)
				{}
				auto operator *() const -> decltype(func(*ptr))
				{
					return func(*ptr);
				}
				Enumerator& operator ++()
				{
					++ptr;
					return *this;
				}
				Enumerator operator ++(int)
				{
					Enumerator rs = *this;
					++rs;
					return rs;
				}
				bool operator != (const Enumerator & iter) const
				{
					return !(ptr == iter.ptr);
				}
				bool operator == (const Enumerator & iter) const
				{
					return ptr == iter.ptr;
				}
			};
			Enumerator begin() const
			{
				return Enumerator(items.begin(), items.end(), func);
			}
			Enumerator end() const
			{
				return Enumerator(items.end(), items.end(), func);
			}
		};

		template <typename TQueryable, typename TEnumerator, typename T, typename TFunc>
		class SelectManyQuery
		{
		private:
			TQueryable items;
			const TFunc & func;
			SelectManyQuery()
			{}
		public:
			SelectManyQuery(const TQueryable & queryable, const TFunc & f)
				: items(queryable), func(f)
			{}
			template<typename TItems, typename TItemPtr>
			class Enumerator
			{
			private:
				TEnumerator ptr;
				TEnumerator end;
				const TFunc &func;
				TItems items;
				TItemPtr subPtr;
			public:
				Enumerator(const Enumerator &) = default;
				Enumerator(TEnumerator ptr, TEnumerator end, const TFunc & f)
					: ptr(ptr), end(end), func(f)
				{
					if (ptr != end)
					{
						items = f(*ptr);
						subPtr = items.begin();
					}
				}
				auto operator *() const -> decltype(*subPtr)
				{
					return *subPtr;
				}
				Enumerator& operator ++()
				{
					++subPtr;
					while (subPtr == items.end() && ptr != end)
					{
						++ptr;
						if (ptr != end)
						{
							items = func(*ptr);
							subPtr = items.begin();
						}
						else
							break;
					}

					return *this;
				}
				Enumerator operator ++(int)
				{
					Enumerator rs = *this;
					++rs;
					return rs;
				}
				bool operator != (const Enumerator & iter) const
				{
					return !operator==(iter);
				}
				bool operator == (const Enumerator & iter) const
				{
					if (ptr == iter.ptr)
					{
						if (ptr == end)
							return true;
						else
							return subPtr == iter.subPtr;
					}
					else
						return false;
				}
			};
			auto begin()->Enumerator<decltype(func(ConstructT<T>())), decltype(func(ConstructT<T>()).begin())> const
			{
				return Enumerator<decltype(func(ConstructT<T>())), decltype(func(ConstructT<T>()).begin())>(items.begin(), items.end(), func);
			}
			auto end()->Enumerator<decltype(func(ConstructT<T>())), decltype(func(ConstructT<T>()).begin())> const
			{
				return Enumerator<decltype(func(ConstructT<T>())), decltype(func(ConstructT<T>()).begin())>(items.end(), items.end(), func);
			}
		};

		template <typename T>
		struct EnumeratorType
		{
			typedef decltype(ConstructT<T>().begin()) Type;
		};

		template <typename TFunc, typename TArg>
		class ExtractReturnType
		{
		public:
			static TFunc * f;
			static TArg ConstructArg() {};
			typedef decltype((*f)(ConstructArg())) ReturnType;
		};

		template <typename T>
		class ExtractItemType
		{
		public:
			typedef typename RemovePointer<decltype(ConstructT<T>().begin())>::Type Type;
		};

		template <typename TQueryable, typename TEnumerator, typename T>
		class Queryable
		{
		private:
			TQueryable items;
		public:
			auto begin() -> decltype(items.begin()) const
			{
				return items.begin();
			}
			auto end() -> decltype(items.end()) const
			{
				return items.end();
			}
		public:
			Queryable(const TQueryable & items)
				: items(items)
			{}

			Queryable<SkipQuery<TQueryable, TEnumerator, T>, typename SkipQuery<TQueryable, TEnumerator, T>::Enumerator, T> Skip(int count) const
			{
				return Queryable<SkipQuery<TQueryable, TEnumerator, T>, typename SkipQuery<TQueryable, TEnumerator, T>::Enumerator, T>(SkipQuery<TQueryable, TEnumerator, T>(items, count));
			}

			template<typename TFunc>
			Queryable<WhereQuery<TQueryable, TEnumerator, T, TFunc>, typename WhereQuery<TQueryable, TEnumerator, T, TFunc>::Enumerator, T> Where(const TFunc & f) const
			{
				return Queryable<WhereQuery<TQueryable, TEnumerator, T, TFunc>, typename WhereQuery<TQueryable, TEnumerator, T, TFunc>::Enumerator, T>(WhereQuery<TQueryable, TEnumerator, T, TFunc>(items, f));
			}

			template<typename TFunc>
			Queryable<SelectQuery<TQueryable, TEnumerator, T, TFunc>, typename SelectQuery<TQueryable, TEnumerator, T, TFunc>::Enumerator, typename RemoveReference<typename ExtractReturnType<TFunc, T>::ReturnType>::Type> Select(const TFunc & f) const
			{
				return Queryable<SelectQuery<TQueryable, TEnumerator, T, TFunc>, typename SelectQuery<TQueryable, TEnumerator, T, TFunc>::Enumerator, typename RemoveReference<typename ExtractReturnType<TFunc, T>::ReturnType>::Type>(SelectQuery<TQueryable, TEnumerator, T, TFunc>(items, f));
			}

			template<typename TFunc>
			auto SelectMany(const TFunc & f) ->Queryable<SelectManyQuery<TQueryable, TEnumerator, T, TFunc>, typename EnumeratorType<SelectManyQuery<TQueryable, TEnumerator, T, TFunc>>::Type, typename ExtractItemType<decltype(f(ConstructT<T>()))>::Type> const
			{
				return Queryable<SelectManyQuery<TQueryable, TEnumerator, T, TFunc>, typename EnumeratorType<SelectManyQuery<TQueryable, TEnumerator, T, TFunc>>::Type, typename ExtractItemType<decltype(f(ConstructT<T>()))>::Type>(SelectManyQuery<TQueryable, TEnumerator, T, TFunc>(items, f));
			}

			template<typename TAggregateResult, typename TFunc>
			auto Aggregate(const TAggregateResult & initial, const TFunc & f) -> decltype(f(initial, *items.begin())) const
			{
				TAggregateResult rs = initial;
				for (auto && x : items)
					rs = f(rs, x);
				return rs;
			}

			template<typename TFunc>
			bool Any(const TFunc & condition) const
			{
				for (auto && x : items)
					if (condition(x))
						return true;
				return false;
			}

			template<typename TFunc>
			T & First(const TFunc & condition) const
			{
				for (auto && x : items)
					if (condition(x))
						return x;
			}

			template <typename TFunc>
			T Max(const TFunc & selector) const
			{
				return Aggregate(*items.begin(), [&](const T & v0, const T & v1)
				{
					return selector(v0) > selector(v1) ? v0 : v1;
				});
			}

			template <typename TFunc>
			T Min(const TFunc & selector) const
			{
				return Aggregate(*items.begin(), [&](const T & v0, const T & v1)
				{
					return selector(v0) < selector(v1) ? v0 : v1;
				});
			}

			template <typename TFunc>
			auto Sum(const TFunc & selector) -> decltype(selector(ConstructT<T>())) const
			{
				decltype(selector(ConstructT<T>())) rs(0);
				for (auto && x : items)
					rs = rs + selector(x);
				return rs;
			}

			T Max() const
			{
				return Aggregate(*items.begin(), [](const T & v0, const T & v1) {return v0 > v1 ? v0 : v1; });
			}

			T Min() const
			{
				return Aggregate(*items.begin(), [](const T & v0, const T & v1) {return v0 < v1 ? v0 : v1; });
			}

			T Sum() const
			{
				T rs = T(0);
				for (auto && x : items)
					rs = rs + x;
				return rs;
			}

			T Avg() const
			{
				T rs = T(0);
				int count = 0;
				for (auto && x : items)
				{
					rs = rs + x;
					count++;
				}
				return rs / count;
			}

			int Count() const
			{
				int rs = 0;
				for (auto && x : items)
					rs++;
				return rs;
			}

			List<T> ToList() const
			{
				List<T> rs;
				for (auto && val : items)
					rs.Add(val);
				return rs;
			}
		};


		template<typename T, typename TAllocator>
		inline Queryable<ArrayView<T>, T*, T> From(const List<T, TAllocator> & list)
		{
			return Queryable<ArrayView<T>, T*, T>(list.GetArrayView());
		}

		template<typename T>
		inline Queryable<ArrayView<T>, T*, T> From(const ArrayView<T> & list)
		{
			return Queryable<ArrayView<T>, T*, T>(list);
		}

		template<typename T>
		struct LinkedListView
		{
			typename LinkedList<T>::Iterator start, last;
			typename LinkedList<T>::Iterator begin()
			{
				return start;
			}
			typename LinkedList<T>::Iterator end()
			{
				return last;
			}
		};

		template<typename T>
		inline Queryable<LinkedListView<T>, LinkedNode<T>, T> From(const LinkedList<T> & list)
		{
			LinkedListView<T> view;
			view.start = list.begin();
			view.last = list.end();
			return Queryable<LinkedListView<T>, LinkedNode<T>, T>(view);
		}

		template<typename TKey, typename TValue>
		struct EnumerableDictView
		{
			typename EnumerableDictionary<TKey, TValue>::Iterator start, last;
			typename EnumerableDictionary<TKey, TValue>::Iterator begin()
			{
				return start;
			}
			typename EnumerableDictionary<TKey, TValue>::Iterator end()
			{
				return last;
			}
		};

		template<typename TKey, typename TValue>
		inline Queryable<EnumerableDictView<TKey, TValue>, typename EnumerableDictionary<TKey, TValue>::Iterator, KeyValuePair<TKey, TValue>> From(const EnumerableDictionary<TKey, TValue> & dict)
		{
			EnumerableDictView<TKey, TValue> view;
			view.start = dict.begin();
			view.last = dict.end();
			return Queryable<EnumerableDictView<TKey, TValue>, typename EnumerableDictionary<TKey, TValue>::Iterator, KeyValuePair<TKey, TValue>>(view);
		}

		template<typename TKey>
		struct EnumerableHashSetView
		{
			typename HashSetBase<TKey, EnumerableDictionary<TKey, _DummyClass>>::Iterator start, last;
			typename EnumerableHashSet<TKey>::Iterator begin()
			{
				return start;
			}
			typename EnumerableHashSet<TKey>::Iterator end()
			{
				return last;
			}
		};

		template<typename TKey>
		inline Queryable<EnumerableHashSetView<TKey>, typename HashSetBase<TKey, EnumerableDictionary<TKey, _DummyClass>>::Iterator, TKey> From(const EnumerableHashSet<TKey> & dict)
		{
			EnumerableHashSetView<TKey> view;
			view.start = dict.begin();
			view.last = dict.end();
			return Queryable<EnumerableHashSetView<TKey>, typename HashSetBase<TKey, EnumerableDictionary<TKey, _DummyClass>>::Iterator, TKey>(view);
		}
	}
}

#endif

/***********************************************************************
CORELIB\BASIC.H
***********************************************************************/
#ifndef CORE_LIB_BASIC_H
#define CORE_LIB_BASIC_H


namespace CoreLib
{
	using namespace Basic;
}

#endif

/***********************************************************************
SPIRECORE\CODEPOSITION.H
***********************************************************************/
#ifndef SPIRE_CODE_POSITION_H
#define SPIRE_CODE_POSITION_H


namespace Spire
{
	namespace Compiler
	{
		using namespace CoreLib::Basic;

		class CodePosition
		{
		public:
			int Line = -1, Col = -1;
			String FileName;
			String ToString()
			{
				StringBuilder sb(100);
				sb << FileName;
				if (Line != -1)
					sb << L"(" << Line << L")";
				return sb.ProduceString();
			}
			CodePosition() = default;
			CodePosition(int line, int col, String fileName)
			{
				Line = line;
				Col = col;
				this->FileName = fileName;
			}
			bool operator < (const CodePosition & pos) const
			{
				return FileName < pos.FileName || (FileName == pos.FileName && Line < pos.Line) ||
					(FileName == pos.FileName && Line == pos.Line && Col < pos.Col);
			}
			bool operator == (const CodePosition & pos) const
			{
				return FileName == pos.FileName && Line == pos.Line && Col == pos.Col;
			}
		};
	}
}

#endif

/***********************************************************************
SPIRECORE\COMPILEERROR.H
***********************************************************************/
#ifndef RASTER_RENDERER_COMPILE_ERROR_H
#define RASTER_RENDERER_COMPILE_ERROR_H


namespace Spire
{
	namespace Compiler
	{
		using namespace CoreLib::Basic;

		class CompileError
		{
		public:
			String Message;
			CodePosition Position;
			int ErrorID;

			CompileError()
			{
				ErrorID = -1;
			}
			CompileError(const String & msg, int id,
						const CodePosition & pos)
			{
				Message = msg;
				ErrorID = id;
				Position = pos;
			}
		};

		class ErrorWriter
		{
		private:
			List<CompileError> & errors;
			List<CompileError> & warnings;
			struct ErrorState
			{
				int ErrorCount, WarningCount;
			};
			List<ErrorState> errStack;
		public:
			ErrorWriter(List<CompileError> & perrors, List<CompileError> & pwarnings)
				: errors(perrors), warnings(pwarnings)
			{}
			void Error(int id, const String & msg, const CodePosition & pos)
			{
				errors.Add(CompileError(msg, id, pos));
			}
			void Warning(int id, const String & msg, const CodePosition & pos)
			{
				warnings.Add(CompileError(msg, id, pos));
			}
			void PushState()
			{
				ErrorState state;
				state.ErrorCount = errors.Count();
				state.WarningCount = warnings.Count();
				errStack.Add(state);
			}
			void PopState()
			{
				ErrorState state = errStack.Last();
				errStack.RemoveAt(errStack.Count() - 1);
				errors.SetSize(state.ErrorCount);
				warnings.SetSize(state.WarningCount);
			}
			int GetErrorCount()
			{
				return errors.Count();
			}
			ErrorWriter & operator = (const ErrorWriter & other) = delete;
		};
	}
}

#endif

/***********************************************************************
CORELIB\REGEX\REGEXTREE.H
***********************************************************************/
#ifndef GX_REGEX_PARSER_H
#define GX_REGEX_PARSER_H


namespace CoreLib
{
	namespace Text
	{
		using namespace CoreLib::Basic;

		class RegexCharSetNode;
		class RegexRepeatNode;
		class RegexConnectionNode;
		class RegexSelectionNode;

		class RegexNodeVisitor : public Object
		{
		public:
			virtual void VisitCharSetNode(RegexCharSetNode * node);
			virtual void VisitRepeatNode(RegexRepeatNode * node);
			virtual void VisitConnectionNode(RegexConnectionNode * node);
			virtual void VisitSelectionNode(RegexSelectionNode * node);
		};

		class RegexNode : public Object
		{
		public:
			virtual String Reinterpret() = 0;
			virtual void Accept(RegexNodeVisitor * visitor) = 0;
		};

		class RegexCharSet : public Object
		{
		private:
			List<RegexCharSet *> OriSet;
			void CopyCtor(const RegexCharSet & set);
		public:
			bool Neg;
			struct RegexCharRange
			{
				wchar_t Begin,End;
				bool operator == (const RegexCharRange & r);
			};
			List<RegexCharRange> Ranges;
			List<unsigned short> Elements; 
		
		public:
			RegexCharSet()
			{
				Neg = false;
			}
			RegexCharSet(const RegexCharSet & set);
			String Reinterpret();
			void Normalize();
			void Sort();
			void AddRange(RegexCharRange r);
			void SubtractRange(RegexCharRange r);
			bool Contains(RegexCharRange r);
			bool operator ==(const RegexCharSet & set);
			RegexCharSet & operator = (const RegexCharSet & set);
			static void InsertElement(List<RefPtr<RegexCharSet>> &L, RefPtr<RegexCharSet> & elem);
			static void RangeMinus(RegexCharRange r1, RegexCharRange r2, RegexCharSet & rs);
			static void CharSetMinus(RegexCharSet & s1, RegexCharSet & s2);
			static void RangeIntersection(RegexCharRange r1, RegexCharRange r2, RegexCharSet &rs);
			static void CalcCharElementFromPair(RegexCharSet * c1, RegexCharSet * c2, RegexCharSet & AmB, RegexCharSet & BmA, RegexCharSet & AnB);
			static void CalcCharElements(List<RegexCharSet *> & sets, List<RegexCharRange> & elements);
		};

		class RegexCharSetNode : public RegexNode
		{
		public:
			RefPtr<RegexCharSet> CharSet;
		public:
			String Reinterpret();
			virtual void Accept(RegexNodeVisitor * visitor);
			RegexCharSetNode();
		};

		class RegexRepeatNode : public RegexNode
		{
		public:
			enum _RepeatType
			{
				rtOptional, rtArbitary, rtMoreThanOnce, rtSpecified
			};
			_RepeatType RepeatType = rtOptional;
			int MinRepeat = -1, MaxRepeat = -1;
			RefPtr<RegexNode> Child;
		public:
			String Reinterpret();
			virtual void Accept(RegexNodeVisitor * visitor);
		};

		class RegexConnectionNode : public RegexNode
		{
		public:
			RefPtr<RegexNode> LeftChild, RightChild;
		public:
			String Reinterpret();
			virtual void Accept(RegexNodeVisitor * visitor);
		};

		class RegexSelectionNode : public RegexNode
		{
		public:
			RefPtr<RegexNode> LeftChild, RightChild;
		public:
			String Reinterpret();
			virtual void Accept(RegexNodeVisitor * visitor);
		};

		class RegexParser : public Object
		{
		private:
			String src;
			int ptr;
			RegexNode * ParseSelectionNode();
			RegexNode * ParseConnectionNode();
			RegexNode * ParseRepeatNode();
			RegexCharSet * ParseCharSet();
			wchar_t ReadNextCharInCharSet();
			int ParseInteger();
			bool IsOperator();
		public:
			struct SyntaxError
			{
				int Position;
				String Text;
			};
			List<SyntaxError> Errors;
			RefPtr<RegexNode> Parse(const String & regex); 
		};
	}
}

#endif

/***********************************************************************
CORELIB\REGEX\REGEXNFA.H
***********************************************************************/
#ifndef REGEX_NFA_H
#define REGEX_NFA_H


namespace CoreLib
{
	namespace Text
	{
		using namespace CoreLib::Basic;

		class NFA_Node;

		class NFA_Translation : public Object
		{
		public:
			RefPtr<RegexCharSet> CharSet;
			NFA_Node * NodeSrc, * NodeDest;
			NFA_Translation();
			NFA_Translation(NFA_Node * src, NFA_Node * dest, RefPtr<RegexCharSet> charSet);
			NFA_Translation(NFA_Node * src, NFA_Node * dest);
		};

		class NFA_Node : public Object
		{
		private:
			static int HandleCount;
		public:
			int ID = -1;
			bool Flag = 0;
			bool IsFinal = false;
			int TerminalIdentifier;
			List<NFA_Translation *> Translations;
			List<NFA_Translation *> PrevTranslations;
			void RemoveTranslation(NFA_Translation * trans);
			void RemovePrevTranslation(NFA_Translation * trans);
			NFA_Node();
		};

		class NFA_Graph : public RegexNodeVisitor
		{
			friend class DFA_Graph;
		private:
			NFA_Node * start = nullptr, * end = nullptr;
			struct NFA_StatePair
			{
				NFA_Node * start = nullptr, * end = nullptr;
			};
			List<NFA_StatePair> stateStack;
			NFA_StatePair PopState();
			void PushState(NFA_StatePair s);
		private:
			List<RefPtr<NFA_Node>> nodes;
			List<RefPtr<NFA_Translation>> translations;
			void ClearNodes();
			void ClearNodeFlags();
			void GetValidStates(List<NFA_Node *> & states);
			void GetEpsilonClosure(NFA_Node * node, List<NFA_Node *> & states);
			void EliminateEpsilon();
		public:
			NFA_Node * CreateNode();
			NFA_Translation * CreateTranslation();
			String Interpret();
			void GenerateFromRegexTree(RegexNode * tree, bool elimEpsilon = true);
			void PostGenerationProcess();
			void CombineNFA(NFA_Graph * graph);
			NFA_Node * GetStartNode();
			void SetStartNode(NFA_Node * node);
			void SetTerminalIdentifier(int id);
			virtual void VisitCharSetNode(RegexCharSetNode * node);
			virtual void VisitRepeatNode(RegexRepeatNode * node);
			virtual void VisitConnectionNode(RegexConnectionNode * node);
			virtual void VisitSelectionNode(RegexSelectionNode * node);
		};
	}
}


#endif

/***********************************************************************
CORELIB\REGEX\REGEXDFA.H
***********************************************************************/
#ifndef REGEX_DFA_H
#define REGEX_DFA_H


namespace CoreLib
{
	namespace Text
	{
		using namespace CoreLib::Basic;

		typedef List<Word> RegexCharTable;
	
		class CharTableGenerator : public Object
		{
		private:
			List<String> sets;
			RegexCharTable * table;
			int AddSet(String set);
		public:
			List<RegexCharSet::RegexCharRange> elements;
			CharTableGenerator(RegexCharTable * _table);
			int Generate(List<RegexCharSet *> & charSets);
		};

		class DFA_Table_Tag
		{
		public:
			bool IsFinal = false;
			List<int> TerminalIdentifiers; // sorted
			DFA_Table_Tag();
		};

		class DFA_Table : public Object
		{
		public:
			int StateCount;
			int AlphabetSize;
			int ** DFA;
			List<RefPtr<DFA_Table_Tag>> Tags;
			int StartState;
			RefPtr<RegexCharTable> CharTable;
			DFA_Table();
			~DFA_Table();
		};

		class DFA_Node : public Object
		{
		public:
			int ID = -1;
			bool IsFinal = false;
			List<int> TerminalIdentifiers; // sorted
			List<NFA_Node*> Nodes;  // sorted
			List<DFA_Node *> Translations;
			DFA_Node(int elements);
			bool operator == (const DFA_Node & node);
		};

		class DFA_Graph : public Object
		{
		private:
			List<RegexCharSet::RegexCharRange> CharElements;
			RefPtr<RegexCharTable> table;
			DFA_Node * startNode;
			List<RefPtr<DFA_Node>> nodes;
			void CombineCharElements(NFA_Node * node, List<Word> & elem);
		public:
			void Generate(NFA_Graph * nfa);
			String Interpret();
			void ToDfaTable(DFA_Table * dfa);
		};
	}
}
#endif

/***********************************************************************
CORELIB\REGEX\REGEX.H
***********************************************************************/
#ifndef GX_REGEX_H
#define GX_REGEX_H


namespace CoreLib
{
	namespace Text
	{
		class IllegalRegexException : public Exception
		{
		};

		class RegexMatcher : public Object
		{
		private:
			DFA_Table * dfa;
		public:
			RegexMatcher(DFA_Table * table);
			int Match(const String & str, int startPos = 0);
		};

		class PureRegex : public Object
		{
		private:
			RefPtr<DFA_Table> dfaTable;
		public:
			struct RegexMatchResult
			{
				int Start;
				int Length;
			};
			PureRegex(const String & regex);
			bool IsMatch(const String & str); // Match Whole Word
			RegexMatchResult Search(const String & str, int startPos = 0);
			DFA_Table * GetDFA();
		};
	}
}

#endif

/***********************************************************************
CORELIB\REGEX\METALEXER.H
***********************************************************************/
#ifndef GX_META_LEXER_H
#define GX_META_LEXER_H


namespace CoreLib
{
	namespace Text
	{
		class LexToken
		{
		public:
			String Str;
			int TypeID;
			int Position;
		};

		class LazyLexToken
		{
		public:
			int TypeID;
			int Position;
			int Length;
		};

		typedef LinkedList<LexToken> LexStream;
	
		class LexerError
		{
		public:
			String Text;
			int Position;
		};

		struct LexProfileToken
		{
			String str;
			enum LexProfileTokenType
			{
				Identifier,
				Equal,
				Regex
			} type;
		};

		typedef LinkedList<LexProfileToken> LexProfileTokenStream;
		typedef LinkedNode<LexProfileToken> LexProfileTokenNode;

		class LexicalParseException : public Exception
		{
		public:
			int Position;
			LexicalParseException(String str, int pos) : Exception(str), Position(pos)
			{}
		};

		class LazyLexStream
		{
		private:
			RefPtr<DFA_Table> dfa; 
			List<bool> *ignoreSet;
		public:
			String InputText;
			LazyLexStream() = default;
			LazyLexStream(String text, const RefPtr<DFA_Table> & dfa, List<bool> *ignoreSet)
				: dfa(dfa), ignoreSet(ignoreSet), InputText(text)
			{}
			inline DFA_Table * GetDFA()
			{
				return dfa.Ptr();
			}
			inline List<bool> & GetIgnoreSet()
			{
				return *ignoreSet;
			}
			class Iterator
			{
			public:
				int ptr, state, lastTokenPtr;
				LazyLexStream * stream;
				LazyLexToken currentToken;
				bool operator != (const Iterator & iter) const
				{
					return lastTokenPtr != iter.lastTokenPtr;
				}
				bool operator == (const Iterator & iter) const
				{
					return lastTokenPtr == iter.lastTokenPtr;
				}
				LazyLexToken * operator ->()
				{
					return &currentToken;
				}
				LazyLexToken operator *()
				{
					return currentToken;
				}
				Iterator & operator ++();
				Iterator operator ++(int)
				{
					Iterator rs = *this;
					this->operator++();
					return rs;
				}
			};
			Iterator begin()
			{
				Iterator iter;
				iter.ptr = 0;
				iter.lastTokenPtr = 0;
				iter.state = dfa->StartState;
				iter.stream = this;
				++iter;
				return iter;
			}
			Iterator end()
			{
				Iterator iter;
				iter.ptr = InputText.Length();
				iter.lastTokenPtr = -1;
				iter.state = dfa->StartState;
				iter.stream = this;
				return iter;
			}
		};

		class MetaLexer : public Object
		{
		private:
			RefPtr<DFA_Table> dfa;
			List<String> Regex;
			List<String> TokenNames;
			List<bool> Ignore;
			String ReadProfileToken(LexProfileTokenNode*n, LexProfileToken::LexProfileTokenType type);
			bool ParseLexProfile(const String &lex);
			void ConstructDFA();
		public:
			int TokensParsed;
			List<LexerError> Errors;
			MetaLexer(String LexProfile);
			MetaLexer();
			DFA_Table * GetDFA();
			String GetTokenName(int id);
			int GetRuleCount();
			void SetLexProfile(String lex);
			bool Parse(String str, LexStream & stream);
			LazyLexStream Parse(String str)
			{
				return LazyLexStream(str, dfa, &Ignore);
			}
		};
	}
}

#endif

/***********************************************************************
CORELIB\PARSER.H
***********************************************************************/
#ifndef CORELIB_TEXT_PARSER_H
#define CORELIB_TEXT_PARSER_H


namespace CoreLib
{
	namespace Text
	{
		class TextFormatException : public Exception
		{
		public:
			TextFormatException(String message)
				: Exception(message)
			{}
		};

		const int TokenType_Identifier = 3;
		const int TokenType_Int = 4;
		const int TokenType_Float = 5;
		const int TokenType_StringLiteral = 6;
		const int TokenType_CharLiteral = 7;

		class Parser
		{
		private:
			static RefPtr<MetaLexer> metaLexer;
			LazyLexStream stream;
			bool legal;
			String text;
			List<LazyLexToken> tokens;
			int tokenPtr;
			LexToken MakeToken(LazyLexToken ltk)
			{
				LexToken tk;
				tk.Position = ltk.Position;
				tk.TypeID = ltk.TypeID;
				tk.Str = text.SubString(ltk.Position, ltk.Length);
				return tk;
			}
		public:
			static MetaLexer * GetTextLexer();
			static void DisposeTextLexer();
			static Basic::List<Basic::String> SplitString(Basic::String str, wchar_t ch);
			Parser(Basic::String text);
			int ReadInt()
			{
				auto token = ReadToken();
				bool neg = false;
				if (token.Str == L'-')
				{
					neg = true;
					token = ReadToken();
				}
				if (token.TypeID == TokenType_Int)
				{
					if (neg)
						return -StringToInt(token.Str);
					else
						return StringToInt(token.Str);
				}
				throw TextFormatException(L"Text parsing error: int expected.");
			}
			unsigned int ReadUInt()
			{
				auto token = ReadToken();
				if (token.TypeID == TokenType_Int)
				{
					return StringToUInt(token.Str);
				}
				throw TextFormatException(L"Text parsing error: int expected.");
			}
			double ReadDouble()
			{
				auto token = ReadToken();
				bool neg = false;
				if (token.Str == L'-')
				{
					neg = true;
					token = ReadToken();
				}
				if (token.TypeID == TokenType_Float || token.TypeID == TokenType_Int)
				{
					if (neg)
						return -StringToDouble(token.Str);
					else
						return StringToDouble(token.Str);
				}
				throw TextFormatException(L"Text parsing error: floating point value expected.");
			}
			String ReadWord()
			{
				auto token = ReadToken();
				if (token.TypeID == TokenType_Identifier)
				{
					return token.Str;
				}
				throw TextFormatException(L"Text parsing error: identifier expected.");
			}
			String Read(const wchar_t * expectedStr)
			{
				auto token = ReadToken();
				if (token.Str == expectedStr)
				{
					return token.Str;
				}
				throw TextFormatException(L"Text parsing error: \'" + String(expectedStr) + L"\' expected.");
			}
			String Read(String expectedStr)
			{
				auto token = ReadToken();
				if (token.Str == expectedStr)
				{
					return token.Str;
				}
				throw TextFormatException(L"Text parsing error: \'" + expectedStr + L"\' expected.");
			}
			static String EscapeStringLiteral(String str)
			{
				StringBuilder sb;
				sb << L"\"";
				for (int i = 0; i < str.Length(); i++)
				{
					switch (str[i])
					{
					case L' ':
						sb << L"\\s";
						break;
					case L'\n':
						sb << L"\\n";
						break;
					case L'\r':
						sb << L"\\r";
						break;
					case L'\t':
						sb << L"\\t";
						break;
					case L'\v':
						sb << L"\\v";
						break;
					case L'\'':
						sb << L"\\\'";
						break;
					case L'\"':
						sb << L"\\\"";
						break;
					case L'\\':
						sb << L"\\\\";
						break;
					default:
						sb << str[i];
						break;
					}
				}
				sb << L"\"";
				return sb.ProduceString();
			}
			String UnescapeStringLiteral(String str)
			{
				StringBuilder sb;
				for (int i = 0; i < str.Length(); i++)
				{
					if (str[i] == L'\\' && i < str.Length() - 1)
					{
						switch (str[i + 1])
						{
						case L's':
							sb << L" ";
							break;
						case L't':
							sb << L'\t';
							break;
						case L'n':
							sb << L'\n';
							break;
						case L'r':
							sb << L'\r';
							break;
						case L'v':
							sb << L'\v';
							break;
						case L'\'':
							sb << L'\'';
							break;
						case L'\"':
							sb << L"\"";
							break;
						case L'\\':
							sb << L"\\";
							break;
						default:
							i = i - 1;
							sb << str[i];
						}
						i++;
					}
					else
						sb << str[i];
				}
				return sb.ProduceString();
			}
			String ReadStringLiteral()
			{
				auto token = ReadToken();
				if (token.TypeID == TokenType_StringLiteral)
				{
					return UnescapeStringLiteral(token.Str.SubString(1, token.Str.Length()-2));
				}
				throw TextFormatException(L"Text parsing error: string literal expected.");
			}
			void Back(int count)
			{
				tokenPtr -= count;
			}
			LexToken ReadToken()
			{
				if (tokenPtr < tokens.Count())
				{
					LexToken rs = MakeToken(tokens[tokenPtr]);
					tokenPtr++;
					return rs;
				}
				throw TextFormatException(L"Unexpected ending.");
			}
			LexToken NextToken()
			{
				if (tokenPtr < tokens.Count())
					return MakeToken(tokens[tokenPtr]);
				else
				{
					LexToken rs;
					rs.TypeID = -1;
					rs.Position = -1;
					return rs;
				}
			}
			bool LookAhead(String token)
			{
				if (tokenPtr < tokens.Count())
				{
					auto next = NextToken();
					return next.Str == token;
				}
				else
				{
					return false;
				}
			}
			bool IsEnd()
			{
				return tokenPtr == tokens.Count();
			}
		public:
			bool IsLegalText()
			{
				return legal;
			}
		};

		List<String> Split(String str, wchar_t c);
	}
}

#endif

/***********************************************************************
SPIRECORE\IL.H
***********************************************************************/
#ifndef RASTER_RENDERER_IL_H
#define RASTER_RENDERER_IL_H


namespace Spire
{
	namespace Compiler
	{
		using namespace CoreLib::Basic;
		enum class LayoutRule
		{
			Std140, Std430, Packed
		};
		enum ILBaseType
		{
			Int = 16, Int2 = 17, Int3 = 18, Int4 = 19,
			Float = 32, Float2 = 33, Float3 = 34, Float4 = 35,
			Float3x3 = 40, Float4x4 = 47,
			Texture2D = 48,
			TextureShadow = 49,
			TextureCube = 50,
			TextureCubeShadow = 51,
			Bool = 128, Bool2 = 129, Bool3 = 130, Bool4 = 131,
			UInt = 512, UInt2 = 513, UInt3 = 514, UInt4 = 515,
		};
		int SizeofBaseType(ILBaseType type);
		int RoundToAlignment(int offset, int alignment);
		extern int NamingCounter;
		class ILType : public RefObject
		{
		public:
			bool IsBool();
			bool IsInt();
			bool IsUInt();
			bool IsIntegral();
			bool IsFloat();
			bool IsScalar()
			{
				return IsInt() || IsUInt() || IsFloat() || IsBool();
			}
			bool IsBoolVector(); 
			bool IsIntVector();
			bool IsUIntVector();
			bool IsFloatVector();
			bool IsFloatMatrix();
			bool IsVector()
			{
				return IsIntVector() || IsUIntVector() || IsFloatVector() || IsBoolVector();
			}
			bool IsTexture();
			bool IsNonShadowTexture();
			int GetVectorSize();
			virtual ILType * Clone() = 0;
			virtual String ToString() = 0;
			virtual bool Equals(ILType* type) = 0;
			virtual int GetSize(LayoutRule rule = LayoutRule::Std430) = 0;
			virtual int GetAlignment(LayoutRule rule = LayoutRule::Std430) = 0;
		};

		RefPtr<ILType> TypeFromString(CoreLib::Text::Parser & parser);

		class ILObjectDefinition
		{
		public:
			RefPtr<ILType> Type;
			String Name;
			EnumerableDictionary<String, String> Attributes;
			CodePosition Position;
		};

		class ILRecordType : public ILType
		{
		public:
			String TypeName;
			EnumerableDictionary<String, ILObjectDefinition> Members;
			virtual ILType * Clone() override;
			virtual String ToString() override;
			virtual bool Equals(ILType* type) override;
			virtual int GetSize(LayoutRule rule) override;
			virtual int GetAlignment(LayoutRule rule) override;
		};

		class ILBasicType : public ILType
		{
		public:
			ILBaseType Type;
			ILBasicType()
			{
				Type = ILBaseType::Int;
			}
			ILBasicType(ILBaseType t)
			{
				Type = t;
			}
			virtual bool Equals(ILType* type) override
			{
				auto btype = dynamic_cast<ILBasicType*>(type);
				if (!btype)
					return false;
				return Type == btype->Type;
			}

			virtual ILType * Clone() override
			{
				auto rs = new ILBasicType();
				rs->Type = Type;
				return rs;
			}
			virtual String ToString() override
			{
				if (Type == ILBaseType::Int)
					return L"int";
				else if (Type == ILBaseType::UInt)
					return L"uint";
				else if (Type == ILBaseType::UInt2)
					return L"uvec2";
				else if (Type == ILBaseType::UInt3)
					return L"uvec3";
				else if (Type == ILBaseType::UInt4)
					return L"uvec4";
				else if (Type == ILBaseType::Int2)
					return L"ivec2";
				else if (Type == ILBaseType::Int3)
					return L"ivec3";
				else if (Type == ILBaseType::Int4)
					return L"ivec4";
				else if (Type == ILBaseType::Float)
					return L"float";
				else if (Type == ILBaseType::Float2)
					return L"vec2";
				else if (Type == ILBaseType::Float3)
					return L"vec3";
				else if (Type == ILBaseType::Float4)
					return L"vec4";
				else if (Type == ILBaseType::Float3x3)
					return L"mat3";
				else if (Type == ILBaseType::Float4x4)
					return L"mat4";
				else if (Type == ILBaseType::Texture2D)
					return L"sampler2D";
				else if (Type == ILBaseType::TextureCube)
					return L"samplerCube";
				else if (Type == ILBaseType::TextureCubeShadow)
					return L"samplerCubeShadow";
				else if (Type == ILBaseType::TextureShadow)
					return L"sampler2DShadow";
				else if (Type == ILBaseType::Bool)
					return L"bool";
				else
					return L"?unkown";
			}
			virtual int GetAlignment(LayoutRule rule) override
			{
				if (rule == LayoutRule::Packed)
					return 0;
				switch (Type)
				{
				case ILBaseType::Int:
					return 4;
				case ILBaseType::UInt:
					return 4;
				case ILBaseType::Int2:
				case ILBaseType::UInt2:
					return 8;
				case ILBaseType::Int3:
				case ILBaseType::UInt3:
					return 16;
				case ILBaseType::Int4:
				case ILBaseType::UInt4:
					return 16;
				case ILBaseType::Float:
					return 4;
				case ILBaseType::Float2:
					return 8;
				case  ILBaseType::Float3:
					return 16;
				case ILBaseType::Float4:
					return 16;
				case ILBaseType::Float3x3:
					return 16;
				case  ILBaseType::Float4x4:
					return 16;
				case ILBaseType::Texture2D:
					return 8;
				case ILBaseType::TextureCube:
					return 8;
				case ILBaseType::TextureCubeShadow:
					return 8;
				case ILBaseType::TextureShadow:
					return 8;
				default:
					return 0;
				}
			}
			virtual int GetSize(LayoutRule /*rule*/) override
			{
				switch (Type)
				{
				case ILBaseType::Float:
				case ILBaseType::Int:
				case ILBaseType::UInt:
					return 4;
				case ILBaseType::Float2:
				case ILBaseType::Int2:
				case ILBaseType::UInt2:
					return 8;
				case ILBaseType::Int3:
				case ILBaseType::Float3:
				case ILBaseType::UInt3:
					return 12;
				case ILBaseType::Int4:
				case ILBaseType::Float4:
				case ILBaseType::UInt4:
					return 16;
				case ILBaseType::Float3x3:
					return 48;
				case ILBaseType::Float4x4:
					return 64;
				case ILBaseType::Texture2D:
				case ILBaseType::TextureCube:
				case ILBaseType::TextureCubeShadow:
				case ILBaseType::TextureShadow:
					return 8;
				default:
					return 0;
				}
			}
		};

		class ILArrayType : public ILType
		{
		public:
			RefPtr<ILType> BaseType;
			int ArrayLength;
			virtual bool Equals(ILType* type) override
			{
				auto btype = dynamic_cast<ILArrayType*>(type);
				if (!btype)
					return false;
				return BaseType->Equals(btype->BaseType.Ptr());;
			}
			virtual ILType * Clone() override
			{
				auto rs = new ILArrayType();
				rs->BaseType = BaseType->Clone();
				rs->ArrayLength = ArrayLength;
				return rs;
			}
			virtual String ToString() override
			{
				if (ArrayLength > 0)
					return BaseType->ToString() + L"[" + String(ArrayLength) + L"]";
				else
					return BaseType->ToString() + L"[]";
			}
			virtual int GetSize(LayoutRule layoutRule) override
			{
				return BaseType->GetSize(layoutRule) * ArrayLength;
			}
			virtual int GetAlignment(LayoutRule layoutRule) override
			{
				int baseAlignment = BaseType->GetAlignment(layoutRule);
				if (layoutRule == LayoutRule::Std140)
				{
					if (baseAlignment < 16)
						return 16;
				}
				return baseAlignment;
			}
		};

		class ILGenericType : public ILType
		{
		public:
			RefPtr<ILType> BaseType;
			String GenericTypeName;
			virtual bool Equals(ILType* type) override
			{
				auto btype = dynamic_cast<ILArrayType*>(type);
				if (!btype)
					return false;
				return BaseType->Equals(btype->BaseType.Ptr());;
			}
			virtual ILType * Clone() override
			{
				auto rs = new ILGenericType();
				rs->BaseType = BaseType->Clone();
				rs->GenericTypeName = GenericTypeName;
				return rs;
			}
			virtual String ToString() override
			{
				return GenericTypeName + L"<" + BaseType->ToString() + L">";
			}
			virtual int GetSize(LayoutRule rule) override
			{
				return BaseType->GetSize(rule);
			}
			virtual int GetAlignment(LayoutRule rule) override
			{
				return BaseType->GetAlignment(rule);
			}
		};

		class ILStructType : public ILType
		{
		public:
			String TypeName;
			bool IsIntrinsic = false;
			class ILStructField
			{
			public:
				RefPtr<ILType> Type;
				String FieldName;
			};
			List<ILStructField> Members;
			virtual ILType * Clone() override;
			virtual String ToString() override;
			virtual bool Equals(ILType * type) override;
			virtual int GetSize(LayoutRule rule) override;
			virtual int GetAlignment(LayoutRule rule) override;
		};

		class ILOperand;

		class UserReferenceSet
		{
		private:
			EnumerableDictionary<ILOperand*, int> userRefCounts;
			int count;
		public:
			UserReferenceSet()
			{
				count = 0;
			}
			int Count()
			{
				return count;
			}
			int GetUseCount(ILOperand * op)
			{
				int rs = -1;
				userRefCounts.TryGetValue(op, rs);
				return rs;
			}
			void Add(ILOperand * user)
			{
				this->count++;
				int ncount = 0;
				if (userRefCounts.TryGetValue(user, ncount))
				{
					ncount++;
					userRefCounts[user] = ncount;
				}
				else
				{
					userRefCounts.Add(user, 1);
				}
			}
			void Remove(ILOperand * user)
			{
				int ncount = 0;
				if (userRefCounts.TryGetValue(user, ncount))
				{
					this->count--;
					ncount--;
					if (ncount)
						userRefCounts[user] = ncount;
					else
						userRefCounts.Remove(user);
				}
			}
			void RemoveAll(ILOperand * user)
			{
				int ncount = 0;
				if (userRefCounts.TryGetValue(user, ncount))
				{
					this->count -= ncount;
					userRefCounts.Remove(user);
				}
			}
			class UserIterator
			{
			private:
				EnumerableDictionary<ILOperand*, int>::Iterator iter;
			public:
				ILOperand * operator *()
				{
					return iter.Current->Value.Key;
				}
				ILOperand ** operator ->()
				{
					return &iter.Current->Value.Key;
				}
				UserIterator & operator ++()
				{
					iter++;
					return *this;
				}
				UserIterator operator ++(int)
				{
					UserIterator rs = *this;
					operator++();
					return rs;
				}
				bool operator != (const UserIterator & _that)
				{
					return iter != _that.iter;
				}
				bool operator == (const UserIterator & _that)
				{
					return iter == _that.iter;
				}
				UserIterator(const EnumerableDictionary<ILOperand*, int>::Iterator & iter)
				{
					this->iter = iter;
				}
				UserIterator()
				{
				}
			};
			UserIterator begin()
			{
				return UserIterator(userRefCounts.begin());
			}
			UserIterator end()
			{
				return UserIterator(userRefCounts.end());
			}
		};

		class ILOperand : public Object
		{
		public:
			String Name;
			RefPtr<ILType> Type;
			UserReferenceSet Users;
			String Attribute;
			void * Tag;
			union VMFields
			{
				void * VMData;
				struct Fields
				{
					int VMDataWords[2];
				} Fields;
			} VMFields;
			Procedure<ILOperand*> OnDelete;
			ILOperand()
			{
				Tag = nullptr;
			}
			ILOperand(const ILOperand & op)
			{
				Tag = op.Tag;
				Name = op.Name;
				Attribute = op.Attribute;
				if (op.Type)
					Type = op.Type->Clone();
				//Users = op.Users;
			}
			virtual ~ILOperand()
			{
				OnDelete(this);
			}
			virtual String ToString()
			{
				return L"<operand>";
			}
			virtual bool IsUndefined()
			{
				return false;
			}
		};

		class ILUndefinedOperand : public ILOperand
		{
		public:
			ILUndefinedOperand()
			{
				Name = L"<undef>";
			}
			virtual String ToString() override
			{
				return L"<undef>";
			}
			virtual bool IsUndefined() override
			{
				return true;
			}
		};

		class UseReference
		{
		private:
			ILOperand * user;
			ILOperand * reference;
		public:
			UseReference()
				: user(0), reference(0)
			{}
			UseReference(const UseReference &)
			{
				user = 0;
				reference = 0;
			}
			UseReference(ILOperand * user)
				: user(user), reference(0)
			{}
			UseReference(ILOperand * user, ILOperand * ref)
			{
				this->user = user;
				this->reference = ref;
			}
			~UseReference()
			{
				if (reference)
					reference->Users.Remove(user);
			}
			void SetUser(ILOperand * _user)
			{
				this->user = _user;
			}
			void operator = (const UseReference & ref)
			{
				if (reference)
					reference->Users.Remove(user);
				reference = ref.Ptr();
				if (ref.Ptr())
				{
					if (!user)
						throw InvalidOperationException(L"user not initialized.");
					ref.Ptr()->Users.Add(user);
				}
			}
			void operator = (ILOperand * newRef)
			{
				if (reference)
					reference->Users.Remove(user);
				reference = newRef;
				if (newRef)
				{
					if (!user)
						throw InvalidOperationException(L"user not initialized.");
					newRef->Users.Add(user);
				}
			}
			bool operator != (const UseReference & _that)
			{
				return reference != _that.reference || user != _that.user;
			}
			bool operator == (const UseReference & _that)
			{
				return reference == _that.reference && user == _that.user;
			}
			ILOperand * Ptr() const
			{
				return reference;
			}
			ILOperand * operator->()
			{
				return reference;
			}
			ILOperand & operator*()
			{
				return *reference;
			}
			explicit operator bool()
			{
				return (reference != 0);
			}
			String ToString()
			{
				if (reference)
					return reference->Name;
				else
					return L"<null>";
			}
		};

		class OperandIterator
		{
		private:
			UseReference * use;
		public:
			OperandIterator()
			{
				use = 0;
			}
			OperandIterator(UseReference * use)
				: use(use)
			{}
			ILOperand & operator *()
			{
				return use->operator*();
			}
			ILOperand * operator ->()
			{
				return use->operator->();
			}
			void Set(ILOperand * user, ILOperand * op)
			{
				(*use).SetUser(user);
				(*use) = op;
			}
			void Set(ILOperand * op)
			{
				(*use) = op; 
			}
			OperandIterator & operator ++()
			{
				use++;
				return *this;
			}
			OperandIterator operator ++(int)
			{
				OperandIterator rs = *this;
				operator++();
				return rs;
			}
			bool operator != (const OperandIterator & _that)
			{
				return use != _that.use;
			}
			bool operator == (const OperandIterator & _that)
			{
				return use == _that.use;
			}
			bool operator == (const ILOperand * op)
			{
				return use->Ptr() == op;
			}
			bool operator != (const ILOperand * op)
			{
				return use->Ptr() != op;
			}
		};

		class ILConstOperand : public ILOperand
		{
		public:
			union
			{
				int IntValues[16];
				float FloatValues[16];
			};
			virtual String ToString() override
			{
				if (Type->IsFloat())
					return String(FloatValues[0]) + L"f";
				else if (Type->IsInt())
					return String(IntValues[0]);
				else if (auto baseType = dynamic_cast<ILBasicType*>(Type.Ptr()))
				{
					StringBuilder sb(256);
					if (baseType->Type == ILBaseType::Float2)
						sb << L"vec2(" << FloatValues[0] << L"f, " << FloatValues[1] << L"f)";
					else if (baseType->Type == ILBaseType::Float3)
						sb << L"vec3(" << FloatValues[0] << L"f, " << FloatValues[1] << L"f, " << FloatValues[2] << L"f)";
					else if (baseType->Type == ILBaseType::Float4)
						sb << L"vec4(" << FloatValues[0] << L"f, " << FloatValues[1] << L"f, " << FloatValues[2] << L"f, " << FloatValues[3] << L"f)";
					else if (baseType->Type == ILBaseType::Float3x3)
						sb << L"mat3(...)";
					else if (baseType->Type == ILBaseType::Float4x4)
						sb << L"mat4(...)";
					else if (baseType->Type == ILBaseType::Int2)
						sb << L"ivec2(" << IntValues[0] << L", " << IntValues[1] << L")";
					else if (baseType->Type == ILBaseType::Int3)
						sb << L"ivec3(" << IntValues[0] << L", " << IntValues[1] << L", " << IntValues[2] << L")";
					else if (baseType->Type == ILBaseType::Int4)
						sb << L"ivec4(" << IntValues[0] << L", " << IntValues[1] << L", " << IntValues[2] << L", " << IntValues[3] << L")";
					else if (baseType->Type == ILBaseType::UInt2)
						sb << L"uvec2(" << IntValues[0] << L", " << IntValues[1] << L")";
					else if (baseType->Type == ILBaseType::UInt3)
						sb << L"uvec3(" << IntValues[0] << L", " << IntValues[1] << L", " << IntValues[2] << L")";
					else if (baseType->Type == ILBaseType::UInt4)
						sb << L"uvec4(" << IntValues[0] << L", " << IntValues[1] << L", " << IntValues[2] << L", " << IntValues[3] << L")";
					return sb.ToString();
				}
				else
					throw InvalidOperationException(L"Illegal constant.");
			}
		};

		class InstructionVisitor;

		class CFGNode;

		class ILInstruction : public ILOperand
		{
		private:
			ILInstruction *next, *prev;
		public:
			CFGNode * Parent;
			ILInstruction()
			{
				next = 0;
				prev = 0;
				Parent = 0;
			}
			ILInstruction(const ILInstruction & instr)
				: ILOperand(instr)
			{
				next = 0;
				prev = 0;
				Parent = 0;
			}
			~ILInstruction()
			{
				
			}
			virtual ILInstruction * Clone()
			{
				return new ILInstruction(*this);
			}

			virtual String GetOperatorString()
			{
				return L"<instruction>";
			}
			virtual bool HasSideEffect()
			{
				return false;
			}
			virtual bool IsDeterministic()
			{
				return true;
			}
			virtual void Accept(InstructionVisitor *)
			{
			}
			void InsertBefore(ILInstruction * instr)
			{
				instr->Parent = Parent;
				instr->prev = prev;
				instr->next = this;
				prev = instr;
				auto *npp = instr->prev;
				if (npp)
					npp->next = instr;
			}
			void InsertAfter(ILInstruction * instr)
			{
				instr->Parent = Parent;
				instr->prev = this;
				instr->next = this->next;
				next = instr;
				auto *npp = instr->next;
				if (npp)
					npp->prev = instr;
			}
			ILInstruction * GetNext()
			{
				return next;
			}
			ILInstruction * GetPrevious()
			{
				return prev;
			}
			void Remove()
			{
				if (prev)
					prev->next = next;
				if (next)
					next->prev = prev;
			}
			void Erase()
			{
				Remove();
				if (Users.Count())
				{
					throw InvalidOperationException(L"All uses must be removed before removing this instruction");
				}
				delete this;
			}
			virtual OperandIterator begin()
			{
				return OperandIterator();
			}
			virtual OperandIterator end()
			{
				return OperandIterator();
			}
			virtual int GetSubBlockCount()
			{
				return 0;
			}
			virtual CFGNode * GetSubBlock(int)
			{
				return nullptr;
			}
			template<typename T>
			T * As()
			{
				return dynamic_cast<T*>(this);
			}
			template<typename T>
			bool Is()
			{
				return dynamic_cast<T*>(this) != 0;
			}
		};

		template <typename T, typename TOperand>
		bool Is(TOperand * op)
		{
			auto ptr = dynamic_cast<T*>(op);
			if (ptr)
				return true;
			else
				return false;
		}

		class SwitchInstruction : public ILInstruction
		{
		public:
			List<UseReference> Candidates;
			virtual OperandIterator begin() override
			{
				return Candidates.begin();
			}
			virtual OperandIterator end() override
			{
				return Candidates.end();
			}
			virtual String ToString() override
			{
				StringBuilder sb(256);
				sb << Name;
				sb << L" = switch ";
				for (auto & op : Candidates)
				{
					sb << op.ToString();
					if (op != Candidates.Last())
						sb << L", ";
				}
				return sb.ProduceString();
			}
			virtual String GetOperatorString() override
			{
				return L"switch";
			}
			virtual bool HasSideEffect() override
			{
				return false;
			}
			SwitchInstruction(int argSize)
			{
				Candidates.SetSize(argSize);
				for (auto & use : Candidates)
					use.SetUser(this);
			}
			SwitchInstruction(const SwitchInstruction & other)
				: ILInstruction(other)
			{
				Candidates.SetSize(other.Candidates.Count());
				for (int i = 0; i < other.Candidates.Count(); i++)
				{
					Candidates[i].SetUser(this);
					Candidates[i] = other.Candidates[i].Ptr();
				}

			}
			virtual SwitchInstruction * Clone() override
			{
				return new SwitchInstruction(*this);
			}
			virtual void Accept(InstructionVisitor * visitor) override;
		};

		class LeaInstruction : public ILInstruction
		{};
		class ILWorld;
		class ImportInstruction : public LeaInstruction
		{
		public:
			String ComponentName;
			RefPtr<CFGNode> ImportOperator;

			List<UseReference> Arguments;
			virtual OperandIterator begin() override
			{
				return Arguments.begin();
			}
			virtual OperandIterator end() override
			{
				return Arguments.end();
			}
			virtual int GetSubBlockCount() override
			{
				return 1;
			}
			virtual CFGNode * GetSubBlock(int i) override
			{
				if (i == 0)
					return ImportOperator.Ptr();
				return nullptr;
			}
			ImportInstruction(int argSize = 0)
				: LeaInstruction()
			{
				Arguments.SetSize(argSize);
				for (auto & use : Arguments)
					use.SetUser(this);
			}
			ImportInstruction(const ImportInstruction & other)
				: LeaInstruction(other)
			{
				Arguments.SetSize(other.Arguments.Count());
				for (int i = 0; i < other.Arguments.Count(); i++)
				{
					Arguments[i].SetUser(this);
					Arguments[i] = other.Arguments[i].Ptr();
				}
			}

			ImportInstruction(int argSize, String compName, RefPtr<CFGNode> importOp, RefPtr<ILType> type)
				:ImportInstruction(argSize)
			{
				this->ComponentName = compName;
				this->ImportOperator = importOp;
				this->Type = type;
			}
			virtual String ToString() override;
			virtual String GetOperatorString() override;
			virtual ImportInstruction * Clone() override
			{
				return new ImportInstruction(*this);
			}
			virtual void Accept(InstructionVisitor * visitor) override;
		};

		class LoadInputInstruction : public LeaInstruction
		{
		public:
			String InputName;
			LoadInputInstruction(RefPtr<ILType> type, String name)
				: InputName(name)
			{
				this->Type = type;
			}
			LoadInputInstruction(const LoadInputInstruction & other)
				:LeaInstruction(other), InputName(other.InputName)
			{
			}
			virtual bool IsDeterministic() override
			{
				return true;
			}
			virtual String ToString() override
			{
				return Name + L" = INPUT " + InputName;
			}
			virtual String GetOperatorString() override
			{
				return L"input";
			}
			virtual LoadInputInstruction * Clone() override
			{
				return new LoadInputInstruction(*this);
			}
			virtual void Accept(InstructionVisitor * visitor) override;
		};

		class AllocVarInstruction : public LeaInstruction
		{
		public:
			UseReference Size;
			AllocVarInstruction(ILType * type, ILOperand * count)
				: Size(this)
			{
				this->Type = type;
				this->Size = count;
			}
			AllocVarInstruction(RefPtr<ILType> & type, ILOperand * count)
				: Size(this)
			{
				auto ptrType = type->Clone();
				if (!type)
					throw ArgumentException(L"type cannot be null.");
				this->Type = ptrType;
				this->Size = count;
			}
			AllocVarInstruction(const AllocVarInstruction & other)
				:LeaInstruction(other), Size(this)
			{
				Size = other.Size.Ptr();
			}
			virtual bool IsDeterministic() override
			{
				return false;
			}
			virtual String ToString() override
			{
				return Name + L" = VAR " + Type->ToString() + L", " + Size.ToString();
			}
			virtual OperandIterator begin() override
			{
				return &Size;
			}
			virtual OperandIterator end() override
			{
				return &Size + 1;
			}
			virtual String GetOperatorString() override
			{
				return L"avar";
			}
			virtual AllocVarInstruction * Clone() override
			{
				return new AllocVarInstruction(*this);
			}
			virtual void Accept(InstructionVisitor * visitor) override;
		};

		class FetchArgInstruction : public LeaInstruction
		{
		public:
			int ArgId;
			FetchArgInstruction(RefPtr<ILType> type)
			{
				this->Type = type;
				ArgId = 0;
			}
			virtual String ToString() override
			{
				return Name + L" = ARG " + Type->ToString();
			}
			virtual String GetOperatorString() override
			{
				return L"arg " + String(ArgId);
			}
			virtual bool IsDeterministic() override
			{
				return false;
			}
			virtual FetchArgInstruction * Clone() override
			{
				return new FetchArgInstruction(*this);
			}
			virtual void Accept(InstructionVisitor * visitor) override;
		};

		class CFGNode;

		class AllInstructionsIterator
		{
		private:
			struct StackItem
			{
				ILInstruction* instr;
				int subBlockPtr;
			};
			List<StackItem> stack;
			ILInstruction * curInstr = nullptr;
			int subBlockPtr = 0;
		public:
			AllInstructionsIterator(ILInstruction * instr)
			{
				curInstr = instr;
			}
			AllInstructionsIterator & operator ++();
			
			AllInstructionsIterator operator ++(int)
			{
				AllInstructionsIterator rs = *this;
				operator++();
				return rs;
			}
			bool operator != (const AllInstructionsIterator & _that)
			{
				return curInstr != _that.curInstr || subBlockPtr != _that.subBlockPtr;
			}
			bool operator == (const AllInstructionsIterator & _that)
			{
				return curInstr == _that.curInstr && subBlockPtr == _that.subBlockPtr;
			}
			ILOperand & operator *()
			{
				return *curInstr;
			}
			ILOperand * operator ->()
			{
				return curInstr;
			}
		};

		class AllInstructionsCollection
		{
		private:
			CFGNode * node;
		public:
			AllInstructionsCollection(CFGNode * _node)
				: node(_node)
			{}
			AllInstructionsIterator begin();
			AllInstructionsIterator end();
		};


		class CFGNode : public Object
		{
		private:
			ILInstruction *headInstr, *tailInstr;
		public:
			class Iterator
			{
			public:
				ILInstruction * Current, *Next;
				void SetCurrent(ILInstruction * cur)
				{
					Current = cur;
					if (Current)
						Next = Current->GetNext();
					else
						Next = 0;
				}
				Iterator(ILInstruction * cur)
				{
					SetCurrent(cur);
				}
				ILInstruction & operator *() const
				{
					return *Current;
				}
				Iterator& operator ++()
				{
					SetCurrent(Next);
					return *this;
				}
				Iterator operator ++(int)
				{
					Iterator rs = *this;
					SetCurrent(Next);
					return rs;
				}
				bool operator != (const Iterator & iter) const
				{
					return Current != iter.Current;
				}
				bool operator == (const Iterator & iter) const
				{
					return Current == iter.Current;
				}
			};

			String ToString() {
				StringBuilder sb;
				bool first = true;
				auto pintr = begin();
				while (pintr != end()) {
					if (!first)
						sb << EndLine;
					first = false;
					sb << pintr.Current->ToString();
					pintr++;
				}
				return sb.ToString();
			}

			Iterator begin() const
			{
				return Iterator(headInstr->GetNext());
			}

			Iterator end() const
			{
				return Iterator(tailInstr);
			}

			AllInstructionsCollection GetAllInstructions()
			{
				return AllInstructionsCollection(this);
			}
			
			ILInstruction * GetFirstNonPhiInstruction();
			bool HasPhiInstruction();

			ILInstruction * GetLastInstruction()
			{
				return (tailInstr->GetPrevious());
			}

			String Name;

			CFGNode()
			{
				headInstr = new ILInstruction();
				tailInstr = new ILInstruction();
				headInstr->Parent = this;
				headInstr->InsertAfter(tailInstr);
			}
			~CFGNode()
			{
				ILInstruction * instr = headInstr;
				while (instr)
				{
					for (auto user : instr->Users)
					{
						auto userInstr = dynamic_cast<ILInstruction*>(user);
						if (userInstr)
						{
							for (auto iter = userInstr->begin(); iter != userInstr->end(); ++iter)
							if (iter == instr)
								iter.Set(0);
						}
					}
				
					auto next = instr->GetNext();
					delete instr;
					instr = next;
				}
			}
			void InsertHead(ILInstruction * instr)
			{
				headInstr->InsertAfter(instr);
			}
			void InsertTail(ILInstruction * instr)
			{
				tailInstr->InsertBefore(instr);
			}
			void NameAllInstructions();
			void DebugPrint();
		};

		template<typename T>
		struct ConstKey
		{
			Array<T, 16> Value;
			int Size;
			ConstKey()
			{
				Value.SetSize(Value.GetCapacity());
			}
			ConstKey(T value, int size)
			{
				if (size == 0)
					size = 1;
				Value.SetSize(Value.GetCapacity());
				for (int i = 0; i < size; i++)
					Value[i] = value;
				Size = size;
			}
			static ConstKey<T> FromValues(T value, T value1)
			{
				ConstKey<T> result;
				result.Value.SetSize(result.Value.GetCapacity());
				result.Size = 2;
				result.Value[0] = value;
				result.Value[1] = value1;
				return result;
			}
			static ConstKey<T> FromValues(T value, T value1, T value2)
			{
				ConstKey<T> result;
				result.Value.SetSize(result.Value.GetCapacity());
				result.Size = 3;
				result.Value[0] = value;
				result.Value[1] = value1;
				result.Value[2] = value2;
				return result;
			}
			static ConstKey<T> FromValues(T value, T value1, T value2, T value3)
			{
				ConstKey<T> result;
				result.Value.SetSize(result.Value.GetCapacity());
				result.Size = 4;
				result.Value[0] = value;
				result.Value[1] = value1;
				result.Value[2] = value2;
				result.Value[3] = value3;
				return result;
			}
			int GetHashCode()
			{
				int result = Size;
				for (int i = 0; i < Size; i++)
					result ^= ((*(int*)&Value) << 5);
				return result;
			}
			bool operator == (const ConstKey<T> & other)
			{
				if (Size != other.Size)
					return false;
				for (int i = 0; i < Size; i++)
					if (Value[i] != other.Value[i])
						return false;
				return true;
			}
		};

		class PhiInstruction : public ILInstruction
		{
		public:
			List<UseReference> Operands; // Use as fixed array, no insert or resize
		public:
			PhiInstruction(int opCount)
			{
				Operands.SetSize(opCount);
				for (int i = 0; i < opCount; i++)
					Operands[i].SetUser(this);
			}
			PhiInstruction(const PhiInstruction & other)
				: ILInstruction(other)
			{
				Operands.SetSize(other.Operands.Count());
				for (int i = 0; i < Operands.Count(); i++)
				{
					Operands[i].SetUser(this);
					Operands[i] = other.Operands[i].Ptr();
				}
			}
			virtual String GetOperatorString() override
			{
				return L"phi";
			}
			virtual OperandIterator begin() override
			{
				return Operands.begin();
			}
			virtual OperandIterator end() override
			{
				return Operands.end();
			}
			virtual String ToString() override
			{
				StringBuilder sb;
				sb << Name << L" = phi ";
				for (auto & op : Operands)
				{
					if (op)
					{
						sb << op.ToString();
					}
					else
						sb << L"<?>";
					sb << L", ";
				}
				return sb.ProduceString();
			}
			virtual PhiInstruction * Clone() override
			{
				return new PhiInstruction(*this);
			}
			virtual void Accept(InstructionVisitor * visitor) override;
		};

		class UnaryInstruction : public ILInstruction
		{
		public:
			UseReference Operand;
			UnaryInstruction()
				: Operand(this)
			{}
			UnaryInstruction(const UnaryInstruction & other)
				: ILInstruction(other), Operand(this)
			{
				Operand = other.Operand.Ptr();
			}
			virtual OperandIterator begin() override
			{
				return &Operand;
			}
			virtual OperandIterator end() override
			{
				return &Operand + 1;
			}
		};

		class MakeRecordInstruction : public ILInstruction
		{
		public:
			RefPtr<ILRecordType> RecordType;
			List<UseReference> Arguments;
		};

		class ExportInstruction : public UnaryInstruction
		{
		public:
			String ComponentName;
			ILWorld * World;

			ExportInstruction() = default;
			ExportInstruction(const ExportInstruction &) = default;

			ExportInstruction(String compName, ILWorld * srcWorld, ILOperand * value)
				: UnaryInstruction()
			{
				this->Operand = value;
				this->ComponentName = compName;
				this->World = srcWorld;
				this->Type = value->Type;
			}
			virtual String ToString() override
			{
				return L"export [" + ComponentName + L"], " + Operand.ToString();
			}
			virtual String GetOperatorString() override
			{
				return L"export [" + ComponentName + L"]";
			}
			virtual ExportInstruction * Clone() override
			{
				return new ExportInstruction(*this);
			}
			virtual bool HasSideEffect() override
			{
				return true;
			}
			virtual void Accept(InstructionVisitor * visitor) override;
		};

		class BinaryInstruction : public ILInstruction
		{
		public:
			Array<UseReference, 2> Operands;
			BinaryInstruction()
			{
				Operands.SetSize(2);
				Operands[0].SetUser(this);
				Operands[1].SetUser(this);
			}
			BinaryInstruction(const BinaryInstruction & other)
				: ILInstruction(other)
			{
				Operands.SetSize(2);
				Operands[0].SetUser(this);
				Operands[1].SetUser(this);
				Operands[0] = other.Operands[0].Ptr();
				Operands[1] = other.Operands[1].Ptr();
			}
			virtual OperandIterator begin() override
			{
				return Operands.begin();
			}
			virtual OperandIterator end() override
			{
				return Operands.end();
			}
		};

		class SelectInstruction : public ILInstruction
		{
		public:
			UseReference Operands[3];
			SelectInstruction()
			{
				Operands[0].SetUser(this);
				Operands[1].SetUser(this);
				Operands[2].SetUser(this);
			}
			SelectInstruction(const SelectInstruction & other)
				: ILInstruction(other)
			{
				Operands[0].SetUser(this);
				Operands[1].SetUser(this);
				Operands[2].SetUser(this);
				Operands[0] = other.Operands[0].Ptr();
				Operands[1] = other.Operands[1].Ptr();
				Operands[2] = other.Operands[2].Ptr();
			}
			SelectInstruction(ILOperand * mask, ILOperand * val0, ILOperand * val1)
			{
				Operands[0].SetUser(this);
				Operands[1].SetUser(this);
				Operands[2].SetUser(this);
				Operands[0] = mask;
				Operands[1] = val0;
				Operands[2] = val1;
				Type = val0->Type->Clone();
			}
			virtual OperandIterator begin() override
			{
				return Operands;
			}
			virtual OperandIterator end() override
			{
				return Operands + 3;
			}

			virtual String ToString() override
			{
				return Name + L" = select " + Operands[0].ToString() + L": " + Operands[1].ToString() + L", " + Operands[2].ToString();
			}
			virtual String GetOperatorString() override
			{
				return L"select";
			}
			virtual SelectInstruction * Clone() override
			{
				return new SelectInstruction(*this);
			}
			virtual void Accept(InstructionVisitor * visitor) override;
		};

		class CallInstruction : public ILInstruction
		{
		public:
			String Function;
			List<UseReference> Arguments;
			virtual OperandIterator begin() override
			{
				return Arguments.begin();
			}
			virtual OperandIterator end() override
			{
				return Arguments.end();
			}
			virtual String ToString() override
			{
				StringBuilder sb(256);
				sb << Name;
				sb << L" = call " << Function << L"(";
				for (auto & op : Arguments)
				{
					sb << op.ToString();
					if (op != Arguments.Last())
						sb << L", ";
				}
				sb << L")";
				return sb.ProduceString();
			}
			virtual String GetOperatorString() override
			{
				return L"call " + Function;
			}
			virtual bool HasSideEffect() override
			{
				return false;
			}
			CallInstruction(int argSize)
			{
				Arguments.SetSize(argSize);
				for (auto & use : Arguments)
					use.SetUser(this);
			}
			CallInstruction(const CallInstruction & other)
				: ILInstruction(other)
			{
				Function = other.Function;
				Arguments.SetSize(other.Arguments.Count());
				for (int i = 0; i < other.Arguments.Count(); i++)
				{
					Arguments[i].SetUser(this);
					Arguments[i] = other.Arguments[i].Ptr();
				}

			}
			virtual CallInstruction * Clone() override
			{
				return new CallInstruction(*this);
			}
			virtual void Accept(InstructionVisitor * visitor) override;
		};

		class NotInstruction : public UnaryInstruction
		{
		public:
			virtual String ToString() override
			{
				return  Name + L" = not " + Operand.ToString();
			}
			virtual String GetOperatorString() override
			{
				return L"not";
			}
			virtual NotInstruction * Clone() override
			{
				return new NotInstruction(*this);
			}
			NotInstruction() = default;
			NotInstruction(const NotInstruction & other) = default;

			NotInstruction(ILOperand * op)
			{
				Operand = op;
				Type = op->Type->Clone();
			}
			virtual void Accept(InstructionVisitor * visitor) override;
		};

		class NegInstruction : public UnaryInstruction
		{
		public:
			virtual String ToString() override
			{
				return  Name + L" = neg " + Operand.ToString();
			}
			virtual String GetOperatorString() override
			{
				return L"neg";
			}
			virtual NegInstruction * Clone() override
			{
				return new NegInstruction(*this);
			}
			virtual void Accept(InstructionVisitor * visitor) override;
		};


		class SwizzleInstruction : public UnaryInstruction
		{
		public:
			String SwizzleString;
			virtual String ToString() override
			{
				return  Name + L" = " + Operand.ToString() + L"." + SwizzleString;
			}
			virtual String GetOperatorString() override
			{
				return L"swizzle";
			}
			virtual SwizzleInstruction * Clone() override
			{
				return new SwizzleInstruction(*this);
			}
			virtual void Accept(InstructionVisitor * visitor) override;
		};

		class BitNotInstruction : public UnaryInstruction
		{
		public:
			virtual String ToString() override
			{
				return  Name + L" = bnot " + Operand.ToString();
			}
			virtual String GetOperatorString() override
			{
				return L"bnot";
			}
			virtual BitNotInstruction * Clone() override
			{
				return new BitNotInstruction(*this);
			}
			BitNotInstruction() = default;
			BitNotInstruction(const BitNotInstruction & instr) = default;

			BitNotInstruction(ILOperand * op)
			{
				Operand = op;
				Type = op->Type->Clone();
			}
			virtual void Accept(InstructionVisitor * visitor) override;
		};

		class AddInstruction : public BinaryInstruction
		{
		public:
			AddInstruction() = default;
			AddInstruction(const AddInstruction & instr) = default;
			AddInstruction(ILOperand * v0, ILOperand * v1)
			{
				Operands[0] = v0;
				Operands[1] = v1;
				Type = v0->Type->Clone();
			}
			virtual String ToString() override
			{
				return Name + L" = add " + Operands[0].ToString() + L", " + Operands[1].ToString();
			}
			virtual String GetOperatorString() override
			{
				return L"add";
			}
			virtual AddInstruction * Clone() override
			{
				return new AddInstruction(*this);
			}
			virtual void Accept(InstructionVisitor * visitor) override;
		};

		class MemberLoadInstruction : public BinaryInstruction
		{
		public:
			MemberLoadInstruction() = default;
			MemberLoadInstruction(const MemberLoadInstruction &) = default;
			MemberLoadInstruction(ILOperand * v0, ILOperand * v1)
			{
				Operands[0] = v0;
				Operands[1] = v1;
				if (auto arrType = dynamic_cast<ILArrayType *>(v0->Type.Ptr()))
				{
					Type = arrType->BaseType->Clone();
				}
				else if (auto baseType = dynamic_cast<ILBasicType *>(v0->Type.Ptr()))
				{
					switch (baseType->Type)
					{
					case ILBaseType::Float2:
					case ILBaseType::Float3:
					case ILBaseType::Float4:
						Type = new ILBasicType(ILBaseType::Float);
						break;
					case ILBaseType::Float3x3:
						Type = new ILBasicType(ILBaseType::Float3);
						break;
					case ILBaseType::Float4x4:
						Type = new ILBasicType(ILBaseType::Float4);
						break;
					case ILBaseType::Int2:
					case ILBaseType::Int3:
					case ILBaseType::Int4:
						Type = new ILBasicType(ILBaseType::Int);
						break;
					case ILBaseType::UInt2:
					case ILBaseType::UInt3:
					case ILBaseType::UInt4:
						Type = new ILBasicType(ILBaseType::UInt);
						break;
					default:
						throw InvalidOperationException(L"Unsupported aggregate type.");
					}
				}
				else if (auto structType = dynamic_cast<ILStructType*>(v0->Type.Ptr()))
				{
					auto cv1 = dynamic_cast<ILConstOperand*>(v1);
					if (!cv1)
						throw InvalidProgramException(L"member field access offset is not constant.");
					if (cv1->IntValues[0] < 0 || cv1->IntValues[0] >= structType->Members.Count())
						throw InvalidProgramException(L"member field access offset out of bounds.");
					Type = structType->Members[cv1->IntValues[0]].Type;
				}
			}
			virtual String ToString() override
			{
				return Name + L" = retrieve " + Operands[0].ToString() + L", " + Operands[1].ToString();
			}
			virtual String GetOperatorString() override
			{
				return L"retrieve";
			}
			virtual MemberLoadInstruction * Clone() override
			{
				return new MemberLoadInstruction(*this);
			}
			virtual void Accept(InstructionVisitor * visitor) override;
		};

		class SubInstruction : public BinaryInstruction
		{
		public:
			virtual String ToString() override
			{
				return Name + L" = sub " + Operands[0].ToString() + L", " + Operands[1].ToString();
			}
			virtual String GetOperatorString() override
			{
				return L"sub";
			}
			virtual SubInstruction * Clone() override
			{
				return new SubInstruction(*this);
			}
			virtual void Accept(InstructionVisitor * visitor) override;
		};

		class MulInstruction : public BinaryInstruction
		{
		public:
			MulInstruction(){}
			MulInstruction(ILOperand * v0, ILOperand * v1)
			{
				Operands[0] = v0;
				Operands[1] = v1;
				Type = v0->Type->Clone();
			}
			MulInstruction(const MulInstruction &) = default;

			virtual String ToString() override
			{
				return Name + L" = mul " + Operands[0].ToString() + L", " + Operands[1].ToString();
			}
			virtual String GetOperatorString() override
			{
				return L"mul";
			}
			virtual MulInstruction * Clone() override
			{
				return new MulInstruction(*this);
			}
			virtual void Accept(InstructionVisitor * visitor) override;
		};

		class DivInstruction : public BinaryInstruction
		{
		public:
			virtual String ToString() override
			{
				return Name + L" = div " + Operands[0].ToString() + L", " + Operands[1].ToString();
			}
			virtual String GetOperatorString() override
			{
				return L"div";
			}
			virtual DivInstruction * Clone() override
			{
				return new DivInstruction(*this);
			}
			virtual void Accept(InstructionVisitor * visitor) override;
		};
		class ModInstruction : public BinaryInstruction
		{
		public:
			virtual String ToString() override
			{
				return Name + L" = mod " + Operands[0].ToString() + L", " + Operands[1].ToString();
			}
			virtual String GetOperatorString() override
			{
				return L"mod";
			}
			virtual ModInstruction * Clone() override
			{
				return new ModInstruction(*this);
			}
			virtual void Accept(InstructionVisitor * visitor) override;
		};
		class AndInstruction : public BinaryInstruction
		{
		public:
			virtual String ToString() override
			{
				return Name + L" = and " + Operands[0].ToString() + L", " + Operands[1].ToString();
			}
			virtual String GetOperatorString() override
			{
				return L"and";
			}
			virtual AndInstruction * Clone() override
			{
				return new AndInstruction(*this);
			}
			virtual void Accept(InstructionVisitor * visitor) override;
		};

		class OrInstruction : public BinaryInstruction
		{
		public:
			virtual String ToString() override
			{
				return Name + L" = or " + Operands[0].ToString() + L", " + Operands[1].ToString();
			}
			virtual String GetOperatorString() override
			{
				return L"or";
			}
			virtual OrInstruction * Clone() override
			{
				return new OrInstruction(*this);
			}
			virtual void Accept(InstructionVisitor * visitor) override;
		};

		class BitAndInstruction : public BinaryInstruction
		{
		public:
			BitAndInstruction(){}
			BitAndInstruction(ILOperand * v0, ILOperand * v1)
			{
				Operands[0] = v0;
				Operands[1] = v1;
				Type = v0->Type->Clone();
			}
			BitAndInstruction(const BitAndInstruction &) = default;
			virtual String ToString() override
			{
				return Name + L" = band " + Operands[0].ToString() + L", " + Operands[1].ToString();
			}
			virtual String GetOperatorString() override
			{
				return L"band";
			}
			virtual BitAndInstruction * Clone() override
			{
				return new BitAndInstruction(*this);
			}
			virtual void Accept(InstructionVisitor * visitor) override;
		};

		class BitOrInstruction : public BinaryInstruction
		{
		public:
			virtual String ToString() override
			{
				return Name + L" = bor " + Operands[0].ToString() + L", " + Operands[1].ToString();
			}
			virtual String GetOperatorString() override
			{
				return L"bor";
			}
			virtual BitOrInstruction * Clone() override
			{
				return new BitOrInstruction(*this);
			}
			BitOrInstruction(){}
			BitOrInstruction(const BitOrInstruction &) = default;
			BitOrInstruction(ILOperand * v0, ILOperand * v1)
			{
				Operands[0] = v0;
				Operands[1] = v1;
				Type = v0->Type->Clone();
			}
			virtual void Accept(InstructionVisitor * visitor) override;
		};

		class BitXorInstruction : public BinaryInstruction
		{
		public:
			virtual String ToString() override
			{
				return Name + L" = bxor " + Operands[0].ToString() + L", " + Operands[1].ToString();
			}
			virtual String GetOperatorString() override
			{
				return L"bxor";
			}
			virtual BitXorInstruction * Clone() override
			{
				return new BitXorInstruction(*this);
			}
			virtual void Accept(InstructionVisitor * visitor) override;
		};

		class ShlInstruction : public BinaryInstruction
		{
		public:
			virtual String ToString() override
			{
				return Name + L" = shl " + Operands[0].ToString() + L", " + Operands[1].ToString();
			}
			virtual String GetOperatorString() override
			{
				return L"shl";
			}
			virtual ShlInstruction * Clone() override
			{
				return new ShlInstruction(*this);
			}
			virtual void Accept(InstructionVisitor * visitor) override;
		};
		class ShrInstruction : public BinaryInstruction
		{
		public:
			virtual String ToString() override
			{
				return Name + L" = shr " + Operands[0].ToString() + L", " + Operands[1].ToString();
			}
			virtual String GetOperatorString() override
			{
				return L"shr";
			}
			virtual ShrInstruction * Clone() override
			{
				return new ShrInstruction(*this);
			}
			virtual void Accept(InstructionVisitor * visitor) override;
		};
		class CompareInstruction : public BinaryInstruction
		{};
		class CmpgtInstruction : public CompareInstruction
		{
		public:
			virtual String ToString() override
			{
				return Name + L" = gt " + Operands[0].ToString() + L", " + Operands[1].ToString();
			}
			virtual String GetOperatorString() override
			{
				return L"gt";
			}
			virtual CmpgtInstruction * Clone() override
			{
				return new CmpgtInstruction(*this);
			}
			virtual void Accept(InstructionVisitor * visitor) override;
		};
		class CmpgeInstruction : public CompareInstruction
		{
		public:
			virtual String ToString() override
			{
				return Name + L" = ge " + Operands[0].ToString() + L", " + Operands[1].ToString();
			}
			virtual String GetOperatorString() override
			{
				return L"ge";
			}
			virtual CmpgeInstruction * Clone() override
			{
				return new CmpgeInstruction(*this);
			}
			virtual void Accept(InstructionVisitor * visitor) override;
		};
		class CmpltInstruction : public CompareInstruction
		{
		public:
			virtual String ToString() override
			{
				return Name + L" = lt " + Operands[0].ToString() + L", " + Operands[1].ToString();
			}
			virtual String GetOperatorString() override
			{
				return L"lt";
			}
			virtual CmpltInstruction * Clone() override
			{
				return new CmpltInstruction(*this);
			}
			virtual void Accept(InstructionVisitor * visitor) override;
		};
		class CmpleInstruction : public CompareInstruction
		{
		public:
			CmpleInstruction() = default;
			CmpleInstruction(const CmpleInstruction &) = default;
			CmpleInstruction(ILOperand * v0, ILOperand * v1)
			{
				Operands[0] = v0;
				Operands[1] = v1;
				Type = v0->Type->Clone();
			}

			virtual String ToString() override
			{
				return Name + L" = le " + Operands[0].ToString() + L", " + Operands[1].ToString();
			}
			virtual String GetOperatorString() override
			{
				return L"le";
			}
			virtual CmpleInstruction * Clone() override
			{
				return new CmpleInstruction(*this);
			}
			virtual void Accept(InstructionVisitor * visitor) override;
		};
		class CmpeqlInstruction : public CompareInstruction
		{
		public:
			virtual String ToString() override
			{
				return Name + L" = eql " + Operands[0].ToString()
					+ L", " + Operands[1].ToString();
			}
			virtual String GetOperatorString() override
			{
				return L"eql";
			}
			virtual CmpeqlInstruction * Clone() override
			{
				return new CmpeqlInstruction(*this);
			}
			virtual void Accept(InstructionVisitor * visitor) override;
		};
		class CmpneqInstruction : public CompareInstruction
		{
		public:
			virtual String ToString() override
			{
				return Name + L" = neq " + Operands[0].ToString() + L", " + Operands[1].ToString();
			}
			virtual String GetOperatorString() override
			{
				return L"neq";
			}
			virtual CmpneqInstruction * Clone() override
			{
				return new CmpneqInstruction(*this);
			}
			virtual void Accept(InstructionVisitor * visitor) override;
		};

		class CastInstruction : public UnaryInstruction
		{};

		class Float2IntInstruction : public CastInstruction
		{
		public:
			Float2IntInstruction(){}
			Float2IntInstruction(const Float2IntInstruction &) = default;

			Float2IntInstruction(ILOperand * op)
			{
				Operand = op;
				Type = new ILBasicType(ILBaseType::Int);
			}
		public:
			virtual String ToString() override
			{
				return Name + L" = f2i " + Operand.ToString();
			}
			virtual String GetOperatorString() override
			{
				return L"f2i";
			}
			virtual Float2IntInstruction * Clone() override
			{
				return new Float2IntInstruction(*this);
			}
			virtual void Accept(InstructionVisitor * visitor) override;
		};

		class Int2FloatInstruction : public CastInstruction
		{
		public:
			Int2FloatInstruction(){}
			Int2FloatInstruction(ILOperand * op)
			{
				Operand = op;
				Type = new ILBasicType(ILBaseType::Float);
			}
			Int2FloatInstruction(const Int2FloatInstruction &) = default;

		public:
			virtual String ToString() override
			{
				return Name + L" = i2f " + Operand.ToString();
			}
			virtual String GetOperatorString() override
			{
				return L"i2f";
			}
			virtual Int2FloatInstruction * Clone() override
			{
				return new Int2FloatInstruction(*this);
			}
			virtual void Accept(InstructionVisitor * visitor) override;
		};

		class CopyInstruction : public UnaryInstruction
		{
		public:
			CopyInstruction(){}
			CopyInstruction(const CopyInstruction &) = default;

			CopyInstruction(ILOperand * dest)
			{
				Operand = dest;
				Type = dest->Type->Clone();
			}
		public:
			virtual String ToString() override
			{
				return Name + L" = " + Operand.ToString();
			}
			virtual String GetOperatorString() override
			{
				return L"copy";
			}
			virtual CopyInstruction * Clone() override
			{
				return new CopyInstruction(*this);
			}
			virtual void Accept(InstructionVisitor * visitor) override;
		};
		// load(src)
		class LoadInstruction : public UnaryInstruction
		{
		public:
			bool Deterministic;
			LoadInstruction()
			{
				Deterministic = false;
			}
			LoadInstruction(const LoadInstruction & other)
				: UnaryInstruction(other)
			{
				Deterministic = other.Deterministic;
			}
			LoadInstruction(ILOperand * dest);
		public:
			virtual String ToString() override
			{
				return Name + L" = load " + Operand.ToString();
			}
			virtual bool IsDeterministic() override
			{
				return Deterministic;
			}
			virtual String GetOperatorString() override
			{
				return L"ld";
			}
			virtual LoadInstruction * Clone() override
			{
				auto rs = new LoadInstruction(*this);
				if (!rs->Type)
					printf("shit");
				return rs;
			}
			virtual void Accept(InstructionVisitor * visitor) override;
		};

		class DiscardInstruction : public ILInstruction
		{
		public:
			virtual bool IsDeterministic() override
			{
				return true;
			}
			virtual bool HasSideEffect() override
			{
				return true;
			}
			virtual String ToString() override
			{
				return  L"discard";
			}
			virtual String GetOperatorString() override
			{
				return L"discard";
			}
			virtual DiscardInstruction * Clone() override
			{
				return new DiscardInstruction(*this);
			}
			virtual void Accept(InstructionVisitor * visitor) override;
		};

		// store(dest, value)
		class StoreInstruction : public BinaryInstruction
		{
		public:
			StoreInstruction(){}
			StoreInstruction(const StoreInstruction &) = default;

			StoreInstruction(ILOperand * dest, ILOperand * value)
			{
				Operands.SetSize(2);
				Operands[0] = dest;
				Operands[1] = value;
			}
		public:
			virtual String ToString() override
			{
				return L"store " + Operands[0].ToString() + L", " +
					Operands[1].ToString();
			}
			virtual String GetOperatorString() override
			{
				return L"st";
			}
			virtual bool HasSideEffect() override
			{
				return true;
			}
			virtual StoreInstruction * Clone() override
			{
				return new StoreInstruction(*this);
			}
			virtual void Accept(InstructionVisitor * visitor) override;
		};

		class MemberUpdateInstruction : public ILInstruction
		{
		public:
			UseReference Operands[3];
			MemberUpdateInstruction()
			{
				Operands[0].SetUser(this);
				Operands[1].SetUser(this);
				Operands[2].SetUser(this);
			}
			MemberUpdateInstruction(const MemberUpdateInstruction & other)
				: ILInstruction(other)
			{
				Operands[0].SetUser(this);
				Operands[1].SetUser(this);
				Operands[2].SetUser(this);
				Operands[0] = other.Operands[0].Ptr();
				Operands[1] = other.Operands[1].Ptr();
				Operands[2] = other.Operands[2].Ptr();
			}
			MemberUpdateInstruction(ILOperand * var, ILOperand * offset, ILOperand * value)
			{
				Operands[0].SetUser(this);
				Operands[1].SetUser(this);
				Operands[2].SetUser(this);
				Operands[0] = var;
				Operands[1] = offset;
				Operands[2] = value;
				Type = var->Type->Clone();
			}
			virtual OperandIterator begin() override
			{
				return Operands;
			}
			virtual OperandIterator end() override
			{
				return Operands + 3;
			}
			virtual String ToString() override
			{
				return Name + L" = update " + Operands[0].ToString() + L", " + Operands[1].ToString() + L"," + Operands[2].ToString();
			}
			virtual String GetOperatorString() override
			{
				return L"update";
			}
			virtual MemberUpdateInstruction * Clone() override
			{
				return new MemberUpdateInstruction(*this);
			}
			virtual bool HasSideEffect() override
			{
				return true;
			}
			virtual void Accept(InstructionVisitor * visitor) override;
		};


		class InstructionVisitor : public Object
		{
		public:
			virtual void VisitAddInstruction(AddInstruction *){}
			virtual void VisitSubInstruction(SubInstruction *){}
			virtual void VisitDivInstruction(DivInstruction *){}
			virtual void VisitMulInstruction(MulInstruction *){}
			virtual void VisitModInstruction(ModInstruction *){}
			virtual void VisitNegInstruction(NegInstruction *){}
			virtual void VisitAndInstruction(AndInstruction *){}
			virtual void VisitOrInstruction(OrInstruction *){}
			virtual void VisitBitAndInstruction(BitAndInstruction *){}
			virtual void VisitBitOrInstruction(BitOrInstruction *){}
			virtual void VisitBitXorInstruction(BitXorInstruction *){}
			virtual void VisitShlInstruction(ShlInstruction *){}
			virtual void VisitShrInstruction(ShrInstruction *){}
			virtual void VisitBitNotInstruction(BitNotInstruction *){}
			virtual void VisitNotInstruction(NotInstruction *){}
			virtual void VisitCmpeqlInstruction(CmpeqlInstruction *){}
			virtual void VisitCmpneqInstruction(CmpneqInstruction *){}
			virtual void VisitCmpltInstruction(CmpltInstruction *){}
			virtual void VisitCmpleInstruction(CmpleInstruction *){}
			virtual void VisitCmpgtInstruction(CmpgtInstruction *){}
			virtual void VisitCmpgeInstruction(CmpgeInstruction *){}

			virtual void VisitLoadInstruction(LoadInstruction *){}
			virtual void VisitStoreInstruction(StoreInstruction *){}
			virtual void VisitCopyInstruction(CopyInstruction *){}

			virtual void VisitAllocVarInstruction(AllocVarInstruction *){}
			virtual void VisitFetchArgInstruction(FetchArgInstruction *){}
			virtual void VisitCastInstruction(CastInstruction *){}
			virtual void VisitInt2FloatInstruction(Int2FloatInstruction *){}
			virtual void VisitFloat2IntInstruction(Float2IntInstruction *){}
			virtual void VisitMemberLoadInstruction(MemberLoadInstruction *){}
			virtual void VisitMemberUpdateInstruction(MemberUpdateInstruction *) {}
			virtual void VisitImportInstruction(ImportInstruction*) {}
			virtual void VisitExportInstruction(ExportInstruction*) {}
			virtual void VisitSelectInstruction(SelectInstruction *){}
			virtual void VisitCallInstruction(CallInstruction *){}
			virtual void VisitSwitchInstruction(SwitchInstruction *){}
			virtual void VisitDiscardInstruction(DiscardInstruction *) {}
			virtual void VisitLoadInputInstruction(LoadInputInstruction *) {}
			virtual void VisitPhiInstruction(PhiInstruction *){}
			virtual void VisitSwizzleInstruction(SwizzleInstruction*) {}
		};

		class ForInstruction : public ILInstruction
		{
		public:
			RefPtr<CFGNode> InitialCode, ConditionCode, SideEffectCode, BodyCode;
			virtual int GetSubBlockCount() override
			{
				int count = 0;
				if (InitialCode)
					count++;
				if (ConditionCode)
					count++;
				if (SideEffectCode)
					count++;
				if (BodyCode)
					count++;
				return count;
			}
			virtual CFGNode * GetSubBlock(int i) override
			{
				int id = 0;
				if (InitialCode)
				{
					if (id == i) return InitialCode.Ptr();
					id++;
				}
				if (ConditionCode)
				{
					if (id == i) return ConditionCode.Ptr();
					id++;
				}
				if (SideEffectCode)
				{
					if (id == i) return SideEffectCode.Ptr();
					id++;
				}
				if (BodyCode)
				{
					if (id == i) return BodyCode.Ptr();
				}
				return nullptr;
			}

			virtual String ToString() override
			{
				StringBuilder sb;
				sb << L"for (" << InitialCode->ToString() << L"; " << ConditionCode->ToString() << L"; ";
				sb << SideEffectCode->ToString() << L")" << EndLine;
				sb << L"{" << EndLine;
				sb << BodyCode->ToString() << EndLine;
				sb << L"}" << EndLine;
				return sb.ProduceString();
			}
		};
		class IfInstruction : public UnaryInstruction
		{
		public:
			RefPtr<CFGNode> TrueCode, FalseCode;
			virtual int GetSubBlockCount() override
			{
				if (FalseCode)
					return 2;
				else
					return 1;
			}
			virtual CFGNode * GetSubBlock(int i) override
			{
				if (i == 0)
					return TrueCode.Ptr();
				else if (i == 1)
					return FalseCode.Ptr();
				return nullptr;
			}

			virtual String ToString() override
			{
				StringBuilder sb;
				sb << L"if (" << Operand->ToString() << L")" << EndLine;
				sb << L"{" << EndLine;
				sb << TrueCode->ToString() << EndLine;
				sb << L"}" << EndLine;
				if (FalseCode)
				{
					sb << L"else" << EndLine;
					sb << L"{" << EndLine;
					sb << FalseCode->ToString() << EndLine;
					sb << L"}" << EndLine;
				}
				return sb.ProduceString();
			}
		};
		class WhileInstruction : public ILInstruction
		{
		public:
			RefPtr<CFGNode> ConditionCode, BodyCode;
			virtual int GetSubBlockCount() override
			{
				return 2;
			}
			virtual CFGNode * GetSubBlock(int i) override
			{
				if (i == 0)
					return ConditionCode.Ptr();
				else if (i == 1)
					return BodyCode.Ptr();
				return nullptr;
			}

			virtual String ToString() override
			{
				StringBuilder sb;
				sb << L"while (" << ConditionCode->ToString() << L")" << EndLine;
				sb << L"{" << EndLine;
				sb << BodyCode->ToString();
				sb << L"}" << EndLine;
				return sb.ProduceString();
			}
		};
		class DoInstruction : public ILInstruction
		{
		public:
			RefPtr<CFGNode> ConditionCode, BodyCode;
			virtual int GetSubBlockCount() override
			{
				return 2;
			}
			virtual CFGNode * GetSubBlock(int i) override
			{
				if (i == 1)
					return ConditionCode.Ptr();
				else if (i == 0)
					return BodyCode.Ptr();
				return nullptr;
			}

			virtual String ToString() override
			{
				StringBuilder sb;
				sb << L"{" << EndLine;
				sb << BodyCode->ToString();
				sb << L"}" << EndLine;
				sb << L"while (" << ConditionCode->ToString() << L")" << EndLine;
				return sb.ProduceString();
			}
		};
		class ReturnInstruction : public UnaryInstruction
		{
		public:
			ReturnInstruction(ILOperand * op)
				:UnaryInstruction()
			{
				Operand = op;
			}

			virtual String ToString() override
			{
				return L"return " + Operand->ToString() + L";";
			}
		};
		class BreakInstruction : public ILInstruction
		{};
		class ContinueInstruction : public ILInstruction
		{};

		class KeyHoleNode
		{
		public:
			String NodeType;
			int CaptureId = -1;
			List<RefPtr<KeyHoleNode>> Children;
			bool Match(List<ILOperand*> & matchResult, ILOperand * instr);
			static RefPtr<KeyHoleNode> Parse(String format);
		};
	}
}

#endif

/***********************************************************************
SPIRECORE\LEXER.H
***********************************************************************/
#ifndef RASTER_RENDERER_LEXER_H
#define RASTER_RENDERER_LEXER_H


namespace Spire
{
	namespace Compiler
	{
		using namespace CoreLib::Basic;

		enum class TokenType
		{
			// illegal
			Unkown,
			// identifier
			Identifier,
			KeywordReturn, KeywordBreak, KeywordContinue,
			KeywordIf, KeywordElse, KeywordFor, KeywordWhile, KeywordDo,
			// constant
			IntLiterial, DoubleLiterial, StringLiterial, CharLiterial,
			// operators
			Semicolon, Comma, Dot, LBrace, RBrace, LBracket, RBracket, LParent, RParent,
			OpAssign, OpAdd, OpSub, OpMul, OpDiv, OpMod, OpNot, OpBitNot, OpLsh, OpRsh, 
			OpEql, OpNeq, OpGreater, OpLess, OpGeq, OpLeq,
			OpAnd, OpOr, OpBitXor, OpBitAnd, OpBitOr,
			OpInc, OpDec, OpAddAssign, OpSubAssign, OpMulAssign, OpDivAssign, OpModAssign,
			OpShlAssign, OpShrAssign, OpOrAssign, OpAndAssign, OpXorAssign,
			
			QuestionMark, Colon, RightArrow, At,
		};

		String TokenTypeToString(TokenType type);

		class Token
		{
		public:
			TokenType Type = TokenType::Unkown;
			String Content;
			CodePosition Position;
			Token() = default;
			Token(TokenType type, const String & content, int line, int col, String fileName)
			{
				Type = type;
				Content = content;
				Position = CodePosition(line, col, fileName);
			}
		};

		class Lexer
		{
		public:
			List<Token> Parse(const String & fileName, const String & str, List<CompileError> & errorList);
		};
	}
}

#endif

/***********************************************************************
SPIRECORE\SYNTAX.H
***********************************************************************/
#ifndef RASTER_RENDERER_SYNTAX_H
#define RASTER_RENDERER_SYNTAX_H


namespace Spire
{
	namespace Compiler
	{
		using namespace CoreLib::Basic;
		class SyntaxVisitor;
		class FunctionSyntaxNode;

		enum class VariableModifier
		{
			None = 0,
			Uniform = 1,
			Out = 2,
			In = 4,
			Centroid = 128,
			Const = 16,
			Instance = 1024,
			Builtin = 256,
			Parameter = 513
		};

		enum class BaseType
		{
			Void = 0,
			Int = 16, Int2 = 17, Int3 = 18, Int4 = 19,
			Float = 32, Float2 = 33, Float3 = 34, Float4 = 35,
			UInt = 512, UInt2 = 513, UInt3 = 514, UInt4 = 515,
			Bool = 128, Bool2 = 129, Bool3 = 130, Bool4 = 131,
			Float3x3 = 40, Float4x4 = 47,
			Texture2D = 48,
			TextureShadow = 49,
			TextureCube = 50,
			TextureCubeShadow = 51,
			Function = 64,
			Shader = 256,
			Struct = 1024,
			Record = 2048,
			Error = 4096,
		};

		inline const wchar_t * BaseTypeToString(BaseType t)
		{
			switch (t)
			{
			case BaseType::Void:
				return L"void";
			case BaseType::Bool:
			case BaseType::Int:
				return L"int";
			case BaseType::Int2:
				return L"int2";
			case BaseType::Int3:
				return L"int3";
			case BaseType::Int4:
				return L"int4";
			case BaseType::Float:
				return L"float";
			case BaseType::Float2:
				return L"float2";
			case BaseType::Float3:
				return L"float3";
			case BaseType::Float4:
				return L"float4";
			case BaseType::Float3x3:
				return L"float3x3";
			case BaseType::Float4x4:
				return L"float4x4";
			case BaseType::Texture2D:
				return L"sampler2D";
			case BaseType::TextureCube:
				return L"samplerCube";
			case BaseType::TextureShadow:
				return L"sampler2DShadow";
			case BaseType::TextureCubeShadow:
				return L"samplerCubeShadow";
			default:
				return L"<err-type>";
			}
		}

		inline bool IsVector(BaseType type)
		{
			return (((int)type) & 15) != 0;
		}

		inline int GetVectorSize(BaseType type)
		{
			return (((int)type) & 15) + 1;
		}

		inline BaseType GetVectorBaseType(BaseType type)
		{
			return (BaseType)(((int)type) & (~15));
		}

		class SymbolTable;
		class ShaderSymbol;
		class StructSymbol;
		class ShaderClosure;
		class StructSyntaxNode;
		class ShaderComponentSymbol;
		class FunctionSymbol;
		class BasicExpressionType;
		class ArrayExpressionType;
		class GenericExpressionType;

		class ExpressionType : public Object
		{
		public:
			static RefPtr<ExpressionType> Bool;
			static RefPtr<ExpressionType> UInt;
			static RefPtr<ExpressionType> UInt2;
			static RefPtr<ExpressionType> UInt3;
			static RefPtr<ExpressionType> UInt4;
			static RefPtr<ExpressionType> Int;
			static RefPtr<ExpressionType> Int2;
			static RefPtr<ExpressionType> Int3;
			static RefPtr<ExpressionType> Int4;
			static RefPtr<ExpressionType> Float;
			static RefPtr<ExpressionType> Float2;
			static RefPtr<ExpressionType> Float3;
			static RefPtr<ExpressionType> Float4;
			static RefPtr<ExpressionType> Void;
			static RefPtr<ExpressionType> Error;
		public:
			virtual String ToString() const = 0;
			virtual bool IsIntegral() const = 0;
			virtual bool Equals(const ExpressionType * type) const = 0;
			virtual bool IsVectorType() const = 0;
			virtual bool IsArray() const = 0;
			virtual bool IsGenericType(String typeName) const = 0;
			virtual BasicExpressionType * AsBasicType() const = 0;
			virtual ArrayExpressionType * AsArrayType() const = 0;
			virtual GenericExpressionType * AsGenericType() const = 0;
			virtual ExpressionType * Clone() = 0;
			bool IsTexture() const;
			bool IsStruct() const;
			bool IsShader() const;
			static void Init();
			static void Finalize();
		};

		class BasicExpressionType : public ExpressionType
		{
		public:
			bool IsLeftValue;
			bool IsReference;
			bool IsMaskedVector = false;
			BaseType BaseType;
			ShaderSymbol * Shader = nullptr;
			ShaderClosure * ShaderClosure = nullptr;
			FunctionSymbol * Func = nullptr;
			ShaderComponentSymbol * Component = nullptr;
			StructSymbol * Struct = nullptr;
			String RecordTypeName;

			BasicExpressionType()
			{
				BaseType = Compiler::BaseType::Int;
				Func = 0;
				IsLeftValue = false;
				IsReference = false;
			}
			BasicExpressionType(Compiler::BaseType baseType)
			{
				BaseType = baseType;
				Func = 0;
				IsLeftValue = false;
				IsReference = false;
			}
			BasicExpressionType(ShaderSymbol * shaderSym, Compiler::ShaderClosure * closure)
			{
				this->BaseType = BaseType::Shader;
				this->ShaderClosure = closure;
				this->Shader = shaderSym;
			}
			virtual bool IsIntegral() const override;
			virtual bool Equals(const ExpressionType * type) const override;
			virtual bool IsVectorType() const override;
			virtual bool IsArray() const override;
			virtual CoreLib::Basic::String ToString() const override;
			virtual ExpressionType * Clone() override;
			virtual bool IsGenericType(String typeName) const override
			{
				return false;
			}
			virtual BasicExpressionType * AsBasicType() const override
			{
				return const_cast<BasicExpressionType*>(this);
			}
			virtual ArrayExpressionType * AsArrayType() const override
			{
				return nullptr;
			}
			virtual GenericExpressionType * AsGenericType() const override
			{
				return nullptr;
			}
		};

		class ArrayExpressionType : public ExpressionType
		{
		public:
			RefPtr<ExpressionType> BaseType;
			int ArrayLength = 0;
			virtual bool IsIntegral() const override;
			virtual bool IsArray() const override;

			virtual bool Equals(const ExpressionType * type) const override;
			virtual bool IsVectorType() const override;
			virtual CoreLib::Basic::String ToString() const override;
			virtual ExpressionType * Clone() override;
			virtual bool IsGenericType(String typeName) const override
			{
				return false;
			}
			virtual BasicExpressionType * AsBasicType() const override
			{
				return nullptr;
			}
			virtual ArrayExpressionType * AsArrayType() const override
			{
				return const_cast<ArrayExpressionType*>(this);
			}
			virtual GenericExpressionType * AsGenericType() const override
			{
				return nullptr;
			}
		};

		class GenericExpressionType : public ExpressionType
		{
		public:
			RefPtr<ExpressionType> BaseType;
			String GenericTypeName;
			virtual bool IsIntegral() const override;
			virtual bool IsArray() const override;

			virtual bool Equals(const ExpressionType * type) const override;
			virtual bool IsVectorType() const override;
			virtual CoreLib::Basic::String ToString() const override;
			virtual ExpressionType * Clone() override;
			virtual bool IsGenericType(String typeName) const override
			{
				return GenericTypeName == typeName;
			}
			virtual BasicExpressionType * AsBasicType() const override
			{
				return nullptr;
			}
			virtual ArrayExpressionType * AsArrayType() const override
			{
				return nullptr;
			}
			virtual GenericExpressionType * AsGenericType() const override
			{
				return const_cast<GenericExpressionType*>(this);
			}
		};
		
		class Type
		{
		public:
			RefPtr<ExpressionType> DataType;
			// ContrainedWorlds: Implementation must be defined at at least one of of these worlds in order to satisfy global dependency
			// FeasibleWorlds: The component can be computed at any of these worlds
			EnumerableHashSet<String> ConstrainedWorlds, FeasibleWorlds;
			EnumerableHashSet<String> PinnedWorlds; 
		};


		class VariableEntry
		{
		public:
			String Name;
			Type Type;
			bool IsComponent = false;
		};

		class Scope
		{
		public:
			Scope * Parent;
			Dictionary<String, VariableEntry> Variables;
			bool FindVariable(const String & name, VariableEntry & variable);
			Scope()
				: Parent(0)
			{}
		};

		class CloneContext
		{
		public:
			Dictionary<Spire::Compiler::Scope*, RefPtr<Spire::Compiler::Scope>> ScopeTranslateTable;
		};

		class SyntaxNode : public RefObject
		{
		protected:
			template<typename T>
			T* CloneSyntaxNodeFields(T * target, CloneContext & ctx)
			{
				if (this->Scope)
				{
					RefPtr<Spire::Compiler::Scope> newScope;
					if (ctx.ScopeTranslateTable.TryGetValue(this->Scope.Ptr(), newScope))
						target->Scope = newScope;
					else
					{
						target->Scope = new Spire::Compiler::Scope(*this->Scope);
						ctx.ScopeTranslateTable[this->Scope.Ptr()] = target->Scope;
						RefPtr<Spire::Compiler::Scope> parentScope;
						if (ctx.ScopeTranslateTable.TryGetValue(target->Scope->Parent, parentScope))
							target->Scope->Parent = parentScope.Ptr();
					}
					
				}
				target->Position = this->Position;
				target->Tags = this->Tags;
				return target;
			}
		public:
			EnumerableDictionary<String, RefPtr<Object>> Tags;
			CodePosition Position;
			RefPtr<Scope> Scope;
			virtual RefPtr<SyntaxNode> Accept(SyntaxVisitor * visitor) = 0;
			virtual SyntaxNode * Clone(CloneContext & ctx) = 0;
		};

		class TypeSyntaxNode : public SyntaxNode
		{
		public:
			static RefPtr<TypeSyntaxNode> FromExpressionType(ExpressionType * t);
			virtual TypeSyntaxNode * Clone(CloneContext & ctx) = 0;
		};

		class BasicTypeSyntaxNode : public TypeSyntaxNode
		{
		public:
			String TypeName;
			virtual RefPtr<SyntaxNode> Accept(SyntaxVisitor * visitor);
			virtual BasicTypeSyntaxNode * Clone(CloneContext & ctx)
			{
				return CloneSyntaxNodeFields(new BasicTypeSyntaxNode(*this), ctx);
			}
		};

		class ArrayTypeSyntaxNode : public TypeSyntaxNode
		{
		public:
			RefPtr<TypeSyntaxNode> BaseType;
			int ArrayLength;
			virtual RefPtr<SyntaxNode> Accept(SyntaxVisitor * visitor);
			virtual ArrayTypeSyntaxNode * Clone(CloneContext & ctx)
			{
				auto rs = CloneSyntaxNodeFields(new ArrayTypeSyntaxNode(*this), ctx);
				rs->BaseType = BaseType->Clone(ctx);
				return rs;
			}
		};

		class GenericTypeSyntaxNode : public TypeSyntaxNode
		{
		public:
			RefPtr<TypeSyntaxNode> BaseType;
			String GenericTypeName;
			virtual RefPtr<SyntaxNode> Accept(SyntaxVisitor * visitor);
			virtual GenericTypeSyntaxNode * Clone(CloneContext & ctx)
			{
				auto rs = CloneSyntaxNodeFields(new GenericTypeSyntaxNode(*this), ctx);
				rs->BaseType = BaseType->Clone(ctx);
				return rs;
			}
		};

		class StructField : public SyntaxNode
		{
		public:
			RefPtr<TypeSyntaxNode> TypeNode;
			RefPtr<ExpressionType> Type;
			Token Name;
			StructField()
			{}
			virtual RefPtr<SyntaxNode> Accept(SyntaxVisitor * visitor) override;
			virtual StructField * Clone(CloneContext & ctx) override
			{
				auto rs = CloneSyntaxNodeFields(new StructField(*this), ctx);
				rs->TypeNode = TypeNode->Clone(ctx);
				return rs;
			}
		};

		class StructSyntaxNode : public SyntaxNode
		{
		public:
			List<RefPtr<StructField>> Fields;
			Token Name;
			bool IsIntrinsic = false;
			virtual RefPtr<SyntaxNode> Accept(SyntaxVisitor * visitor) override;
			int FindField(String name)
			{
				for (int i = 0; i < Fields.Count(); i++)
				{
					if (Fields[i]->Name.Content == name)
						return i;
				}
				return -1;
			}
			virtual StructSyntaxNode * Clone(CloneContext & ctx) override
			{
				auto rs = CloneSyntaxNodeFields(new StructSyntaxNode(*this), ctx);
				rs->Fields.Clear();
				for (auto & f : Fields)
					rs->Fields.Add(f->Clone(ctx));
				return rs;
			}
		};

		enum class ExpressionAccess
		{
			Read, Write
		};

		class ExpressionSyntaxNode : public SyntaxNode
		{
		public:
			RefPtr<ExpressionType> Type;
			ExpressionAccess Access;
			ExpressionSyntaxNode()
			{
				Access = ExpressionAccess::Read;
			}
			ExpressionSyntaxNode(const ExpressionSyntaxNode & expr) = default;
			virtual ExpressionSyntaxNode* Clone(CloneContext & ctx) = 0;
		};

		class StatementSyntaxNode : public SyntaxNode
		{
		public:
			virtual StatementSyntaxNode* Clone(CloneContext & ctx) = 0;
		};

		class BlockStatementSyntaxNode : public StatementSyntaxNode
		{
		public:
			List<RefPtr<StatementSyntaxNode>> Statements;
			virtual RefPtr<SyntaxNode> Accept(SyntaxVisitor * visitor);
			virtual BlockStatementSyntaxNode * Clone(CloneContext & ctx);
		};

		class ParameterSyntaxNode : public SyntaxNode
		{
		public:
			RefPtr<TypeSyntaxNode> TypeNode;
			RefPtr<ExpressionType> Type;
			String Name;
			RefPtr<ExpressionSyntaxNode> Expr;
			virtual RefPtr<SyntaxNode> Accept(SyntaxVisitor * visitor);
			virtual ParameterSyntaxNode * Clone(CloneContext & ctx);
		};

		class FunctionSyntaxNode : public SyntaxNode
		{
		public:
			String Name, InternalName;
			RefPtr<ExpressionType> ReturnType;
			RefPtr<TypeSyntaxNode> ReturnTypeNode;
			List<RefPtr<ParameterSyntaxNode>> Parameters;
			RefPtr<BlockStatementSyntaxNode> Body;
			bool IsInline;
			bool IsExtern;
			bool HasSideEffect;
			virtual RefPtr<SyntaxNode> Accept(SyntaxVisitor * visitor);
			FunctionSyntaxNode()
			{
				IsInline = false;
				IsExtern = false;
				HasSideEffect = true;
			}

			virtual FunctionSyntaxNode * Clone(CloneContext & ctx);
		};

		class ImportOperatorDefSyntaxNode : public SyntaxNode
		{
		public:
			Token Name;
			Token SourceWorld, DestWorld;
			List<RefPtr<ParameterSyntaxNode>> Parameters;
			RefPtr<BlockStatementSyntaxNode> Body;
			EnumerableDictionary<String, String> LayoutAttributes;
			Token TypeName;
			List<RefPtr<FunctionSyntaxNode>> Requirements;
			List<String> Usings;
			virtual RefPtr<SyntaxNode> Accept(SyntaxVisitor * visitor) override;
			virtual ImportOperatorDefSyntaxNode * Clone(CloneContext & ctx) override;
		};

		class ChoiceValueSyntaxNode : public ExpressionSyntaxNode
		{
		public:
			String WorldName, AlternateName;
			virtual RefPtr<SyntaxNode> Accept(SyntaxVisitor *) { return this; }
			virtual ChoiceValueSyntaxNode * Clone(CloneContext & ctx);
		};

		class VarExpressionSyntaxNode : public ExpressionSyntaxNode
		{
		public:
			String Variable;
			virtual RefPtr<SyntaxNode> Accept(SyntaxVisitor * visitor);
			virtual VarExpressionSyntaxNode * Clone(CloneContext & ctx);
		};

		class ConstantExpressionSyntaxNode : public ExpressionSyntaxNode
		{
		public:
			enum class ConstantType
			{
				Int, Bool, Float
			};
			ConstantType ConstType;
			union
			{
				int IntValue;
				float FloatValue;
			};
			virtual RefPtr<SyntaxNode> Accept(SyntaxVisitor * visitor);
			virtual ConstantExpressionSyntaxNode * Clone(CloneContext & ctx);
		};

		enum class Operator
		{
			Neg, Not, BitNot, PreInc, PreDec, PostInc, PostDec,
			Mul, Div, Mod,
			Add, Sub, 
			Lsh, Rsh,
			Eql, Neq, Greater, Less, Geq, Leq,
			BitAnd, BitXor, BitOr,
			And,
			Or,
			Assign = 200, AddAssign, SubAssign, MulAssign, DivAssign, ModAssign,
			LshAssign, RshAssign, OrAssign, AndAssign, XorAssign
		};

		String GetOperatorFunctionName(Operator op);
		
		class ImportExpressionSyntaxNode : public ExpressionSyntaxNode
		{
		public:
			RefPtr<ExpressionSyntaxNode> Component;
			String ComponentUniqueName; // filled by RsolveDependence
			RefPtr<ImportOperatorDefSyntaxNode> ImportOperatorDef; // filled by semantics
			List<RefPtr<ExpressionSyntaxNode>> Arguments;
			virtual RefPtr<SyntaxNode> Accept(SyntaxVisitor * visitor) override;
			virtual ImportExpressionSyntaxNode * Clone(CloneContext & ctx) override;
		};

		class UnaryExpressionSyntaxNode : public ExpressionSyntaxNode
		{
		public:
			Operator Operator;
			RefPtr<ExpressionSyntaxNode> Expression;
			virtual RefPtr<SyntaxNode> Accept(SyntaxVisitor * visitor);
			virtual UnaryExpressionSyntaxNode * Clone(CloneContext & ctx);
		};
		
		class BinaryExpressionSyntaxNode : public ExpressionSyntaxNode
		{
		public:
			Operator Operator;
			RefPtr<ExpressionSyntaxNode> LeftExpression;
			RefPtr<ExpressionSyntaxNode> RightExpression;
			virtual RefPtr<SyntaxNode> Accept(SyntaxVisitor * visitor);
			virtual BinaryExpressionSyntaxNode * Clone(CloneContext & ctx);
		};

		class IndexExpressionSyntaxNode : public ExpressionSyntaxNode
		{
		public:
			RefPtr<ExpressionSyntaxNode> BaseExpression;
			RefPtr<ExpressionSyntaxNode> IndexExpression;
			virtual IndexExpressionSyntaxNode * Clone(CloneContext & ctx);
			virtual RefPtr<SyntaxNode> Accept(SyntaxVisitor * visitor);
		};

		class MemberExpressionSyntaxNode : public ExpressionSyntaxNode
		{
		public:
			RefPtr<ExpressionSyntaxNode> BaseExpression;
			String MemberName;
			virtual RefPtr<SyntaxNode> Accept(SyntaxVisitor * visitor);
			virtual MemberExpressionSyntaxNode * Clone(CloneContext & ctx);
		};

		class InvokeExpressionSyntaxNode : public ExpressionSyntaxNode
		{
		public:
			RefPtr<ExpressionSyntaxNode> FunctionExpr;
			List<RefPtr<ExpressionSyntaxNode>> Arguments;
			virtual RefPtr<SyntaxNode> Accept(SyntaxVisitor * visitor);
			virtual InvokeExpressionSyntaxNode * Clone(CloneContext & ctx);
		};

		class TypeCastExpressionSyntaxNode : public ExpressionSyntaxNode
		{
		public:
			RefPtr<TypeSyntaxNode> TargetType;
			RefPtr<ExpressionSyntaxNode> Expression;
			virtual RefPtr<SyntaxNode> Accept(SyntaxVisitor * visitor);
			virtual TypeCastExpressionSyntaxNode * Clone(CloneContext & ctx);
		};

		class SelectExpressionSyntaxNode : public ExpressionSyntaxNode
		{
		public:
			RefPtr<ExpressionSyntaxNode> SelectorExpr, Expr0, Expr1;
			virtual RefPtr<SyntaxNode> Accept(SyntaxVisitor * visitor);
			virtual SelectExpressionSyntaxNode * Clone(CloneContext & ctx);
		};


		class EmptyStatementSyntaxNode : public StatementSyntaxNode
		{
		public:
			virtual RefPtr<SyntaxNode> Accept(SyntaxVisitor * visitor);
			virtual EmptyStatementSyntaxNode * Clone(CloneContext & ctx);
		};

		class DiscardStatementSyntaxNode : public StatementSyntaxNode
		{
		public:
			virtual RefPtr<SyntaxNode> Accept(SyntaxVisitor * visitor);
			virtual DiscardStatementSyntaxNode * Clone(CloneContext & ctx);
		};

		class VariableDeclr
		{
		public:
			RefPtr<ExpressionType> Type;
			String Name;

			bool operator ==(const VariableDeclr & var)
			{
				return Name == var.Name;
			}
			bool operator ==(const String & name)
			{
				return name == Name;
			}
		};

		struct Variable : public SyntaxNode
		{
			String Name;
			RefPtr<ExpressionSyntaxNode> Expression;
			virtual RefPtr<SyntaxNode> Accept(SyntaxVisitor * visitor);
			virtual Variable * Clone(CloneContext & ctx);
		};

		class VarDeclrStatementSyntaxNode : public StatementSyntaxNode
		{
		public:
			RefPtr<TypeSyntaxNode> TypeNode;
			RefPtr<ExpressionType> Type;
			String LayoutString;
			List<RefPtr<Variable>> Variables;
			virtual RefPtr<SyntaxNode> Accept(SyntaxVisitor * visitor);
			virtual VarDeclrStatementSyntaxNode * Clone(CloneContext & ctx);
		};

		class RateWorld
		{
		public:
			Token World;
			bool Pinned = false;
			RateWorld() {}
			RateWorld(String world)
			{
				World.Content = world;
				World.Type = TokenType::Identifier;
			}
		};

		class RateSyntaxNode : public SyntaxNode
		{
		public:
			List<RateWorld> Worlds;
			virtual RefPtr<SyntaxNode> Accept(SyntaxVisitor *) override
			{
				return this;
			}
			virtual RateSyntaxNode * Clone(CloneContext & ctx) override;
		};

		class ShaderMemberNode : public SyntaxNode
		{
		public:
			Token ParentModuleName;
			virtual ShaderMemberNode * Clone(CloneContext & ctx) = 0;
		};

		class ComponentSyntaxNode : public ShaderMemberNode
		{
		public:
			bool IsOutput = false, IsPublic = false, IsInline = false, IsParam = false, IsInput = false;
			RefPtr<TypeSyntaxNode> TypeNode;
			RefPtr<ExpressionType> Type;
			RefPtr<RateSyntaxNode> Rate;
			Token Name, AlternateName;
			EnumerableDictionary<String, String> LayoutAttributes;
			RefPtr<BlockStatementSyntaxNode> BlockStatement;
			RefPtr<ExpressionSyntaxNode> Expression;
			List<RefPtr<ParameterSyntaxNode>> Parameters;
			virtual RefPtr<SyntaxNode> Accept(SyntaxVisitor * visitor) override;
			virtual ComponentSyntaxNode * Clone(CloneContext & ctx) override;
		};

		class WorldSyntaxNode : public SyntaxNode
		{
		public:
			bool IsAbstract = false;
			Token Name;
			EnumerableDictionary<String, String> LayoutAttributes;
			virtual RefPtr<SyntaxNode> Accept(SyntaxVisitor *) override { return this; }
			virtual WorldSyntaxNode * Clone(CloneContext & ctx) override;
		};

		class StageSyntaxNode : public SyntaxNode
		{
		public:
			Token Name;
			Token StageType;
			EnumerableDictionary<String, Token> Attributes;
			virtual RefPtr<SyntaxNode> Accept(SyntaxVisitor *) override { return this; }
			virtual StageSyntaxNode * Clone(CloneContext & ctx) override;
		};
		
		class PipelineSyntaxNode : public SyntaxNode
		{
		public:
			Token Name;
			Token ParentPipeline;
			List<RefPtr<WorldSyntaxNode>> Worlds;
			List<RefPtr<ImportOperatorDefSyntaxNode>> ImportOperators;
			List<RefPtr<StageSyntaxNode>> Stages;
			List<RefPtr<ComponentSyntaxNode>> AbstractComponents;
			virtual RefPtr<SyntaxNode> Accept(SyntaxVisitor *) override { return this; }
			virtual PipelineSyntaxNode * Clone(CloneContext & ctx) override;
		};

		class ImportArgumentSyntaxNode : public SyntaxNode
		{
		public:
			RefPtr<ExpressionSyntaxNode> Expression;
			Token ArgumentName;
			virtual RefPtr<SyntaxNode> Accept(SyntaxVisitor *) override;
			virtual ImportArgumentSyntaxNode * Clone(CloneContext & ctx) override;
		};

		class ImportSyntaxNode : public ShaderMemberNode
		{
		public:
			bool IsInplace = false;
			bool IsPublic = false;
			Token ShaderName;
			Token ObjectName;
			List<RefPtr<ImportArgumentSyntaxNode>> Arguments;
			virtual RefPtr<SyntaxNode> Accept(SyntaxVisitor *) override;
			virtual ImportSyntaxNode * Clone(CloneContext & ctx) override;

		};

		class ShaderSyntaxNode : public SyntaxNode
		{
		public:
			Token Name;
			Token Pipeline;
			List<RefPtr<ShaderMemberNode>> Members;
			bool IsModule = false;
			virtual RefPtr<SyntaxNode> Accept(SyntaxVisitor * visitor) override;
			virtual ShaderSyntaxNode * Clone(CloneContext & ctx) override;
		};

		class ProgramSyntaxNode : public SyntaxNode
		{
		public:
			List<Token> Usings;
			List<RefPtr<FunctionSyntaxNode>> Functions;
			List<RefPtr<PipelineSyntaxNode>> Pipelines;
			List<RefPtr<ShaderSyntaxNode>> Shaders;
			List<RefPtr<StructSyntaxNode>> Structs;
			void Include(ProgramSyntaxNode * other)
			{
				Functions.AddRange(other->Functions);
				Pipelines.AddRange(other->Pipelines);
				Shaders.AddRange(other->Shaders);
				Structs.AddRange(other->Structs);
			}
			virtual RefPtr<SyntaxNode> Accept(SyntaxVisitor * visitor) override;
			virtual ProgramSyntaxNode * Clone(CloneContext & ctx) override;
		};

		class ImportStatementSyntaxNode : public StatementSyntaxNode
		{
		public:
			RefPtr<ImportSyntaxNode> Import;
			virtual RefPtr<SyntaxNode> Accept(SyntaxVisitor * visitor) override;
			virtual ImportStatementSyntaxNode * Clone(CloneContext & ctx) override;
		};

		class IfStatementSyntaxNode : public StatementSyntaxNode
		{
		public:
			RefPtr<ExpressionSyntaxNode> Predicate;
			RefPtr<StatementSyntaxNode> PositiveStatement;
			RefPtr<StatementSyntaxNode> NegativeStatement;
			virtual RefPtr<SyntaxNode> Accept(SyntaxVisitor * visitor) override;
			virtual IfStatementSyntaxNode * Clone(CloneContext & ctx) override;
		};

		class ForStatementSyntaxNode : public StatementSyntaxNode
		{
		public:
			RefPtr<TypeSyntaxNode> TypeDef;
			RefPtr<ExpressionType> IterationVariableType;
			Token IterationVariable;

			RefPtr<ExpressionSyntaxNode> InitialExpression, SideEffectExpression, PredicateExpression;
			RefPtr<StatementSyntaxNode> Statement;
			virtual RefPtr<SyntaxNode> Accept(SyntaxVisitor * visitor) override;
			virtual ForStatementSyntaxNode * Clone(CloneContext & ctx) override;
		};

		class WhileStatementSyntaxNode : public StatementSyntaxNode
		{
		public:
			RefPtr<ExpressionSyntaxNode> Predicate;
			RefPtr<StatementSyntaxNode> Statement;
			virtual RefPtr<SyntaxNode> Accept(SyntaxVisitor * visitor) override;
			virtual WhileStatementSyntaxNode * Clone(CloneContext & ctx) override;
		};

		class DoWhileStatementSyntaxNode : public StatementSyntaxNode
		{
		public:
			RefPtr<StatementSyntaxNode> Statement;
			RefPtr<ExpressionSyntaxNode> Predicate;
			virtual RefPtr<SyntaxNode> Accept(SyntaxVisitor * visitor) override;
			virtual DoWhileStatementSyntaxNode * Clone(CloneContext & ctx) override;
		};

		class BreakStatementSyntaxNode : public StatementSyntaxNode
		{
		public:
			virtual RefPtr<SyntaxNode> Accept(SyntaxVisitor * visitor) override;
			virtual BreakStatementSyntaxNode * Clone(CloneContext & ctx) override;
		};

		class ContinueStatementSyntaxNode : public StatementSyntaxNode
		{
		public:
			virtual RefPtr<SyntaxNode> Accept(SyntaxVisitor * visitor) override;
			virtual ContinueStatementSyntaxNode * Clone(CloneContext & ctx) override;
		};

		class ReturnStatementSyntaxNode : public StatementSyntaxNode
		{
		public:
			RefPtr<ExpressionSyntaxNode> Expression;
			virtual RefPtr<SyntaxNode> Accept(SyntaxVisitor * visitor) override;
			virtual ReturnStatementSyntaxNode * Clone(CloneContext & ctx) override;
		};

		class ExpressionStatementSyntaxNode : public StatementSyntaxNode
		{
		public:
			RefPtr<ExpressionSyntaxNode> Expression;
			virtual RefPtr<SyntaxNode> Accept(SyntaxVisitor * visitor) override;
			virtual ExpressionStatementSyntaxNode * Clone(CloneContext & ctx) override;
		};

		class SyntaxVisitor : public Object
		{
		protected:
			ErrorWriter * err = nullptr;
			void Error(int id, const String & text, SyntaxNode * node)
			{
				err->Error(id, text, node->Position);
			}
			void Error(int id, const String & text, Token node)
			{
				err->Error(id, text, node.Position);
			}
			void Warning(int id, const String & text, SyntaxNode * node)
			{
				err->Warning(id, text, node->Position);
			}
			void Warning(int id, const String & text, Token node)
			{
				err->Warning(id, text, node.Position);
			}
		public:
			SyntaxVisitor(ErrorWriter * pErr)
				: err(pErr)
			{}
			virtual RefPtr<ProgramSyntaxNode> VisitProgram(ProgramSyntaxNode* program)
			{
				for (auto & f : program->Functions)
					f = f->Accept(this).As<FunctionSyntaxNode>();
				for (auto & shader : program->Shaders)
					shader = shader->Accept(this).As<ShaderSyntaxNode>();
				return program;
			}
			virtual RefPtr<ShaderSyntaxNode> VisitShader(ShaderSyntaxNode * shader)
			{
				for (auto & comp : shader->Members)
					comp = comp->Accept(this).As<ShaderMemberNode>();
				return shader;
			}
			virtual RefPtr<ComponentSyntaxNode> VisitComponent(ComponentSyntaxNode * comp);
			virtual RefPtr<FunctionSyntaxNode> VisitFunction(FunctionSyntaxNode* func)
			{
				func->ReturnTypeNode = func->ReturnTypeNode->Accept(this).As<TypeSyntaxNode>();
				for (auto & param : func->Parameters)
					param = param->Accept(this).As<ParameterSyntaxNode>();
				if (func->Body)
					func->Body = func->Body->Accept(this).As<BlockStatementSyntaxNode>();
				return func;
			}
			virtual RefPtr<StructSyntaxNode> VisitStruct(StructSyntaxNode * s)
			{
				for (auto & f : s->Fields)
					f = f->Accept(this).As<StructField>();
				return s;
			}
			virtual RefPtr<StatementSyntaxNode> VisitDiscardStatement(DiscardStatementSyntaxNode * stmt)
			{
				return stmt;
			}
			virtual RefPtr<StructField> VisitStructField(StructField * f)
			{
				f->TypeNode = f->TypeNode->Accept(this).As<TypeSyntaxNode>();
				return f;
			}
			virtual RefPtr<StatementSyntaxNode> VisitBlockStatement(BlockStatementSyntaxNode* stmt)
			{
				for (auto & s : stmt->Statements)
					s = s->Accept(this).As<StatementSyntaxNode>();
				return stmt;
			}
			virtual RefPtr<StatementSyntaxNode> VisitBreakStatement(BreakStatementSyntaxNode* stmt)
			{
				return stmt;
			}
			virtual RefPtr<StatementSyntaxNode> VisitContinueStatement(ContinueStatementSyntaxNode* stmt)
			{
				return stmt;
			}

			virtual RefPtr<StatementSyntaxNode> VisitDoWhileStatement(DoWhileStatementSyntaxNode* stmt)
			{
				if (stmt->Predicate)
					stmt->Predicate = stmt->Predicate->Accept(this).As<ExpressionSyntaxNode>();
				if (stmt->Statement)
					stmt->Statement = stmt->Statement->Accept(this).As<StatementSyntaxNode>();
				return stmt;
			}
			virtual RefPtr<StatementSyntaxNode> VisitEmptyStatement(EmptyStatementSyntaxNode* stmt)
			{
				return stmt;
			}
			virtual RefPtr<StatementSyntaxNode> VisitForStatement(ForStatementSyntaxNode* stmt)
			{
				if (stmt->InitialExpression)
					stmt->InitialExpression = stmt->InitialExpression->Accept(this).As<ExpressionSyntaxNode>();
				if (stmt->PredicateExpression)
					stmt->PredicateExpression = stmt->PredicateExpression->Accept(this).As<ExpressionSyntaxNode>();
				if (stmt->SideEffectExpression)
					stmt->SideEffectExpression = stmt->SideEffectExpression->Accept(this).As<ExpressionSyntaxNode>();
				if (stmt->Statement)
					stmt->Statement = stmt->Statement->Accept(this).As<StatementSyntaxNode>();
				return stmt;
			}
			virtual RefPtr<StatementSyntaxNode> VisitIfStatement(IfStatementSyntaxNode* stmt)
			{
				if (stmt->Predicate)
					stmt->Predicate = stmt->Predicate->Accept(this).As<ExpressionSyntaxNode>();
				if (stmt->PositiveStatement)
					stmt->PositiveStatement = stmt->PositiveStatement->Accept(this).As<StatementSyntaxNode>();
				if (stmt->NegativeStatement)
					stmt->NegativeStatement = stmt->NegativeStatement->Accept(this).As<StatementSyntaxNode>();
				return stmt;
			}
			virtual RefPtr<StatementSyntaxNode> VisitReturnStatement(ReturnStatementSyntaxNode* stmt)
			{
				if (stmt->Expression)
					stmt->Expression = stmt->Expression->Accept(this).As<ExpressionSyntaxNode>();
				return stmt;
			}
			virtual RefPtr<StatementSyntaxNode> VisitVarDeclrStatement(VarDeclrStatementSyntaxNode* stmt)
			{
				for (auto & var : stmt->Variables)
					var = var->Accept(this).As<Variable>();
				return stmt;
			}
			virtual RefPtr<StatementSyntaxNode> VisitWhileStatement(WhileStatementSyntaxNode* stmt)
			{
				if (stmt->Predicate)
					stmt->Predicate = stmt->Predicate->Accept(this).As<ExpressionSyntaxNode>();
				if (stmt->Statement)
					stmt->Statement = stmt->Statement->Accept(this).As<StatementSyntaxNode>();
				return stmt;
			}
			virtual RefPtr<StatementSyntaxNode> VisitExpressionStatement(ExpressionStatementSyntaxNode* stmt)
			{
				if (stmt->Expression)
					stmt->Expression = stmt->Expression->Accept(this).As<ExpressionSyntaxNode>();
				return stmt;
			}

			virtual RefPtr<ExpressionSyntaxNode> VisitBinaryExpression(BinaryExpressionSyntaxNode* expr)
			{
				if (expr->LeftExpression)
					expr->LeftExpression = expr->LeftExpression->Accept(this).As<ExpressionSyntaxNode>();
				if (expr->RightExpression)
					expr->RightExpression = expr->RightExpression->Accept(this).As<ExpressionSyntaxNode>();
				return expr;
			}
			virtual RefPtr<ExpressionSyntaxNode> VisitConstantExpression(ConstantExpressionSyntaxNode* expr)
			{
				return expr;
			}
			virtual RefPtr<ExpressionSyntaxNode> VisitIndexExpression(IndexExpressionSyntaxNode* expr)
			{
				if (expr->BaseExpression)
					expr->BaseExpression = expr->BaseExpression->Accept(this).As<ExpressionSyntaxNode>();
				if (expr->IndexExpression)
					expr->IndexExpression = expr->IndexExpression->Accept(this).As<ExpressionSyntaxNode>();
				return expr;
			}
			virtual RefPtr<ExpressionSyntaxNode> VisitMemberExpression(MemberExpressionSyntaxNode * stmt)
			{
				if (stmt->BaseExpression)
					stmt->BaseExpression = stmt->BaseExpression->Accept(this).As<ExpressionSyntaxNode>();
				return stmt;
			}
			virtual RefPtr<ExpressionSyntaxNode> VisitInvokeExpression(InvokeExpressionSyntaxNode* stmt)
			{
				stmt->FunctionExpr->Accept(this);
				for (auto & arg : stmt->Arguments)
					arg = arg->Accept(this).As<ExpressionSyntaxNode>();
				return stmt;
			}
			virtual RefPtr<ExpressionSyntaxNode> VisitImportExpression(ImportExpressionSyntaxNode * expr)
			{
				for (auto & arg : expr->Arguments)
					arg = arg->Accept(this).As<ExpressionSyntaxNode>();
				return expr;
			}
			virtual RefPtr<ExpressionSyntaxNode> VisitTypeCastExpression(TypeCastExpressionSyntaxNode * stmt)
			{
				if (stmt->Expression)
					stmt->Expression = stmt->Expression->Accept(this).As<ExpressionSyntaxNode>();
				return stmt->Expression;
			}
			virtual RefPtr<ExpressionSyntaxNode> VisitSelectExpression(SelectExpressionSyntaxNode * expr)
			{
				if (expr->SelectorExpr)
					expr->SelectorExpr = expr->SelectorExpr->Accept(this).As<ExpressionSyntaxNode>();
				if (expr->Expr0)
					expr->Expr0 = expr->Expr0->Accept(this).As<ExpressionSyntaxNode>();
				if (expr->Expr1)
					expr->Expr1 = expr->Expr1->Accept(this).As<ExpressionSyntaxNode>();
				return expr;
			}
			virtual RefPtr<ExpressionSyntaxNode> VisitUnaryExpression(UnaryExpressionSyntaxNode* expr)
			{
				if (expr->Expression)
					expr->Expression = expr->Expression->Accept(this).As<ExpressionSyntaxNode>();
				return expr;
			}
			virtual RefPtr<ExpressionSyntaxNode> VisitVarExpression(VarExpressionSyntaxNode* expr)
			{
				return expr;
			}
			virtual RefPtr<PipelineSyntaxNode> VisitPipeline(PipelineSyntaxNode * pipe)
			{
				for (auto & comp : pipe->AbstractComponents)
					comp = comp->Accept(this).As<ComponentSyntaxNode>();
				for (auto & imp : pipe->ImportOperators)
					imp = imp->Accept(this).As<ImportOperatorDefSyntaxNode>();
				return pipe;
			}
			virtual RefPtr<ImportOperatorDefSyntaxNode> VisitImportOperatorDef(ImportOperatorDefSyntaxNode * imp)
			{
				imp->Body = imp->Body->Accept(this).As<BlockStatementSyntaxNode>();
				return imp;
			}
			virtual RefPtr<ParameterSyntaxNode> VisitParameter(ParameterSyntaxNode* param)
			{
				return param;
			}
			virtual RefPtr<TypeSyntaxNode> VisitBasicType(BasicTypeSyntaxNode* type)
			{
				return type;
			}
			virtual RefPtr<TypeSyntaxNode> VisitArrayType(ArrayTypeSyntaxNode* type)
			{
				return type;
			}
			virtual RefPtr<TypeSyntaxNode> VisitGenericType(GenericTypeSyntaxNode* type)
			{
				return type;
			}

			virtual RefPtr<Variable> VisitDeclrVariable(Variable* dclr)
			{
				if (dclr->Expression)
					dclr->Expression = dclr->Expression->Accept(this).As<ExpressionSyntaxNode>();
				return dclr;
			}
			virtual RefPtr<ImportSyntaxNode> VisitImport(ImportSyntaxNode* imp)
			{
				for (auto & arg : imp->Arguments)
					if (arg->Expression)
						arg->Expression = arg->Expression->Accept(this).As<ExpressionSyntaxNode>();
				return imp;
			}
			virtual RefPtr<StatementSyntaxNode> VisitImportStatement(ImportStatementSyntaxNode* stmt)
			{
				if (stmt->Import)
					stmt->Import = stmt->Import->Accept(this).As<ImportSyntaxNode>();
				return stmt;
			}
			virtual RefPtr<ImportArgumentSyntaxNode> VisitImportArgument(ImportArgumentSyntaxNode * arg)
			{
				if (arg->Expression)
					arg->Expression = arg->Expression->Accept(this).As<ExpressionSyntaxNode>();
				return arg;
			}

		};
	}
}

#endif

/***********************************************************************
SPIRECORE\COMPILEDPROGRAM.H
***********************************************************************/
#ifndef BAKER_SL_COMPILED_PROGRAM_H
#define BAKER_SL_COMPILED_PROGRAM_H


namespace Spire
{
	namespace Compiler
	{
		class ConstantPoolImpl;

		class ConstantPool
		{
		private:
			ConstantPoolImpl * impl;
		public:
			ILConstOperand * CreateConstant(ILConstOperand * c);
			ILConstOperand * CreateConstantIntVec(int val0, int val1);
			ILConstOperand * CreateConstantIntVec(int val0, int val1, int val2);
			ILConstOperand * CreateConstantIntVec(int val0, int val1, int val3, int val4);
			ILConstOperand * CreateConstant(int val, int vectorSize = 0);
			ILConstOperand * CreateConstant(float val, int vectorSize = 0);
			ILConstOperand * CreateConstant(float val, float val1);
			ILConstOperand * CreateConstant(float val, float val1, float val2);
			ILConstOperand * CreateConstant(float val, float val1, float val2, float val3);
			ILConstOperand * CreateConstant(bool b);
			ILOperand * CreateDefaultValue(ILType * type);
			ILUndefinedOperand * GetUndefinedOperand();
			ConstantPool();
			~ConstantPool();
		};

		class ILShader;

		class ILWorld : public Object
		{
		public:
			String Name;
			CodePosition Position;
			RefPtr<ILRecordType> OutputType;
			List<ILObjectDefinition> Inputs;
			RefPtr<CFGNode> Code;
			EnumerableDictionary<String, ILOperand*> Components;
			bool IsAbstract = false;
			EnumerableDictionary<String, String> Attributes;
			EnumerableHashSet<String> ReferencedFunctions; // internal names of referenced functions
			ILShader * Shader = nullptr;
		};

		class StageAttribute
		{
		public:
			String Name;
			String Value;
			CodePosition Position;
		};

		class ILStage : public Object
		{
		public:
			CodePosition Position;
			String Name;
			String StageType;
			EnumerableDictionary<String, StageAttribute> Attributes;
		};

		class ILShader
		{
		public:
			CodePosition Position;
			String Name;
			EnumerableDictionary<String, RefPtr<ILWorld>> Worlds;
			EnumerableDictionary<String, RefPtr<ILStage>> Stages;
		};

		class ILFunction
		{
		public:
			EnumerableDictionary<String, RefPtr<ILType>> Parameters;
			RefPtr<ILType> ReturnType;
			RefPtr<CFGNode> Code;
			String Name;
		};

		class ILProgram
		{
		public:
			RefPtr<ConstantPool> ConstantPool = new Compiler::ConstantPool();
			List<RefPtr<ILShader>> Shaders;
			EnumerableDictionary<String, RefPtr<ILFunction>> Functions;
			List<RefPtr<ILStructType>> Structs;
		};

		class ShaderChoiceValue
		{
		public:
			String WorldName, AlternateName;
			ShaderChoiceValue() = default;
			ShaderChoiceValue(String world, String alt)
			{
				WorldName = world;
				AlternateName = alt;
			}
			static ShaderChoiceValue Parse(String str);
			String ToString()
			{
				if (AlternateName.Length() == 0)
					return WorldName;
				else
					return WorldName + L":" + AlternateName;
			}
			bool operator == (const ShaderChoiceValue & val)
			{
				return WorldName == val.WorldName && AlternateName == val.AlternateName;
			}
			bool operator != (const ShaderChoiceValue & val)
			{
				return WorldName != val.WorldName || AlternateName != val.AlternateName;
			}
			int GetHashCode()
			{
				return WorldName.GetHashCode() ^ AlternateName.GetHashCode();
			}
		};

		class ShaderChoice
		{
		public:
			String ChoiceName;
			String DefaultValue;
			List<ShaderChoiceValue> Options;
		};


		class InterfaceMetaData
		{
		public:
			CoreLib::Basic::String Name;
			RefPtr<Spire::Compiler::ILType> Type;
			EnumerableDictionary<String, String> Attributes;

			int GetHashCode()
			{
				return Name.GetHashCode();
			}
			bool operator == (const InterfaceMetaData & other)
			{
				return Name == other.Name;
			}
		};

		class StageMetaData
		{
		public:
			CoreLib::Basic::String Name;
			CoreLib::Basic::String TargetName;
			CoreLib::Basic::String OutputBlock;
			CoreLib::Basic::List<CoreLib::Basic::String> InputBlocks;
			CoreLib::Basic::List<CoreLib::Basic::String> Components;
		};

		class InterfaceBlockEntry : public InterfaceMetaData
		{
		public:
			int Offset = 0, Size = 0;
		};
		class InterfaceBlockMetaData
		{
		public:
			String Name;
			int Size = 0;
			EnumerableHashSet<InterfaceBlockEntry> Entries;
			EnumerableDictionary<String, String> Attributes;
			EnumerableHashSet<String> UserWorlds;
		};
		class ShaderMetaData
		{
		public:
			CoreLib::String ShaderName;
			CoreLib::EnumerableDictionary<CoreLib::String, StageMetaData> Stages;
			EnumerableDictionary<String, InterfaceBlockMetaData> InterfaceBlocks;
		};

		class StageSource
		{
		public:
			String MainCode;
			List<unsigned char> BinaryCode;
		};

		class CompiledShaderSource
		{
		public:
			EnumerableDictionary<String, StageSource> Stages;
			ShaderMetaData MetaData;
		};

		void IndentString(StringBuilder & sb, String src);

		class CompileResult
		{
		private:
			ErrorWriter errWriter;
		public:
			bool Success;
			List<CompileError> ErrorList, WarningList;
			String ScheduleFile;
			RefPtr<ILProgram> Program;
			List<ShaderChoice> Choices;
			EnumerableDictionary<String, CompiledShaderSource> CompiledSource; // shader -> stage -> code
			void PrintError(bool printWarning = false)
			{
				for (int i = 0; i < ErrorList.Count(); i++)
				{
					printf("%s(%d): error %d: %s\n", ErrorList[i].Position.FileName.ToMultiByteString(), ErrorList[i].Position.Line,
						ErrorList[i].ErrorID, ErrorList[i].Message.ToMultiByteString());
				}
				if (printWarning)
					for (int i = 0; i < WarningList.Count(); i++)
					{
						printf("%s(%d): warning %d: %s\n", WarningList[i].Position.FileName.ToMultiByteString(),
							WarningList[i].Position.Line, WarningList[i].ErrorID, WarningList[i].Message.ToMultiByteString());
					}
			}
			CompileResult()
				: errWriter(ErrorList, WarningList)
			{}
			ErrorWriter * GetErrorWriter()
			{
				return &errWriter;
			}
		};

	}
}

#endif

/***********************************************************************
SPIRECORE\VARIANTIR.H
***********************************************************************/
#ifndef VARIANT_IR_H
#define VARIANT_IR_H


namespace Spire
{
	namespace Compiler
	{
		class ShaderClosure;

		class ComponentDefinitionIR
		{
		private:
			EnumerableHashSet<ComponentDefinitionIR *> dependencyClosure;
		public:
			String OriginalName, UniqueName, UniqueKey;
			RefPtr<ComponentSyntaxNode> SyntaxNode;
			RefPtr<ExpressionType> Type;
			String World;
			bool IsEntryPoint = false;
			EnumerableHashSet<ComponentDefinitionIR *> Users, Dependency; // Bidirectional dependency;
			EnumerableHashSet<ComponentDefinitionIR *> & GetComponentFunctionDependencyClosure();
			void ClearDependency()
			{
				Dependency.Clear();
				dependencyClosure.Clear();
			}
		};

		class ShaderIR
		{
		public:
			ShaderClosure * Shader;
			SymbolTable * SymbolTable;
			List<RefPtr<ComponentDefinitionIR>> Definitions;
			EnumerableDictionary<String, EnumerableDictionary<String, ComponentDefinitionIR*>> DefinitionsByComponent;
			void EliminateDeadCode(); // returns remaining definitions in reverse dependency order
			void ResolveComponentReference(); // resolve reference and build dependency map
			List<String> GetComponentDependencyOrder(); // returns a list of all components' unique names in dependency order
			template<typename ShouldRemoveFunc>
			void RemoveDefinitions(const ShouldRemoveFunc &shouldRemove)
			{
				List<RefPtr<ComponentDefinitionIR>> newDefinitions;
				for (auto & def : Definitions)
				{
					if (!shouldRemove(def.Ptr()))
					{
						newDefinitions.Add(def);
					}
				}
				Definitions = _Move(newDefinitions);
				for (auto & kv : DefinitionsByComponent)
				{
					for (auto & def : kv.Value)
						if (shouldRemove(def.Value))
							kv.Value.Remove(def.Key);
				}
			}

		};
	}
}

#endif

/***********************************************************************
SPIRECORE\SYMBOLTABLE.H
***********************************************************************/
#ifndef RASTER_RENDERER_SYMBOL_TABLE_H
#define RASTER_RENDERER_SYMBOL_TABLE_H


namespace Spire
{
	namespace Compiler
	{
		
		class FunctionSymbol
		{
		public:
			bool IsReferencedFunctionsTransitiveClosureEvaluated = false;

			FunctionSyntaxNode * SyntaxNode;
			EnumerableHashSet<String> ReferencedFunctions;
		};
		class ShaderComponentSymbol;
		class ShaderComponentImplSymbol : public Object
		{
		public:
			String AlternateName;
			EnumerableHashSet<String> Worlds, ExportWorlds, SrcPinnedWorlds;
			RefPtr<ComponentSyntaxNode> SyntaxNode;
			EnumerableDictionary<ShaderComponentSymbol *, EnumerableHashSet<RefPtr<ImportExpressionSyntaxNode>>> DependentComponents; // key: dependent components, value: set of import expression nodes (null means implicit reference)
			EnumerableDictionary<ShaderComponentSymbol *, CodePosition> ComponentReferencePositions;
			ShaderComponentImplSymbol() = default;
			ShaderComponentImplSymbol(const ShaderComponentImplSymbol & other)
			{
				AlternateName = other.AlternateName;
				Worlds = other.Worlds;
				ExportWorlds = other.ExportWorlds;
				SrcPinnedWorlds = other.SrcPinnedWorlds;
				CloneContext ctx;
				SyntaxNode = other.SyntaxNode->Clone(ctx);
			}
		};

		class ShaderComponentSymbol : public Object
		{
		public:
			bool IsDceEntryPoint = false;
			String Name, UniqueName, UniqueKey;
			List<String> ChoiceNames;
			EnumerableDictionary<ShaderComponentSymbol *, EnumerableHashSet<RefPtr<ImportExpressionSyntaxNode>>> DependentComponents;
			EnumerableHashSet<ShaderComponentSymbol *>UserComponents;
			List<RefPtr<ShaderComponentImplSymbol>> Implementations;
			RefPtr<Type> Type;
			bool IsParam()
			{
				for (auto & impl : Implementations)
					if (impl->SyntaxNode->IsParam)
						return true;
				return false;
			}
			ShaderComponentSymbol() = default;
			ShaderComponentSymbol(const ShaderComponentSymbol & other)
			{
				Type = new Spire::Compiler::Type(*other.Type);
				for (auto &impl : other.Implementations)
					this->Implementations.Add(new ShaderComponentImplSymbol(*impl));
				this->Name = other.Name;
			}
		};
		
		class WorldSymbol
		{
		public:
			bool IsAbstract = false;
			WorldSyntaxNode * SyntaxNode = nullptr;
		};

		class PipelineSymbol;
		class ShaderClosure;
		
		class ShaderSymbol;

		class ShaderUsing
		{
		public:
			ShaderSymbol * Shader;
			bool IsPublic;
		};

		class ShaderSymbol
		{
		public:
			bool IsAbstract = false;
			bool SemanticallyChecked = false;
			ShaderSyntaxNode * SyntaxNode = nullptr;
			PipelineSymbol * Pipeline = nullptr;

			// components that are functions, they are also listed in Components, index by original names
			EnumerableDictionary<String, List<RefPtr<ShaderComponentSymbol>>> FunctionComponents; 
			
			// all components in this shader, function components are indexed by their unique names
			EnumerableDictionary<String, RefPtr<ShaderComponentSymbol>> Components;

			List<ShaderComponentSymbol*> GetComponentDependencyOrder();
			EnumerableHashSet<ShaderSymbol*> DependentShaders;
			List<ShaderUsing> ShaderUsings;
			EnumerableDictionary<String, ShaderUsing> ShaderObjects;
			void SortComponents(List<ShaderComponentSymbol*> & comps);
			struct ComponentReference
			{
				ShaderComponentSymbol * Component = nullptr;
				bool IsAccessible = false;
			};
			ComponentReference ResolveComponentReference(String compName, bool topLevel = true);
		};

		class ShaderClosure : public Object
		{
		public:
			ShaderClosure * Parent = nullptr;
			CodePosition Position;
			PipelineSymbol * Pipeline = nullptr;
			bool IsInPlace = false;
			bool IsPublic = false;
			String Name;
			CodePosition UsingPosition;
			EnumerableDictionary<String, RefPtr<ShaderComponentSymbol>> RefMap;
			EnumerableDictionary<String, RefPtr<ShaderComponentSymbol>> Components;
			EnumerableDictionary<String, ShaderComponentSymbol *> AllComponents;
			EnumerableDictionary<String, RefPtr<ShaderClosure>> SubClosures;
			RefPtr<ShaderComponentSymbol> FindComponent(String name, bool findInPrivate = false, bool includeParams = true);
			RefPtr<ShaderClosure> FindClosure(String name);
			List<ShaderComponentSymbol*> GetDependencyOrder();
			RefPtr<ShaderIR> IR;
		};

		class ImportPath
		{
		public:
			class Node
			{
			public:
				String TargetWorld;
				ImportOperatorDefSyntaxNode * ImportOperator;
				Node() = default;
				Node(String world, ImportOperatorDefSyntaxNode * imp)
					: TargetWorld(world), ImportOperator(imp)
				{}
			};
			bool IsImplicitPath = true;
			EnumerableHashSet<FunctionSyntaxNode*> TypeRequirements;
			List<Node> Nodes;
		};

		class PipelineSymbol
		{
		private:
			List<String> WorldTopologyOrder;
			EnumerableDictionary<String, EnumerableDictionary<String, List<ImportPath>>> pathCache;
			List<ImportPath> FindPaths(String worldSrc, String worldDest);
		public:
			PipelineSyntaxNode * SyntaxNode;
			PipelineSymbol * ParentPipeline;
			EnumerableDictionary<String, List<RefPtr<ImportOperatorDefSyntaxNode>>> ImportOperators;
			// SourceWorld=>DestinationWorld=>ImportOperator
			EnumerableDictionary<String, EnumerableDictionary<String, List<RefPtr<ImportOperatorDefSyntaxNode>>>> ImportOperatorsByPath;
			EnumerableDictionary<String, RefPtr<ShaderComponentSymbol>> Components;
			EnumerableDictionary<String, List<RefPtr<ShaderComponentSymbol>>> FunctionComponents;
			EnumerableDictionary<String, EnumerableHashSet<String>> WorldDependency;
			EnumerableDictionary<String, WorldSymbol> Worlds;
			bool IsAbstractWorld(String world);
			bool IsChildOf(PipelineSymbol * parentPipeline);
			
			List<String> & GetWorldTopologyOrder();
			List<ImportPath> & GetPaths(String srcWorld, String destWorld);
			List<ImportOperatorDefSyntaxNode*> GetImportOperatorsFromSourceWorld(String worldSrc);
			void AddImportOperator(RefPtr<ImportOperatorDefSyntaxNode> op);
		};

		class CompileResult;

		class StructSymbol
		{
		public:
			String Name;
			RefPtr<StructSyntaxNode> SyntaxNode;
			RefPtr<ILStructType> Type;
		};

		class SymbolTable
		{
		private:
			bool CheckTypeRequirement(const ImportPath & p, RefPtr<ExpressionType> type);
		public:
			EnumerableDictionary<String, List<RefPtr<FunctionSymbol>>> FunctionOverloads; // indexed by original name
			EnumerableDictionary<String, RefPtr<FunctionSymbol>> Functions; // indexed by internal name
			EnumerableDictionary<String, RefPtr<ShaderSymbol>> Shaders;
			EnumerableDictionary<String, RefPtr<PipelineSymbol>> Pipelines;
			EnumerableDictionary<String, RefPtr<StructSymbol>> Structs;
			List<ShaderSymbol*> ShaderDependenceOrder;
			bool SortShaders(); // return true if success, return false if dependency is cyclic
			void EvalFunctionReferenceClosure();
			bool CheckComponentImplementationConsistency(ErrorWriter * err, ShaderComponentSymbol * comp, ShaderComponentImplSymbol * impl);

			bool IsWorldReachable(PipelineSymbol * pipe, EnumerableHashSet<String> & src, String targetWorld, RefPtr<ExpressionType> type);
			bool IsWorldReachable(PipelineSymbol * pipe, String src, String targetWorld, RefPtr<ExpressionType> type);
			bool IsWorldImplicitlyReachable(PipelineSymbol * pipe, EnumerableHashSet<String> & src, String targetWorld, RefPtr<ExpressionType> type);
			bool IsWorldImplicitlyReachable(PipelineSymbol * pipe, String src, String targetWorld, RefPtr<ExpressionType> type);
			List<ImportPath> FindImplicitImportOperatorChain(PipelineSymbol * pipe, String worldSrc, String worldDest, RefPtr<ExpressionType> type);
		};

		class UniqueIdGenerator
		{
		private:
			static int currentGUID;
		public:
			static void Clear();
			static int Next();
		};


		template<typename T, typename GetDependencyFunc>
		void DependencySort(List<T> & list, const GetDependencyFunc & getDep)
		{
			HashSet<T> allSymbols, addedSymbols;
			for (auto & comp : list)
				allSymbols.Add(comp);
			List<T> sorted;
			bool changed = true;
			while (changed)
			{
				changed = false;
				for (auto & comp : list)
				{
					if (!addedSymbols.Contains(comp))
					{
						bool isFirst = true;
						auto && dependency = getDep(comp);
						for (auto & dep : dependency)
							if (allSymbols.Contains(dep) && !addedSymbols.Contains(dep))
							{
								isFirst = false;
								break;
							}
						if (isFirst)
						{
							addedSymbols.Add(comp);
							sorted.Add(comp);
							changed = true;
						}
					}
				}
			}
			list = _Move(sorted);
		}

	}
}
#endif

/***********************************************************************
SPIRECORE\CODEGENBACKEND.H
***********************************************************************/
#ifndef CODE_GEN_BACKEND_H
#define CODE_GEN_BACKEND_H


namespace Spire
{
	namespace Compiler
	{		
		class CodeGenBackend : public CoreLib::Basic::Object
		{
		public:
			virtual CompiledShaderSource GenerateShader(CompileResult & result, SymbolTable * symbols, ILShader * shader, ErrorWriter * err) = 0;
		};

		CodeGenBackend * CreateGLSLCodeGen();
		CodeGenBackend * CreateHLSLCodeGen();
		CodeGenBackend * CreateSpirVCodeGen();
	}
}

#endif

/***********************************************************************
SPIRECORE\NAMING.H
***********************************************************************/
#ifndef SPIRE_NAMING_H
#define SPIRE_NAMING_H


namespace Spire
{
	namespace Compiler
	{
		CoreLib::String EscapeDoubleUnderscore(CoreLib::String str);
	}
}

#endif

/***********************************************************************
SPIRECORE\SHADERCOMPILER.H
***********************************************************************/
#ifndef RASTER_SHADER_COMPILER_H
#define RASTER_SHADER_COMPILER_H


namespace Spire
{
	namespace Compiler
	{
		class ILConstOperand;

		enum class CompilerMode
		{
			ProduceShader,
			GenerateChoice
		};

		enum class CodeGenTarget
		{
			GLSL, HLSL, SPIRV
		};

		class CompileOptions
		{
		public:
			CompilerMode Mode = CompilerMode::ProduceShader;
			CodeGenTarget Target = CodeGenTarget::GLSL;
			EnumerableDictionary<String, String> BackendArguments;
			String ScheduleSource, ScheduleFileName;
			String SymbolToCompile;
			List<String> SearchDirectories;
		};

		class CompileUnit
		{
		public:
			RefPtr<ProgramSyntaxNode> SyntaxNode;
		};

		class CompilationContext
		{
		public:
			SymbolTable Symbols;
			EnumerableDictionary<String, RefPtr<ShaderClosure>> ShaderClosures;
			RefPtr<ILProgram> Program;
		};

		class ShaderCompiler : public CoreLib::Basic::Object
		{
		public:
			virtual CompileUnit Parse(CompileResult & result, String source, String fileName) = 0;
			virtual void Compile(CompileResult & result, CompilationContext & context, List<CompileUnit> & units, const CompileOptions & options) = 0;
			void Compile(CompileResult & result, List<CompileUnit> & units, const CompileOptions & options)
			{
				CompilationContext context;
				Compile(result, context, units, options);
			}
		};

		ShaderCompiler * CreateShaderCompiler();
	}
}

#endif

/***********************************************************************
CORELIB\STREAM.H
***********************************************************************/
#ifndef CORE_LIB_STREAM_H
#define CORE_LIB_STREAM_H


namespace CoreLib
{
	namespace IO
	{
		using CoreLib::Basic::Exception;
		using CoreLib::Basic::String;
		using CoreLib::Basic::RefPtr;

		class IOException : public Exception
		{
		public:
			IOException()
			{}
			IOException(const String & message)
				: CoreLib::Basic::Exception(message)
			{
			}
		};

		class EndOfStreamException : public IOException
		{
		public:
			EndOfStreamException()
			{}
			EndOfStreamException(const String & message)
				: IOException(message)
			{
			}
		};

		enum class SeekOrigin
		{
			Start, End, Current
		};

		class Stream : public CoreLib::Basic::Object
		{
		public:
			virtual Int64 GetPosition()=0;
			virtual void Seek(SeekOrigin origin, Int64 offset)=0;
			virtual Int64 Read(void * buffer, Int64 length) = 0;
			virtual Int64 Write(const void * buffer, Int64 length) = 0;
			virtual bool IsEnd() = 0;
			virtual bool CanRead() = 0;
			virtual bool CanWrite() = 0;
			virtual void Close() = 0;
		};

		class BinaryReader
		{
		private:
			RefPtr<Stream> stream;
		public:
			BinaryReader(RefPtr<Stream> stream)
			{
				this->stream = stream;
			}
			Stream * GetStream()
			{
				return stream.Ptr();
			}
			void ReleaseStream()
			{
				stream.Release();
			}
			template<typename T>
			void Read(T * buffer, int count)
			{
				stream->Read(buffer, sizeof(T)*(Int64)count);
			}
			int ReadInt32()
			{
				int rs;
				stream->Read(&rs, sizeof(int));
				return rs;
			}
			short ReadInt16()
			{
				short rs;
				stream->Read(&rs, sizeof(short));
				return rs;
			}
			Int64 ReadInt64()
			{
				Int64 rs;
				stream->Read(&rs, sizeof(Int64));
				return rs;
			}
			float ReadFloat()
			{
				float rs;
				stream->Read(&rs, sizeof(float));
				return rs;
			}
			double ReadDouble()
			{
				double rs;
				stream->Read(&rs, sizeof(double));
				return rs;
			}
			char ReadChar()
			{
				char rs;
				stream->Read(&rs, sizeof(char));
				return rs;
			}
			String ReadString()
			{
				int len = ReadInt32();
				wchar_t * buffer = new wchar_t[len+1];
				try
				{
					stream->Read(buffer, sizeof(wchar_t)*len);
				}
				catch(IOException & e)
				{
					delete [] buffer;
					throw e;
				}
				buffer[len] = 0;
				return String::FromBuffer(buffer, len);
			}
		};

		class BinaryWriter
		{
		private:
			RefPtr<Stream> stream;
		public:
			BinaryWriter(RefPtr<Stream> stream)
			{
				this->stream = stream;
			}
			Stream * GetStream()
			{
				return stream.Ptr();
			}
			template<typename T>
			void Write(const T& val)
			{
				stream->Write(&val, sizeof(T));
			}
			template<typename T>
			void Write(T * buffer, int count)
			{
				stream->Write(buffer, sizeof(T)*(Int64)count);
			}
			void Write(const String & str)
			{
				Write(str.Length());
				Write(str.Buffer(), str.Length());
			}
			void ReleaseStream()
			{
				stream.Release();
			}
			void Close()
			{
				stream->Close();
			}
		};

		enum class FileMode
		{
			Create, Open, CreateNew, Append
		};

		enum class FileAccess
		{
			Read = 1, Write = 2, ReadWrite = 3
		};

		enum class FileShare
		{
			None, ReadOnly, WriteOnly, ReadWrite
		};

		class FileStream : public Stream
		{
		private:
			FILE * handle;
			FileAccess fileAccess;
			bool endReached = false;
			void Init(const CoreLib::Basic::String & fileName, FileMode fileMode, FileAccess access, FileShare share);
		public:
			FileStream(const CoreLib::Basic::String & fileName, FileMode fileMode = FileMode::Open);
			FileStream(const CoreLib::Basic::String & fileName, FileMode fileMode, FileAccess access, FileShare share);
			~FileStream();
		public:
			virtual Int64 GetPosition();
			virtual void Seek(SeekOrigin origin, Int64 offset);
			virtual Int64 Read(void * buffer, Int64 length);
			virtual Int64 Write(const void * buffer, Int64 length);
			virtual bool CanRead();
			virtual bool CanWrite();
			virtual void Close();
			virtual bool IsEnd();
		};
	}
}

#endif

/***********************************************************************
CORELIB\TEXTIO.H
***********************************************************************/
#ifndef CORE_LIB_TEXT_IO_H
#define CORE_LIB_TEXT_IO_H


namespace CoreLib
{
	namespace IO
	{
		using CoreLib::Basic::List;
		using CoreLib::Basic::_EndLine;

		class TextReader : public CoreLib::Basic::Object
		{
		private:
			wchar_t lookAhead = 0;
			bool hasLookAhead = false;
		protected:
			virtual wchar_t ReadChar() = 0;
		public:
			~TextReader()
			{
				Close();
			}
			virtual void Close(){}
			virtual String ReadLine()=0;
			virtual String ReadToEnd()=0;
			virtual bool IsEnd() = 0;
			int Read(wchar_t * buffer, int count);
			wchar_t Read()
			{
				if (!hasLookAhead)
					return ReadChar();
				else
				{
					hasLookAhead = false;
					return lookAhead;
				}
			}
			wchar_t Peak()
			{
				if (hasLookAhead)
					return lookAhead;
				lookAhead = Read();
				hasLookAhead = true;
				return lookAhead;
			}
		};

		class TextWriter : public CoreLib::Basic::Object
		{
		public:
			~TextWriter()
			{
				Close();
			}
			virtual void Write(const String & str)=0;
			virtual void Write(const wchar_t * str)=0;
			virtual void Write(const char * str)=0;
			virtual void Close(){}
			template<typename T>
			TextWriter & operator << (const T& val)
			{
				Write(val.ToString());
				return *this;
			}
			TextWriter & operator << (wchar_t value)
			{
				Write(String(value));
				return *this;
			}
			TextWriter & operator << (int value)
			{
				Write(String(value));
				return *this;
			}
			TextWriter & operator << (float value)
			{
				Write(String(value));
				return *this;
			}
			TextWriter & operator << (double value)
			{
				Write(String(value));
				return *this;
			}
			TextWriter & operator << (const char* value)
			{
				Write(value);
				return *this;
			}
			TextWriter & operator << (const wchar_t * const val)
			{
				Write(val);
				return *this;
			}
			TextWriter & operator << (wchar_t * const val)
			{
				Write(val);
				return *this;
			}
			TextWriter & operator << (const String & val)
			{
				Write(val);
				return *this;
			}
			TextWriter & operator << (const _EndLine &)
			{
#ifdef _WIN32
				Write(L"\r\n");
#else
				Write(L"\n");
#endif
				return *this;
			}
		};

		class Encoding
		{
		public:
			static Encoding * UTF8, * Ansi, * UTF16, *UTF16Reversed;
			virtual void GetBytes(List<char> & buffer, const String & str)=0;
			virtual ~Encoding()
			{}
		};

		class StreamWriter : public TextWriter
		{
		private:
			List<char> encodingBuffer;
			RefPtr<Stream> stream;
			Encoding * encoding;
		public:
			StreamWriter(const String & path, Encoding * encoding = Encoding::UTF8);
			StreamWriter(RefPtr<Stream> stream, Encoding * encoding = Encoding::UTF8);
			virtual void Write(const String & str);
			virtual void Write(const wchar_t * str);
			virtual void Write(const char * str);
			virtual void Close()
			{
				stream->Close();
			}
		};

		class StreamReader : public TextReader
		{
		private:
			wchar_t lowSurrogate = 0;
			bool hasLowSurrogate = false;
			RefPtr<Stream> stream;
			List<char> buffer;
			Encoding * encoding;
			int ptr;
			char ReadBufferChar();
			void ReadBuffer();
			template<typename GetFunc>
			wchar_t GetChar(GetFunc get)
			{
				wchar_t decoded = 0;
				if (encoding == Encoding::UTF8)
				{
					if (hasLowSurrogate)
					{
						hasLowSurrogate = false;
						return lowSurrogate;
					}
					int codePoint = 0;
					int leading = get(0);
					int mask = 0x80;
					int count = 0;
					while (leading & mask)
					{
						count++;
						mask >>= 1;
					}
					codePoint = (leading & (mask - 1));
					for (int i = 1; i <= count - 1; i++)
					{
						codePoint <<= 6;
						codePoint += (get(i) & 0x3F);
					}
#ifdef _WIN32
					if (codePoint <= 0xD7FF || (codePoint >= 0xE000 && codePoint <= 0xFFFF))
						return (wchar_t)codePoint;
					else
					{
						int sub = codePoint - 0x10000;
						int high = (sub >> 10) + 0xD800;
						int low = (sub & 0x3FF) + 0xDC00;
						hasLowSurrogate = true;
						lowSurrogate = (wchar_t)low;
						return (wchar_t)high;
					}
#else
					return (wchar_t)codePoint; // linux platforms use UTF32
#endif
				}
				else if (encoding == Encoding::UTF16)
				{
					decoded = get(0) + (get(1) << 8);
#ifndef _WIN32
					if (decoded >= 0xD800 && decoded <= 0xDBFF) // high surrogate detected
					{
						unsigned short lowSurrogate = get(2) + (get(3) << 8);
						decoded = ((decoded - 0xD800) << 10) + (lowSurrogate - 0xDC00);
					}
#endif
					return decoded;
				}
				else if (encoding == Encoding::UTF16Reversed)
				{
					decoded = (get(0) << 8) + get(1);
#ifndef _WIN32
					if (decoded >= 0xD800 && decoded <= 0xDBFF) // high surrogate detected
					{
						unsigned short lowSurrogate = (get(2) << 8) + get(3);
						decoded = ((decoded - 0xD800) << 10) + (lowSurrogate - 0xDC00);
					}
#endif
					return decoded;
				}
				else
				{
					return get(0);
				}
			}
			Encoding * DetermineEncoding();
		protected:
			virtual wchar_t ReadChar()
			{
				return GetChar([&](int) {return ReadBufferChar(); });
			}
		public:
			StreamReader(const String & path);
			StreamReader(RefPtr<Stream> stream, Encoding * encoding = nullptr);
			virtual String ReadLine();
			virtual String ReadToEnd();
			virtual bool IsEnd()
			{
				return ptr == buffer.Count() && stream->IsEnd();
			}
			virtual void Close()
			{
				stream->Close();
			}
		};
	}
}

#endif

/***********************************************************************
CORELIB\EVENTS.H
***********************************************************************/
#ifndef GX_EVENTS_H
#define GX_EVENTS_H

namespace CoreLib
{
	namespace Basic
	{
	/***************************************************************************

	Events.h

	Usage:

		class A
		{
		public:
			void EventHandler(int a)
			{
				cout<<endl<<"function of object handler invoked. a*a = ";
				cout<<a*a<<endl;
			}
		};

		class B
		{
		public:
			typedef gxEvent1<int> gxOnEvent;
		public:
			gxOnEvent OnEvent;
			void DoSomething()
			{
				OnEvent.Invoke(4);
			}
		};

		void FuncHandler()
		{
			cout<<"Function invoked."<<endl;
		}

		void main()
		{
			A a;
			B b;
			b.OnEvent.Bind(&a,&A::EventHandler);	
			b.OnEvent.Bind(FuncHandler);			
			b.DoSomething();
			b.OnEvent.Unbind(FuncHandler);			
			b.OnEvent.Unbind(&a,&A::EventHandler);
			b.DoSomething();                       
		}

	***************************************************************************/
		template <typename... Arguments>
		class Event
		{
		private:
			List<RefPtr<FuncPtr<void, Arguments... >>> Handlers;
			void Bind(FuncPtr<void, Arguments...> * fobj)
			{
				Handlers.Add(fobj);
			}
			void Unbind(FuncPtr<void, Arguments...> * fobj)
			{
				int id = -1;
				for (int i = 0; i < Handlers.Count(); i++)
				{
					if ((*Handlers[i]) == fobj)
					{
						id = i;
						break;
					}
				}
				if (id != -1)
				{
					Handlers[id] = 0;
					Handlers.Delete(id);				
				}
			}
		public:
			Event()
			{
			}
			Event(const Event & e)
			{
				operator=(e);
			}
			Event & operator = (const Event & e)
			{
				for (int i = 0; i < e.Handlers.Count(); i++)
					Handlers.Add(e.Handlers[i]->Clone());
				return *this;
			}
			template <typename Class>
			Event(Class * Owner, typename MemberFuncPtr<Class, void, Arguments...>::FuncType handler)
			{
				Bind(Owner, handler);
			}
			Event(typename CdeclFuncPtr<void, Arguments...>::FuncType f)
			{
				Bind(f);
			}
			template <typename TFunctor>
			Event(const TFunctor & func)
			{
				Bind(func);
			}
			template <typename Class>
			void Bind(Class * Owner, typename MemberFuncPtr<Class, void, Arguments...>::FuncType handler)
			{
				Handlers.Add(new MemberFuncPtr<Class, void, Arguments...>(Owner, handler));
			}
			template <typename Class>
			void Unbind(Class * Owner, typename MemberFuncPtr<Class, void, Arguments...>::FuncType handler)
			{
				MemberFuncPtr<Class, void, Arguments...> h(Owner, handler);
				Unbind(&h);
			}
			void Bind(typename CdeclFuncPtr<void, Arguments...>::FuncType f)
			{
				Bind(new CdeclFuncPtr<void, Arguments...>(f));
			}
			void Unbind(typename CdeclFuncPtr<void, Arguments...>::FuncType f)
			{
				CdeclFuncPtr<void, Arguments...> h(f);
				Unbind(&h);
			}
			template <typename TFunctor>
			void Bind(const TFunctor & func)
			{
				Handlers.Add(new LambdaFuncPtr<TFunctor, void, Arguments...>(func));
			}
			template <typename TFunctor>
			void Unbind(const TFunctor & func)
			{
				LambdaFuncPtr<TFunctor, void, Arguments...> h(func);
				Unbind(&h);
			}
			Event & operator += (typename CdeclFuncPtr<void, Arguments...>::FuncType f)
			{
				Bind(f);
				return *this;
			}
			Event & operator -= (typename CdeclFuncPtr<void, Arguments...>::FuncType f)
			{
				Unbind(f);
				return *this;
			}
			template <typename TFunctor>
			Event & operator += (const TFunctor & f)
			{
				Bind(f);
				return *this;
			}
			template <typename TFunctor>
			Event & operator -= (const TFunctor & f)
			{
				Unbind(f);
				return *this;
			}
			void Invoke(Arguments... params) const
			{
				for (int i = 0; i < Handlers.Count(); i++)
					Handlers[i]->operator()(params...);
			}
			void operator ()(Arguments... params) const
			{
				Invoke(params...);
			}
		};
	}
}

#endif

/***********************************************************************
SPIRECORE\CLIKECODEGEN.H
***********************************************************************/
// CLikeCodeGen.h
#ifndef SPIRE_C_LIKE_CODE_GEN_H
#define SPIRE_C_LIKE_CODE_GEN_H

//
// This file implements the shared logic for code generation in C-like
// languages, such as GLSL and HLSL.
//


namespace Spire
{
	namespace Compiler
	{
		using namespace CoreLib::Basic;

		ILRecordType * ExtractRecordType(ILType * type);
		String AddWorldNameSuffix(String name, String suffix);

		class CLikeCodeGen;

		class CodeGenContext
		{
		public:
			CLikeCodeGen * codeGen;
			HashSet<String> GeneratedDefinitions;
			Dictionary<String, String> SubstituteNames;
			Dictionary<ILOperand*, String> VarName;
			CompileResult * Result = nullptr;
			HashSet<String> UsedVarNames;
			int TextureBindingsAllocator = 0;
			StringBuilder Body, Header, GlobalHeader;
			List<ILType*> Arguments;
			String ReturnVarName;
			String GenerateCodeName(String name, String prefix)
			{
				StringBuilder nameBuilder;
				int startPos = 0;
				if (name.StartsWith(L"_sys_"))
					startPos = name.IndexOf(L'_', 5) + 1;
				nameBuilder << prefix;
				for (int i = startPos; i < name.Length(); i++)
				{
					if ((name[i] >= L'a' && name[i] <= L'z') || 
						(name[i] >= L'A' && name[i] <= L'Z') ||
						name[i] == L'_' || 
						(name[i] >= L'0' && name[i] <= L'9'))
					{
						nameBuilder << name[i];
					}
					else
						nameBuilder << L'_';
				}
				auto rs = nameBuilder.ToString();
				int i = 0;
				while (UsedVarNames.Contains(rs))
				{
					i++;
					rs = nameBuilder.ToString() + String(i);
				}
				UsedVarNames.Add(rs);

				return rs;
			}


			String DefineVariable(ILOperand * op);
		};

		class ExternComponentCodeGenInfo
		{
		public:
			enum class DataStructureType
			{
				StandardInput, UniformBuffer, ArrayBuffer, PackedBuffer, StorageBuffer, Texture, Patch
			};
			enum class SystemVarType
			{
				None, TessCoord, InvocationId, ThreadId, FragCoord, PatchVertexCount, PrimitiveId
			};
			DataStructureType DataStructure = DataStructureType::StandardInput;
			RefPtr<ILType> Type;
			SystemVarType SystemVar = SystemVarType::None;
			bool IsArray = false;
			int ArrayLength = 0;
			int Binding = -1;
		};

		class OutputStrategy : public Object
		{
		protected:
			CLikeCodeGen * codeGen = nullptr;
			ILWorld * world = nullptr;
		public:
			OutputStrategy(CLikeCodeGen * pCodeGen, ILWorld * pWorld)
			{
				codeGen = pCodeGen;
				world = pWorld;
			}

			virtual void DeclareOutput(CodeGenContext & ctx, ILStage * stage) = 0;
			virtual void ProcessExportInstruction(CodeGenContext & ctx, ExportInstruction * instr) = 0;
		};

		class CLikeCodeGen : public CodeGenBackend
		{
		protected:
			//ILWorld * currentWorld = nullptr;
			//ILRecordType * currentRecordType = nullptr;
			//bool exportWriteToPackedBuffer = false;
			CoreLib::Basic::RefPtr<OutputStrategy> outputStrategy;
			Dictionary<String, ExternComponentCodeGenInfo> extCompInfo;
			ImportInstruction * currentImportInstr = nullptr;
			bool useBindlessTexture = false;
			ErrorWriter * errWriter;

			virtual OutputStrategy * CreateStandardOutputStrategy(ILWorld * world, String layoutPrefix) = 0;
			virtual OutputStrategy * CreatePackedBufferOutputStrategy(ILWorld * world) = 0;
			virtual OutputStrategy * CreateArrayOutputStrategy(ILWorld * world, bool pIsPatch, int pArraySize, String arrayIndex) = 0;

			// Hooks for declaring an input record based on the storage mode used (uniform, SSBO, etc.)
			virtual void DeclareUniformBuffer(CodeGenContext & sb, const ILObjectDefinition & input, bool isVertexShader) = 0;
			virtual void DeclareStorageBuffer(CodeGenContext & sb, const ILObjectDefinition & input, bool isVertexShader) = 0;
			virtual void DeclareArrayBuffer(CodeGenContext & sb, const ILObjectDefinition & input, bool isVertexShader) = 0;
			virtual void DeclarePackedBuffer(CodeGenContext & sb, const ILObjectDefinition & input, bool isVertexShader) = 0;
			virtual void DeclareTextureInputRecord(CodeGenContext & sb, const ILObjectDefinition & input, bool isVertexShader) = 0;
			virtual void DeclareStandardInputRecord(CodeGenContext & sb, const ILObjectDefinition & input, bool isVertexShader) = 0;
			virtual void DeclarePatchInputRecord(CodeGenContext & sb, const ILObjectDefinition & input, bool isVertexShader) = 0;

			// Hooks for generating per-stage kernels
			virtual StageSource GenerateSingleWorldShader(ILProgram * program, ILShader * shader, ILStage * stage) = 0;
			virtual StageSource GenerateHullShader(ILProgram * program, ILShader * shader, ILStage * stage) = 0;

			// Print a reference to some entity that is input to a kernel
			virtual void PrintUniformBufferInputReference(StringBuilder& sb, String inputName, String componentName) = 0;
			virtual void PrintStorageBufferInputReference(StringBuilder& sb, String inputName, String componentName) = 0;
			virtual void PrintArrayBufferInputReference(StringBuilder& sb, String inputName, String componentName) = 0;
			virtual void PrintPackedBufferInputReference(StringBuilder& sb, String inputName, String componentName) = 0;
			virtual void PrintStandardInputReference(StringBuilder& sb, ILRecordType* recType, String inputName, String componentName) = 0;
			virtual void PrintPatchInputReference(StringBuilder& sb, ILRecordType* recType, String inputName, String componentName) = 0;
			virtual void PrintDefaultInputReference(StringBuilder& sb, ILRecordType* recType, String inputName, String componentName) = 0;
			virtual void PrintSystemVarReference(StringBuilder& sb, String inputName, ExternComponentCodeGenInfo::SystemVarType systemVar) = 0;

			//
			virtual void PrintTypeName(StringBuilder& sb, ILType* type) = 0;
			virtual String RemapFuncNameForTarget(String name);
			virtual void PrintMatrixMulInstrExpr(CodeGenContext & ctx, ILOperand* op0, ILOperand* op1);
			virtual void PrintRasterPositionOutputWrite(CodeGenContext & ctx, ILOperand * operand) = 0;

		public:
			void Error(int errId, String msg, CodePosition pos);
			void PrintType(StringBuilder & sbCode, ILType* type);

			void PrintDef(StringBuilder & sbCode, ILType* type, const String & name);

			String GetFunctionCallName(String name);

			String GetFuncOriginalName(const String & name);

			void PrintOp(CodeGenContext & ctx, ILOperand * op, bool forceExpression = false);
			void PrintBinaryInstrExpr(CodeGenContext & ctx, BinaryInstruction * instr);
			void PrintBinaryInstr(CodeGenContext & ctx, BinaryInstruction * instr);
			void PrintUnaryInstrExpr(CodeGenContext & ctx, UnaryInstruction * instr);
			void PrintUnaryInstr(CodeGenContext & ctx, UnaryInstruction * instr);
			void PrintAllocVarInstrExpr(CodeGenContext & ctx, AllocVarInstruction * instr);
			void PrintAllocVarInstr(CodeGenContext & ctx, AllocVarInstruction * instr);
			void PrintFetchArgInstrExpr(CodeGenContext & ctx, FetchArgInstruction * instr);
			void PrintFetchArgInstr(CodeGenContext & ctx, FetchArgInstruction * instr);
			void PrintSelectInstrExpr(CodeGenContext & ctx, SelectInstruction * instr);
			void PrintSelectInstr(CodeGenContext & ctx, SelectInstruction * instr);
			void PrintCallInstrExpr(CodeGenContext & ctx, CallInstruction * instr);
			void PrintCallInstr(CodeGenContext & ctx, CallInstruction * instr);
			void PrintCastF2IInstrExpr(CodeGenContext & ctx, Float2IntInstruction * instr);
			void PrintCastF2IInstr(CodeGenContext & ctx, Float2IntInstruction * instr);
			void PrintCastI2FInstrExpr(CodeGenContext & ctx, Int2FloatInstruction * instr);
			void PrintCastI2FInstr(CodeGenContext & ctx, Int2FloatInstruction * instr);
			bool AppearAsExpression(ILInstruction & instr, bool force);
			void PrintExportInstr(CodeGenContext &ctx, ExportInstruction * exportInstr);
			void PrintUpdateInstr(CodeGenContext & ctx, MemberUpdateInstruction * instr);
			void PrintSwizzleInstrExpr(CodeGenContext & ctx, SwizzleInstruction * swizzle);
			void PrintImportInstr(CodeGenContext & ctx, ImportInstruction * importInstr);
			void PrintImportInstrExpr(CodeGenContext & ctx, ImportInstruction * importInstr);
			void PrintInstrExpr(CodeGenContext & ctx, ILInstruction & instr);
			void PrintInstr(CodeGenContext & ctx, ILInstruction & instr);
			void PrintLoadInputInstrExpr(CodeGenContext & ctx, LoadInputInstruction * instr);
			void GenerateCode(CodeGenContext & context, CFGNode * code);

		public:
			virtual CompiledShaderSource GenerateShader(CompileResult & result, SymbolTable *, ILShader * shader, ErrorWriter * err) override;
			void GenerateStructs(StringBuilder & sb, ILProgram * program);
			void GenerateReferencedFunctions(StringBuilder & sb, ILProgram * program, ArrayView<ILWorld*> worlds);
			ExternComponentCodeGenInfo ExtractExternComponentInfo(const ILObjectDefinition & input);
			void PrintInputReference(StringBuilder & sb, String input);
			void DeclareInput(CodeGenContext & sb, const ILObjectDefinition & input, bool isVertexShader);
			void GenerateVertexShaderEpilog(CodeGenContext & ctx, ILWorld * world, ILStage * stage);
			void GenerateDomainShaderProlog(CodeGenContext & ctx, ILStage * stage);

			StageSource GenerateVertexFragmentDomainShader(ILProgram * program, ILShader * shader, ILStage * stage);
			StageSource GenerateComputeShader(ILProgram * program, ILShader * shader, ILStage * stage);
			void GenerateFunctionDeclaration(StringBuilder & sbCode, ILFunction * function);
			String GenerateFunction(ILFunction * function);
		};
	}
}

#endif // SPIRE_C_LIKE_CODE_GEN_H

/***********************************************************************
SPIRECORE\CLOSURE.H
***********************************************************************/
#ifndef BAKERSL_SHADER_CLOSURE_H
#define BAKERSL_SHADER_CLOSURE_H

namespace Spire
{
	namespace Compiler
	{
		RefPtr<ShaderClosure> CreateShaderClosure(ErrorWriter * err, SymbolTable * symTable, ShaderSymbol * shader);
		void FlattenShaderClosure(ErrorWriter * err, SymbolTable * symTable, ShaderClosure * shader);
		void InsertImplicitImportOperators(ShaderIR * shader);
	}
}

#endif

/***********************************************************************
SPIRECORE\STRINGOBJECT.H
***********************************************************************/
#ifndef SPIRE_STRING_OBJECT_H
#define SPIRE_STRING_OBJECT_H


namespace Spire
{
	namespace Compiler
	{
		class StringObject : public CoreLib::Object
		{
		public:
			CoreLib::String Content;
			StringObject() {}
			StringObject(const CoreLib::String & str)
				: Content(str)
			{}
		};
	}
}

#endif

/***********************************************************************
SPIRECORE\SYNTAXVISITORS.H
***********************************************************************/
#ifndef RASTER_RENDERER_SYNTAX_PRINTER_H
#define RASTER_RENDERER_SYNTAX_PRINTER_H


namespace Spire
{
	namespace Compiler
	{
		class ShaderCompiler;
		class ShaderLinkInfo;
		class ShaderSymbol;

		class ICodeGenerator : public SyntaxVisitor
		{
		public:
			ICodeGenerator(ErrorWriter * perr)
				: SyntaxVisitor(perr)
			{}
			virtual void ProcessFunction(FunctionSyntaxNode * func) = 0;
			virtual void ProcessShader(ShaderIR * shader) = 0;
			virtual void ProcessStruct(StructSyntaxNode * st) = 0;
		};

		SyntaxVisitor * CreateSemanticsVisitor(SymbolTable * symbols, ErrorWriter * err);
		ICodeGenerator * CreateCodeGenerator(SymbolTable * symbols, CompileResult & result);
	}
}

#endif

/***********************************************************************
SPIRECORE\SCOPEDICTIONARY.H
***********************************************************************/
#ifndef RASTER_RENDERER_SCOPE_DICTIONARY_H
#define RASTER_RENDERER_SCOPE_DICTIONARY_H


using namespace CoreLib::Basic;

namespace Spire
{
	namespace Compiler
	{
		template <typename TKey, typename TValue>
		class ScopeDictionary
		{
		public:
			LinkedList<Dictionary<TKey, TValue>> dicts;
		public:
			void PushScope()
			{
				dicts.AddLast();
			}
			void PopScope()
			{
				dicts.Delete(dicts.LastNode());
			}
			bool TryGetValue(const TKey & key, TValue & value)
			{
				for (auto iter = dicts.LastNode(); iter; iter = iter->GetPrevious())
				{
					bool rs = iter->Value.TryGetValue(key, value);
					if (rs)
						return true;
				}
				return false;
			}
			bool TryGetValueInCurrentScope(const TKey & key, TValue & value)
			{
				return dicts.Last().TryGetValue(key, value);
			}
			void Add(const TKey & key, const TValue & value)
			{
				dicts.Last().Add(key, value);
			}
			void Set(const TKey & key, const TValue & value)
			{
				dicts.Last()[key] = value;
			}
		};
	}
}

#endif

/***********************************************************************
SPIRECORE\CODEWRITER.H
***********************************************************************/
#ifndef IL_CODE_WRITER_H
#define IL_CODE_WRITER_H


namespace Spire
{
	namespace Compiler
	{
		class CodeWriter
		{
		private:
			List<RefPtr<CFGNode>> cfgNode;
			ConstantPool * constantPool = nullptr;
		public:
			void SetConstantPool(ConstantPool * pool)
			{
				constantPool = pool;
			}
			CFGNode * GetCurrentNode()
			{
				return cfgNode.Last().Ptr();
			}
			void PushNode()
			{
				RefPtr<CFGNode> n = new CFGNode();
				cfgNode.Add(n);
			}
			RefPtr<CFGNode> PopNode()
			{
				auto rs = cfgNode.Last();
				cfgNode.SetSize(cfgNode.Count() - 1);
				return rs;
			}
			void Assign(ILType * type, ILOperand * dest, ILOperand * src) // handles base type and ILArrayType assignment
			{
				auto arrType = dynamic_cast<ILArrayType*>(type);
				if (arrType)
				{
					for (int i = 0; i < arrType->ArrayLength; i++)
					{
						auto srcAddr = Add(src, i);
						auto destAddr = Add(dest, i);
						Store(destAddr, Load(srcAddr));
					}
				}
				else
					Store(dest, Load(src));
			}
			ILOperand * Select(ILOperand * cond, ILOperand * v0, ILOperand * v1)
			{
				auto rs = new SelectInstruction(cond, v0, v1);
				cfgNode.Last()->InsertTail(rs);
				return rs;
			}
			ILOperand * BitAnd(ILOperand * v0, ILOperand * v1)
			{
				auto instr = new BitAndInstruction(v0, v1);
				cfgNode.Last()->InsertTail(instr);
				return instr;
			}
			ILOperand * BitAnd(ILOperand * v0, int c)
			{
				auto instr = new BitAndInstruction(v0, constantPool->CreateConstant(c));
				cfgNode.Last()->InsertTail(instr);
				return instr;
			}
			ILOperand * Add(ILOperand * v0, ILOperand * v1)
			{
				auto instr = new AddInstruction(v0, v1);
				cfgNode.Last()->InsertTail(instr);
				return instr;
			}
			ILOperand * Add(ILOperand * v0, int v1)
			{
				auto instr = new AddInstruction(v0, constantPool->CreateConstant(v1));
				cfgNode.Last()->InsertTail(instr);
				return instr;
			}
			ILOperand * Mul(ILOperand * v0, ILOperand * v1)
			{
				auto instr = new MulInstruction(v0, v1);
				cfgNode.Last()->InsertTail(instr);
				return instr;
			}
			ILOperand * Copy(ILOperand * src)
			{
				auto rs = new CopyInstruction(src);
				cfgNode.Last()->InsertTail(rs);
				return rs;
			}
			ILOperand * Load(ILOperand * src, int offset)
			{
				if (offset == 0)
				{
					auto instr = new LoadInstruction(src);
					cfgNode.Last()->InsertTail(instr);
					return instr;
				}
				else
				{
					auto dest = new AddInstruction(src, constantPool->CreateConstant(offset));
					cfgNode.Last()->InsertTail(dest);
					auto instr = new LoadInstruction(dest);
					cfgNode.Last()->InsertTail(instr);
					return instr;
				}
			}
			ILOperand * Load(ILOperand * src)
			{
				auto instr = new LoadInstruction(src);
				cfgNode.Last()->InsertTail(instr);
				return instr;
			}
			ILOperand * Load(ILOperand * src, ILOperand * offset)
			{
				auto dest = new AddInstruction(src, offset);
				cfgNode.Last()->InsertTail(dest);
				return Load(dest);
			}
			StoreInstruction * Store(ILOperand * dest, ILOperand * value)
			{
				auto instr = new StoreInstruction(dest, value);
				cfgNode.Last()->InsertTail(instr);
				return instr;
			}
			DiscardInstruction * Discard()
			{
				auto instr = new DiscardInstruction();
				cfgNode.Last()->InsertTail(instr);
				return instr;
			}
			MemberUpdateInstruction * Update(ILOperand * dest, ILOperand * offset, ILOperand * value)
			{
				auto instr = new MemberUpdateInstruction(dest, offset, value);
				cfgNode.Last()->InsertTail(instr);
				return instr;
			}
			MemberLoadInstruction * Retrieve(ILOperand * dest, ILOperand * offset)
			{
				auto instr = new MemberLoadInstruction(dest, offset);
				cfgNode.Last()->InsertTail(instr);
				return instr;
			}
			//AllocVarInstruction * AllocVar(ILType * type, ILOperand * size)
			//{
			//	auto arrType = dynamic_cast<ILArrayType*>(type);
			//	if (arrType)
			//	{
			//		// check: size must be constant 1. Do not support array of array in IL level.
			//		auto s = dynamic_cast<ILConstOperand*>(size);
			//		if (!s || s->IntValues[0] != 1)
			//			throw ArgumentException(L"AllocVar(arrayType, size): size must be constant 1.");
			//		auto instr = new AllocVarInstruction(arrType->BaseType, program.CreateConstant(arrType->ArrayLength));
			//		cfgNode->InsertTail(instr);
			//		return instr;
			//	}
			//	else
			//	{
			//		auto instr = new AllocVarInstruction(type, size);
			//		cfgNode->InsertTail(instr);
			//		return instr;
			//	}
			//}
			AllocVarInstruction * AllocVar(RefPtr<ILType> & type, ILOperand * size)
			{
				auto arrType = dynamic_cast<ILArrayType*>(type.Ptr());
				if (arrType)
				{
					// check: size must be constant 1. Do not support array of array in IL level.
					auto s = dynamic_cast<ILConstOperand*>(size);
					if (!s || s->IntValues[0] != 1)
						throw ArgumentException(L"AllocVar(arrayType, size): size must be constant 1.");
					auto instr = new AllocVarInstruction(arrType->BaseType, constantPool->CreateConstant(arrType->ArrayLength));
					cfgNode.Last()->InsertTail(instr);
					return instr;
				}
				else
				{
					auto instr = new AllocVarInstruction(type, size);
					cfgNode.Last()->InsertTail(instr);
					return instr;
				}
			}
			/*GLeaInstruction * GLea(ILType * type, const String & name)
			{
				auto arrType = dynamic_cast<ILArrayType*>(type);
				auto instr = new GLeaInstruction();
				if (arrType)
					instr->Type = new ILPointerType(arrType->BaseType);
				else
					instr->Type = new ILPointerType(type);
				instr->Name = name;
				instr->VariableName = name;
				cfgNode->InsertTail(instr);
				return instr;
			}*/
			FetchArgInstruction * FetchArg(RefPtr<ILType> type, int argId)
			{
				auto instr = new FetchArgInstruction(type);
				cfgNode.Last()->InsertTail(instr);
				instr->ArgId = argId;
				return instr;
			}
			
			void Insert(ILInstruction * instr)
			{
				cfgNode.Last()->InsertTail(instr);
			}
		};
	}
}

#endif

/***********************************************************************
SPIRECORE\TYPETRANSLATION.H
***********************************************************************/
#ifndef SPIRE_TYPE_TRANSLATION_H
#define SPIRE_TYPE_TRANSLATION_H


namespace Spire
{
	namespace Compiler
	{
		RefPtr<ILType> TranslateExpressionType(ExpressionType * type, Dictionary<String, RefPtr<ILRecordType>> * recordTypes = nullptr);
		RefPtr<ILType> TranslateExpressionType(const RefPtr<ExpressionType> & type, Dictionary<String, RefPtr<ILRecordType>> * recordTypes = nullptr);
	}
}

#endif

/***********************************************************************
CORELIB\LIBIO.H
***********************************************************************/
#ifndef CORE_LIB_IO_H
#define CORE_LIB_IO_H


namespace CoreLib
{
	namespace IO
	{
		class File
		{
		public:
			static bool Exists(const CoreLib::Basic::String & fileName);
			static CoreLib::Basic::String ReadAllText(const CoreLib::Basic::String & fileName);
			static void WriteAllText(const CoreLib::Basic::String & fileName, const CoreLib::Basic::String & text);
		};

		class Path
		{
		public:
#ifdef _WIN32
			static const wchar_t PathDelimiter = L'\\';
#else
			static const wchar_t PathDelimiter = L'/';
#endif
			static String TruncateExt(const String & path);
			static String ReplaceExt(const String & path, const wchar_t * newExt);
			static String GetFileName(const String & path);
			static String GetFileNameWithoutEXT(const String & path);
			static String GetFileExt(const String & path);
			static String GetDirectoryName(const String & path);
			static String Combine(const String & path1, const String & path2);
			static String Combine(const String & path1, const String & path2, const String & path3);
#ifdef CreateDirectory
#undef CreateDirectory
#endif
			static bool CreateDirectory(const String & path);
		};

		class CommandLineWriter : public Object
		{
		public:
			virtual void Write(const String & text) = 0;
		};

		void SetCommandLineWriter(CommandLineWriter * writer);

		extern CommandLineWriter * currentCommandWriter;
		template<typename ...Args>
		void uiprintf(const wchar_t * format, Args... args)
		{
			if (currentCommandWriter)
			{
				wchar_t buffer[1024];
				swprintf_s(buffer, format, args...);
				currentCommandWriter->Write(buffer);
			}
		}
	}
}

#endif

/***********************************************************************
SPIRECORE\PARSER.H
***********************************************************************/
#ifndef RASTER_RENDERER_PARSER_H
#define RASTER_RENDERER_PARSER_H


namespace Spire
{
	namespace Compiler
	{
		const int MaxExprLevel = 12;

		// TODO: implement two pass parsing for file reference and struct type recognition

		class Parser
		{
		private:
			int anonymousParamCounter = 0;
			int pos;
			List<RefPtr<Scope>> scopeStack;
			List<Token> & tokens;
			List<CompileError> & errors;
			String fileName;
			HashSet<String> typeNames;
			HashSet<String> classNames;
			void FillPosition(SyntaxNode * node)
			{
				int id = Math::Min(pos, tokens.Count() - 1);
				if (id >= 0)
				{
					node->Position = tokens[id].Position;
				}
				else
				{
					node->Position = CodePosition(0, 0, fileName);
				}
				node->Scope = scopeStack.Last();
			}
			void PushScope()
			{
				scopeStack.Add(new Scope());
				if (scopeStack.Count() > 1)
					scopeStack.Last()->Parent = scopeStack[scopeStack.Count() - 2].Ptr();
			}
			void PopScope()
			{
				scopeStack.Last() = 0;
				scopeStack.RemoveAt(scopeStack.Count() - 1);
			}
		public:
			Parser(List<Token> & _tokens, List<CompileError> & _errors, String _fileName)
				: pos(0), tokens(_tokens), errors(_errors), fileName(_fileName)
			{
				typeNames.Add(L"int");
				typeNames.Add(L"uint");
				typeNames.Add(L"bool");
				typeNames.Add(L"float");
				typeNames.Add(L"half");
				typeNames.Add(L"void");
				typeNames.Add(L"ivec2");
				typeNames.Add(L"ivec3");
				typeNames.Add(L"ivec4");
				typeNames.Add(L"uvec2");
				typeNames.Add(L"uvec3");
				typeNames.Add(L"uvec4");
				typeNames.Add(L"vec2");
				typeNames.Add(L"vec3");
				typeNames.Add(L"vec4");
				typeNames.Add(L"mat3");
				typeNames.Add(L"mat4");
				typeNames.Add(L"mat4x4");
				typeNames.Add(L"mat3x3");
				typeNames.Add(L"int2");
				typeNames.Add(L"int3");
				typeNames.Add(L"int4");
				typeNames.Add(L"uint2");
				typeNames.Add(L"uint3");
				typeNames.Add(L"uint4");
				typeNames.Add(L"float2");
				typeNames.Add(L"float3");
				typeNames.Add(L"float4");
				typeNames.Add(L"half2");
				typeNames.Add(L"half3");
				typeNames.Add(L"half4");
				typeNames.Add(L"float3x3");
				typeNames.Add(L"float4x4");
				typeNames.Add(L"half3x3");
				typeNames.Add(L"half4x4");
				typeNames.Add(L"Texture2D");
				typeNames.Add(L"sampler2D");
				typeNames.Add(L"sampler2DShadow");
				typeNames.Add(L"samplerCube");
				typeNames.Add(L"samplerCubeShadow");
				typeNames.Add(L"Texture");
				typeNames.Add(L"Uniform");
				typeNames.Add(L"ArrayBuffer");
				typeNames.Add(L"PackedBuffer");
				typeNames.Add(L"StorageBuffer");
				typeNames.Add(L"Patch");
			}
			RefPtr<ProgramSyntaxNode> Parse();
		private:
			Token & ReadToken();
			Token & ReadToken(TokenType type);
			Token & ReadToken(const wchar_t * string);
			bool LookAheadToken(TokenType type, int offset = 0);
			bool LookAheadToken(const wchar_t * string, int offset = 0);
			Token & ReadTypeKeyword();
			VariableModifier ReadVariableModifier();
			bool IsTypeKeyword();
			EnumerableDictionary<String, String>	ParseAttribute();
			RefPtr<ProgramSyntaxNode>				ParseProgram();
			RefPtr<ShaderSyntaxNode>				ParseShader();
			RefPtr<PipelineSyntaxNode>				ParsePipeline();
			RefPtr<StageSyntaxNode>					ParseStage();
			RefPtr<ComponentSyntaxNode>				ParseComponent();
			RefPtr<WorldSyntaxNode>					ParseWorld();
			RefPtr<RateSyntaxNode>					ParseRate();
			RefPtr<ImportSyntaxNode>				ParseImport();
			RefPtr<ImportStatementSyntaxNode>		ParseImportStatement();
			RefPtr<ImportOperatorDefSyntaxNode>		ParseImportOperator();
			RefPtr<FunctionSyntaxNode>				ParseFunction(bool parseBody = true);
			RefPtr<StructSyntaxNode>				ParseStruct();
			RefPtr<StatementSyntaxNode>				ParseStatement();
			RefPtr<BlockStatementSyntaxNode>		ParseBlockStatement();
			RefPtr<VarDeclrStatementSyntaxNode>		ParseVarDeclrStatement();
			RefPtr<IfStatementSyntaxNode>			ParseIfStatement();
			RefPtr<ForStatementSyntaxNode>			ParseForStatement();
			RefPtr<WhileStatementSyntaxNode>		ParseWhileStatement();
			RefPtr<DoWhileStatementSyntaxNode>		ParseDoWhileStatement();
			RefPtr<BreakStatementSyntaxNode>		ParseBreakStatement();
			RefPtr<ContinueStatementSyntaxNode>		ParseContinueStatement();
			RefPtr<ReturnStatementSyntaxNode>		ParseReturnStatement();
			RefPtr<ExpressionStatementSyntaxNode>	ParseExpressionStatement();
			RefPtr<ExpressionSyntaxNode>			ParseExpression(int level = 0);
			RefPtr<ExpressionSyntaxNode>			ParseLeafExpression();
			RefPtr<ParameterSyntaxNode>				ParseParameter();
			RefPtr<TypeSyntaxNode>					ParseType();

			Parser & operator = (const Parser &) = delete;
		};
		
	}
}

#endif

/***********************************************************************
SPIRECORE\SCHEDULE.H
***********************************************************************/
#ifndef BAKER_SL_SCHEDULE_H
#define BAKER_SL_SCHEDULE_H


namespace Spire
{
	namespace Compiler
	{
		class Schedule
		{
		public:
			CoreLib::EnumerableDictionary<CoreLib::String, CoreLib::List<RefPtr<ChoiceValueSyntaxNode>>> Choices;
			CoreLib::EnumerableDictionary<CoreLib::String, CoreLib::EnumerableDictionary<CoreLib::String, CoreLib::String>> AddtionalAttributes;
			static Schedule Parse(CoreLib::String source, CoreLib::String fileName, CoreLib::List<CompileError> & errorList);
		};
	}
}

#endif

/***********************************************************************
SPIRECORE\STDINCLUDE.H
***********************************************************************/
#ifndef SHADER_COMPILER_STD_LIB_H
#define SHADER_COMPILER_STD_LIB_H


namespace Spire
{
	namespace Compiler
	{
		class SpireStdLib
		{
		private:
			static CoreLib::String code;
		public:
			static CoreLib::String GetCode();
			static void Finalize();
		};
	}
}

#endif

/***********************************************************************
SPIRELIB\SPIRELIB.H
***********************************************************************/
#ifndef LIB_BAKER_SL_H
#define LIB_BAKER_SL_H


namespace SpireLib
{
	class ShaderLibFile : public CoreLib::Basic::Object
	{
	public:
		CoreLib::Basic::EnumerableDictionary<CoreLib::Basic::String, Spire::Compiler::StageSource> Sources; // indexed by world
		Spire::Compiler::ShaderMetaData MetaData;
		void AddSource(CoreLib::Basic::String source, CoreLib::Text::Parser & parser);
		void FromString(const CoreLib::String & str);
		CoreLib::String ToString();
		void SaveToFile(CoreLib::Basic::String fileName);
		ShaderLibFile() = default;
		void Clear();
		void Load(CoreLib::Basic::String fileName);
	};
	
	CoreLib::Basic::List<ShaderLibFile> CompileShaderSourceFromFile(Spire::Compiler::CompileResult & result,
		const CoreLib::Basic::String & sourceFileName,
		Spire::Compiler::CompileOptions &options);

	CoreLib::Basic::List<ShaderLibFile> CompileShaderSource(Spire::Compiler::CompileResult & result,
		const CoreLib::Basic::String &source, const CoreLib::Basic::String & sourceFileName, Spire::Compiler::CompileOptions &options);

	class ShaderLib : public ShaderLibFile
	{
	public:
		Spire::Compiler::StageSource GetStageSource(CoreLib::Basic::String world);
		ShaderLib() = default;
		ShaderLib(CoreLib::Basic::String fileName);
		void Reload(CoreLib::Basic::String fileName);
		bool CompileFrom(CoreLib::Basic::String symbolName, CoreLib::Basic::String sourceFileName, CoreLib::Basic::String schedule);
	};

}

#endif

/***********************************************************************
SPIRELIB\INCLUDE\SPIRE.H
***********************************************************************/
#ifndef SPIRE_H
#define SPIRE_H

#ifdef _MSC_VER
#ifdef SPIRE_COMPILING_DLL
#define SPIRE_API __declspec(dllexport)
#else
#ifdef SPIRE_DYNAMIC
#define SPIRE_API __declspec(dllimport)
#else
#define SPIRE_API
#endif
#endif
#else
#define SPIRE_API
#endif

#ifdef __cplusplus  
extern "C" {  // only need to export C interface if  
			  // used by C++ source code  
#endif  

			  /*!
			  @mainpage Introduction
			  Spire is a shading language and compiler framework that facilitates modular shader authoring and rapid exploration of
			  shader optimization choices (such as frequency reduction and algorithmic approximation) afforded by modern real-time
			  graphics engines. The current implementation of the Spire compiler can generate either GLSL or SPIR-V output for use
			  with OpenGL and Vulkan based engines.

			  Paper: http://graphics.cs.cmu.edu/projects/spire/


			  API Reference: Spire.h

			  @file Spire.h
			  */

#define SPIRE_ERROR 0
#define SPIRE_WARNING 1

#define SPIRE_GLSL 0
#define SPIRE_HLSL 1
#define SPIRE_SPIRV 2

#define SPIRE_LAYOUT_UNIFORM 0
#define SPIRE_LAYOUT_PACKED 1
#define SPIRE_LAYOUT_STORAGE 2

#define SPIRE_ERROR_INSUFFICIENT_BUFFER -1
#define SPIRE_ERROR_INVALID_PARAMETER -2

	/*!
	@brief Represents a compilation context. Created by spCreateCompilationContext().

	Related Functions
	- spCreateCompilationContext()
	- spDestroyCompilationContext()
	- spCreateShader()
	- spCompileShader()
	- spSetCodeGenTarget()
	- spAddSearchPath()
	- spSetBackendParameter()
	*/
	struct SpireCompilationContext {};

	/*!
	@brief Represents a shader. A SpireShader can be assembled by calling spCreateShader().
	Modules can be added to a shader by calling spShaderAddModule().

	Related Functions
	- spShaderAddModule()
	- spShaderAddModuleByName()
	- spShaderTargetPipeline()
	*/
	struct SpireShader {};

	/*!
	@brief SpireModule objects provide reflection data about a module.
	Module objects can be obtained by calling spFindModule() once a module library is loaded via spLoadModuleLibrary().

	Related Functions
	- spLoadModuleLibrary()
	- spLoadModuleLibraryFromSource()
	- spFindModule()
	- spModuleGetComponentsByWorld()
	- spModuleGetRequiredComponents()
	*/
	struct SpireModule {};

	/*!
	@brief Represents the compilation result, including error messages and compiled source code for each stage.

	Related Functions
	- spCompileShader()
	- spCompileShaderFromSource()
	- spIsCompilationSucessful()
	- spGetCompilerOutput()
	- spGetMessageCount()
	- spGetMessageContent()
	- spGetCompiledShaderNames()
	- spGetCompiledShaderStageNames()
	- spGetShaderStageSource()
	- spDestroyCompilationResult()
	*/
	struct SpireCompilationResult {};

	/*!
	@brief Represents an error message from the compiler.
	*/
	struct SpireErrorMessage
	{
		const char * Message;    /**< Content of the message. Storage is owned by SpireCompilationContext.*/
		int ErrorId;             /**< A unique identifier for this type of error.*/
		const char * FileName;   /**< The source file name of this error. Storage is owned by SpireCompilationContext*/
		int Line;                /**< The line number of this error.*/
		int Col;                 /**< The column position of this error.*/
	};

	/*!
	@brief Stores description of a component.
	*/
	struct SpireComponentInfo
	{
		const char * Name;         /**< The name of the component. Storage is owned by SpireCompilationContext.*/
		const char * TypeName;     /**< The type name of the component. Storage is owned by SpireCompilationContext.*/
		const char * Register;     /**< The register binding (if available) of the component. Storage is owned by SpireCompilationContext.*/
		int Size;                  /**< The size (in bytes) of the component. For opaque types (e.g. sampler and texture), this value is 0.*/
		int Alignment;             /**< The alignment (in bytes) of the component. For opaque types (e.g. sampler and texture), this value is 0.*/
		int Offset;				   /**< The offset (in bytes) of the component. For opaque types (e.g. sampler and texture), this value is 0.*/
	};

	/*!
	@brief Represents a collection of SpireComponentInfo.

	Related Functions
	- spComponentInfoCollectionGetCount()
	- spComponentInfoCollectionGetComponent()
	*/
	struct SpireComponentInfoCollection {};

	/*!
	@brief Create a compilation context.
	@param cacheDir The directory used to store cached compilation results. Pass NULL to disable caching.
	@return A new compilation context.
	*/
	SPIRE_API SpireCompilationContext * spCreateCompilationContext(const char * cacheDir);

	/*!
	@brief Sets the target for code generation.
	@param ctx The compilation context.
	@param target The code generation target. Possible values are:
	- SPIRE_GLSL. Generates GLSL code.
	- SPIRE_HLSL. Generates HLSL code.
	- SPIRE_SPIRV. Generates SPIR-V code.
	*/
	SPIRE_API void spSetCodeGenTarget(SpireCompilationContext * ctx, int target);

	/*!
	@brief Add a path in which source files are being search. When the programmer specifies @code using <file_name> @endcode in code, the compiler searches the file
	in all search pathes in order.
	@param ctx The compilation context.
	@param searchDir The additional search directory.
	*/
	SPIRE_API void spAddSearchPath(SpireCompilationContext * ctx, const char * searchDir);

	/*!
	@brief Sets a parameter used by the compiler back-end.
	@param ctx The compilation context.
	@param paramName The name of the parameter.
	@param value The value of the parameter.
	*/
	SPIRE_API void spSetBackendParameter(SpireCompilationContext * ctx, const char * paramName, const char * value);

	/*!
	@brief Sets a shader to compile. By default, the compiler will generate code for all shaders in current context. After setting this option,
	the compiler will only generate code for the specified shader.
	@param ctx The compilation context.
	@param shaderName The name of the shader to compile.
	*/
	SPIRE_API void spSetShaderToCompile(SpireCompilationContext * ctx, const char * shaderName);

	/*!
	@brief Destorys the compilation context. Destorying a compilation context will free the memory for all strings owned by the
	SpireComilationContext and all SpireModule objects. These objects will not be available after a call to spDestroyCompilationContext.
	However, all SpireCompilationResult objects will continue to be available until they are destroyed.
	@param ctx The compilation context to destroy.
	*/
	SPIRE_API void spDestroyCompilationContext(SpireCompilationContext * ctx);

	/*!
	@brief Load and precompile spire modules from spire source file. Compilation status and error messages can be obtained via spIsCompilationSucessful(),
	spGetMessageCount() and spGetMessageContent() functions.
	@param ctx The compilation context.
	@param fileName The filename of the spire source code.
	*/
	SPIRE_API void spLoadModuleLibrary(SpireCompilationContext * ctx, const char * fileName);

	/*!
	@brief Load and precompile spire modules from spire source code in memory. Compilation status and error messages can be obtained via spIsCompilationSucessful(),
	spGetMessageCount() and spGetMessageContent() functions.
	@param ctx The compilation context.
	@param source The spire source code to precompile. All strings should be in UTF-8 encoding.
	@param fileName The filename used to report error messages regarding to code in @p source.
	*/
	SPIRE_API void spLoadModuleLibraryFromSource(SpireCompilationContext * ctx, const char * source, const char * fileName);

	/*!
	@brief Create a shader object that can be used to assemble a final shader from modules.
	@param ctx The compilation context.
	@param name The name of the shader.
	*/
	SPIRE_API SpireShader* spCreateShader(SpireCompilationContext * ctx, const char * name);

	/*!
	@brief Adds a module to a shader.
	@param shader A shader object.
	@param moduleName The name of the module to add to @p shader.
	*/
	SPIRE_API void spShaderAddModuleByName(SpireShader * shader, const char * moduleName);

	/*!
	@brief Adds a module to a shader.
	@param shader A shader object.
	@param module The handle of the module to add to @p shader.
	*/
	SPIRE_API void spShaderAddModule(SpireShader * shader, SpireModule * moduleName);

	/*!
	@brief Sets the target pipeline of a shader
	@param shader A shader object.
	@param pipelineName The name of the Pipeline that @p shader targets.
	*/
	SPIRE_API void spShaderSetPipeline(SpireShader * shader, const char * pipelineName);

	/*!
	@brief Find a precompiled module in a SpireCompilationContext.
	@param ctx The compilation context.
	@param moduleName The name of the module to find.
	@return If a module with the specified name exists in the current context, a handle to the module is returned. Otherwise, the return value is NULL.
	@note All SpireModule objects are destroyed when its containing SpireCompilationContext is destroyed.
	*/
	SPIRE_API SpireModule * spFindModule(SpireCompilationContext * ctx, const char * moduleName);

	/*!
	@brief Retrieve the name of a SpireModule.
	@param module The module to get the name of.
	@return The name of the module as a null-terminated string, or NULL if ther are any errors.
	@note The memory for the return value will be freed when the containing SpireCopmilationContext is destroyed.
	*/
	SPIRE_API const char * spGetModuleName(SpireModule * module);

	/*!
	@brief Retrieves components that are qualified with the specified world.
	@param module The module from which to retrieve components.
	@param worldName The world name of requesting components.
	@param layout The layout rule used to compute offsets of the components. Can be SPIRE_LAYOUT_UNIFORM, SPIRE_LAYOUT_STORAGE or SPIRE_LAYOUT_PACKED.
	@return
	A handle to a collection of SpireComponentInfo structures. Individual components can be retrieved from
	the collection using spComponentInfoCollectionGetComponent() function.
	*/
	SPIRE_API SpireComponentInfoCollection * spModuleGetComponentsByWorld(SpireModule * module, const char * worldName, int layout);

	/*!
	@brief Retrieves component info from SpireComponentInfoCollection.
	@param collection The collection from which to retrieve components.
	@param index Index of the requesting component.
	@param result A pointer to a SpireComponentInfo structure used to receive info on the specified component.
	@return
	If successful, this function returns 0. 
	Otherwise, the return value is one of the following error codes:
	- SPIRE_ERROR_INVALID_PARAMETER if any of the parameters are invalid.
	*/
	SPIRE_API int spComponentInfoCollectionGetComponent(SpireComponentInfoCollection * collection, int index, SpireComponentInfo * result);

	/*!
	@brief Get the number of components contained in a SpireComponentInfoCollection.
	@param collection The collection from which to retrieve components.
	@return
	If successful, this function the number of components in @p collection.
	Otherwise, the return value is one of the following error codes:
	- SPIRE_ERROR_INVALID_PARAMETER if any of the parameters are invalid.
	*/
	SPIRE_API int spComponentInfoCollectionGetCount(SpireComponentInfoCollection * collection);

	
	/*!
	@brief Retrieve a list of components that are required by the specified module.
	@param module The module from where to retrieve components.
	@param buffer A user allocated buffer of SpireComponentInfo for receiving outputs.
	@param bufferSize The size (in number of SpireComponentInfo structs) of the specified buffer.
	@return
	If @p buffer is NULL, the return value is the required size, in number of SpireComponentInfo.
	Otherwise, if the function suceeds, the return value is the number of SpireComponentInfo instances written to
	@p buffer. The function returns a negative value if it does not suceed. Possible error codes are:
	- SPIRE_ERROR_INSUFFICIENT_BUFFER. The supplied buffer size was not large enough.
	- SPIRE_ERROR_INVALID_PARAMETER. Any of the parameter values was invalid.
	*/
	SPIRE_API int spModuleGetRequiredComponents(SpireModule * module, SpireComponentInfo * buffer, int bufferSize);

	/*!
	@brief Destroys a shader object.
	@param shader The shader object to destroy.
	@note You are responsible for destorying a shader object when it is no longer used (e.g. after it has been compiled). Destroying a SpireCompilationContext
	does not automatically destroy SpireShader objects.
	*/
	SPIRE_API void spDestroyShader(SpireShader * shader);

	/*!
	@brief Compiles a shader object.
	@param ctx A shader compilation context.
	@param shader The shader object to compile.
	@return The return value is a handle to a SpireCompilationResult object that contains error messages and compiled source code.
	@note You are responsible for destorying a SpireCompilationResult object when it is no longer used. Destroying a SpireCompilationContext
	does not automatically destroy SpireCompilationResult objects.
	*/
	SPIRE_API SpireCompilationResult* spCompileShader(SpireCompilationContext * ctx, SpireShader * shader);

	/*!
	@brief Compiles a shader object.
	@param ctx A shader compilation context.
	@param source A string that represents the Spire source code that defines a shader.
	@param fileName The filename to use to report error messages regarding to @p source.
	@return The return value is a handle to a SpireCompilationResult object that contains error messages and compiled source code.
	@note You are responsible for destorying a SpireCompilationResult object when it is no longer used. Destroying a SpireCompilationContext
	does not automatically destroy SpireCompilationResult objects.
	@see spDestroyCompilationResult()
	*/
	SPIRE_API SpireCompilationResult* spCompileShaderFromSource(SpireCompilationContext * ctx, const char * source, const char * fileName);

	/*!
	@brief Checks if a compilation operation has succeeded.
	@param result The SpireCompilationResult object returned by spCompileShader().
	@return 1 if compilation is sucessful, 0 otherwise.
	*/
	SPIRE_API int spIsCompilationSucessful(SpireCompilationResult * result);

	/*!
	@brief Retrieve the number of compiler messages in a SpireCompilationResult object.
	@param result A SpireCompilationResult object.
	@param messageType The type of compiler message to check. Possible values are:
	- SPIRE_ERROR. compilation errors.
	- SPIRE_WARNING. compiler warnings.
	@return The number of messages of specified type.
	*/
	SPIRE_API int spGetMessageCount(SpireCompilationResult * result, int messageType);

	/*!
	@brief Retrieve the content of compiler messages in a SpireCompilationResult object.
	@param result A SpireCompilationResult object.
	@param messageType The type of compiler message to check. Possible values are:
	- SPIRE_ERROR. compilation errors.
	- SPIRE_WARNING. compiler warnings.
	@param index The index of the compiler message to retrieve.
	@param pMsg A pointer to a SpireErrorMessage structure to receive the error message.
	@return 1 if successful. SPIRE_ERROR_INVALID_PARAMETER if any of the parameters is invalid.
	*/
	SPIRE_API int spGetMessageContent(SpireCompilationResult * result, int messageType, int index, SpireErrorMessage * pMsg);

	/*!
	@brief Get compiler output messages as a single string.
	@param result A SpireCompilationResult object.
	@param buffer The buffer used to receive compiler messages. If this parameter is NULL, the function returns the number of bytes required for the buffer.
	@param bufferSize The size of @p buffer (in bytes).
	@return
		If successful, the return value is the number of bytes written to @p buffer. If @p buffer is NULL, the return value is the number of bytes required for @p buffer
		to store the entire output message. Otherwise, the function returns one of the following error codes:
		- SPIRE_ERROR_INSUFFICIENT_BUFFER. if @p bufferSize is smaller than required buffer size.
		- SPIRE_ERROR_INVALID_PARAMETER. if any of the parameters is invalid.
	*/
	SPIRE_API int spGetCompilerOutput(SpireCompilationResult * result, char * buffer, int bufferSize);

	/*!
	@brief Retrieve a list of shader names that has been compiled.
	@param result A SpireCompilationResult object.
	@param buffer A buffer used to receive shader names. Shader names are separated by '\\n'. If this parameter is NULL, the function returns the required buffer size.
	@param bufferSize The size (in bytes) of @p buffer.
	@return If sucessful, the return value is greater or equal to 0 representing the number of charaters required or written to buffer, including the trailing 0.
	Otherwise, it returns one of the following error codes:
	- SPIRE_ERROR_INSUFFICIENT_BUFFER. The supplied buffer size was not large enough.
	- SPIRE_ERROR_INVALID_PARAMETER. Any of the parameter values was invalid.
	*/
	SPIRE_API int spGetCompiledShaderNames(SpireCompilationResult * result, char * buffer, int bufferSize);

	/*!
	@brief Retrieve a list of stage names in a compiled shader.
	@param result A SpireCompilationResult object.
	@param shaderName The name of a shader.
	@param buffer A buffer used to receive stage names. Stage names are separated by '\\n'. If this parameter is NULL, the function returns the required buffer size.
	@param bufferSize The size (in bytes) of @p buffer.
	@return If sucessful, the return value is greater or equal to 0 representing the number of charaters required or written to buffer, including the trailing 0.
	Otherwise, it returns one of the following error codes:
	- SPIRE_ERROR_INSUFFICIENT_BUFFER. The supplied buffer size was not large enough.
	- SPIRE_ERROR_INVALID_PARAMETER. Any of the parameter values was invalid.
	*/
	SPIRE_API int spGetCompiledShaderStageNames(SpireCompilationResult * result, const char * shaderName, char * buffer, int bufferSize);

	/*!
	@brief Retrieve the compiled code (binary or textual, depending on the target language) of a stage in a compiled shader.
	@param result A SpireCompilationResult object.
	@param shaderName The name of a shader. If @p shaderName is NULL, the function returns the source code of the first shader in @p result.
	@param stage The name of a stage.
	@param[out] length A pointer used to receive the length of the compiled code, can be set to NULL.
	@return If sucessful, the return value is a pointer to the buffer storing the compiled code. Otherwise, the return value is NULL.
	@note The backing memory of the returned code buffer is owned by the SpireCompilationResult object. Destroying the SpireCompilationResult object will render this code
	buffer unusable.
	*/
	SPIRE_API char * spGetShaderStageSource(SpireCompilationResult * result, const char * shaderName, const char * stage, int * length);

	/*!
	@brief Destroys the SpireCompilationResult object.
	@param result A SpireCompilationResult object to destroy.
	@note Destroying a SpireCompilationContext object does not automatically destroy SpireCompilationResult objects. You are required to destroy a SpireCompilationResult object
	once it is no longer in use.
	*/
	SPIRE_API void spDestroyCompilationResult(SpireCompilationResult * result);

#ifdef __cplusplus  
}
#endif  

#endif

/***********************************************************************
CORELIB\MD5.H
***********************************************************************/
/*
* This is an OpenSSL-compatible implementation of the RSA Data Security, Inc.
* MD5 Message-Digest Algorithm (RFC 1321).
*
* Homepage:
* http://openwall.info/wiki/people/solar/software/public-domain-source-code/md5
*
* Author:
* Alexander Peslyak, better known as Solar Designer <solar at openwall.com>
*
* This software was written by Alexander Peslyak in 2001.  No copyright is
* claimed, and the software is hereby placed in the public domain.
* In case this attempt to disclaim copyright and place the software in the
* public domain is deemed null and void, then the software is
* Copyright (c) 2001 Alexander Peslyak and it is hereby released to the
* general public under the following terms:
*
* Redistribution and use in source and binary forms, with or without
* modification, are permitted.
*
* There's ABSOLUTELY NO WARRANTY, express or implied.
*
* See md5.c for more information.
*/

#ifdef HAVE_OPENSSL
#include <openssl/md5.h>
#elif !defined(_MD5_H)
#define _MD5_H

/* Any 32-bit or wider unsigned integer data type will do */
typedef unsigned int MD5_u32plus;

typedef struct {
	MD5_u32plus lo, hi;
	MD5_u32plus a, b, c, d;
	unsigned char buffer[64];
	MD5_u32plus block[16];
} MD5_CTX;

extern void MD5_Init(MD5_CTX *ctx);
extern void MD5_Update(MD5_CTX *ctx, const void *data, unsigned long size);
extern void MD5_Final(unsigned char *result, MD5_CTX *ctx);

#endif

/***********************************************************************
CORELIB\MEMORYPOOL.H
***********************************************************************/
#ifndef CORE_LIB_MEMORY_POOL_H
#define CORE_LIB_MEMORY_POOL_H


namespace CoreLib
{
	namespace Basic
	{
		struct MemoryBlockFields
		{
			unsigned int Occupied : 1;
			unsigned int Order : 31;
		};
		struct FreeListNode
		{
			FreeListNode * PrevPtr = nullptr, *NextPtr = nullptr;
		};
		class MemoryPool
		{
		private:
			static const int MaxLevels = 32;
			int blockSize = 0, log2BlockSize = 0;
			int numLevels = 0;
			int bytesAllocated = 0;
			int bytesWasted = 0;
			unsigned char * buffer = nullptr;
			FreeListNode * freeList[MaxLevels];
			IntSet used;
			int AllocBlock(int level);
			void FreeBlock(unsigned char * ptr, int level);
		public:
			MemoryPool(unsigned char * buffer, int log2BlockSize, int numBlocks);
			MemoryPool() = default;
			void Init(unsigned char * buffer, int log2BlockSize, int numBlocks);
			unsigned char * Alloc(int size);
			void Free(unsigned char * ptr, int size);
		};
	}
}

#endif

/***********************************************************************
CORELIB\PERFORMANCECOUNTER.H
***********************************************************************/
#ifndef CORELIB_PERFORMANCE_COUNTER_H
#define CORELIB_PERFORMANCE_COUNTER_H

#include <chrono>

namespace CoreLib
{
	namespace Diagnostics
	{
		typedef std::chrono::high_resolution_clock::time_point TimePoint;
		typedef std::chrono::high_resolution_clock::duration Duration;
		class PerformanceCounter
		{
		public:
			static TimePoint Start();
			static Duration End(TimePoint counter);
			static float EndSeconds(TimePoint counter);
			static double ToSeconds(Duration duration);
		};
	}
}

#endif

/***********************************************************************
CORELIB\THREADING.H
***********************************************************************/
#ifndef CORE_LIB_THREADING_H
#define CORE_LIB_THREADING_H
#include <atomic>
#include <thread>
#include <mutex>
#include <xmmintrin.h>

#ifndef _WIN32
#define __stdcall
#endif

namespace CoreLib
{
	namespace Threading
	{
		class SpinLock
		{
		private:
			std::atomic_flag lck;
		public:
			SpinLock()
			{
				lck.clear();
			}
			inline bool TryLock()
			{
				return !lck.test_and_set(std::memory_order_acquire);
			}
			inline void Lock()
			{
				while (lck.test_and_set(std::memory_order_acquire))
				{
				}
			}
			inline void Unlock()
			{
				lck.clear(std::memory_order_release);
			}
			SpinLock & operator = (const SpinLock & /*other*/)
			{
				lck.clear();
				return *this;
			}
		};

		class ParallelSystemInfo
		{
		public:
			static int GetProcessorCount();
		};

		typedef CoreLib::Basic::Event<> ThreadProc;
		typedef CoreLib::Basic::Event<CoreLib::Basic::Object *> ThreadParameterizedProc;
		class Thread;

		class ThreadParam
		{
		public:
			Thread * thread;
			CoreLib::Basic::Object * threadParam;
		};

		enum class ThreadPriority
		{
			Normal,
			AboveNormal,
			Highest,
			Critical,
			BelowNormal,
			Lowest,
			Idle
		};
		unsigned int __stdcall ThreadProcedure(const ThreadParam& param);
		class Thread : public CoreLib::Basic::Object
		{
			friend unsigned int __stdcall ThreadProcedure(const ThreadParam& param);
		private:
			 ThreadParam internalParam;
		public:
			
		private:
			std::thread threadHandle;
			CoreLib::Basic::RefPtr<ThreadProc> threadProc;
			CoreLib::Basic::RefPtr<ThreadParameterizedProc> paramedThreadProc;
		public:
			Thread()
			{
				internalParam.threadParam = nullptr;
				internalParam.thread = this;
			}
			Thread(ThreadProc * p)
				: Thread()
			{
				Start(p);
			}
			Thread(ThreadParameterizedProc * p, CoreLib::Basic::Object * param)
				: Thread()
			{
				Start(p, param);
			}
			void Start(ThreadProc * p)
			{
				threadProc = p;
				threadHandle = std::thread(ThreadProcedure, internalParam);
			}
			void Start(ThreadParameterizedProc * p, CoreLib::Basic::Object * param)
			{
				paramedThreadProc = p;
				internalParam.thread = this;
				internalParam.threadParam = param;
				threadHandle = std::thread(ThreadProcedure, internalParam);
			}
			void Join()
			{
				if (threadHandle.joinable())
					threadHandle.join();
			}
			void Detach()
			{
				if (threadHandle.joinable())
					threadHandle.detach();
			}
			std::thread::id GetHandle()
			{
				return threadHandle.get_id();
			}
		};

		class Mutex : public CoreLib::Basic::Object
		{
		private:
			std::mutex handle;
		public:
			void Lock()
			{
				handle.lock();
			}
			bool TryLock()
			{
				return handle.try_lock();
			}
			void Unlock()
			{
				return handle.unlock();
			}
		};
	}
}

#endif

/***********************************************************************
CORELIB\VECTORMATH.H
***********************************************************************/
#ifndef VECTOR_MATH_H
#define VECTOR_MATH_H
#include <random>
#include <cmath>
#ifdef _M_X64
#define NO_SIMD_ASM
#endif
#if !defined(_MSC_VER) || defined(__clang__)
#define NO_SIMD_ASM
#endif
#ifndef NO_VECTOR_CONSTRUCTORS
#define NO_VECTOR_CONSTRUCTORS
#endif
namespace VectorMath
{
	using namespace CoreLib::Basic;
	const float PI = 3.1415926535f;
	const float Epsilon = 1e-4f;
	const int DefaultFloatUlps = 1024;
	inline float Clamp(float val, float vmin, float vmax)
	{
		return val>vmax?vmax:val<vmin?vmin:val;
	}
	inline bool FloatEquals(float A, float B, int maxUlps = DefaultFloatUlps)
	{
		int aInt = *(int*)&A;
		// Make aInt lexicographically ordered as a twos-complement int
		if (aInt < 0)
			aInt = 0x80000000 - aInt;
		// Make bInt lexicographically ordered as a twos-complement int
		int bInt = *(int*)&B;
		if (bInt < 0)
			bInt = 0x80000000 - bInt;
		int intDiff = abs(aInt - bInt);
		if (intDiff <= maxUlps)
			return true;
		return false;
	}
	inline bool FloatLarger(float A, float B, int maxUlps = DefaultFloatUlps)
	{
		return A>B && !FloatEquals(A,B,maxUlps);
	}
	inline bool FloatSmaller(float A, float B, int maxUlps = DefaultFloatUlps)
	{
		return A<B && !FloatEquals(A,B,maxUlps);
	}
	inline bool FloatSmallerOrEquals(float A, float B, int maxUlps = DefaultFloatUlps)
	{
		return A<B || FloatEquals(A, B, maxUlps);
	}
	inline bool FloatLargerOrEquals(float A, float B, int maxUlps = DefaultFloatUlps)
	{
		return A>B || FloatEquals(A, B, maxUlps);
	}

	template<typename T>
	inline T Max(T v1, T v2)
	{
		if (v1>v2) return v1; else return v2;
	}
	template<typename T>
	inline T Min(T v1, T v2)
	{
		if (v1<v2) return v1; else return v2;
	}

	class Vec4;
	class Vec2
	{
	public:
		float x, y;
#ifndef NO_VECTOR_CONSTRUCTORS
		Vec2() = default;
		Vec2(const Vec2 & v) = default;
		Vec2(float vx, float vy)
		{
			x = vx; y = vy;
		}
#endif
		static Vec2 Create(float f)
		{
			Vec2 rs;
			rs.x = rs.y = f;
			return rs;
		}
		static Vec2 Create(float vx, float vy)
		{
			Vec2 rs;
			rs.x = vx;	rs.y = vy;
			return rs;
		}
		inline void SetZero()
		{
			x = y = 0.0f;
		}
		static inline float Dot(const Vec2 & v0, const Vec2 & v1)
		{
			return v0.x * v1.x + v0.y * v1.y;
		}
		inline float & operator [] (int i)
		{
			return ((float*)this)[i];
		}
		inline Vec2 operator * (float s) const
		{
			Vec2 rs;
			rs.x = x * s;
			rs.y = y * s;
			return rs;
		}
		inline Vec2 operator * (const Vec2 &vin) const
		{
			Vec2 rs;
			rs.x = x * vin.x;
			rs.y = y * vin.y;
			return rs;
		}
		inline Vec2 operator + (const Vec2 &vin) const
		{
			Vec2 rs;
			rs.x = x + vin.x;
			rs.y = y + vin.y;
			return rs;
		}
		inline Vec2 operator - (const Vec2 &vin) const
		{
			Vec2 rs;
			rs.x = x - vin.x;
			rs.y = y - vin.y;
			return rs;
		}
		inline Vec2 & operator += (const Vec2 & vin)
		{
			x += vin.x;
			y += vin.y;
			return *this;
		}
		inline Vec2 & operator -= (const Vec2 & vin)
		{
			x -= vin.x;
			y -= vin.y;
			return *this;
		}
		Vec2 & operator = (float v)
		{
			x = y = v;
			return *this;
		}
		inline Vec2 & operator *= (float s)
		{
			x *= s;
			y *= s;
			return *this;
		}
		inline Vec2 & operator *= (const Vec2 & vin)
		{
			x *= vin.x;
			y *= vin.y;
			return *this;
		}
		inline Vec2 Normalize()
		{
			float len = sqrt(x*x + y*y);
			float invLen = 1.0f / len;
			Vec2 rs;
			rs.x = x * invLen;
			rs.y = y * invLen;
			return rs;
		}
		inline float Length()
		{
			return sqrt(x*x + y*y);
		}
	};

	struct Vec3_Struct
	{
		float x,y,z;
	};

	class Vec3 : public Vec3_Struct
	{
	public:
#ifndef NO_VECTOR_CONSTRUCTORS
		inline Vec3() = default;
		inline Vec3(float f)
		{
			x = y = z = f;
		}
		inline Vec3(float vx, float vy, float vz)
		{
			x = vx;	y = vy;	z = vz;
		}
		inline Vec3(const Vec3 & v) = default;
#endif
		static inline Vec3 Create(float f)
		{
			Vec3 rs;
			rs.x = rs.y = rs.z = f;
			return rs;
		}
		static inline Vec3 Create(float vx, float vy, float vz)
		{
			Vec3 rs;
			rs.x = vx;	rs.y = vy;	rs.z = vz;
			return rs;
		}
		static inline Vec3 FromHomogeneous(const Vec4 & v);
		inline void SetZero()
		{
			x = y = z = 0.0f;
		}
		inline float& operator [] (int i) const
		{
			return ((float*)this)[i];
		}
		inline Vec3 operator + (const Vec3 &vin) const
		{
			Vec3 rs;
			rs.x = x + vin.x;
			rs.y = y + vin.y;
			rs.z = z + vin.z;
			return rs;
		}
		inline Vec3 operator - (const Vec3 &vin) const
		{
			Vec3 rs;
			rs.x = x - vin.x;
			rs.y = y - vin.y;
			rs.z = z - vin.z;
			return rs;
		}
		inline Vec3 operator - () const
		{
			Vec3 rs;
			rs.x = -x;
			rs.y = -y;
			rs.z = -z;
			return rs;
		}
		inline Vec3 operator * (float scale) const
		{
			Vec3 rs;
			rs.x = x * scale;
			rs.y = y * scale;
			rs.z = z * scale;
			return rs;
		}
		inline Vec3 & operator += (const Vec3 & vin)
		{
			x += vin.x; y += vin.y; z += vin.z;
			return *this;
		}
		inline Vec3 & operator -= (const Vec3 & vin)
		{
			x -= vin.x; y -= vin.y; z -= vin.z; 
			return *this;
		}
		inline Vec3 & operator *= (const Vec3 & vin)
		{
			x *= vin.x; y *= vin.y; z *= vin.z;
			return *this;
		}
		inline Vec3 & operator *= (float s)
		{
			x *= s; y *= s; z *= s;
			return *this;
		}
		inline Vec3 & operator /= (const Vec3 & vin)
		{
			x /= vin.x; y /= vin.y; z /= vin.z;
			return *this;
		}
		inline Vec3 & operator /= (float s)
		{
			float inv = 1.0f/s;
			return (*this)*=inv;
		}
		inline bool operator == (const Vec3 & vin)
		{
			return x == vin.x && y == vin.y && z == vin.z;
		}
		inline bool operator != (const Vec3 & vin)
		{
			return x != vin.x || y != vin.y || z != vin.z;
		}
		inline int GetHashCode()
		{
			return FloatAsInt(x) ^ FloatAsInt(y) ^ FloatAsInt(z);
		}
		inline static float Dot(const Vec3 & v1, const Vec3 & v2)
		{
			return v1.x*v2.x + v1.y*v2.y + v1.z*v2.z;
		}
		inline static void Cross(Vec3 & rs_d, const Vec3 & v1, const Vec3 & v2)
		{
			rs_d.x = v1.y*v2.z - v1.z * v2.y;
			rs_d.y = v1.z*v2.x - v1.x * v2.z;
			rs_d.z = v1.x*v2.y - v1.y * v2.x;
		}
		inline static Vec3 Cross(const Vec3 & v1, const Vec3 & v2)
		{
			Vec3 rs_d;
			rs_d.x = v1.y*v2.z - v1.z * v2.y;
			rs_d.y = v1.z*v2.x - v1.x * v2.z;
			rs_d.z = v1.x*v2.y - v1.y * v2.x;
			return rs_d;
		}
		inline static void Scale(Vec3 & rs, const Vec3 & v1, float s)
		{
			rs.x = v1.x*s;	rs.y = v1.y*s;	rs.z = v1.z*s;
		}
		inline static void Add(Vec3 & rs, const Vec3 & v1, const Vec3 & v2)
		{
			rs.x = v1.x + v2.x;
			rs.y = v1.y + v2.y;
			rs.z = v1.z + v2.z;
		}
		inline static void Subtract(Vec3 & rs, const Vec3 & v1, const Vec3 & v2)
		{
			rs.x = v1.x - v2.x;
			rs.y = v1.y - v2.y;
			rs.z = v1.z - v2.z;
		}
		inline static void Multiply(Vec3 & rs, const Vec3 & v1, const Vec3 & v2)
		{
			rs.x = v1.x * v2.x;
			rs.y = v1.y * v2.y;
			rs.z = v1.z * v2.z;
		}
		inline float LengthFPU() const
		{
			return sqrt(x*x + y*y + z*z);
		}
		inline float Length2() const
		{
			return x*x+y*y+z*z;
		}
		static inline void NormalizeFPU(Vec3 & rs, const Vec3 & vin)
		{
			float invLen = 1.0f/vin.LengthFPU();
			Scale(rs, vin, invLen);
		}
		inline float Length() const;
		static inline void Normalize(Vec3 & rs, const Vec3 & vin);
		inline Vec3 Normalize() const
		{
			Vec3 rs;
			Normalize(rs, *this);
			return rs;
		}
	};

	struct Vec4_Struct
	{
		float x,y,z,w;
	};

	class Vec4 : public Vec4_Struct
	{
	public:
#ifndef NO_VECTOR_CONSTRUCTORS
		inline Vec4() = default;
		inline Vec4(const Vec4_Struct & v)
		{
			x = v.x;
			y = v.y;
			z = v.z;
			w = v.w;
		}
		inline Vec4(float f)
		{
			x = y = z = w = f;
		}
		inline Vec4(float vx, float vy, float vz, float vw)
		{
			x = vx;	y = vy;	z = vz;	w = vw;
		}
		inline Vec4(const Vec3 & v)
		{
			x = v.x; y = v.y; z = v.z; w = 0.0f;
		}
		inline Vec4(const Vec3 & v, float vw)
		{
			x = v.x; y = v.y; z = v.z; w = vw;
		}
		inline Vec4(const Vec4 & v) = default;
#endif
		static inline Vec4 Create(float f)
		{
			Vec4 rs;
			rs.x = rs.y = rs.z = rs.w = f;
			return rs;
		}
		static inline Vec4 Create(float vx, float vy, float vz, float vw)
		{
			Vec4 rs;
			rs.x = vx;	rs.y = vy;	rs.z = vz; rs.w = vw;
			return rs;
		}
		static inline Vec4 Create(const Vec3 & v, float vw)
		{
			Vec4 rs;
			rs.x = v.x; rs.y = v.y; rs.z = v.z; rs.w = vw;
			return rs;
		}
		inline void SetZero()
		{
			x = y = z = w = 0.0f;
		}
		inline void xyz(Vec3 & v) const
		{
			v.x = x;
			v.y = y;
			v.z = z;
		}
		inline Vec3 xyz() const
		{
			Vec3 rs;
			rs.x = x;
			rs.y = y;
			rs.z = z;
			return rs;
		}
		inline float& operator [] (int i)
		{
			return ((float*)this)[i];
		}
		inline Vec4 operator + (const Vec4 &vin)
		{
			Vec4 rs;
			rs.x = x + vin.x;
			rs.y = y + vin.y;
			rs.z = z + vin.z;
			rs.w = w + vin.w;
			return rs;
		}
		inline Vec4 operator - (const Vec4 &vin)
		{
			Vec4 rs;
			rs.x = x - vin.x;
			rs.y = y - vin.y;
			rs.z = z - vin.z;
			rs.w = w - vin.w;
			return rs;
		}
		inline Vec4 operator - ()
		{
			Vec4 rs;
			rs.x = -x;
			rs.y = -y;
			rs.z = -z;
			rs.w = -w;
			return rs;
		}
		inline Vec4 operator * (float scale) const
		{
			Vec4 rs;
			rs.x = x * scale;
			rs.y = y * scale;
			rs.z = z * scale;
			rs.w = w * scale;
			return rs;
		}
		inline Vec4 & operator += (const Vec4 & vin)
		{
			x += vin.x; y += vin.y; z += vin.z; w += vin.w;
			return *this;
		}
		inline Vec4 & operator -= (const Vec4 & vin)
		{
			x -= vin.x; y -= vin.y; z -= vin.z; w -= vin.w;
			return *this;
		}
		inline Vec4 & operator *= (const Vec4 & vin)
		{
			x *= vin.x; y *= vin.y; z *= vin.z; w *= vin.w;
			return *this;
		}
		inline Vec4 & operator *= (float s)
		{
			x *= s; y *= s; z *= s; w *= s;
			return *this;
		}
		inline Vec4 & operator /= (const Vec4 & vin)
		{
			x /= vin.x; y /= vin.y; z /= vin.z; w /= vin.w;
			return *this;
		}
		inline Vec4 & operator /= (float s)
		{
			float inv = 1.0f/s;
			return (*this)*=inv;
		}
		inline bool operator == (const Vec4 & vin)
		{
			return vin.x == x && vin.y == y && vin.z == z && vin.w == w;
		}
		inline bool operator != (const Vec4 & vin)
		{
			return vin.x != x || vin.y != y || vin.z != z || vin.w != w;
		}
		inline int GetHashCode()
		{
			return FloatAsInt(x) ^ FloatAsInt(y) ^ FloatAsInt(z) ^ FloatAsInt(w);
		}
		static inline void Add(Vec4 & rs, const Vec4 & v1, const Vec4 & v2);
		static inline void Subtract(Vec4 & rs, const Vec4 & v1, const Vec4 & v2);
		static inline void Multiply(Vec4 & rs, const Vec4 & v1, const Vec4 & v2);
		static inline void MultiplyScale(Vec4 & rs, const Vec4 & v1, const Vec4 & v2);
		static inline void Scale(Vec4 & rs, const Vec4 & v1, float s);
		static inline float Dot(const Vec4 & v1, const Vec4 & v2);
		static inline void Cross(Vec4 & rs_d, const Vec4 & v1, const Vec4 & v2);
		inline float LengthFPU() const;
		inline float Length() const;
		static inline void NormalizeFPU(Vec4& vout, const Vec4& vin);
		static inline void Normalize(Vec4 &vout, const Vec4 &vin);
		inline Vec4 Normalize()
		{
			Vec4 rs;
			Normalize(rs, *this);
			return rs;
		}
	};

	class Vec4_M128
	{
	public:
		__m128 vec;
		Vec4_M128()
		{}
		Vec4_M128(__m128 v)
		{
			vec = v;
		}
		Vec4_M128(float a, float b, float c, float d)
		{
			vec = _mm_set_ps(a, b, c, d);
		}
		Vec4_M128(const Vec4 & v)
		{
			vec = _mm_load_ps((const float*)&v);
		}
		inline void Zero()
		{
			vec = _mm_setzero_ps();
		}
		inline void ToVec4(Vec4 & v) const
		{
			_mm_store_ps((float*)&v, vec);
		}
	};

	class Matrix3
	{
	public:
		union
		{
			float values[9];
			float m[3][3];
			struct
			{
				float _11, _12, _13,
				_21, _22, _23,
				_31, _32, _33;
			} mi;
		};
		inline Vec3 Transform(const Vec3& vIn) const
		{
			Vec3 rs;
			rs.x = m[0][0] * vIn.x + m[1][0] * vIn.y + m[2][0] * vIn.z;
			rs.y = m[0][1] * vIn.x + m[1][1] * vIn.y + m[2][1] * vIn.z;
			rs.z = m[0][2] * vIn.x + m[1][2] * vIn.y + m[2][2] * vIn.z;
			return rs;
		}
		static inline void Multiply(Matrix3 & rs, Matrix3 & m1, Matrix3 & m2)
		{
			for (int i = 0; i < 3; i++)
				for (int j = 0; j < 3; j++)
				{
					float dot = 0.0f;
					for (int k = 0; k < 3; k++)
						dot += m1.m[k][j] * m2.m[i][k];
					rs.m[i][j] = dot;
				}
		}
	};

	class Matrix4
	{
	public:
		union
		{
			float values[16];
			float m[4][4];
			struct
			{
				float _11,_12,_13,_14,
				  _21,_22,_23,_24,
				  _31,_32,_33,_34,
				  _41,_42,_43,_44;
			} mi;
			struct
			{
				float _11,_12,_13,_14,
				  _21,_22,_23,_24,
				  _31,_32,_33,_34,
				  _41,_42,_43,_44;
			} mr;
		};
		Matrix4()
		{}
		Matrix4(float v)
		{
			for (int i = 0; i<16; i++)
				values[i] = v;
		}
		Matrix4(const Vec4 & c1, const Vec4 & c2, const Vec4 & c3, const Vec4 &c4)
		{
			memcpy(m[0], &c1, sizeof(Vec4));
			memcpy(m[1], &c2, sizeof(Vec4));
			memcpy(m[2], &c3, sizeof(Vec4));
			memcpy(m[3], &c4, sizeof(Vec4));
		}
		inline Matrix4 & operator += (const Matrix4 & v)
		{
			for (int i = 0; i < 16; i++)
				values[i] += v.values[i];
			return *this;
		}
		inline Matrix3 GetMatrix3()
		{
			Matrix3 rs;
			for (int i = 0; i < 3; i++)
			for (int j = 0; j < 3; j++)
				rs.m[i][j] = m[i][j];
			return rs;
		}
		inline Matrix4 & operator *= (const float & val)
		{
			for (int i = 0; i < 16; i++)
				values[i] *= val;
			return *this;
		}
		inline Matrix4 & operator *= (const Matrix4 & matrix)
		{
			Multiply(*this, *this, matrix);
			return *this;
		}
		inline Matrix4 operator * (const Matrix4 & matrix)
		{
			Matrix4 rs;
			Multiply(rs, *this, matrix);
			return rs;
		}
		inline Matrix4 & LeftMultiply(const Matrix4 & matrix)
		{
			Multiply(*this, matrix, *this);
			return *this;
		}
		inline void Transpose()
		{
			float tmp;
			for (int i = 1; i<4; i++)
				for (int j = 0; j < i; j++)
				{
					tmp = m[i][j];
					m[i][j] = m[j][i];
					m[j][i] = tmp;
				}
		}
		static inline void CreateIdentityMatrix(Matrix4 & mOut);
		static inline void CreateRandomMatrix(Matrix4 & mOut);
		static inline void CreateOrthoMatrix(Matrix4 & mOut, float left, float right, float top, float bottom, float zNear, float zFar);
		static inline void CreatePerspectiveMatrixFromViewAngle(Matrix4 &mOut, float fovY, float aspect, float zNear, float zFar);
		static inline void CreatePerspectiveMatrixFromViewAngleTiled(Matrix4 &mOut, float fovY, float aspect, float zNear, float zFar, float x0, float y0, float x1, float y1);
		static inline void CreatePerspectiveMatrix(Matrix4 &mOut, float left, float right, float bottom, float top, float zNear, float zFar);
		static void LookAt(Matrix4 & rs, const Vec3 & pos, const Vec3 & center, const Vec3 & up);
		static inline void RotationX(Matrix4 & rs, float angle);
		static inline void RotationY(Matrix4 & rs, float angle);
		static inline void RotationZ(Matrix4 & rs, float angle);
		static void Rotation(Matrix4 & rs, const Vec3 & axis, float angle);
		static void Rotation(Matrix4 & rs, float yaw, float pitch, float roll);
		static inline void Scale(Matrix4 & rs, float sx, float sy, float sz);
		static inline void Translation(Matrix4 & rs, float tx, float ty, float tz);
		inline void Transform(Vec3 & rs_d, const Vec3& vIn) const;
		inline void Transform(Vec4 & rs_d, const Vec4& vIn) const;
		inline void TransformNormal(Vec3 & rs, const Vec3& vIn) const;
		inline void TransposeTransformNormal(Vec3 & rs, const Vec3 & vIn) const;
		inline void TransposeTransform(Vec3 & rs, const Vec3 & vIn) const;
		inline void TransposeTransform(Vec4 & rs_d, const Vec4& vIn) const;
		inline void TransformHomogeneous(Vec3 & rs, const Vec3 & vIn) const;
		inline void TransformHomogeneous2D(Vec2 & rs, const Vec3 & vIn) const;
		static inline void MultiplyFPU(Matrix4 &mOut, const Matrix4& M1, const Matrix4& M2);
		static inline void Multiply(Matrix4 &mOut, const Matrix4& M1, const Matrix4& M2);
		float Inverse3D(Matrix4 & mOut_d) const;
		float InverseFPU(Matrix4 &mOut_d) const;
		void GetNormalMatrix(Matrix4 & mOut) const;
		inline float Inverse(Matrix4 &mOut_d) const;
	};

	//__declspec(align(16))
	class Matrix4_M128
	{
	private:
		static const __m128 VecOne;
	public:
		__m128 C1,C2,C3,C4;
		Matrix4_M128()
		{}
		Matrix4_M128(const Matrix4 & m)
		{
			C1 = _mm_loadu_ps(m.values);
			C2 = _mm_loadu_ps(m.values+4);
			C3 = _mm_loadu_ps(m.values+8);
			C4 = _mm_loadu_ps(m.values+12);
		}
		inline void ToMatrix4(Matrix4 & mOut) const;
		inline void Transform(Vec4_M128 & rs, const Vec4& vIn) const;
		inline void Transform(Vec4 & rs, const Vec4& vIn) const;
		inline void Transform(Vec4_M128 & rs, const Vec3& vIn) const;
		inline void Transform(Vec3 & rs, const Vec3& vIn) const;
		inline void Transform(Vec4_M128 & rs, const Vec4_M128& vIn) const;
		inline void TransformNormal(Vec4_M128 & rs, const Vec4& vIn) const;
		inline void TransformNormal(Vec4 & rs, const Vec4& vIn) const;
		inline void TransformNormal(Vec4_M128 & rs, const Vec3& vIn) const;
		inline void TransformNormal(Vec3 & rs, const Vec3& vIn) const;
		inline void Multiply(Matrix4_M128 & rs, const Matrix4 & mB) const;
		inline void Multiply(Matrix4_M128 & rs, const Matrix4_M128 & mB) const;
		float Inverse(Matrix4_M128 &mOut) const;
	};

	//***********************************************************************
	/**************************** Implementation ****************************/
	//***********************************************************************
	//inline int FloatAsInt(float val)
	//{
	//	union InterCast
	//	{
	//		float fvalue;
	//		int ivalue;
	//	} cast;
	//	cast.fvalue = val;
	//	return cast.ivalue;
	//}
	//inline float IntAsFloat(int val)
	//{
	//	union InterCast
	//	{
	//		float fvalue;
	//		int ivalue;
	//	} cast;
	//	cast.ivalue = val;
	//	return cast.fvalue;
	//}
	inline Vec3 Vec3::FromHomogeneous(const Vec4 & v)
	{
		float invW = 1.0f/v.w;
		return v.xyz()*invW;
	}
	// Vec3
	inline float Vec3::Length() const
	{
		return Vec4::Create(*this, 0.0f).Length();
	}
	inline void Vec3::Normalize(Vec3 & rs, const Vec3 & vin)
	{
		Vec3::NormalizeFPU(rs, vin);
	}
	// Vec4
	inline void Vec4::Add(Vec4 & rs, const Vec4 & v1, const Vec4 & v2)
	{
		rs.x = v1.x + v2.x;
		rs.y = v1.y + v2.y;
		rs.z = v1.z + v2.z;
		rs.w = v1.w + v2.w;
	}
	inline void Vec4::Subtract(Vec4 & rs, const Vec4 & v1, const Vec4 & v2)
	{
		rs.x = v1.x - v2.x;
		rs.y = v1.y - v2.y;
		rs.z = v1.z - v2.z;
		rs.w = v1.w - v2.w;
	}
	inline void Vec4::Multiply(Vec4 & rs, const Vec4 & v1, const Vec4 & v2)
	{
		rs.x = v1.x * v2.x;
		rs.y = v1.y * v2.y;
		rs.z = v1.z * v2.z;
		rs.w = v1.w * v2.w;
	}
	inline void Vec4::MultiplyScale(Vec4 & rs, const Vec4 & v1, const Vec4 & v2)
	{
		rs.x = v1.x * v2.x;
		rs.y = v1.y * v2.y;
		rs.z = v1.z * v2.z;
		rs.w = v1.w * v2.w;
	}
	inline void Vec4::Scale(Vec4 & rs, const Vec4 & v1, float s)
	{
		rs.x = v1.x * s;
		rs.y = v1.y * s;
		rs.z = v1.z * s;
		rs.w = v1.w * s;
	}
	inline float Vec4::Dot(const Vec4 & v1, const Vec4 & v2)
	{
		return v1.x*v2.x + v1.y*v2.y + v1.z*v2.z + v1.w*v2.w;
	}
	inline void Vec4::Cross(Vec4 & rs_d, const Vec4 & v1, const Vec4 & v2)
	{
		rs_d.x = v1.y*v2.z - v1.z * v2.y;
		rs_d.y = v1.z*v2.x - v1.x * v2.z;
		rs_d.z = v1.x*v2.y - v1.y * v2.x;
		rs_d.w = 0.0f;
	}
	inline float Vec4::LengthFPU() const
	{
		return sqrt(Dot(*this, *this));
	}
	inline float Vec4::Length() const
	{
#ifdef NO_SIMD_ASM
		return LengthFPU();
#else
		float f;
		_asm
		{
			lea	ecx, f;
			mov	eax, this;

			movups	xmm0, [eax];
			mulps	xmm0, xmm0;
			movaps	xmm1, xmm0;
			shufps	xmm1, xmm1, 4Eh;
			addps	xmm0, xmm1;
			movaps	xmm1, xmm0;
			shufps	xmm1, xmm1, 11h;
			addss	xmm0, xmm1;

			sqrtss	xmm0, xmm0;
			movss	dword ptr [ecx], xmm0;
		}
		return f;
#endif
	}
	inline void Vec4::NormalizeFPU(Vec4& vout, const Vec4& vin)
	{
		float len = 1.0f/vin.Length();
		Scale(vout, vin, len);
	}
	inline void Vec4::Normalize(Vec4 &vout, const Vec4 &vin)
	{
#ifdef NO_SIMD_ASM
		NormalizeFPU(vout, vin);
#else
		__m128 xmm0 = _mm_loadu_ps((float*)&vin);
		__m128 xmm2 = xmm0;
		xmm0 = _mm_mul_ps(xmm0, xmm0);
		__m128 xmm1 = xmm0;
		xmm1 = _mm_shuffle_ps(xmm1, xmm1, 0x4E);
		xmm0 = _mm_add_ps(xmm0, xmm1);
		xmm1 = xmm0;
		xmm1 = _mm_shuffle_ps(xmm1, xmm1, 0x11);
		xmm0 = _mm_add_ps(xmm0, xmm1);
		xmm0 = _mm_rsqrt_ps(xmm0);
		xmm2 = _mm_mul_ps(xmm2, xmm0);
		_mm_storeu_ps((float*)&vout, xmm2);
#endif
	}

	// Matrix4
	inline void Matrix4::CreateIdentityMatrix(Matrix4 & mOut)
	{
		memset(&mOut, 0, sizeof(Matrix4));
		mOut.m[0][0] = mOut.m[1][1] = mOut.m[2][2] = mOut.m[3][3] = 1.0f;
	}

	inline void Matrix4::CreateOrthoMatrix(Matrix4 & mOut, float left, float right, float top, float bottom, float zNear, float zFar)
	{
		memset(&mOut, 0, sizeof(Matrix4));
		mOut.m[0][0] = 2.0f / (right - left);
		mOut.m[1][1] = 2.0f / (top - bottom);
		mOut.m[2][2] = -2.0f / (zFar - zNear);
		mOut.m[3][0] = -(right + left) / (right - left);
		mOut.m[3][1] = -(top + bottom) / (top - bottom);
		mOut.m[3][2] = -(zFar + zNear) / (zFar - zNear);
		mOut.m[3][3] = 1.0f;
	}

	inline void Matrix4::CreatePerspectiveMatrix(Matrix4 &mOut, float left, float right, float bottom, float top, float znear, float zfar)
	{
		memset(&mOut, 0, sizeof(Matrix4));
		mOut.m[0][0] = (znear*2.0f)/(right-left);
		mOut.m[1][1] = (2.0f*znear)/(top-bottom);
		mOut.m[2][0] = (right+left)/(right-left);
		mOut.m[2][1] = (top+bottom)/(top-bottom);
		mOut.m[2][2] = (zfar+znear)/(znear-zfar);
		mOut.m[2][3] = -1.0f;
		mOut.m[3][2] = 2.0f*zfar*znear/(znear-zfar);
	}

	inline void Matrix4::CreatePerspectiveMatrixFromViewAngle(Matrix4 &mOut, float fovY, float aspect, float zNear, float zFar)
	{
		float xmin, xmax, ymin, ymax;
		ymax = zNear * tan(fovY * CoreLib::Basic::Math::Pi / 360.0f);
		ymin = -ymax;
		xmin = ymin * aspect;
		xmax = ymax * aspect;
		Matrix4::CreatePerspectiveMatrix(mOut, xmin, xmax, ymin, ymax, zNear, zFar);
	}

	inline void Matrix4::CreatePerspectiveMatrixFromViewAngleTiled(Matrix4 &mOut, float fovY, float aspect, float zNear, float zFar, float x0, float y0, float x1, float y1)
	{
		float xmin, xmax, ymin, ymax;
		ymax = zNear * tan(fovY * CoreLib::Basic::Math::Pi / 360.0f);
		ymin = -ymax;
		xmin = ymin * aspect;
		xmax = ymax * aspect;
		x0 *= (xmax - xmin);  x0 += xmin;
		y0 *= (ymax - ymin); y0 += ymin;
		x1 *= (xmax - xmin);  x1 += xmin;
		y1 *= (ymax - ymin); y1 += ymin; 
		Matrix4::CreatePerspectiveMatrix(mOut, x0, x1, y0, y1, zNear, zFar);
	}

	inline void Matrix4::CreateRandomMatrix(Matrix4 & mOut)
	{
		for (int i = 0; i<16; i++)
		{
			mOut.values[i] = rand()/(float)RAND_MAX;
		}
	}
	inline void Matrix4::RotationX(Matrix4 & rs, float angle)
	{
		float c = cosf(angle);
		float s = sinf(angle);

		Matrix4::CreateIdentityMatrix(rs);
		rs.m[1][1] = c;
		rs.m[2][1] = s;
		rs.m[1][2] = -s;
		rs.m[2][2] = c;
	}
	inline void Matrix4::RotationY(Matrix4 & rs, float angle)
	{
		float c = cosf(angle);
		float s = sinf(angle);

		Matrix4::CreateIdentityMatrix(rs);
		rs.m[0][0] = c;
		rs.m[2][0] = s;
		rs.m[0][2] = -s;
		rs.m[2][2] = c;
	}
	inline void Matrix4::RotationZ(Matrix4 & rs, float angle)
	{
		float c = cosf(angle);
		float s = sinf(angle);

		Matrix4::CreateIdentityMatrix(rs);
		rs.m[0][0] = c;
		rs.m[1][0] = s;
		rs.m[0][1] = -s;
		rs.m[1][1] = c;
	}

	inline void Matrix4::Scale(Matrix4 & rs, float sx, float sy, float sz)
	{
		Matrix4::CreateIdentityMatrix(rs);
		rs.m[0][0] = sx;
		rs.m[1][1] = sy;
		rs.m[2][2] = sz;
	}
	inline void Matrix4::Translation(Matrix4 & rs, float tx, float ty, float tz)
	{
		Matrix4::CreateIdentityMatrix(rs);
		rs.values[12] = tx;
		rs.values[13] = ty;
		rs.values[14] = tz;
	}
	inline void Matrix4::TransposeTransformNormal(Vec3 & rs, const Vec3 & vIn) const
	{
		rs.x = m[0][0]*vIn.x + m[0][1]*vIn.y + m[0][2]*vIn.z;
		rs.y = m[1][0]*vIn.x + m[1][1]*vIn.y + m[1][2]*vIn.z;
		rs.z = m[2][0]*vIn.x + m[2][1]*vIn.y + m[2][2]*vIn.z;
	}
	inline void Matrix4::TransposeTransform(Vec3 & rs, const Vec3 & vIn) const
	{
		rs.x = m[0][0]*vIn.x + m[0][1]*vIn.y + m[0][2]*vIn.z + m[0][3];
		rs.y = m[1][0]*vIn.x + m[1][1]*vIn.y + m[1][2]*vIn.z + m[1][3];
		rs.z = m[2][0]*vIn.x + m[2][1]*vIn.y + m[2][2]*vIn.z + m[2][3];
	}
	inline void Matrix4::TransposeTransform(Vec4 & rs, const Vec4 & vIn) const
	{
		rs.x = m[0][0]*vIn.x + m[0][1]*vIn.y + m[0][2]*vIn.z + m[0][3]*vIn.w;
		rs.y = m[1][0]*vIn.x + m[1][1]*vIn.y + m[1][2]*vIn.z + m[1][3]*vIn.w;
		rs.z = m[2][0]*vIn.x + m[2][1]*vIn.y + m[2][2]*vIn.z + m[2][3]*vIn.w;
		rs.w = m[3][0]*vIn.x + m[3][1]*vIn.y + m[3][2]*vIn.z + m[3][3]*vIn.w;
	}
	inline void Matrix4::Transform(Vec3 & rs, const Vec3& vIn) const
	{
		rs.x = m[0][0]*vIn.x + m[1][0]*vIn.y + m[2][0]*vIn.z + m[3][0];
		rs.y = m[0][1]*vIn.x + m[1][1]*vIn.y + m[2][1]*vIn.z + m[3][1];
		rs.z = m[0][2]*vIn.x + m[1][2]*vIn.y + m[2][2]*vIn.z + m[3][2];
	}
	inline void Matrix4::TransformHomogeneous(Vec3 & rs, const Vec3 & vIn) const
	{
		rs.x = m[0][0]*vIn.x + m[1][0]*vIn.y + m[2][0]*vIn.z + m[3][0];
		rs.y = m[0][1]*vIn.x + m[1][1]*vIn.y + m[2][1]*vIn.z + m[3][1];
		rs.z = m[0][2]*vIn.x + m[1][2]*vIn.y + m[2][2]*vIn.z + m[3][2];
		float w = 1.0f/(m[0][3]*vIn.x + m[1][3]*vIn.y + m[2][3]*vIn.z + m[3][3]);
		rs.x *= w;
		rs.y *= w;
		rs.z *= w;
	}
	inline void Matrix4::TransformHomogeneous2D(Vec2 & rs, const Vec3 & vIn) const
	{
		rs.x = m[0][0]*vIn.x + m[1][0]*vIn.y + m[2][0]*vIn.z + m[3][0];
		rs.y = m[0][1]*vIn.x + m[1][1]*vIn.y + m[2][1]*vIn.z + m[3][1];
		float w = 1.0f/(m[0][3]*vIn.x + m[1][3]*vIn.y + m[2][3]*vIn.z + m[3][3]);
		rs.x *= w;
		rs.y *= w;
	}
	inline void Matrix4::TransformNormal(Vec3 & rs, const Vec3& vIn) const
	{
		rs.x = m[0][0]*vIn.x + m[1][0]*vIn.y + m[2][0]*vIn.z;
		rs.y = m[0][1]*vIn.x + m[1][1]*vIn.y + m[2][1]*vIn.z;
		rs.z = m[0][2]*vIn.x + m[1][2]*vIn.y + m[2][2]*vIn.z;
	}
	inline void Matrix4::Transform(Vec4 & rs, const Vec4& vIn) const
	{
		rs.x = m[0][0]*vIn.x + m[1][0]*vIn.y + m[2][0]*vIn.z + m[3][0]*vIn.w;
		rs.y = m[0][1]*vIn.x + m[1][1]*vIn.y + m[2][1]*vIn.z + m[3][1]*vIn.w;
		rs.z = m[0][2]*vIn.x + m[1][2]*vIn.y + m[2][2]*vIn.z + m[3][2]*vIn.w;
		rs.w = m[0][3]*vIn.x + m[1][3]*vIn.y + m[2][3]*vIn.z + m[3][3]*vIn.w;
	}
	inline void Matrix4::MultiplyFPU(Matrix4 &mOut, const Matrix4& M1, const Matrix4& M2)
	{
		Matrix4 TempMat;
		for (int i=0;i<4;i++) //col
		{
			for (int j=0;j<4;j++) // row
			{
				TempMat.m[i][j] = M1.m[0][j]*M2.m[i][0] + M1.m[1][j]*M2.m[i][1] + M1.m[2][j]*M2.m[i][2] + M1.m[3][j]*M2.m[i][3];
			}
		}
		memcpy(&mOut,&TempMat,sizeof(Matrix4));
	}

	inline void Matrix4::Multiply(Matrix4 &mOut, const Matrix4 &M1, const Matrix4 &M2)
	{
		Matrix4 rs;
		Matrix4_M128 TempMat;
		Matrix4_M128 mA(M1);
		mA.Multiply(TempMat, M2);
		TempMat.ToMatrix4(rs);
		mOut = rs;
	}
	inline float Matrix4::Inverse(Matrix4 &mOut_d) const
	{
		Matrix4 mat;
		Matrix4_M128 m_m(*this);
		Matrix4_M128 tmr;
		float rs = m_m.Inverse(tmr);
		tmr.ToMatrix4(mat);
		mOut_d = mat;
		return rs;
	}

	// Matrix4_M128

	inline void Matrix4_M128::ToMatrix4(Matrix4 & mOut) const
	{
		_mm_storeu_ps(mOut.values, C1);
		_mm_storeu_ps(mOut.values+4, C2);
		_mm_storeu_ps(mOut.values+8, C3);
		_mm_storeu_ps(mOut.values+12, C4);
	}
	inline void Matrix4_M128::Transform(Vec4_M128 & rs, const Vec4& vIn) const
	{
		__m128 r;
		r = _mm_mul_ps(C1, _mm_set_ps1(vIn.x));
		r = _mm_add_ps(r, _mm_mul_ps(C2, _mm_set_ps1(vIn.y)));
		r = _mm_add_ps(r, _mm_mul_ps(C3, _mm_set_ps1(vIn.z)));
		r = _mm_add_ps(r, _mm_mul_ps(C4, _mm_set_ps1(vIn.w)));
		rs.vec = r;
	}
	inline void Matrix4_M128::Transform(Vec4 & rs, const Vec4& vIn) const
	{
		Vec4_M128 r;
		Transform(r, vIn);
		_mm_store_ps((float*)&rs, r.vec);
	}
	inline void Matrix4_M128::Transform(Vec4_M128 & rs, const Vec3& vIn) const
	{
		__m128 r;
		r = _mm_mul_ps(C1, _mm_set_ps1(vIn.x));
		r = _mm_add_ps(r, _mm_mul_ps(C2, _mm_set_ps1(vIn.y)));
		r = _mm_add_ps(r, _mm_mul_ps(C3, _mm_set_ps1(vIn.z)));
		rs.vec = r;
	}
	inline void Matrix4_M128::Transform(Vec3 & rs, const Vec3& vIn) const
	{
		Vec4_M128 r;
		Transform(r, vIn);
		Vec4 tmp;
		_mm_store_ps((float*)&tmp, r.vec);
		rs.x = tmp.x;
		rs.y = tmp.y;
		rs.z = tmp.z;
	}
	inline void Matrix4_M128::Transform(Vec4_M128 & rs, const Vec4_M128& vIn) const
	{
		__m128 r;
		__m128 x,y,z,w;
		x = _mm_shuffle_ps(vIn.vec, vIn.vec, _MM_SHUFFLE(0, 0, 0, 0));
		r = _mm_mul_ps(C1, x);
		y = _mm_shuffle_ps(vIn.vec, vIn.vec, _MM_SHUFFLE(1, 1, 1, 1));
		r = _mm_add_ps(r, _mm_mul_ps(C2, y));
		z = _mm_shuffle_ps(vIn.vec, vIn.vec, _MM_SHUFFLE(2, 2, 2, 2));
		r = _mm_add_ps(r, _mm_mul_ps(C3, z));
		w = _mm_shuffle_ps(vIn.vec, vIn.vec, _MM_SHUFFLE(3, 3, 3, 3));
		r = _mm_add_ps(r, _mm_mul_ps(C4, w));
		rs.vec = r;
	}
	inline void Matrix4_M128::TransformNormal(Vec4_M128 & rs, const Vec4& vIn) const
	{
		__m128 r;
		r = _mm_mul_ps(C1, _mm_set_ps1(vIn.x));
		r = _mm_add_ps(r, _mm_mul_ps(C2, _mm_set_ps1(vIn.y)));
		r = _mm_add_ps(r, _mm_mul_ps(C3, _mm_set_ps1(vIn.z)));
		rs.vec = r;
	}
	inline void Matrix4_M128::TransformNormal(Vec4 & rs, const Vec4& vIn) const
	{
		Vec4_M128 r;
		TransformNormal(r, vIn);
		_mm_store_ps((float*)&rs, r.vec);
		rs.w = 0.0f;
	}
	inline void Matrix4_M128::TransformNormal(Vec4_M128 & rs, const Vec3& vIn) const
	{
		__m128 r;
		r = _mm_mul_ps(C1, _mm_set_ps1(vIn.x));
		r = _mm_add_ps(r, _mm_mul_ps(C2, _mm_set_ps1(vIn.y)));
		r = _mm_add_ps(r, _mm_mul_ps(C3, _mm_set_ps1(vIn.z)));
		rs.vec = r;
	}
	inline void Matrix4_M128::TransformNormal(Vec3 & rs, const Vec3& vIn) const
	{
		Vec4_M128 r;
		TransformNormal(r, vIn);
		Vec4 tmp;
		_mm_store_ps((float*)&tmp, r.vec);
		rs = tmp.xyz();
	}
	inline void Matrix4_M128::Multiply(Matrix4_M128 & rs, const Matrix4 & mB) const
	{
		__m128 T0, T1, T2, T3, R0, R1, R2, R3;
		T0 = _mm_set_ps1(mB.values[0]);
		T1 = _mm_set_ps1(mB.values[1]);
		T2 = _mm_set_ps1(mB.values[2]);
		T3 = _mm_set_ps1(mB.values[3]);
		R0 = _mm_mul_ps(C1, T0);
		T0 = _mm_set_ps1(mB.values[4]);
		R1 = _mm_mul_ps(C2, T1);
		R1 = _mm_add_ps(R1, R0);
		R2 = _mm_mul_ps(C3, T2);
		T1 = _mm_set_ps1(mB.values[5]);
		R3 = _mm_mul_ps(C4, T3);
		R2 = _mm_add_ps(R2, R1);
		T2 = _mm_set_ps1(mB.values[6]);
		rs.C1 = _mm_add_ps(R3, R2);
		R0 = _mm_mul_ps(C1, T0);
		T3 = _mm_set_ps1(mB.values[7]);
		R1 = _mm_mul_ps(C2, T1);
		T0 = _mm_set_ps1(mB.values[8]);
		R2 = _mm_mul_ps(C3, T2);
		R1 = _mm_add_ps(R1, R0);
		T1 = _mm_set_ps1(mB.values[9]);
		R3 = _mm_mul_ps(C4, T3);
		R2 = _mm_add_ps(R2, R1);
		rs.C2 = _mm_add_ps(R3, R2);
		T2 = _mm_set_ps1(mB.values[10]);
		R0 = _mm_mul_ps(C1, T0);
		T3 = _mm_set_ps1(mB.values[11]);
		R1 = _mm_mul_ps(C2, T1);
		T0 = _mm_set_ps1(mB.values[12]);
		R2 = _mm_mul_ps(C3, T2);
		R1 = _mm_add_ps(R1, R0);
		T2 = _mm_set_ps1(mB.values[14]);
		R3 = _mm_mul_ps(C4, T3);
		R2 = _mm_add_ps(R2, R1);
		T1 = _mm_set_ps1(mB.values[13]);
		rs.C3 = _mm_add_ps(R3, R2);
		R0 = _mm_mul_ps(C1, T0);
		R1 = _mm_mul_ps(C2, T1);
		T3 = _mm_set_ps1(mB.values[15]);
		R2 = _mm_mul_ps(C3, T2);
		R1 = _mm_add_ps(R1, R0);
		R3 = _mm_mul_ps(C4, T3);
		R2 = _mm_add_ps(R2, R1);
		rs.C4 = _mm_add_ps(R3, R2);
	}
	inline void Matrix4_M128::Multiply(Matrix4_M128 & rs, const Matrix4_M128 & mB) const
	{
		__m128 T0, T1, T2, T3, R0, R1, R2, R3;
		T0 = _mm_shuffle_ps(mB.C1, mB.C1, _MM_SHUFFLE(0,0,0,0));
		T1 = _mm_shuffle_ps(mB.C1, mB.C1, _MM_SHUFFLE(1,1,1,1));
		T2 = _mm_shuffle_ps(mB.C1, mB.C1, _MM_SHUFFLE(2,2,2,2));
		T3 = _mm_shuffle_ps(mB.C1, mB.C1, _MM_SHUFFLE(3,3,3,3));
		R0 = _mm_mul_ps(C1, T0);
		R1 = _mm_mul_ps(C2, T1);
		R2 = _mm_mul_ps(C3, T2);
		R3 = _mm_mul_ps(C4, T3);
		R1 = _mm_add_ps(R1, R0);
		R2 = _mm_add_ps(R2, R1);
		rs.C1 = _mm_add_ps(R3, R2);

		T0 = _mm_shuffle_ps(mB.C2, mB.C2, _MM_SHUFFLE(0,0,0,0));
		T1 = _mm_shuffle_ps(mB.C2, mB.C2, _MM_SHUFFLE(1,1,1,1));
		T2 = _mm_shuffle_ps(mB.C2, mB.C2, _MM_SHUFFLE(2,2,2,2));
		T3 = _mm_shuffle_ps(mB.C2, mB.C2, _MM_SHUFFLE(3,3,3,3));
		R0 = _mm_mul_ps(C1, T0);
		R1 = _mm_mul_ps(C2, T1);
		R2 = _mm_mul_ps(C3, T2);
		R3 = _mm_mul_ps(C4, T3);
		R1 = _mm_add_ps(R1, R0);
		R2 = _mm_add_ps(R2, R1);
		rs.C2 = _mm_add_ps(R3, R2);

		T0 = _mm_shuffle_ps(mB.C3, mB.C3, _MM_SHUFFLE(0,0,0,0));
		T1 = _mm_shuffle_ps(mB.C3, mB.C3, _MM_SHUFFLE(1,1,1,1));
		T2 = _mm_shuffle_ps(mB.C3, mB.C3, _MM_SHUFFLE(2,2,2,2));
		T3 = _mm_shuffle_ps(mB.C3, mB.C3, _MM_SHUFFLE(3,3,3,3));
		R0 = _mm_mul_ps(C1, T0);
		R1 = _mm_mul_ps(C2, T1);
		R2 = _mm_mul_ps(C3, T2);
		R3 = _mm_mul_ps(C4, T3);
		R1 = _mm_add_ps(R1, R0);
		R2 = _mm_add_ps(R2, R1);
		rs.C3 = _mm_add_ps(R3, R2);

		T0 = _mm_shuffle_ps(mB.C4, mB.C4, _MM_SHUFFLE(0,0,0,0));
		T1 = _mm_shuffle_ps(mB.C4, mB.C4, _MM_SHUFFLE(1,1,1,1));
		T2 = _mm_shuffle_ps(mB.C4, mB.C4, _MM_SHUFFLE(2,2,2,2));
		T3 = _mm_shuffle_ps(mB.C4, mB.C4, _MM_SHUFFLE(3,3,3,3));
		R0 = _mm_mul_ps(C1, T0);
		R1 = _mm_mul_ps(C2, T1);
		R2 = _mm_mul_ps(C3, T2);
		R3 = _mm_mul_ps(C4, T3);
		R1 = _mm_add_ps(R1, R0);
		R2 = _mm_add_ps(R2, R1);
		rs.C4 = _mm_add_ps(R3, R2);
	}

	inline void CartesianToSphere(const Vec3 & dir, float & u, float & v)
	{
		const float inv2Pi = 0.5f/PI;
		v = acos(dir.y);
		u = atan2(dir.z, dir.x);
		if (u<0.0f)
			u += PI * 2.0f;
		u *= inv2Pi;
		v *= 1.0f/PI;
	}

	inline void SphereToCartesian(Vec3 & dir, float u, float v)
	{
		dir.y = cos(v);
		float s = sin(v);
		dir.x = cos(u) * s;
		dir.z = sin(u) * s;
	}

	inline void GetOrthoVec(Vec3 & vout, const Vec3 & vin)
	{
		Vec3 absV = Vec3::Create(abs(vin.x), abs(vin.y), abs(vin.z));
		if (absV.x <= absV.y && absV.x <= absV.z)
			Vec3::Cross(vout, vin, Vec3::Create(1.0f, 0.0f, 0.0f));
		else if (absV.y <= absV.x && absV.y <= absV.z)
			Vec3::Cross(vout, vin, Vec3::Create(0.0f, 1.0f, 0.0f));
		else
			Vec3::Cross(vout, vin, Vec3::Create(0.0f, 0.0f, 1.0f));
	}

	template<typename T>
	inline T CatmullInterpolate(const T & p0, const T & p1, const T & p2, const T & p3, float t)
	{
		float t2 = t * t;
		float t3 = t2 * t;
		return (p1 * 2.0f + (-p0 + p2) * t +
			(p0 * 2.0f - p1 * 5.0f + p2 * 4.0f - p3) * t2 +
			(-p0 + p1 * 3.0f - p2 * 3.0f + p3) * t3) * 0.5f;
	}
#ifdef _MSC_VER
#ifndef __clang__
#ifndef M128_OPERATOR_OVERLOADS
#define M128_OPERATOR_OVERLOADS
	inline __m128 & operator += (__m128 & v0, const __m128 &v1)
	{
		v0 = _mm_add_ps(v0, v1);
		return v0;
	}
	inline __m128 & operator -= (__m128 & v0, const __m128 &v1)
	{
		v0 = _mm_sub_ps(v0, v1);
		return v0;
	}
	inline __m128 & operator *= (__m128 & v0, const __m128 &v1)
	{
		v0 = _mm_mul_ps(v0, v1);
		return v0;
	}
	inline __m128 & operator /= (__m128 & v0, const __m128 &v1)
	{
		v0 = _mm_div_ps(v0, v1);
		return v0;
	}
	inline __m128 operator + (const __m128 & v0, const __m128 & v1)
	{
		return _mm_add_ps(v0, v1);
	}
	inline __m128 operator - (const __m128 & v0, const __m128 & v1)
	{
		return _mm_sub_ps(v0, v1);
	}
	inline __m128 operator * (const __m128 & v0, const __m128 & v1)
	{
		return _mm_mul_ps(v0, v1);
	}
	inline __m128 operator / (const __m128 & v0, const __m128 & v1)
	{
		return _mm_div_ps(v0, v1);
	}
	inline __m128 operator - (const __m128 & v0)
	{
		static const __m128 SIGNMASK = 
               _mm_castsi128_ps(_mm_set1_epi32(0x80000000));
		return _mm_xor_ps(v0, SIGNMASK);
	}

	inline __m128i & operator += (__m128i & v0, const __m128i &v1)
	{
		v0 = _mm_add_epi32(v0, v1);
		return v0;
	}
	inline __m128i & operator -= (__m128i & v0, const __m128i &v1)
	{
		v0 = _mm_sub_epi32(v0, v1);
		return v0;
	}
	inline __m128i & operator *= (__m128i & v0, const __m128i &v1)
	{
		v0 = _mm_mul_epi32(v0, v1);
		return v0;
	}
	inline __m128i operator + (const __m128i & v0, const __m128i & v1)
	{
		return _mm_add_epi32(v0, v1);
	}
	inline __m128i operator - (const __m128i & v0, const __m128i & v1)
	{
		return _mm_sub_epi32(v0, v1);
	}
	inline __m128i operator * (const __m128i & v0, const __m128i & v1)
	{
		return _mm_mullo_epi32(v0, v1);
	}
	inline __m128i operator - (const __m128i & v0)
	{
		return _mm_xor_si128(v0, _mm_set1_epi32(0xFFFFFFFF));
	}
#endif
#endif
	_declspec(align(16))
	class SSEVec3
	{
	public:
		__m128 x,y,z;
		SSEVec3()
		{};
		SSEVec3(__m128 x, __m128 y, __m128 z)
			:x(x), y(y), z(z)
		{
		}
		SSEVec3(const Vec3 &v)
		{
			this->x = _mm_set_ps1(v.x);
			this->y = _mm_set_ps1(v.y);
			this->z = _mm_set_ps1(v.z);
		}
		SSEVec3(float x, float y, float z)
		{
			this->x = _mm_set_ps1(x);
			this->y = _mm_set_ps1(y);
			this->z = _mm_set_ps1(z);
		}
		inline __m128 Length()
		{
			return _mm_sqrt_ps(x*x + y*y + z*z);
		}
		inline void Normalize(__m128 one)
		{
			auto s = one / Length();
			x *= s;
			y *= s;
			z *= s;
		}
		inline SSEVec3 operator + (const SSEVec3 &vin)
		{
			SSEVec3 rs;
			rs.x = x + vin.x;
			rs.y = y + vin.y;
			rs.z = z + vin.z;
			return rs;
		}
		inline SSEVec3 operator - (const SSEVec3 &vin)
		{
			SSEVec3 rs;
			rs.x = x - vin.x;
			rs.y = y - vin.y;
			rs.z = z - vin.z;
			return rs;
		}
		inline SSEVec3 operator - ()
		{
			SSEVec3 rs;
			rs.x = -x;
			rs.y = -y;
			rs.z = -z;
			return rs;
		}
		inline SSEVec3 operator * (__m128 scale)
		{
			SSEVec3 rs;
			rs.x = x * scale;
			rs.y = y * scale;
			rs.z = z * scale;
			return rs;
		}
		inline SSEVec3 & operator += (const SSEVec3 & vin)
		{
			x += vin.x; y += vin.y; z += vin.z;
			return *this;
		}
		inline SSEVec3 & operator -= (const SSEVec3 & vin)
		{
			x -= vin.x; y -= vin.y; z -= vin.z; 
			return *this;
		}
		inline SSEVec3 & operator *= (const SSEVec3 & vin)
		{
			x *= vin.x; y *= vin.y; z *= vin.z;
			return *this;
		}
		inline SSEVec3 & operator *= (__m128 s)
		{
			x *= s; y *= s; z *= s;
			return *this;
		}
		inline SSEVec3 & operator /= (const SSEVec3 & vin)
		{
			x /= vin.x; y /= vin.y; z /= vin.z;
			return *this;
		}
		inline SSEVec3 & operator /= (float s)
		{
			float inv = 1.0f/s;
			return (*this)*=_mm_set_ps1(inv);
		}

		inline static __m128 Dot(const SSEVec3 & v1, const SSEVec3 & v2)
		{
			return v1.x*v2.x + v1.y*v2.y + v1.z*v2.z;
		}
		inline static void Cross(SSEVec3 & rs_d, const SSEVec3 & v1, const SSEVec3 & v2)
		{
			rs_d.x = v1.y*v2.z - v1.z * v2.y;
			rs_d.y = v1.z*v2.x - v1.x * v2.z;
			rs_d.z = v1.x*v2.y - v1.y * v2.x;
		}
	};

	_declspec(align(16))
	class SSEVec4
	{
	public:
		__m128 x, y, z, w;
		SSEVec4()
		{};
		SSEVec4(const __m128 & x, const __m128 & y, const __m128 & z, const __m128 & w)
			:x(x), y(y), z(z), w(w)
		{
		}
		SSEVec4(const Vec4 &v)
		{
			this->x = _mm_set_ps1(v.x);
			this->y = _mm_set_ps1(v.y);
			this->z = _mm_set_ps1(v.z);
			this->w = _mm_set_ps1(v.w);
		}
		SSEVec4(float x, float y, float z, float w)
		{
			this->x = _mm_set_ps1(x);
			this->y = _mm_set_ps1(y);
			this->z = _mm_set_ps1(z);
			this->w = _mm_set_ps1(w);
		}
		inline __m128 Length()
		{
			return _mm_sqrt_ps(x*x + y*y + z*z + w*w);
		}
		inline void Normalize(__m128 one)
		{
			auto s = one / Length();
			x *= s;
			y *= s;
			z *= s;
			w *= s;
		}
		inline SSEVec4 operator + (const SSEVec4 &vin)
		{
			SSEVec4 rs;
			rs.x = x + vin.x;
			rs.y = y + vin.y;
			rs.z = z + vin.z;
			rs.w = w + vin.w;
			return rs;
		}
		inline SSEVec4 operator - (const SSEVec4 &vin)
		{
			SSEVec4 rs;
			rs.x = x - vin.x;
			rs.y = y - vin.y;
			rs.z = z - vin.z;
			rs.w = w - vin.w;
			return rs;
		}
		inline SSEVec4 operator - ()
		{
			SSEVec4 rs;
			rs.x = -x;
			rs.y = -y;
			rs.z = -z;
			rs.w = -w;
			return rs;
		}
		inline SSEVec4 operator * (__m128 scale)
		{
			SSEVec4 rs;
			rs.x = x * scale;
			rs.y = y * scale;
			rs.z = z * scale;
			rs.w = w * scale;
			return rs;
		}
		inline SSEVec4 & operator += (const SSEVec4 & vin)
		{
			x += vin.x; y += vin.y; z += vin.z; w += vin.w;
			return *this;
		}
		inline SSEVec4 & operator -= (const SSEVec4 & vin)
		{
			x -= vin.x; y -= vin.y; z -= vin.z; w -= vin.w;
			return *this;
		}
		inline SSEVec4 & operator *= (const SSEVec4 & vin)
		{
			x *= vin.x; y *= vin.y; z *= vin.z; w *= vin.w;
			return *this;
		}
		inline SSEVec4 & operator *= (__m128 s)
		{
			x *= s; y *= s; z *= s; w *= s;
			return *this;
		}
		inline SSEVec4 & operator /= (const SSEVec4 & vin)
		{
			x /= vin.x; y /= vin.y; z /= vin.z; w /= vin.w;
			return *this;
		}
		inline SSEVec4 & operator /= (float s)
		{
			float inv = 1.0f / s;
			return (*this) *= _mm_set_ps1(inv);
		}

		inline static __m128 Dot(const SSEVec4 & v1, const SSEVec4 & v2)
		{
			return v1.x*v2.x + v1.y*v2.y + v1.z*v2.z + v1.w*v2.w;
		}
	};

	_declspec(align(16))
	class SSEMatrix4
	{
	public:
		__m128 values[16];
		SSEMatrix4()
		{}
		SSEMatrix4(const Matrix4 & mat)
		{
			for (int i = 0; i<16; i++)
				values[i] = _mm_set_ps1(mat.values[i]);
		}
		inline SSEVec3 Transform(SSEVec3 & v)
		{
			SSEVec3 rs;
			rs.x = values[0]*v.x + values[4]*v.y + values[8]*v.z + values[12];
			rs.y = values[1]*v.x + values[5]*v.y + values[9]*v.z + values[13];
			rs.z = values[2]*v.x + values[6]*v.y + values[10]*v.z + values[14];
			auto w = values[3]*v.x + values[7]*v.y + values[11]*v.z + values[15];
			w = _mm_set_ps1(1.0f) / w;
			rs.x *= w;
			rs.y *= w;
			rs.z *= w;
			return rs;
		}
		inline SSEVec3 TransformNonPerspective(SSEVec3 & v)
		{
			SSEVec3 rs;
			rs.x = values[0]*v.x + values[4]*v.y + values[8]*v.z + values[12];
			rs.y = values[1]*v.x + values[5]*v.y + values[9]*v.z + values[13];
			rs.z = values[2]*v.x + values[6]*v.y + values[10]*v.z + values[14];
			return rs;
		}
	};
#endif

	class Vec2i
	{
	public:
		int x, y;
		static Vec2i Create(int px, int py)
		{
			Vec2i rs;
			rs.x = px;
			rs.y = py;
			return rs;
		}
	};

	class Vec3i
	{
	public:
		int x, y, z;
		static Vec3i Create(int px, int py, int pz)
		{
			Vec3i rs;
			rs.x = px;
			rs.y = py;
			rs.z = pz;
			return rs;
		}
	};

	class Vec4i
	{
	public:
		int x, y, z, w;
		static Vec4i Create(int px, int py, int pz, int pw)
		{
			Vec4i rs;
			rs.x = px;
			rs.y = py;
			rs.z = pz;
			rs.w = pw;
			return rs;
		}
	};
}

#endif
/***********************************************************************

Spire - The MIT License (MIT)
Copyright (c) 2016, Carnegie Mellon University

Developers: Yong He, Haomin Long

Permission is hereby granted, free of charge, to any person obtaining a 
copy of this software and associated documentation files (the "Software"), 
to deal in the Software without restriction, including without limitation 
the rights to use, copy, modify, merge, publish, distribute, sublicense, 
and/or sell copies of the Software, and to permit persons to whom the 
Software is furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in 
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR 
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, 
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL 
THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER 
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING 
FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER 
DEALINGS IN THE SOFTWARE.


========================================================================
WARNING: THIS FILE IS AUTOMATICALLY GENERATED. DO NOT MODIFY
***********************************************************************/
#include "Spire.h"

/***********************************************************************
SPIRECORE\CLIKECODEGEN.CPP
***********************************************************************/

using namespace CoreLib::Basic;

namespace Spire
{
	namespace Compiler
	{
		ILRecordType * ExtractRecordType(ILType * type)
		{
			if (auto recType = dynamic_cast<ILRecordType*>(type))
				return recType;
			else if (auto arrType = dynamic_cast<ILArrayType*>(type))
				return ExtractRecordType(arrType->BaseType.Ptr());
			else if (auto genType = dynamic_cast<ILGenericType*>(type))
				return ExtractRecordType(genType->BaseType.Ptr());
			else
				return nullptr;
		}

		String AddWorldNameSuffix(String name, String suffix)
		{
			if (name.EndsWith(suffix))
				return name;
			else
				return EscapeDoubleUnderscore(name + L"_" + suffix);
		}


		void CLikeCodeGen::Error(int errId, String msg, CodePosition pos)
		{
			errWriter->Error(errId, msg, pos);
		}

		void CLikeCodeGen::PrintType(StringBuilder & sbCode, ILType* type)
		{
			if (dynamic_cast<ILRecordType*>(type))
				PrintType(sbCode, currentImportInstr->Type.Ptr());
			else
				PrintTypeName(sbCode, type);
		}

		void CLikeCodeGen::PrintDef(StringBuilder & sbCode, ILType* type, const String & name)
		{
			PrintType(sbCode, type);
			sbCode << L" ";
			sbCode << name;
			if (name.Length() == 0)
				throw InvalidProgramException(L"unnamed instruction.");
		}

		String CLikeCodeGen::GetFunctionCallName(String name)
		{
			StringBuilder rs;
			for (int i = 0; i < name.Length(); i++)
			{
				if ((name[i] >= L'a' && name[i] <= L'z') || (name[i] >= L'A' && name[i] <= L'Z') || 
					name[i] == L'_' || (name[i] >= L'0' && name[i] <= L'9'))
				{
					rs << name[i];
				}
				else if (i != name.Length() - 1)
					rs << L'_';
			}
			return rs.ProduceString();
		}

		String CLikeCodeGen::GetFuncOriginalName(const String & name)
		{
			String originalName;
			int splitPos = name.IndexOf(L'@');
			if (splitPos == 0)
				return name;
			if (splitPos != -1)
				originalName = name.SubString(0, splitPos);
			else
				originalName = name;
			return originalName;
		}

		void CLikeCodeGen::PrintOp(CodeGenContext & ctx, ILOperand * op, bool forceExpression)
		{
			auto makeFloat = [](float v)
			{
				String rs(v, L"%.12e");
				if (!rs.Contains(L'.') && !rs.Contains(L'e') && !rs.Contains(L'E'))
					rs = rs + L".0";
				if (rs.StartsWith(L"-"))
					rs = L"(" + rs + L")";
				return rs;
			};
			if (auto c = dynamic_cast<ILConstOperand*>(op))
			{
				auto type = c->Type.Ptr();
				if (type->IsFloat())
					ctx.Body << makeFloat(c->FloatValues[0]);
				else if (type->IsInt())
					ctx.Body << (c->IntValues[0]);
				else if (type->IsBool())
					ctx.Body << ((c->IntValues[0] != 0) ? L"true" : L"false");
				else if (auto baseType = dynamic_cast<ILBasicType*>(type))
				{
					PrintType(ctx.Body, baseType);
					ctx.Body << "(";

					if (baseType->Type == ILBaseType::Float2)
						ctx.Body << makeFloat(c->FloatValues[0]) << L", " << makeFloat(c->FloatValues[1]);
					else if (baseType->Type == ILBaseType::Float3)
						ctx.Body << makeFloat(c->FloatValues[0]) << L", " << makeFloat(c->FloatValues[1]) << L", " << makeFloat(c->FloatValues[2]);
					else if (baseType->Type == ILBaseType::Float4)
						ctx.Body << makeFloat(c->FloatValues[0]) << L", " << makeFloat(c->FloatValues[1]) << L", " << makeFloat(c->FloatValues[2]) << L", " << makeFloat(c->FloatValues[3]);
					else if (baseType->Type == ILBaseType::Float3x3)
					{
						ctx.Body << L"mat3(";
						for (int i = 0; i < 9; i++)
						{
							ctx.Body << makeFloat(c->FloatValues[i]);
							if (i != 8)
								ctx.Body << L", ";
						}
						ctx.Body;
					}
					else if (baseType->Type == ILBaseType::Float4x4)
					{
						for (int i = 0; i < 16; i++)
						{
							ctx.Body << makeFloat(c->FloatValues[i]);
							if (i != 15)
								ctx.Body << L", ";
						}
					}
					else if (baseType->Type == ILBaseType::Int2)
						ctx.Body << c->IntValues[0] << L", " << c->IntValues[1];
					else if (baseType->Type == ILBaseType::Int3)
						ctx.Body << c->IntValues[0] << L", " << c->IntValues[1] << L", " << c->IntValues[2];
					else if (baseType->Type == ILBaseType::Int4)
						ctx.Body << c->IntValues[0] << L", " << c->IntValues[1] << L", " << c->IntValues[2] << L", " << c->IntValues[3];

					ctx.Body << ")";
				}
				else
					throw InvalidOperationException(L"Illegal constant.");
			}
			else if (auto instr = dynamic_cast<ILInstruction*>(op))
			{
				if (AppearAsExpression(*instr, forceExpression))
				{
					PrintInstrExpr(ctx, *instr);
				}
				else
				{
					if (forceExpression)
						throw InvalidProgramException(L"cannot generate code block as an expression.");
					String substituteName;
					if (ctx.SubstituteNames.TryGetValue(instr->Name, substituteName))
						ctx.Body << substituteName;
					else
						ctx.Body << instr->Name;
				}
			}
			else
				throw InvalidOperationException(L"Unsupported operand type.");
		}

		static bool IsMatrix(ILOperand* operand)
		{
			auto type = operand->Type;
			// TODO(tfoley): This needs to be expanded once other matrix types are supported
			return type->IsFloatMatrix();
		}

		void CLikeCodeGen::PrintMatrixMulInstrExpr(CodeGenContext & ctx, ILOperand* op0, ILOperand* op1)
		{
			ctx.Body << L"(";
			PrintOp(ctx, op0);
			ctx.Body << L" * ";
			PrintOp(ctx, op1);
			ctx.Body << L")";
		}

		void CLikeCodeGen::PrintBinaryInstrExpr(CodeGenContext & ctx, BinaryInstruction * instr)
		{
			if (instr->Is<StoreInstruction>())
			{
				auto op0 = instr->Operands[0].Ptr();
				auto op1 = instr->Operands[1].Ptr();
				ctx.Body << L"(";
				PrintOp(ctx, op0);
				ctx.Body << L" = ";
				PrintOp(ctx, op1);
				ctx.Body << L")";
				return;
			}
			auto op0 = instr->Operands[0].Ptr();
			auto op1 = instr->Operands[1].Ptr();
			if (instr->Is<StoreInstruction>())
			{
				throw InvalidOperationException(L"store instruction cannot appear as expression.");
			}
			if (instr->Is<MemberLoadInstruction>())
			{
				auto genType = dynamic_cast<ILGenericType*>(op0->Type.Ptr());
				if (genType && genType->GenericTypeName == L"PackedBuffer")
				{
					// load record type from packed buffer
					String conversionFunction;
					int size = 0;
					if (instr->Type->ToString() == L"int")
					{
						conversionFunction = L"floatBitsToInt";
						size = 1;
					}
					else if (instr->Type->ToString() == L"ivec2")
					{
						conversionFunction = L"floatBitsToInt";
						size = 2;
					}
					else if (instr->Type->ToString() == L"ivec3")
					{
						conversionFunction = L"floatBitsToInt";
						size = 3;
					}
					else if (instr->Type->ToString() == L"ivec4")
					{
						conversionFunction = L"floatBitsToInt";
						size = 4;
					}
					else if (instr->Type->ToString() == L"uint")
					{
						conversionFunction = L"floatBitsToUint";
						size = 1;
					}
					else if (instr->Type->ToString() == L"uvec2")
					{
						conversionFunction = L"floatBitsToUint";
						size = 2;
					}
					else if (instr->Type->ToString() == L"uvec3")
					{
						conversionFunction = L"floatBitsToUint";
						size = 3;
					}
					else if (instr->Type->ToString() == L"uvec4")
					{
						conversionFunction = L"floatBitsToUint";
						size = 4;
					}
					else if (instr->Type->ToString() == L"float")
					{
						conversionFunction = L"";
						size = 1;
					}
					else if (instr->Type->ToString() == L"vec2")
					{
						conversionFunction = L"";
						size = 2;
					}
					else if (instr->Type->ToString() == L"vec3")
					{
						conversionFunction = L"";
						size = 3;
					}
					else if (instr->Type->ToString() == L"vec4")
					{
						conversionFunction = L"";
						size = 4;
					}
					else if (instr->Type->ToString() == L"mat3")
					{
						conversionFunction = L"";
						size = 9;
					}
					else if (instr->Type->ToString() == L"mat4")
					{
						conversionFunction = L"";
						size = 16;
					}
					else
					{
						errWriter->Error(50082, L"importing type '" + instr->Type->ToString() + L"' from PackedBuffer is not supported by the GLSL backend.",
							CodePosition());
					}
					ctx.Body << instr->Type->ToString() << L"(";
					auto recType = dynamic_cast<ILRecordType*>(genType->BaseType.Ptr());
					int recTypeSize = 0;
					EnumerableDictionary<String, int> memberOffsets;
					for (auto & member : recType->Members)
					{
						memberOffsets[member.Key] = recTypeSize;
						recTypeSize += member.Value.Type->GetVectorSize();
					}
					for (int i = 0; i < size; i++)
					{
						ctx.Body << conversionFunction << L"(";
						PrintOp(ctx, op0);
						ctx.Body << L"[(";
						PrintOp(ctx, op1);
						ctx.Body << L") * " << recTypeSize << L" + " << memberOffsets[currentImportInstr->ComponentName]() << L"])";
						if (i != size - 1)
							ctx.Body << L", ";
					}
					ctx.Body << L")";
				}
				else
				{
					PrintOp(ctx, op0);
					bool printDefault = true;
					if (op0->Type->IsVector())
					{
						if (auto c = dynamic_cast<ILConstOperand*>(op1))
						{
							switch (c->IntValues[0])
							{
							case 0:
								ctx.Body << L".x";
								break;
							case 1:
								ctx.Body << L".y";
								break;
							case 2:
								ctx.Body << L".z";
								break;
							case 3:
								ctx.Body << L".w";
								break;
							default:
								throw InvalidOperationException(L"Invalid member access.");
							}
							printDefault = false;
						}
					}
					else if (auto structType = dynamic_cast<ILStructType*>(op0->Type.Ptr()))
					{
						if (auto c = dynamic_cast<ILConstOperand*>(op1))
						{
							ctx.Body << L"." << structType->Members[c->IntValues[0]].FieldName;
						}
						printDefault = false;
					}
					if (printDefault)
					{
						ctx.Body << L"[";
						PrintOp(ctx, op1);
						ctx.Body << L"]";
					}
					if (genType)
					{
						if (genType->GenericTypeName == L"Buffer" && dynamic_cast<ILRecordType*>(genType->BaseType.Ptr()))
							ctx.Body << L"." << currentImportInstr->ComponentName;
					}
				}
				return;
			}
			const wchar_t * op = L"";
			if (instr->Is<AddInstruction>())
			{
				op = L"+";
			}
			else if (instr->Is<SubInstruction>())
			{
				op = L"-";
			}
			else if (instr->Is<MulInstruction>())
			{
				// For matrix-matrix, matrix-vector, and vector-matrix `*`,
				// GLSL performs a linear-algebraic inner product, while HLSL
				// always does element-wise product. We need to give the
				// codegen backend a change to handle this case.
				if(IsMatrix(op0) || IsMatrix(op1))
				{
					PrintMatrixMulInstrExpr(ctx, op0, op1);
					return;
				}

				op = L"*";
			}
			else if (instr->Is<DivInstruction>())
			{
				op = L"/";
			}
			else if (instr->Is<ModInstruction>())
			{
				op = L"%";
			}
			else if (instr->Is<ShlInstruction>())
			{
				op = L"<<";
			}
			else if (instr->Is<ShrInstruction>())
			{
				op = L">>";
			}
			else if (instr->Is<CmpeqlInstruction>())
			{
				op = L"==";
				//ctx.Body << L"int";
			}
			else if (instr->Is<CmpgeInstruction>())
			{
				op = L">=";
				//ctx.Body << L"int";
			}
			else if (instr->Is<CmpgtInstruction>())
			{
				op = L">";
				//ctx.Body << L"int";
			}
			else if (instr->Is<CmpleInstruction>())
			{
				op = L"<=";
				//ctx.Body << L"int";
			}
			else if (instr->Is<CmpltInstruction>())
			{
				op = L"<";
				//ctx.Body << L"int";
			}
			else if (instr->Is<CmpneqInstruction>())
			{
				op = L"!=";
				//ctx.Body << L"int";
			}
			else if (instr->Is<AndInstruction>())
			{
				op = L"&&";
			}
			else if (instr->Is<OrInstruction>())
			{
				op = L"||";
			}
			else if (instr->Is<BitXorInstruction>())
			{
				op = L"^";
			}
			else if (instr->Is<BitAndInstruction>())
			{
				op = L"&";
			}
			else if (instr->Is<BitOrInstruction>())
			{
				op = L"|";
			}
			else
				throw InvalidProgramException(L"unsupported binary instruction.");
			ctx.Body << L"(";
			PrintOp(ctx, op0);
			ctx.Body << L" " << op << L" ";
			PrintOp(ctx, op1);
			ctx.Body << L")";
		}

		void CLikeCodeGen::PrintBinaryInstr(CodeGenContext & ctx, BinaryInstruction * instr)
		{
			auto op0 = instr->Operands[0].Ptr();
			auto op1 = instr->Operands[1].Ptr();
			if (instr->Is<StoreInstruction>())
			{
				PrintOp(ctx, op0);
				ctx.Body << L" = ";
				PrintOp(ctx, op1);
				ctx.Body << L";\n";
				return;
			}
			auto varName = ctx.DefineVariable(instr);
			if (instr->Is<MemberLoadInstruction>())
			{
				ctx.Body << varName << L" = ";
				PrintBinaryInstrExpr(ctx, instr);
				ctx.Body << L";\n";
				return;
			}
			ctx.Body << varName << L" = ";
			PrintBinaryInstrExpr(ctx, instr);
			ctx.Body << L";\n";
		}

		void CLikeCodeGen::PrintUnaryInstrExpr(CodeGenContext & ctx, UnaryInstruction * instr)
		{
			auto op0 = instr->Operand.Ptr();
			if (instr->Is<LoadInstruction>())
			{
				PrintOp(ctx, op0);
				return;
			}
			else if (instr->Is<SwizzleInstruction>())
			{
				PrintSwizzleInstrExpr(ctx, instr->As<SwizzleInstruction>());
				return;
			}
			const wchar_t * op = L"";
			if (instr->Is<BitNotInstruction>())
				op = L"~";
			else if (instr->Is<Float2IntInstruction>())
				op = L"(int)";
			else if (instr->Is<Int2FloatInstruction>())
				op = L"(float)";
			else if (instr->Is<CopyInstruction>())
				op = L"";
			else if (instr->Is<NegInstruction>())
				op = L"-";
			else if (instr->Is<NotInstruction>())
				op = L"!";
			else
				throw InvalidProgramException(L"unsupported unary instruction.");
			ctx.Body << L"(" << op;
			PrintOp(ctx, op0);
			ctx.Body << L")";
		}

		void CLikeCodeGen::PrintUnaryInstr(CodeGenContext & ctx, UnaryInstruction * instr)
		{
			auto varName = ctx.DefineVariable(instr);
			ctx.Body << varName << L" = ";
			PrintUnaryInstrExpr(ctx, instr);
			ctx.Body << L";\n";
		}

		void CLikeCodeGen::PrintAllocVarInstrExpr(CodeGenContext & ctx, AllocVarInstruction * instr)
		{
			ctx.Body << instr->Name;
		}

		void CLikeCodeGen::PrintAllocVarInstr(CodeGenContext & ctx, AllocVarInstruction * instr)
		{
			if (dynamic_cast<ILConstOperand*>(instr->Size.Ptr()))
			{
				ctx.DefineVariable(instr);
			}
			else
				throw InvalidProgramException(L"size operand of allocVar instr is not an intermediate.");
		}

		void CLikeCodeGen::PrintFetchArgInstrExpr(CodeGenContext & ctx, FetchArgInstruction * instr)
		{
			ctx.Body << instr->Name;
		}

		void CLikeCodeGen::PrintFetchArgInstr(CodeGenContext & ctx, FetchArgInstruction * instr)
		{
			if (instr->ArgId == 0)
			{
				ctx.ReturnVarName = ctx.DefineVariable(instr);
			}
		}

		void CLikeCodeGen::PrintSelectInstrExpr(CodeGenContext & ctx, SelectInstruction * instr)
		{
			ctx.Body << L"(";
			PrintOp(ctx, instr->Operands[0].Ptr());
			ctx.Body << L"?";
			PrintOp(ctx, instr->Operands[1].Ptr());
			ctx.Body << L":";
			PrintOp(ctx, instr->Operands[2].Ptr());
			ctx.Body << L")";
		}

		void CLikeCodeGen::PrintSelectInstr(CodeGenContext & ctx, SelectInstruction * instr)
		{
			auto varName = ctx.DefineVariable(instr);
			ctx.Body << varName << L" = ";
			PrintSelectInstrExpr(ctx, instr);
			ctx.Body << L";\n";
		}

		String CLikeCodeGen::RemapFuncNameForTarget(String name)
		{
			return name;
		}

		void CLikeCodeGen::PrintCallInstrExpr(CodeGenContext & ctx, CallInstruction * instr)
		{
			String callName;
			callName = GetFuncOriginalName(instr->Function);
			callName = RemapFuncNameForTarget(callName);
			ctx.Body << callName;
			ctx.Body << L"(";
			int id = 0;
			for (auto & arg : instr->Arguments)
			{
				PrintOp(ctx, arg.Ptr());
				if (id != instr->Arguments.Count() - 1)
					ctx.Body << L", ";
				id++;
			}
			ctx.Body << L")";
		}

		void CLikeCodeGen::PrintCallInstr(CodeGenContext & ctx, CallInstruction * instr)
		{
			auto varName = ctx.DefineVariable(instr);
			ctx.Body << varName;
			ctx.Body << L" = ";
			PrintCallInstrExpr(ctx, instr);
			ctx.Body << L";\n";
		}

		void CLikeCodeGen::PrintCastF2IInstrExpr(CodeGenContext & ctx, Float2IntInstruction * instr)
		{
			ctx.Body << L"((int)(";
			PrintOp(ctx, instr->Operand.Ptr());
			ctx.Body << L"))";
		}
		void CLikeCodeGen::PrintCastF2IInstr(CodeGenContext & ctx, Float2IntInstruction * instr)
		{
			auto varName = ctx.DefineVariable(instr);
			ctx.Body << varName;
			ctx.Body << L" = ";
			PrintCastF2IInstrExpr(ctx, instr);
			ctx.Body << L";\n";
		}
		void CLikeCodeGen::PrintCastI2FInstrExpr(CodeGenContext & ctx, Int2FloatInstruction * instr)
		{
			ctx.Body << L"((float)(";
			PrintOp(ctx, instr->Operand.Ptr());
			ctx.Body << L"))";
		}
		void CLikeCodeGen::PrintCastI2FInstr(CodeGenContext & ctx, Int2FloatInstruction * instr)
		{
			auto varName = ctx.DefineVariable(instr);
			ctx.Body << varName;
			ctx.Body << L" = ";
			PrintCastI2FInstrExpr(ctx, instr);
			ctx.Body << L";\n";
		}

		bool CLikeCodeGen::AppearAsExpression(ILInstruction & instr, bool force)
		{
			if (instr.Is<LoadInputInstruction>())
				return true;
			if (auto arg = instr.As<FetchArgInstruction>())
			{
				if (arg->ArgId == 0)
					return false;
			}
			if (auto import = instr.As<ImportInstruction>())
			{
				if (!useBindlessTexture && import->Type->IsTexture() || import->Type.As<ILArrayType>())
					return true;
			}
			for (auto &&usr : instr.Users)
			{
				if (auto update = dynamic_cast<MemberUpdateInstruction*>(usr))
				{
					if (&instr == update->Operands[0].Ptr())
						return false;
				}
				else if (dynamic_cast<MemberLoadInstruction*>(usr))
					return false;
				else if (dynamic_cast<ExportInstruction*>(usr))
					return false;
				else if (dynamic_cast<ImportInstruction*>(usr))
					return false;
			}
			if (instr.Is<StoreInstruction>() && force)
				return true;

			return (instr.Users.Count() <= 1 && !instr.HasSideEffect() && !instr.Is<MemberUpdateInstruction>()
				&& !instr.Is<AllocVarInstruction>() && !instr.Is<ImportInstruction>())
				|| instr.Is<FetchArgInstruction>();
		}

		void CLikeCodeGen::PrintExportInstr(CodeGenContext &ctx, ExportInstruction * exportInstr)
		{
			outputStrategy->ProcessExportInstruction(ctx, exportInstr);
		}

		void CLikeCodeGen::PrintUpdateInstr(CodeGenContext & ctx, MemberUpdateInstruction * instr)
		{
			auto genCode = [&](String varName, ILType * srcType, ILOperand * op1, ILOperand * op2)
			{
				ctx.Body << varName;
				if (auto structType = dynamic_cast<ILStructType*>(srcType))
				{
					ctx.Body << L".";
					ctx.Body << structType->Members[dynamic_cast<ILConstOperand*>(op1)->IntValues[0]].FieldName;
				}
				else
				{
					ctx.Body << L"[";
					PrintOp(ctx, op1);
					ctx.Body << L"]";
				}
				ctx.Body << L" = ";
				PrintOp(ctx, op2);
				ctx.Body << L";\n";
			};
			if (auto srcInstr = dynamic_cast<ILInstruction*>(instr->Operands[0].Ptr()))
			{
				if (srcInstr->Users.Count() == 1)
				{
					auto srcName = srcInstr->Name;
					while (ctx.SubstituteNames.TryGetValue(srcName, srcName));
					genCode(srcName, srcInstr->Type.Ptr(), instr->Operands[1].Ptr(), instr->Operands[2].Ptr());
					ctx.SubstituteNames[instr->Name] = srcName;
					return;
				}
			}
			genCode(instr->Operands[0]->Name, instr->Operands[0]->Type.Ptr(), instr->Operands[1].Ptr(), instr->Operands[2].Ptr());
		}

		void CLikeCodeGen::PrintSwizzleInstrExpr(CodeGenContext & ctx, SwizzleInstruction * swizzle)
		{
			PrintOp(ctx, swizzle->Operand.Ptr());
			ctx.Body << L"." << swizzle->SwizzleString;
		}

		void CLikeCodeGen::PrintImportInstr(CodeGenContext & ctx, ImportInstruction * importInstr)
		{
			currentImportInstr = importInstr;
				
			ctx.DefineVariable(importInstr);
			GenerateCode(ctx, importInstr->ImportOperator.Ptr());
				
			currentImportInstr = nullptr;
		}

		void CLikeCodeGen::PrintImportInstrExpr(CodeGenContext & ctx, ImportInstruction * importInstr)
		{
			currentImportInstr = importInstr;
			PrintOp(ctx, importInstr->ImportOperator->GetLastInstruction()->As<ReturnInstruction>()->Operand.Ptr());
			currentImportInstr = nullptr;
		}

		void CLikeCodeGen::PrintInstrExpr(CodeGenContext & ctx, ILInstruction & instr)
		{
			if (auto binInstr = instr.As<BinaryInstruction>())
				PrintBinaryInstrExpr(ctx, binInstr);
			else if (auto unaryInstr = instr.As<UnaryInstruction>())
				PrintUnaryInstrExpr(ctx, unaryInstr);
			else if (auto allocVar = instr.As<AllocVarInstruction>())
				PrintAllocVarInstrExpr(ctx, allocVar);
			else if (auto fetchArg = instr.As<FetchArgInstruction>())
				PrintFetchArgInstrExpr(ctx, fetchArg);
			else if (auto select = instr.As<SelectInstruction>())
				PrintSelectInstrExpr(ctx, select);
			else if (auto call = instr.As<CallInstruction>())
				PrintCallInstrExpr(ctx, call);
			else if (auto castf2i = instr.As<Float2IntInstruction>())
				PrintCastF2IInstrExpr(ctx, castf2i);
			else if (auto casti2f = instr.As<Int2FloatInstruction>())
				PrintCastI2FInstrExpr(ctx, casti2f);
			else if (auto ldInput = instr.As<LoadInputInstruction>())
				PrintLoadInputInstrExpr(ctx, ldInput);
			else if (auto import = instr.As<ImportInstruction>())
				PrintImportInstrExpr(ctx, import);
			else if (instr.As<MemberUpdateInstruction>())
				throw InvalidOperationException(L"member update instruction cannot appear as expression.");
		}

		void CLikeCodeGen::PrintInstr(CodeGenContext & ctx, ILInstruction & instr)
		{
			// ctx.Body << L"// " << instr.ToString() << L";\n";
			if (!AppearAsExpression(instr, false))
			{
				if (auto binInstr = instr.As<BinaryInstruction>())
					PrintBinaryInstr(ctx, binInstr);
				else if (auto exportInstr = instr.As<ExportInstruction>())
					PrintExportInstr(ctx, exportInstr);
				else if (auto unaryInstr = instr.As<UnaryInstruction>())
					PrintUnaryInstr(ctx, unaryInstr);
				else if (auto allocVar = instr.As<AllocVarInstruction>())
					PrintAllocVarInstr(ctx, allocVar);
				else if (auto fetchArg = instr.As<FetchArgInstruction>())
					PrintFetchArgInstr(ctx, fetchArg);
				else if (auto select = instr.As<SelectInstruction>())
					PrintSelectInstr(ctx, select);
				else if (auto call = instr.As<CallInstruction>())
					PrintCallInstr(ctx, call);
				else if (auto castf2i = instr.As<Float2IntInstruction>())
					PrintCastF2IInstr(ctx, castf2i);
				else if (auto casti2f = instr.As<Int2FloatInstruction>())
					PrintCastI2FInstr(ctx, casti2f);
				else if (auto update = instr.As<MemberUpdateInstruction>())
					PrintUpdateInstr(ctx, update);
				else if (auto importInstr = instr.As<ImportInstruction>())
					PrintImportInstr(ctx, importInstr);
					
			}
		}

		void CLikeCodeGen::PrintLoadInputInstrExpr(CodeGenContext & ctx, LoadInputInstruction * instr)
		{
			PrintInputReference(ctx.Body, instr->InputName);
		}

		void CLikeCodeGen::GenerateCode(CodeGenContext & context, CFGNode * code)
		{
			for (auto & instr : *code)
			{
				if (auto ifInstr = instr.As<IfInstruction>())
				{
					context.Body << L"if (bool(";
					PrintOp(context, ifInstr->Operand.Ptr(), true);
					context.Body << L"))\n{\n";
					GenerateCode(context, ifInstr->TrueCode.Ptr());
					context.Body << L"}\n";
					if (ifInstr->FalseCode)
					{
						context.Body << L"else\n{\n";
						GenerateCode(context, ifInstr->FalseCode.Ptr());
						context.Body << L"}\n";
					}
				}
				else if (auto forInstr = instr.As<ForInstruction>())
				{
					context.Body << L"for (";
					if (forInstr->InitialCode)
						PrintOp(context, forInstr->InitialCode->GetLastInstruction(), true);
					context.Body << L"; ";
					if (forInstr->ConditionCode)
						PrintOp(context, forInstr->ConditionCode->GetLastInstruction(), true);
					context.Body << L"; ";
					if (forInstr->SideEffectCode)
						PrintOp(context, forInstr->SideEffectCode->GetLastInstruction(), true);
					context.Body << L")\n{\n";
					GenerateCode(context, forInstr->BodyCode.Ptr());
					context.Body << L"}\n";
				}
				else if (auto doInstr = instr.As<DoInstruction>())
				{
					context.Body << L"do\n{\n";
					GenerateCode(context, doInstr->BodyCode.Ptr());
					context.Body << L"} while (bool(";
					PrintOp(context, doInstr->ConditionCode->GetLastInstruction()->As<ReturnInstruction>()->Operand.Ptr(), true);
					context.Body << L"));\n";
				}
				else if (auto whileInstr = instr.As<WhileInstruction>())
				{
					context.Body << L"while (bool(";
					PrintOp(context, whileInstr->ConditionCode->GetLastInstruction()->As<ReturnInstruction>()->Operand.Ptr(), true);
					context.Body << L"))\n{\n";
					GenerateCode(context, whileInstr->BodyCode.Ptr());
					context.Body << L"}\n";
				}
				else if (auto ret = instr.As<ReturnInstruction>())
				{
					if (currentImportInstr) 
					{
						context.Body << currentImportInstr->Name << L" = ";
						PrintOp(context, ret->Operand.Ptr());
						context.Body << L";\n";
					}
					else
					{
						context.Body << L"return ";
						PrintOp(context, ret->Operand.Ptr());
						context.Body << L";\n";
					}
				}
				else if (instr.Is<BreakInstruction>())
				{
					context.Body << L"break;\n";
				}
				else if (instr.Is<ContinueInstruction>())
				{
					context.Body << L"continue;\n";
				}
				else if (instr.Is<DiscardInstruction>())
				{
					context.Body << L"discard;\n";
				}
					
				else
					PrintInstr(context, instr);
			}
		}

		CompiledShaderSource CLikeCodeGen::GenerateShader(CompileResult & result, SymbolTable *, ILShader * shader, ErrorWriter * err)
		{
			this->errWriter = err;

			CompiledShaderSource rs;

			for (auto & stage : shader->Stages)
			{
				StageSource src;
				if (stage.Value->StageType == L"VertexShader" || stage.Value->StageType == L"FragmentShader" || stage.Value->StageType == L"DomainShader")
					src = GenerateVertexFragmentDomainShader(result.Program.Ptr(), shader, stage.Value.Ptr());
				else if (stage.Value->StageType == L"ComputeShader")
					src = GenerateComputeShader(result.Program.Ptr(), shader, stage.Value.Ptr());
				else if (stage.Value->StageType == L"HullShader")
					src = GenerateHullShader(result.Program.Ptr(), shader, stage.Value.Ptr());
				else
					errWriter->Error(50020, L"Unknown stage type '" + stage.Value->StageType + L"'.", stage.Value->Position);
				rs.Stages[stage.Key] = src;
			}
				
			// TODO: fill metadatas
			rs.MetaData.ShaderName = shader->Name;
				
			return rs;
		}

		void CLikeCodeGen::GenerateStructs(StringBuilder & sb, ILProgram * program)
		{
			for (auto & st : program->Structs)
			{
				if (!st->IsIntrinsic)
				{
					sb << L"struct " << st->TypeName << L"\n{\n";
					for (auto & f : st->Members)
					{
						sb << f.Type->ToString();
						sb << " " << f.FieldName << L";\n";
					}
					sb << L"};\n";
				}
			}
		}

		void CLikeCodeGen::GenerateReferencedFunctions(StringBuilder & sb, ILProgram * program, ArrayView<ILWorld*> worlds)
		{
			EnumerableHashSet<String> refFuncs;
			for (auto & world : worlds)
				for (auto & func : world->ReferencedFunctions)
					refFuncs.Add(func);
			for (auto & func : program->Functions)
			{
				if (refFuncs.Contains(func.Value->Name))
				{
					GenerateFunctionDeclaration(sb, func.Value.Ptr());
					sb << L";\n";
				}
			}
			for (auto & func : program->Functions)
			{
				if (refFuncs.Contains(func.Value->Name))
					sb << GenerateFunction(func.Value.Ptr());
			}
		}

		ExternComponentCodeGenInfo CLikeCodeGen::ExtractExternComponentInfo(const ILObjectDefinition & input)
		{
			auto type = input.Type.Ptr();
			auto recType = ExtractRecordType(type);
			ExternComponentCodeGenInfo info;
			info.Type = type;
			String bindingVal;
			if (input.Attributes.TryGetValue(L"Binding", bindingVal))
				info.Binding = StringToInt(bindingVal);
			if (recType)
			{
				if (auto genType = dynamic_cast<ILGenericType*>(type))
				{
					type = genType->BaseType.Ptr();
					if (genType->GenericTypeName == L"Uniform")
						info.DataStructure = ExternComponentCodeGenInfo::DataStructureType::UniformBuffer;
					else if (genType->GenericTypeName == L"Patch")
						info.DataStructure = ExternComponentCodeGenInfo::DataStructureType::Patch;
					else if (genType->GenericTypeName == L"Texture")
						info.DataStructure = ExternComponentCodeGenInfo::DataStructureType::Texture;
					else if (genType->GenericTypeName == L"PackedBuffer")
						info.DataStructure = ExternComponentCodeGenInfo::DataStructureType::PackedBuffer;
					else if (genType->GenericTypeName == L"ArrayBuffer")
						info.DataStructure = ExternComponentCodeGenInfo::DataStructureType::ArrayBuffer;
					else if (genType->GenericTypeName == L"StorageBuffer")
						info.DataStructure = ExternComponentCodeGenInfo::DataStructureType::StorageBuffer;
				}
				if (auto arrType = dynamic_cast<ILArrayType*>(type))
				{
					if (info.DataStructure != ExternComponentCodeGenInfo::DataStructureType::StandardInput &&
						info.DataStructure != ExternComponentCodeGenInfo::DataStructureType::UniformBuffer &&
						info.DataStructure != ExternComponentCodeGenInfo::DataStructureType::Patch)
						errWriter->Error(51090, L"cannot generate code for extern component type '" + type->ToString() + L"'.",
							input.Position);
					type = arrType->BaseType.Ptr();
					info.IsArray = true;
					info.ArrayLength = arrType->ArrayLength;
				}
				if (type != recType)
				{
					errWriter->Error(51090, L"cannot generate code for extern component type '" + type->ToString() + L"'.",
						input.Position);
				}
			}
			else
			{
				// check for attributes 
				if (input.Attributes.ContainsKey(L"TessCoord"))
				{
					info.SystemVar = ExternComponentCodeGenInfo::SystemVarType::TessCoord;
					if (!(input.Type->IsFloatVector() && input.Type->GetVectorSize() <= 3))
						Error(50020, L"TessCoord must have vec2 or vec3 type.", input.Position);
				}
				else if (input.Attributes.ContainsKey(L"FragCoord"))
				{
					info.SystemVar = ExternComponentCodeGenInfo::SystemVarType::FragCoord;
					if (!(input.Type->IsFloatVector() && input.Type->GetVectorSize() == 4))
						Error(50020, L"FragCoord must be a vec4.", input.Position);
				}
				else if (input.Attributes.ContainsKey(L"InvocationId"))
				{
					info.SystemVar = ExternComponentCodeGenInfo::SystemVarType::InvocationId;
					if (!input.Type->IsInt())
						Error(50020, L"InvocationId must have int type.", input.Position);
				}
				else if (input.Attributes.ContainsKey(L"ThreadId"))
				{
					info.SystemVar = ExternComponentCodeGenInfo::SystemVarType::InvocationId;
					if (!input.Type->IsInt())
						Error(50020, L"ThreadId must have int type.", input.Position);
				}
				else if (input.Attributes.ContainsKey(L"PrimitiveId"))
				{
					info.SystemVar = ExternComponentCodeGenInfo::SystemVarType::PrimitiveId;
					if (!input.Type->IsInt())
						Error(50020, L"PrimitiveId must have int type.", input.Position);
				}
				else if (input.Attributes.ContainsKey(L"PatchVertexCount"))
				{
					info.SystemVar = ExternComponentCodeGenInfo::SystemVarType::PatchVertexCount;
					if (!input.Type->IsInt())
						Error(50020, L"PatchVertexCount must have int type.", input.Position);
				}
			}
			return info;
		}

		void CLikeCodeGen::PrintInputReference(StringBuilder & sb, String input)
		{
			auto info = extCompInfo[input]();

			// TODO(tfoley): Is there any reason why this isn't just a `switch`?
			if (info.DataStructure == ExternComponentCodeGenInfo::DataStructureType::UniformBuffer)
			{
				PrintUniformBufferInputReference(sb, input, currentImportInstr->ComponentName);
			}
			else if (info.DataStructure == ExternComponentCodeGenInfo::DataStructureType::StorageBuffer)
			{
				PrintStorageBufferInputReference(sb, input, currentImportInstr->ComponentName);
			}
			else if (info.DataStructure == ExternComponentCodeGenInfo::DataStructureType::ArrayBuffer)
			{
				PrintArrayBufferInputReference(sb, input, currentImportInstr->ComponentName);
			}
			else if (info.DataStructure == ExternComponentCodeGenInfo::DataStructureType::PackedBuffer)
			{
				PrintPackedBufferInputReference(sb, input, currentImportInstr->ComponentName);
			}
			else if (auto recType = ExtractRecordType(info.Type.Ptr()))
			{
				// TODO(tfoley): hoist this logic up to the top-level if chain?
				if(info.DataStructure == ExternComponentCodeGenInfo::DataStructureType::StandardInput)
				{
					PrintStandardInputReference(sb, recType, input, currentImportInstr->ComponentName);
				}
				else if(info.DataStructure == ExternComponentCodeGenInfo::DataStructureType::Patch)
				{
					PrintPatchInputReference(sb, recType, input, currentImportInstr->ComponentName);
				}
				else
				{
					// TODO(tfoley): Does this case ever actually trigger?
					PrintDefaultInputReference(sb, recType, input, currentImportInstr->ComponentName);
				}
			}
			else
			{
				PrintSystemVarReference(sb, input, info.SystemVar);
			}
		}

		void CLikeCodeGen::DeclareInput(CodeGenContext & sb, const ILObjectDefinition & input, bool isVertexShader)
		{
			auto info = ExtractExternComponentInfo(input);
			extCompInfo[input.Name] = info;
			auto recType = ExtractRecordType(input.Type.Ptr());
			if (recType)
			{
				switch(info.DataStructure)
				{
				case ExternComponentCodeGenInfo::DataStructureType::UniformBuffer:
					DeclareUniformBuffer(sb, input, isVertexShader);
					return;

				case ExternComponentCodeGenInfo::DataStructureType::StorageBuffer:
					DeclareStorageBuffer(sb, input, isVertexShader);
					return;

				case ExternComponentCodeGenInfo::DataStructureType::ArrayBuffer:
					DeclareArrayBuffer(sb, input, isVertexShader);
					return;

				case ExternComponentCodeGenInfo::DataStructureType::PackedBuffer:
					DeclareArrayBuffer(sb, input, isVertexShader);
					return;

				case ExternComponentCodeGenInfo::DataStructureType::Texture:
					DeclareTextureInputRecord(sb, input, isVertexShader);
					return;

				case ExternComponentCodeGenInfo::DataStructureType::StandardInput:
					DeclareStandardInputRecord(sb, input, isVertexShader);
					return;

				case ExternComponentCodeGenInfo::DataStructureType::Patch:
					DeclarePatchInputRecord(sb, input, isVertexShader);
					return;

				default:
					errWriter->Error(99999, L"internal error: unexpected data structure for record type",
							input.Position);
					break;
				}
			}
		}

		void CLikeCodeGen::GenerateVertexShaderEpilog(CodeGenContext & ctx, ILWorld * world, ILStage * stage)
		{
			StageAttribute positionVar;
			if (stage->Attributes.TryGetValue(L"Position", positionVar))
			{
				ILOperand * operand;
				if (world->Components.TryGetValue(positionVar.Value, operand))
				{
					if(operand->Type->IsFloatVector() && operand->Type->GetVectorSize() == 4)
					{
						PrintRasterPositionOutputWrite(ctx, operand);
					}
					else
						errWriter->Error(50040, L"'" + positionVar.Value + L"': component used as 'Position' output must be of vec4 type.",
							positionVar.Position);
				}
				else
					errWriter->Error(50041, L"'" + positionVar.Value + L"': component not defined.",
						positionVar.Position);
			}
		}

		void CLikeCodeGen::GenerateDomainShaderProlog(CodeGenContext & ctx, ILStage * stage)
		{
			ctx.GlobalHeader << L"layout(";
			StageAttribute val;
			if (stage->Attributes.TryGetValue(L"Domain", val))
				ctx.GlobalHeader << ((val.Value == L"quads") ? L"quads" : L"triangles");
			else
				ctx.GlobalHeader << L"triangles";
			if (val.Value != L"triangles" && val.Value != L"quads")
				Error(50093, L"'Domain' should be either 'triangles' or 'quads'.", val.Position);
			if (stage->Attributes.TryGetValue(L"Winding", val))
			{
				if (val.Value == L"cw")
					ctx.GlobalHeader << L", cw";
				else
					ctx.GlobalHeader << L", ccw";
			}
			if (stage->Attributes.TryGetValue(L"EqualSpacing", val))
			{
				if (val.Value == L"1" || val.Value == L"true")
					ctx.GlobalHeader << L", equal_spacing";
			}
			ctx.GlobalHeader << L") in;\n";
		}

		StageSource CLikeCodeGen::GenerateVertexFragmentDomainShader(ILProgram * program, ILShader * shader, ILStage * stage)
		{
			RefPtr<ILWorld> world = nullptr;
			StageAttribute worldName;
			if (stage->Attributes.TryGetValue(L"World", worldName))
			{
				if (!shader->Worlds.TryGetValue(worldName.Value, world))
					errWriter->Error(50022, L"world '" + worldName.Value + L"' is not defined.", worldName.Position);
			}
			outputStrategy = CreateStandardOutputStrategy(world.Ptr(), L"");
			return GenerateSingleWorldShader(program, shader, stage);
		}

		StageSource CLikeCodeGen::GenerateComputeShader(ILProgram * program, ILShader * shader, ILStage * stage)
		{
			RefPtr<ILWorld> world = nullptr;
			StageAttribute worldName;
			if (stage->Attributes.TryGetValue(L"World", worldName))
			{
				if (!shader->Worlds.TryGetValue(worldName.Value, world))
					errWriter->Error(50022, L"world '" + worldName.Value + L"' is not defined.", worldName.Position);
			}
			outputStrategy = CreatePackedBufferOutputStrategy(world.Ptr());
			return GenerateSingleWorldShader(program, shader, stage);
		}

		void CLikeCodeGen::GenerateFunctionDeclaration(StringBuilder & sbCode, ILFunction * function)
		{
			function->Code->NameAllInstructions();
			auto retType = function->ReturnType.Ptr();
			if (retType)
				PrintType(sbCode, retType);
			else
				sbCode << L"void";
			sbCode << L" " << GetFuncOriginalName(function->Name) << L"(";
			int id = 0;
			for (auto & instr : *function->Code)
			{
				if (auto arg = instr.As<FetchArgInstruction>())
				{
					if (arg->ArgId != 0)
					{
						if (id > 0)
						{
							sbCode << L", ";
						}
						PrintDef(sbCode, arg->Type.Ptr(), arg->Name);
						id++;
					}
				}
			}
			sbCode << L")";
		}
		String CLikeCodeGen::GenerateFunction(ILFunction * function)
		{
			StringBuilder sbCode;
			CodeGenContext ctx;
			ctx.codeGen = this;
			ctx.UsedVarNames.Clear();
			ctx.Body.Clear();
			ctx.Header.Clear();
			ctx.Arguments.Clear();
			ctx.ReturnVarName = L"";
			ctx.VarName.Clear();
				
			function->Code->NameAllInstructions();
			GenerateFunctionDeclaration(sbCode, function);
			sbCode << L"\n{\n";
			GenerateCode(ctx, function->Code.Ptr());
			sbCode << ctx.Header.ToString() << ctx.Body.ToString();
			if (ctx.ReturnVarName.Length())
				sbCode << L"return " << ctx.ReturnVarName << L";\n";
			sbCode << L"}\n";
			return sbCode.ProduceString();
		}

		String CodeGenContext::DefineVariable(ILOperand * op)
		{
			String rs;
			if (VarName.TryGetValue(op, rs))
			{
				return rs;
			}
			else
			{
				auto name = GenerateCodeName(op->Name, L"");
				codeGen->PrintDef(Header, op->Type.Ptr(), name);
				if (op->Type->IsInt() || op->Type->IsUInt())
				{
					Header << L" = 0;";
				}
				Header << L";\n";
				VarName.Add(op, name);
				op->Name = name;
				return op->Name;
			}
		}
	}
}

/***********************************************************************
SPIRECORE\CLOSURE.CPP
***********************************************************************/

namespace Spire
{
	namespace Compiler
	{
		void CheckComponentRedefinition(ErrorWriter * err, ShaderClosure * parent, ShaderClosure * child)
		{
			for (auto & comp : child->Components)
			{
				RefPtr<ShaderComponentSymbol> ccomp;
				RefPtr<ShaderClosure> su;
				if ((comp.Value->Implementations.First()->SyntaxNode->IsPublic ||
					comp.Value->Implementations.First()->SyntaxNode->IsOutput))
				{
					if (parent->Components.TryGetValue(comp.Key, ccomp))
						err->Error(33022, L"\'" + comp.Key + L"\' is already defined in current scope.\nsee previous definition at " + ccomp->Implementations.First()->SyntaxNode->Position.ToString(),
							comp.Value->Implementations.First()->SyntaxNode->Position);
					else if (parent->SubClosures.TryGetValue(comp.Key, su))
						err->Error(33022, L"\'" + comp.Key + L"\' is already defined in current scope.\nsee previous definition at " + su->UsingPosition.ToString(),
							comp.Value->Implementations.First()->SyntaxNode->Position);
				}
			}
			for (auto & c : child->SubClosures)
			{
				if (c.Value->IsInPlace)
				{
					RefPtr<ShaderComponentSymbol> ccomp;
					RefPtr<ShaderClosure> su;
					if (parent->Components.TryGetValue(c.Key, ccomp))
						err->Error(33022, L"\'" + c.Key + L"\' is already defined in current scope.\nsee previous definition at " + ccomp->Implementations.First()->SyntaxNode->Position.ToString(),
							c.Value->UsingPosition);
					else if (parent->SubClosures.TryGetValue(c.Key, su))
						err->Error(33022, L"\'" + c.Key + L"\' is already defined in current scope.\nsee previous definition at " + su->UsingPosition.ToString(),
							c.Value->UsingPosition);
					for (auto & sc : c.Value->SubClosures)
						if (sc.Value->IsInPlace)
							CheckComponentRedefinition(err, parent, sc.Value.Ptr());
				}
			}
		}
		RefPtr<ShaderClosure> CreateShaderClosure(ErrorWriter * err, SymbolTable * symTable, ShaderSymbol * shader, CodePosition usingPos, 
			ShaderClosure * rootShader,
			const EnumerableDictionary<String, RefPtr<ShaderComponentSymbol>>& pRefMap)
		{
			RefPtr<ShaderClosure> rs = new ShaderClosure();
			if (rootShader == nullptr)
			{
				rootShader = rs.Ptr();
				rootShader->Pipeline = shader->Pipeline;
			}
			rs->Name = shader->SyntaxNode->Name.Content;
			rs->RefMap = pRefMap;
			if (shader->Pipeline && rootShader->Pipeline)
			{
				if (shader->Pipeline->IsChildOf(rootShader->Pipeline))
					rootShader->Pipeline = shader->Pipeline;
				else
				{
					StringBuilder sb;
					sb << L"pipeline '" << shader->Pipeline->SyntaxNode->Name.Content << L"' targeted by module '" <<
						shader->SyntaxNode->Name.Content << L"' is incompatible with pipeline '" << rootShader->Pipeline->SyntaxNode->Name.Content << L"' targeted by shader '" << rootShader->Name << L"'.\nsee definition of shader '" << shader->SyntaxNode->Name.Content << L"' at " << shader->SyntaxNode->Position.ToString();
					err->Error(33041, sb.ProduceString(), shader->SyntaxNode->Position);
				}
			}
			
			rs->Pipeline = rootShader->Pipeline;
			rs->UsingPosition = usingPos;
			rs->Position = shader->SyntaxNode->Position;
			for (auto & mbr : shader->SyntaxNode->Members)
			{
				if (auto import = dynamic_cast<ImportSyntaxNode*>(mbr.Ptr()))
				{
					// create component for each argument
					EnumerableDictionary<String, RefPtr<ShaderComponentSymbol>> refMap;
					for (auto & arg : import->Arguments)
					{
						RefPtr<ShaderComponentSymbol> ccomp = new ShaderComponentSymbol();
						auto compName = L"arg" + String(rs->Components.Count()) + L"_" + 
							(import->ObjectName.Content.Length()==0?import->ShaderName.Content:import->ObjectName.Content) + arg->ArgumentName.Content;
						auto impl = new ShaderComponentImplSymbol();
						auto compSyntax = new ComponentSyntaxNode();
						compSyntax->Position = arg->Expression->Position;
						compSyntax->Name.Content = compName;
						CloneContext cloneCtx;
						compSyntax->Expression = arg->Expression->Clone(cloneCtx);
						compSyntax->TypeNode = TypeSyntaxNode::FromExpressionType(arg->Expression->Type.Ptr());
						compSyntax->TypeNode->Position = compSyntax->Position;
						impl->SyntaxNode = compSyntax;
						ccomp->Name = compName;
						ccomp->Type = new Type();
						ccomp->Type->DataType = arg->Expression->Type;
						ccomp->Implementations.Add(impl);
						rs->Components[compName] = ccomp;
						refMap[arg->ArgumentName.Content] = ccomp;
					}
					RefPtr<ShaderSymbol> shaderSym;
					if (symTable->Shaders.TryGetValue(import->ShaderName.Content, shaderSym))
					{
						// fill in automatic arguments
						for (auto & param : shaderSym->Components)
						{
							if (param.Value->IsParam() && !refMap.ContainsKey(param.Key))
							{
								auto arg = rs->FindComponent(param.Key);
								if (arg && arg->Type->DataType->Equals(param.Value->Type->DataType.Ptr()))
								{
									refMap[param.Key] = arg;
								}
							}
						}
						auto refClosure = CreateShaderClosure(err, symTable, shaderSym.Ptr(), import->Position, rootShader, refMap);
						refClosure->IsPublic = import->IsPublic;
						refClosure->Parent = rs.Ptr();
						if (import->IsInplace)
						{
							refClosure->IsInPlace = true;
							CheckComponentRedefinition(err, rs.Ptr(), refClosure.Ptr());
							rs->SubClosures[L"annonymousObj" + String(UniqueIdGenerator::Next())] = refClosure;
						}
						else
						{
							rs->SubClosures[import->ObjectName.Content] = refClosure;
						}
					}
				}
				else if (auto compt = dynamic_cast<ComponentSyntaxNode*>(mbr.Ptr()))
				{
					RefPtr<ShaderComponentSymbol> comp;
					if (shader->Components.TryGetValue(compt->Name.Content, comp) &&
						!rs->Components.ContainsKey(compt->Name.Content))
					{
						RefPtr<ShaderComponentSymbol> ccomp = new ShaderComponentSymbol(*comp);
						rs->Components.Add(comp->Name, ccomp);
					}
				}
			}
			// check for unassigned arguments
			for (auto & comp : shader->Components)
			{
				if (comp.Value->Implementations.First()->SyntaxNode->IsParam &&
					!pRefMap.ContainsKey(comp.Key))
				{
					StringBuilder errMsg;
					errMsg << L"parameter '" << comp.Key << L"' of module '" << shader->SyntaxNode->Name.Content << L"' is unassigned.";
					// try to provide more info on why it is unassigned
					auto arg = rootShader->FindComponent(comp.Key, true, false);
					if (!arg)
						errMsg << L" implicit parameter matching failed because shader '" << rootShader->Name << L"' does not define component '" + comp.Key + L"'.";
					else
					{
						if (comp.Value->Type->DataType->Equals(arg->Type->DataType.Ptr()))
						{
							errMsg << L" implicit parameter matching failed because the component of the same name is not accessible from '" << shader->SyntaxNode->Name.Content << L"'.\ncheck if you have declared necessary requirements and properly used the 'public' qualifier.";
						}
						else
						{
							errMsg << L"implicit parameter matching failed because the component of the same name does not match parameter type '"
								<< comp.Value->Type->DataType->ToString() << L"'.";
						}
						errMsg << L"\nsee requirement declaration at " << comp.Value->Implementations.First()->SyntaxNode->Position.ToString() << L".";
						errMsg << L"\nsee potential definition of component '" << comp.Key << L"' at " << arg->Implementations.First()->SyntaxNode->Position.ToString()
							<< L".\n";
					}
					err->Error(33023,errMsg.ProduceString(), rs->UsingPosition);
				}
			}
			return rs;
		}

		RefPtr<ShaderClosure> CreateShaderClosure(ErrorWriter * err, SymbolTable * symTable, ShaderSymbol * shader)
		{
			return CreateShaderClosure(err, symTable, shader, shader->SyntaxNode->Position, nullptr, EnumerableDictionary<String, RefPtr<ShaderComponentSymbol>>());
		}

		class ReplaceReferenceVisitor : public SyntaxVisitor
		{
		private:
			ShaderClosure * shaderClosure = nullptr;
			ShaderComponentSymbol * currentComponent = nullptr;
			ImportExpressionSyntaxNode * currentImport = nullptr;
			void ReplaceReference(RefPtr<StringObject> refComp)
			{
				String targetComp;
				if (replacements.TryGetValue(refComp->Content, targetComp))
				{
					auto oldComp = shaderClosure->AllComponents[refComp->Content]();
					auto newComp = shaderClosure->AllComponents[targetComp]();
					newComp->UserComponents.Add(currentComponent);
					if (auto * importOps = currentComponent->DependentComponents.TryGetValue(newComp))
						importOps->Add(currentImport);
					else
					{
						EnumerableHashSet<RefPtr<ImportExpressionSyntaxNode>> op;
						op.Add(currentImport);
						currentComponent->DependentComponents.Add(newComp, op);
					}
					currentComponent->DependentComponents.Remove(oldComp);
					if (auto * importOps = currentImpl->DependentComponents.TryGetValue(newComp))
						importOps->Add(currentImport);
					else
					{
						EnumerableHashSet<RefPtr<ImportExpressionSyntaxNode>> op;
						op.Add(currentImport);
						currentImpl->DependentComponents.Add(newComp, op);
					}
					currentImpl->DependentComponents.Remove(oldComp);
					currentImpl->ComponentReferencePositions[newComp] = currentImpl->ComponentReferencePositions[oldComp]();
					refComp->Content = newComp->UniqueName;
				}
			}
		public:
			ShaderComponentImplSymbol * currentImpl = nullptr;
			EnumerableDictionary<String, String> & replacements;
			ReplaceReferenceVisitor(ShaderClosure * closure, ShaderComponentSymbol * comp, EnumerableDictionary<String, String> &pReplacements)
				: SyntaxVisitor(nullptr), shaderClosure(closure), currentComponent(comp), replacements(pReplacements)
			{}

			RefPtr<ExpressionSyntaxNode> VisitImportExpression(ImportExpressionSyntaxNode * import) override
			{
				currentImport = import;
				import->Component->Accept(this);
				if (import->Component->Tags.ContainsKey(L"ComponentReference"))
				{
					import->ComponentUniqueName = import->Component->Tags[L"ComponentReference"]().As<StringObject>()->Content;
				}
				currentImport = nullptr;
				for (auto & arg : import->Arguments)
					arg->Accept(this);
				return import;
			}

			RefPtr<ExpressionSyntaxNode> VisitVarExpression(VarExpressionSyntaxNode * var) override
			{
				RefPtr<Object> compRef;
				if (var->Tags.TryGetValue(L"ComponentReference", compRef))
				{
					ReplaceReference(compRef.As<StringObject>());
				}
				return var;
			}

			RefPtr<ExpressionSyntaxNode> VisitMemberExpression(MemberExpressionSyntaxNode * member) override
			{
				member->BaseExpression->Accept(this);
				RefPtr<Object> compRef;
				if (member->Tags.TryGetValue(L"ComponentReference", compRef))
				{
					ReplaceReference(compRef.As<StringObject>());
				}
				return member;
			}
		};

		class ResolveDependencyVisitor : public SyntaxVisitor
		{
		private:
			ShaderClosure * shaderClosure = nullptr, *rootShader = nullptr;
			ShaderComponentSymbol * currentComponent = nullptr;
			ImportExpressionSyntaxNode * currentImport = nullptr;
			void AddReference(ShaderComponentSymbol * referee, ImportExpressionSyntaxNode * importOp, CodePosition pos)
			{
				rootShader->AllComponents.TryGetValue(referee->UniqueName, referee);
				referee->UserComponents.Add(currentComponent);
				if (auto * importOps = currentComponent->DependentComponents.TryGetValue(referee))
					importOps->Add(importOp);
				else
				{
					EnumerableHashSet<RefPtr<ImportExpressionSyntaxNode>> op;
					op.Add(importOp);
					currentComponent->DependentComponents.Add(referee, op);
				}

				if (auto * importOps = currentImpl->DependentComponents.TryGetValue(referee))
					importOps->Add(importOp);
				else
				{
					EnumerableHashSet<RefPtr<ImportExpressionSyntaxNode>> op;
					op.Add(importOp);
					currentImpl->DependentComponents.Add(referee, op);
				}
				currentImpl->ComponentReferencePositions[referee] = pos;
			}
		public:
			ShaderComponentImplSymbol * currentImpl = nullptr;

			ResolveDependencyVisitor(ErrorWriter * err, ShaderClosure * pRootShader, ShaderClosure * closure, ShaderComponentSymbol * comp)
				: SyntaxVisitor(err), shaderClosure(closure), rootShader(pRootShader), currentComponent(comp)
			{}

			RefPtr<ExpressionSyntaxNode> VisitImportExpression(ImportExpressionSyntaxNode * import) override
			{
				currentImport = import;
				import->Component->Accept(this);
				if (!import->Component->Tags.ContainsKey(L"ComponentReference"))
				{
					Error(32047, L"first argument of an import operator call does not resolve to a component.", import->Component.Ptr());
				}
				else
				{
					import->ComponentUniqueName = import->Component->Tags[L"ComponentReference"]().As<StringObject>()->Content;
				}
				currentImport = nullptr;
				for (auto & arg : import->Arguments)
					arg->Accept(this);
				return import;
			}

			RefPtr<ExpressionSyntaxNode> VisitVarExpression(VarExpressionSyntaxNode * var) override
			{
				VariableEntry varEntry;
				if (!var->Scope->FindVariable(var->Variable, varEntry))
				{
					if (var->Type->AsBasicType() && var->Type->AsBasicType()->Component)
					{
						if (auto comp = shaderClosure->FindComponent(var->Type->AsBasicType()->Component->Name))
						{
							if (comp->Implementations.First()->SyntaxNode->IsParam)
								shaderClosure->RefMap.TryGetValue(comp->Name, comp);
							var->Tags[L"ComponentReference"] = new StringObject(comp->UniqueName);
							AddReference(comp.Ptr(), currentImport, var->Position);
						}
						else
							throw InvalidProgramException(L"cannot resolve reference.");
					}
					if (auto comp = shaderClosure->FindComponent(var->Variable))
					{
						if (comp->Implementations.First()->SyntaxNode->IsParam)
							shaderClosure->RefMap.TryGetValue(var->Variable, comp);
						var->Tags[L"ComponentReference"] = new StringObject(comp->UniqueName);

						AddReference(comp.Ptr(), currentImport, var->Position);
					}
					else if (auto closure = shaderClosure->FindClosure(var->Variable))
					{
						ShaderSymbol * originalShader = nullptr;
						if (var->Type->AsBasicType())
							originalShader = var->Type->AsBasicType()->Shader;
						var->Type = new BasicExpressionType(originalShader, closure.Ptr());
					}
					else if (!(var->Type->AsBasicType() && var->Type->AsBasicType()->BaseType == BaseType::Function))
						throw InvalidProgramException(L"cannot resolve reference.");
				}
				return var;
			}

			RefPtr<ExpressionSyntaxNode> VisitMemberExpression(MemberExpressionSyntaxNode * member) override
			{
				member->BaseExpression->Accept(this);
				if (member->BaseExpression->Type->AsBasicType() && member->BaseExpression->Type->AsBasicType()->ShaderClosure)
				{
					if (auto comp = member->BaseExpression->Type->AsBasicType()->ShaderClosure->FindComponent(member->MemberName))
					{
						member->Tags[L"ComponentReference"] = new StringObject(comp->UniqueName);
						AddReference(comp.Ptr(), currentImport, member->Position);
					}
					else if (auto shader = member->BaseExpression->Type->AsBasicType()->ShaderClosure->FindClosure(member->MemberName))
					{
						ShaderSymbol * originalShader = nullptr;
						if (member->Type->AsBasicType())
							originalShader = member->Type->AsBasicType()->Shader;
						member->Type = new BasicExpressionType(originalShader, shader.Ptr());
					}
				}
				else if (member->Type->AsBasicType() && member->Type->AsBasicType()->Component)
				{
					if (auto comp = shaderClosure->FindComponent(member->Type->AsBasicType()->Component->Name))
					{
						member->Tags[L"ComponentReference"] = new StringObject(comp->UniqueName);
						AddReference(comp.Ptr(), currentImport, member->Position);
					}
					else
						throw InvalidProgramException(L"cannot resolve reference.");
				}
				return member;
			}
		};

		void ResolveReference(ErrorWriter * err, ShaderClosure * rootShader, ShaderClosure* shader)
		{
			for (auto & comp : shader->Components)
			{
				ResolveDependencyVisitor depVisitor(err, rootShader, shader, comp.Value.Ptr());
				for (auto & impl : comp.Value->Implementations)
				{
					depVisitor.currentImpl = impl.Ptr();
					impl->SyntaxNode->Accept(&depVisitor);
				}
			}
			for (auto & subClosure : shader->SubClosures)
				ResolveReference(err, rootShader, subClosure.Value.Ptr());
		}

		void ReplaceReference(ShaderClosure * shader, EnumerableDictionary<String, String> & replacements)
		{
			for (auto & comp : shader->AllComponents)
			{
				ReplaceReferenceVisitor replaceVisitor(shader, comp.Value, replacements);
				for (auto & impl : comp.Value->Implementations)
				{
					replaceVisitor.currentImpl = impl.Ptr();
					impl->SyntaxNode->Accept(&replaceVisitor);
				}
			}
			for (auto & rep : replacements)
			{
				shader->AllComponents[rep.Key]()->UserComponents.Clear();
			}
		}

		String GetUniqueCodeName(String name)
		{
			StringBuilder sb;
			for (auto ch : name)
			{
				if (ch == L'.')
					sb << L"_";
				else
					sb << ch;
			}
			return EscapeDoubleUnderscore(sb.ProduceString());
		}

		bool IsInAbstractWorld(PipelineSymbol * pipeline, ShaderComponentSymbol* comp)
		{
			return comp->Implementations.First()->Worlds.Count() && !comp->Implementations.First()->SyntaxNode->IsParam &&
				pipeline->IsAbstractWorld(comp->Implementations.First()->Worlds.First());
		}

		void AssignUniqueNames(ShaderClosure * shader, String namePrefix, String publicNamePrefix)
		{
			for (auto & comp : shader->Components)
			{
				if (IsInAbstractWorld(shader->Pipeline, comp.Value.Ptr()))
				{
					comp.Value->UniqueKey = comp.Value->UniqueName = comp.Value->Name;
				}
				else
				{
					String uniqueChoiceName;
					if (comp.Value->Implementations.First()->SyntaxNode->IsPublic)
						uniqueChoiceName = publicNamePrefix + comp.Key;
					else
						uniqueChoiceName = namePrefix + comp.Key;
					comp.Value->ChoiceNames.Add(uniqueChoiceName);
					comp.Value->UniqueKey = uniqueChoiceName;
					comp.Value->UniqueName = GetUniqueCodeName(uniqueChoiceName);
				}
			}
			for (auto & subClosure : shader->SubClosures)
			{
				if (subClosure.Value->IsInPlace)
					AssignUniqueNames(subClosure.Value.Ptr(), namePrefix + subClosure.Value->Name + L".", publicNamePrefix);
				else
					AssignUniqueNames(subClosure.Value.Ptr(), namePrefix + subClosure.Key + L".", publicNamePrefix + subClosure.Key + L".");
			}
		}

		bool IsConsistentGlobalComponentDefinition(ShaderComponentSymbol * comp0, ShaderComponentSymbol * comp1)
		{
			if (comp0->Type->DataType != comp1->Type->DataType)
				return false;
			if (comp0->Implementations.First()->Worlds.Count() != comp1->Implementations.First()->Worlds.Count())
				return false;
			for (auto w : comp0->Implementations.First()->Worlds)
				if (!comp1->Implementations.First()->Worlds.Contains(w))
					return false;
			return true;
		}

		void GatherComponents(ErrorWriter * err, ShaderClosure * closure, ShaderClosure * subClosure)
		{
			for (auto & comp : subClosure->Components)
			{
				ShaderComponentSymbol* existingComp = nullptr;
				if (comp.Value->IsParam())
					continue;
				if (closure->AllComponents.TryGetValue(comp.Value->UniqueName, existingComp))
				{
					if (IsInAbstractWorld(closure->Pipeline, comp.Value.Ptr()) &&
						IsInAbstractWorld(closure->Pipeline, existingComp))
					{
						// silently ignore consistently defined global components (components in abstract worlds)
						if (!IsConsistentGlobalComponentDefinition(comp.Value.Ptr(), existingComp))
						{
							err->Error(34025, L"'" + existingComp->Name + L"': global component conflicts with previous declaration.\nsee previous declaration at " + existingComp->Implementations.First()->SyntaxNode->Position.ToString(),
								comp.Value->Implementations.First()->SyntaxNode->Position);
						}
						else
						{
							err->Warning(34026, L"'" + existingComp->Name + L"': component is already defined when compiling shader '" + closure->Name + L"'. use 'require' to declare it as a parameter. \nsee previous declaration at " + existingComp->Implementations.First()->SyntaxNode->Position.ToString(),
								comp.Value->Implementations.First()->SyntaxNode->Position);
						}
					}
					else if (comp.Value->Implementations.First()->SyntaxNode->Parameters.Count() == 0)
					{
						StringBuilder errBuilder;
						errBuilder << L"component named '" << comp.Value->UniqueKey << L"\' is already defined when compiling '" << closure->Name << L"'.";
						auto currentClosure = subClosure;
						while (currentClosure != nullptr && currentClosure != closure)
						{
							errBuilder << L"\nsee inclusion of '" << currentClosure->Name << L"' at " << currentClosure->UsingPosition.ToString() << L".";
							currentClosure = currentClosure->Parent;
						}
						err->Error(34024, errBuilder.ProduceString(), comp.Value->Implementations.First()->SyntaxNode->Position);
					}
				}
				closure->AllComponents[comp.Value->UniqueName] = comp.Value.Ptr();
			}
			for (auto & sc : subClosure->SubClosures)
				GatherComponents(err, closure, sc.Value.Ptr());
		}

		bool IsWorldFeasible(SymbolTable * symTable, PipelineSymbol * pipeline, ShaderComponentImplSymbol * impl, String world, ShaderComponentSymbol*& unaccessibleComp)
		{
			bool isWFeasible = true;
			for (auto & dcomp : impl->DependentComponents)
			{
				if (dcomp.Value.Contains(nullptr))
				{
					bool reachable = false;
					for (auto & dw : dcomp.Key->Type->FeasibleWorlds)
					{
						if (symTable->IsWorldImplicitlyReachable(pipeline, dw, world, dcomp.Key->Type->DataType))
						{
							reachable = true;
							break;
						}
					}
					if (!reachable)
					{
						unaccessibleComp = dcomp.Key;
						isWFeasible = false;
						break;
					}
				}
			}
			return isWFeasible;
		}

		void SolveWorldConstraints(ErrorWriter * err, SymbolTable * symTable, ShaderClosure * shader)
		{
			EnumerableHashSet<String> allWorlds;
			for (auto w : shader->Pipeline->Worlds)
				if (!shader->Pipeline->IsAbstractWorld(w.Key))
					allWorlds.Add(w.Key);
			auto depOrder = shader->GetDependencyOrder();
			for (auto & comp : depOrder)
			{
				Dictionary<String, EnumerableHashSet<String>> autoWorlds;
				comp->Type->FeasibleWorlds.Clear();
				for (auto & impl : comp->Implementations)
				{
					if (!autoWorlds.ContainsKey(impl->AlternateName))
						autoWorlds[impl->AlternateName] = allWorlds;
					auto & autoWorld = autoWorlds[impl->AlternateName]();
					for (auto & w : impl->Worlds)
					{
						ShaderComponentSymbol* unaccessibleComp = nullptr;
						if (!IsWorldFeasible(symTable, shader->Pipeline, impl.Ptr(), w, unaccessibleComp))
						{
							err->Error(33100, L"'" + comp->Name + L"' cannot be computed at '" + w + L"' because the dependent component '" + unaccessibleComp->Name + L"' is not accessible.\nsee definition of '"
								+ unaccessibleComp->Name + L"' at " + unaccessibleComp->Implementations.First()->SyntaxNode->Position.ToString(),
								impl->ComponentReferencePositions[unaccessibleComp]());
						}
						autoWorld.Remove(w);
					}
				}
				for (auto & impl : comp->Implementations)
				{
					if (impl->Worlds.Count() == 0)
					{
						EnumerableHashSet<String> deducedWorlds = autoWorlds[impl->AlternateName]();
						EnumerableHashSet<String> feasibleWorlds;
						for (auto & w : deducedWorlds)
						{
							ShaderComponentSymbol* unaccessibleComp = nullptr;
							bool isWFeasible = IsWorldFeasible(symTable, shader->Pipeline, impl.Ptr(), w, unaccessibleComp);
							if (isWFeasible)
								feasibleWorlds.Add(w);
						}
						impl->Worlds = feasibleWorlds;
					}
					for (auto & w : impl->Worlds)
						comp->Type->FeasibleWorlds.Add(w);
				}
			}
			for (auto & comp : depOrder)
			{
				comp->Type->ConstrainedWorlds = comp->Type->FeasibleWorlds;
			}
			auto useInWorld = [&](String comp, String world)
			{
				// comp is used in world, restrict comp.ContainedWorlds to guarantee
				// all candidate definitions can reach world
				RefPtr<ShaderComponentSymbol> compSym;
				if (shader->Components.TryGetValue(comp, compSym))
				{
					EnumerableHashSet<String> newWorlds;
					for (auto & w : compSym->Type->ConstrainedWorlds)
						if (symTable->IsWorldReachable(shader->Pipeline, w, world, compSym->Type->DataType))
							newWorlds.Add(w);
					compSym->Type->ConstrainedWorlds = _Move(newWorlds);
				}
			};
			for (auto impOp : shader->Pipeline->SyntaxNode->ImportOperators)
			{
				for (auto comp : impOp->Usings)
				{
					useInWorld(comp, impOp->DestWorld.Content);
				}
			}
		}

		bool CheckCircularReference(ErrorWriter * err, ShaderClosure * shader)
		{
			bool rs = false;
			for (auto & comp : shader->AllComponents)
			{
				for (auto & impl : comp.Value->Implementations)
				{
					// check circular references
					HashSet<ShaderComponentSymbol*> set;
					List<ShaderComponentSymbol*> referredComponents;
					referredComponents.Add(comp.Value);
					for (int i = 0; i < referredComponents.Count(); i++)
					{
						auto xcomp = referredComponents[i];
						for (auto & xcompImpl : xcomp->Implementations)
						{
							for (auto & rcomp : xcompImpl->DependentComponents)
							{
								if (set.Add(rcomp.Key))
								{
									referredComponents.Add(rcomp.Key);
								}
								if (rcomp.Key == comp.Value)
								{
									err->Error(32013, L"'" + rcomp.Key->Name + L"': circular reference is not allowed.", impl->SyntaxNode->Position);
									rs = true;
								}
							}
						}
					}
				}
			}
			return rs;
		}

		void PropagateArgumentConstraints(ShaderComponentSymbol * requirement, ShaderComponentSymbol * arg)
		{
			for (auto w : requirement->Implementations.First()->ExportWorlds)
			{
				for (auto impl : arg->Implementations)
				{
					if (impl->Worlds.Contains(w))
						impl->ExportWorlds.Add(w);
				}
			}
			for (auto w : requirement->Implementations.First()->SrcPinnedWorlds)
			{
				for (auto impl : arg->Implementations)
				{
					if (impl->Worlds.Contains(w))
						impl->SrcPinnedWorlds.Add(w);
				}
			}
		}

		void VerifyAndPropagateArgumentConstraints(ErrorWriter * err, SymbolTable * symTable, ShaderClosure * shader)
		{
			for (auto & map : shader->RefMap)
			{
				auto & arg = map.Value;
				RefPtr<ShaderComponentSymbol> requirement;
				if (shader->Components.TryGetValue(map.Key, requirement) && requirement->IsParam())
				{
					if (requirement->Implementations.First()->SyntaxNode->Rate)
					{
						for (auto w : requirement->Implementations.First()->Worlds)
						{
							if (!symTable->IsWorldImplicitlyReachable(shader->Pipeline, arg->Type->FeasibleWorlds, w, requirement->Type->DataType))
							{
								err->Error(32015, L"argument '" + arg->Name + L"' is not available in world '" + w + L"' as required by '" + shader->Name
									+ L"'.\nsee requirement declaration at " +
									requirement->Implementations.First()->SyntaxNode->Position.ToString(), arg->Implementations.First()->SyntaxNode->Position);
							}
						}
						PropagateArgumentConstraints(requirement.Ptr(), arg.Ptr());
					}
				}
			}
			for (auto & subClosure : shader->SubClosures)
				VerifyAndPropagateArgumentConstraints(err, symTable, subClosure.Value.Ptr());
		}

		void AddPipelineComponents(ShaderClosure * shader)
		{
			for (auto & comp : shader->Pipeline->Components)
			{
				if (!comp.Value->IsParam())
					shader->Components.AddIfNotExists(comp.Key, new ShaderComponentSymbol(*comp.Value));
			}
		}

		void GatherArgumentMappings(EnumerableDictionary<String, String> & result, ShaderClosure* shader)
		{
			for (auto & map : shader->RefMap)
			{
				result[shader->Components[map.Key]()->UniqueName] = map.Value->UniqueName;
			}
			for (auto & subShader : shader->SubClosures)
				GatherArgumentMappings(result, subShader.Value.Ptr());
		}

		void RemoveTrivialComponents(ShaderClosure * shader)
		{
			// remove trivial components, e.g. if A = B, replace all references to A with B.
			// this is not just an optimization, it is also critical for CodeGen because 
			// code gen does not support components that returns another function component or sampler2D etc.
			// i.e. function/sampler2D components must be referenced directly.
			EnumerableDictionary<String, String> compSub;
			for (auto & comp : shader->AllComponents)
			{
				// if this component is required by pipeline (e.g. gl_Position), do not attempt to remove it
				if (shader->Pipeline->Components.ContainsKey(comp.Key))
					continue;

				if (comp.Value->Implementations.Count() == 1 &&
					comp.Value->Implementations.First()->SyntaxNode->Expression &&
					!comp.Value->Implementations.First()->SyntaxNode->IsOutput)
				{
					RefPtr<Object> compRef;
					if (comp.Value->Implementations.First()->SyntaxNode->Expression->Tags.TryGetValue(L"ComponentReference", compRef))
					{
						compSub[comp.Key] = compRef.As<StringObject>()->Content;
					}
				}
			}
			// gather argument mappings
			EnumerableDictionary<String, String> arguments;
			GatherArgumentMappings(arguments, shader);
			EnumerableDictionary<String, String> replacements;
			for (auto & replace : compSub)
			{
				// search transitively for replaceDest;
				String replaceDest = replace.Key;
				while (compSub.ContainsKey(replaceDest))
				{
					replaceDest = compSub[replaceDest]();
					arguments.TryGetValue(replaceDest, replaceDest);
				}
				if (replace.Key != replaceDest)
					replacements[replace.Key] = replaceDest;
			}
			ReplaceReference(shader, replacements);
			for (auto & r : replacements)
				shader->AllComponents.Remove(r.Key);
		}

		void PropagatePipelineRequirements(ErrorWriter * err, ShaderClosure * shader)
		{
			for (auto & req : shader->Pipeline->Components)
			{
				if (req.Value->IsParam())
				{
					ShaderComponentSymbol * comp;
					StringBuilder errMsg;
					if (shader->AllComponents.TryGetValue(req.Key, comp))
					{
						if (!comp->Type->DataType->Equals(req.Value->Type->DataType.Ptr()))
						{
							errMsg << L"component '" << req.Key << L"' has type '" << comp->Type->DataType->ToString() << L"', but pipeline '"
								<< shader->Pipeline->SyntaxNode->Name.Content << L"' requires it to be '" << req.Value->Type->DataType->ToString() 
								<< L"'.\nsee pipeline requirement definition at " << req.Value->Implementations.First()->SyntaxNode->Position.ToString();
							err->Error(32051, errMsg.ProduceString(), comp->Implementations.First()->SyntaxNode->Position);
						}
					}
					else
					{
						errMsg << L"shader '" << shader->Name << L"' does not define '" << req.Key << L"' as required by pipeline '"
							<< shader->Pipeline->SyntaxNode->Name.Content << L"''.\nsee pipeline requirement definition at "
							<< req.Value->Implementations.First()->SyntaxNode->Position.ToString();
						err->Error(32052, errMsg.ProduceString(), shader->Position);
					}
				}
			}
		}

		void PrintModuleUsingStack(StringBuilder & sb, ShaderClosure * shader)
		{
			if (shader->Parent)
			{
				sb << L"see module '" + shader->Name << L"' being used in '" + shader->Parent->Name << L"' at " << shader->Position.ToString() << L"\n";
				PrintModuleUsingStack(sb, shader->Parent);
			}
			else
			{
				sb << L"shader '" << shader->Name << L"' is targeting pipeline '" << shader->Pipeline->SyntaxNode->Name.Content << L"' at " << shader->Position.ToString() << L"\nalso see pipeline definition at " << shader->Pipeline->SyntaxNode->Position.ToString();
			}
		}
	
		void CheckPipelineShaderConsistency(ErrorWriter * err, ShaderClosure * shader)
		{
			for (auto & comp : shader->Components)
			{
				for (auto & impl : comp.Value->Implementations)
				{
					bool inAbstractWorld = false;
					if (impl->SyntaxNode->Rate)
					{
						auto & userSpecifiedWorlds = impl->SyntaxNode->Rate->Worlds;
						for (auto & world : userSpecifiedWorlds)
						{
							{
								StringBuilder sb;
								sb << L"\'" << world.World.Content << L"' is not a defined world in '" <<
									shader->Pipeline->SyntaxNode->Name.Content << L"'.\n";
								PrintModuleUsingStack(sb, shader);
								if (!shader->Pipeline->WorldDependency.ContainsKey(world.World.Content))
									err->Error(33012, sb.ProduceString(), world.World.Position);
							}
							WorldSymbol worldSym;
							if (shader->Pipeline->Worlds.TryGetValue(world.World.Content, worldSym))
							{
								if (worldSym.IsAbstract)
								{
									inAbstractWorld = true;
									if (userSpecifiedWorlds.Count() > 1)
									{
										StringBuilder sb;
										sb << L"abstract world cannot appear with other worlds.\n";
										PrintModuleUsingStack(sb, shader);
										err->Error(33013, sb.ProduceString(),
											world.World.Position);
										PrintModuleUsingStack(sb, shader);
									}
								}
							}
						}
					}
					if (!inAbstractWorld && !impl->SyntaxNode->IsParam && !impl->SyntaxNode->IsInput
						&& !impl->SyntaxNode->Expression && !impl->SyntaxNode->BlockStatement)
					{
						err->Error(33014, L"non-abstract component must have an implementation.",
							impl->SyntaxNode->Position);
					}

					bool isDefinedInAbstractWorld = false, isDefinedInNonAbstractWorld = false;
					if (impl->SyntaxNode->Rate)
					{
						for (auto & w : impl->SyntaxNode->Rate->Worlds)
						{
							auto world = shader->Pipeline->Worlds.TryGetValue(w.World.Content);
							if (world)
							{
								if (world->IsAbstract)
									isDefinedInAbstractWorld = true;
								else
									isDefinedInNonAbstractWorld = true;
							}
						}
					}
					else
						isDefinedInNonAbstractWorld = true;
					if (impl->SyntaxNode->Expression || impl->SyntaxNode->BlockStatement)
					{
						if (isDefinedInAbstractWorld)
							err->Error(33039, L"'" + impl->SyntaxNode->Name.Content + L"': no code allowed for component defined in input world.", impl->SyntaxNode->Position);
					}
				}
			}
			for (auto & subShader : shader->SubClosures)
				CheckPipelineShaderConsistency(err, subShader.Value.Ptr());
		}

		void FlattenShaderClosure(ErrorWriter * err, SymbolTable * symTable, ShaderClosure * shader)
		{
			// add input(extern) components from pipeline
			AddPipelineComponents(shader);
			CheckPipelineShaderConsistency(err, shader);
			// assign choice names
			AssignUniqueNames(shader, L"", L"");
			// traverse closures to get component list
			GatherComponents(err, shader, shader);
			PropagatePipelineRequirements(err, shader);
			ResolveReference(err, shader, shader);
			// propagate world constraints
			if (CheckCircularReference(err, shader))
				return;
			if (err->GetErrorCount())
				return;
			RemoveTrivialComponents(shader);
			SolveWorldConstraints(err, symTable, shader);
			// check pipeline constraints
			for (auto & requirement : shader->Pipeline->Components)
			{
				if (!requirement.Value->IsParam())
					continue;
				auto comp = shader->FindComponent(requirement.Key);
				if (!comp)
				{
					err->Error(32014, L"shader '" + shader->Name + L"' does not provide '" + requirement.Key + L"' as required by '" + shader->Pipeline->SyntaxNode->Name.Content
						+ L"'.\nsee requirement declaration at " +
						requirement.Value->Implementations.First()->SyntaxNode->Position.ToString(), shader->Position);
				}
				else
				{
					for (auto & impl : requirement.Value->Implementations)
					{
						for (auto w : impl->Worlds)
						{
							if (!symTable->IsWorldImplicitlyReachable(shader->Pipeline, comp->Type->FeasibleWorlds, w, requirement.Value->Type->DataType))
							{
								err->Error(32015, L"component '" + comp->Name + L"' is not available in world '" + w + L"' as required by '" + shader->Pipeline->SyntaxNode->Name.Content
									+ L"'.\nsee requirement declaration at " +
									requirement.Value->Implementations.First()->SyntaxNode->Position.ToString(), comp->Implementations.First()->SyntaxNode->Position);
							}
						}
					}
					PropagateArgumentConstraints(requirement.Value.Ptr(), comp.Ptr());
				}
			}
			// check argument constraints
			VerifyAndPropagateArgumentConstraints(err, symTable, shader);
		}
	}
}

/***********************************************************************
SPIRECORE\CODEGENERATOR.CPP
***********************************************************************/
#include <assert.h>

namespace Spire
{
	namespace Compiler
	{
		template<typename Func>
		class ImportNodeVisitor : public SyntaxVisitor
		{
		public:
			const Func & func;
			ImportNodeVisitor(const Func & f)
				: SyntaxVisitor(nullptr), func(f)
			{}
			virtual RefPtr<ExpressionSyntaxNode> VisitImportExpression(ImportExpressionSyntaxNode * expr) override
			{
				func(expr);
				return expr;
			}
		};

		template<typename Func>
		void EnumerateImportExpressions(SyntaxNode * node, const Func & f)
		{
			ImportNodeVisitor<Func> visitor(f);
			node->Accept(&visitor);
		}

		class CodeGenerator : public ICodeGenerator
		{
		private:
			SymbolTable * symTable;
			ILWorld * currentWorld = nullptr;
			ComponentDefinitionIR * currentComponent = nullptr;
			ILOperand * returnRegister = nullptr;
			ImportOperatorDefSyntaxNode * currentImportDef = nullptr;
			ShaderIR * currentShader = nullptr;
			CompileResult & result;
			List<ILOperand*> exprStack;
			CodeWriter codeWriter;
			ScopeDictionary<String, ILOperand*> variables;
			Dictionary<String, RefPtr<ILRecordType>> recordTypes;

			void PushStack(ILOperand * op)
			{
				exprStack.Add(op);
			}
			ILOperand * PopStack()
			{
				auto rs = exprStack.Last();
				exprStack.SetSize(exprStack.Count() - 1);
				return rs;
			}
			AllocVarInstruction * AllocVar(ExpressionType * etype)
			{
				AllocVarInstruction * varOp = 0;
				RefPtr<ILType> type = TranslateExpressionType(etype, &recordTypes);
				auto arrType = dynamic_cast<ILArrayType*>(type.Ptr());

				if (arrType)
				{
					varOp = codeWriter.AllocVar(arrType->BaseType, result.Program->ConstantPool->CreateConstant(arrType->ArrayLength));
				}
				else
				{
					assert(type);
					varOp = codeWriter.AllocVar(type, result.Program->ConstantPool->CreateConstant(0));
				}
				return varOp;
			}
			FetchArgInstruction * FetchArg(ExpressionType * etype, int argId)
			{
				auto type = TranslateExpressionType(etype, &recordTypes);
				auto arrType = dynamic_cast<ILArrayType*>(type.Ptr());
				FetchArgInstruction * varOp = 0;
				if (arrType)
				{
					auto baseType = arrType->BaseType.Release();
					varOp = codeWriter.FetchArg(baseType, argId);
				}
				else
				{
					varOp = codeWriter.FetchArg(type, argId);
				}
				return varOp;
			}
			void TranslateStages(ILShader * compiledShader, PipelineSyntaxNode * pipeline)
			{
				for (auto & stage : pipeline->Stages)
				{
					RefPtr<ILStage> ilStage = new ILStage();
					ilStage->Position = stage->Position;
					ilStage->Name = stage->Name.Content;
					ilStage->StageType = stage->StageType.Content;
					for (auto & attrib : stage->Attributes)
					{
						StageAttribute sattrib;
						sattrib.Name = attrib.Key;
						sattrib.Position = attrib.Value.Position;
						sattrib.Value = attrib.Value.Content;
						ilStage->Attributes[attrib.Key] = sattrib;
					}
					compiledShader->Stages[stage->Name.Content] = ilStage;
				}
			}
			String GetComponentFunctionName(ComponentSyntaxNode * comp)
			{
				StringBuilder nameSb;
				nameSb << comp->ParentModuleName.Content << L"." << comp->Name.Content;
				StringBuilder finalNameSb;
				for (auto ch : nameSb.ProduceString())
				{
					if ((ch >= L'0' && ch <= L'9') || (ch >= L'a' && ch <= L'z') || (ch >= 'A' && ch <= 'Z'))
						finalNameSb << ch;
					else
						finalNameSb << L'_';
				}
				return EscapeDoubleUnderscore(finalNameSb.ProduceString());
			}
		public:
			virtual RefPtr<StructSyntaxNode> VisitStruct(StructSyntaxNode * st) override
			{
				result.Program->Structs.Add(symTable->Structs[st->Name.Content]()->Type);
				return st;
			}
			virtual void ProcessFunction(FunctionSyntaxNode * func) override
			{
				VisitFunction(func);
			}
			virtual void ProcessStruct(StructSyntaxNode * st) override
			{
				VisitStruct(st);
			}

			virtual void ProcessShader(ShaderIR * shader) override
			{
				currentShader = shader;
				auto pipeline = shader->Shader->Pipeline;
				RefPtr<ILShader> compiledShader = new ILShader();
				compiledShader->Name = shader->Shader->Name;
				compiledShader->Position = shader->Shader->Position;
				TranslateStages(compiledShader.Ptr(), pipeline->SyntaxNode);
				result.Program->Shaders.Add(compiledShader);

				recordTypes.Clear();

				// pass 1: iterating all worlds
				// create ILWorld and ILRecordType objects for all worlds

				for (auto & world : pipeline->Worlds)
				{
					auto w = new ILWorld();
					auto recordType = new ILRecordType();
					recordType->TypeName = world.Key;
					recordTypes[world.Key] = recordType;
					w->Name = world.Key;
					w->OutputType = recordType;
					w->Attributes = world.Value.SyntaxNode->LayoutAttributes;
					w->Shader = compiledShader.Ptr();
					w->IsAbstract = world.Value.IsAbstract;
					auto impOps = pipeline->GetImportOperatorsFromSourceWorld(world.Key);
					w->Position = world.Value.SyntaxNode->Position;
					compiledShader->Worlds[world.Key] = w;
				}

				// pass 2: iterating all worlds:
				// 1) Gather list of components for each world, and store it in worldComps dictionary.
				// 2) For each abstract world, add its components to record type

				Dictionary<String, List<ComponentDefinitionIR*>> worldComps;
				
				for (auto & world : pipeline->Worlds)
				{
					// gather list of components
					List<ComponentDefinitionIR*> components;
					for (auto & compDef : shader->Definitions)
						if (compDef->World == world.Key)
							components.Add(compDef.Ptr());

					// for abstract world, fill in record type now
					if (world.Value.IsAbstract)
					{
						auto compiledWorld = compiledShader->Worlds[world.Key]();
						for (auto & comp : components)
						{
							ILObjectDefinition compDef;
							compDef.Attributes = comp->SyntaxNode->LayoutAttributes;
							compDef.Name = comp->UniqueName;
							compDef.Type = TranslateExpressionType(comp->Type.Ptr(), &recordTypes);
							compDef.Position = comp->SyntaxNode->Position;
							compiledWorld->OutputType->Members.AddIfNotExists(compDef.Name, compDef);
						}
					}

					// sort components by dependency
					DependencySort(components, [](ComponentDefinitionIR * def)
					{
						return def->Dependency;
					});
					// put the list in worldComps
					worldComps[world.Key] = components;
				}

				// now we need to deal with import operators
				// create world input declarations base on input components
				for (auto & world : compiledShader->Worlds)
				{
					auto components = worldComps[world.Key]();
					for (auto & comp : components)
					{
						if (comp->SyntaxNode->IsInput)
						{
							ILObjectDefinition def;
							def.Name = comp->UniqueName;
							def.Type = TranslateExpressionType(comp->Type.Ptr(), &recordTypes);
							def.Position = comp->SyntaxNode->Position;
							def.Attributes = comp->SyntaxNode->LayoutAttributes;
							world.Value->Inputs.Add(def);
						}
					}
				}

				// fill in record types
				for (auto & comps : worldComps)
				{
					for (auto & comp : comps.Value)
					{
						// for each import operator call "import[w0->w1](x)", add x to w0's record type
						EnumerateImportExpressions(comp->SyntaxNode.Ptr(), [&](ImportExpressionSyntaxNode * importExpr)
						{
							auto & recType = recordTypes[importExpr->ImportOperatorDef->SourceWorld.Content]();
							ILObjectDefinition entryDef;
							entryDef.Attributes = comp->SyntaxNode->LayoutAttributes;
							entryDef.Name = importExpr->ComponentUniqueName;
							entryDef.Type = TranslateExpressionType(importExpr->Type.Ptr(), &recordTypes);
							entryDef.Position = importExpr->Position;
							recType->Members.AddIfNotExists(importExpr->ComponentUniqueName, entryDef);
						});
						// if comp is output, add comp to its world's record type
						if (comp->SyntaxNode->IsOutput)
						{
							auto & recType = recordTypes[comp->World]();
							ILObjectDefinition entryDef;
							entryDef.Attributes = comp->SyntaxNode->LayoutAttributes;
							entryDef.Name = comp->UniqueName;
							entryDef.Type = TranslateExpressionType(comp->Type.Ptr(), &recordTypes);
							entryDef.Position = comp->SyntaxNode->Position;
							recType->Members.AddIfNotExists(comp->UniqueName, entryDef);
						}
					}
				}
			
				// generate component functions
				for (auto & comp : shader->Definitions)
				{
					currentComponent = comp.Ptr();
					if (comp->SyntaxNode->Parameters.Count())
					{
						auto funcName = GetComponentFunctionName(comp->SyntaxNode.Ptr());
						if (result.Program->Functions.ContainsKey(funcName))
							continue;
						RefPtr<ILFunction> func = new ILFunction();
						RefPtr<FunctionSymbol> funcSym = new FunctionSymbol();
						func->Name = funcName;
						func->ReturnType = TranslateExpressionType(comp->Type, &recordTypes);
						symTable->Functions[funcName] = funcSym;
						result.Program->Functions[funcName] = func;
						for (auto dep : comp->GetComponentFunctionDependencyClosure())
						{
							if (dep->SyntaxNode->Parameters.Count())
							{
								funcSym->ReferencedFunctions.Add(GetComponentFunctionName(dep->SyntaxNode.Ptr()));
							}
						}
						int id = 0;
						Dictionary<String, ILOperand*> refComponents;
						variables.PushScope();
						codeWriter.PushNode();
						for (auto & dep : comp->GetComponentFunctionDependencyClosure())
						{
							if (dep->SyntaxNode->Parameters.Count() == 0)
							{
								auto paramType = TranslateExpressionType(dep->Type, &recordTypes);
								String paramName = EscapeDoubleUnderscore(L"p" + String(id) + L"_" + dep->OriginalName); 
								func->Parameters.Add(paramName, paramType);
								auto argInstr = codeWriter.FetchArg(paramType, id + 1);
								argInstr->Name = paramName;
								variables.Add(dep->UniqueName, argInstr);
								id++;
							}
						}
						for (auto & param : comp->SyntaxNode->Parameters)
						{
							auto paramType = TranslateExpressionType(param->Type, &recordTypes);
							String paramName = EscapeDoubleUnderscore(L"p" + String(id) + L"_" + param->Name);
							func->Parameters.Add(paramName, paramType);
							auto argInstr = codeWriter.FetchArg(paramType, id + 1);
							argInstr->Name = paramName;
							variables.Add(param->Name, argInstr);
							id++;
						}
						if (comp->SyntaxNode->Expression)
						{
							comp->SyntaxNode->Expression->Accept(this);
							codeWriter.Insert(new ReturnInstruction(PopStack()));
						}
						else
						{
							comp->SyntaxNode->BlockStatement->Accept(this);
						}
						variables.PopScope();
						func->Code = codeWriter.PopNode();
					}
					currentComponent = nullptr;
				}
				
				for (auto & world : pipeline->Worlds)
				{
					if (world.Value.IsAbstract)
						continue;
					NamingCounter = 0;

					auto & components = worldComps[world.Key].GetValue();
					auto compiledWorld = compiledShader->Worlds[world.Key].GetValue().Ptr();
					currentWorld = compiledWorld;
					codeWriter.PushNode();
					variables.PushScope();
					HashSet<String> localComponents;
					for (auto & comp : components)
						localComponents.Add(comp->UniqueName);

					DependencySort(components, [](ComponentDefinitionIR * def)
					{
						return def->Dependency;
					});

					for (auto & comp : components)
					{
						if (comp->SyntaxNode->Parameters.Count() == 0)
							VisitComponent(comp);
					}
					
					variables.PopScope();
					compiledWorld->Code = codeWriter.PopNode();
					EvalReferencedFunctionClosure(compiledWorld);
					currentWorld = nullptr;
				}
				currentShader = nullptr;
			}

			void EvalReferencedFunctionClosure(ILWorld * world)
			{
				List<String> workList;
				for (auto & rfunc : world->ReferencedFunctions)
					workList.Add(rfunc);
				for (int i = 0; i < workList.Count(); i++)
				{
					auto rfunc = workList[i];
					RefPtr<FunctionSymbol> funcSym;
					if (symTable->Functions.TryGetValue(rfunc, funcSym))
					{
						for (auto & rrfunc : funcSym->ReferencedFunctions)
						{
							world->ReferencedFunctions.Add(rrfunc);
							workList.Add(rrfunc);
						}
					}
				}
			}
			virtual RefPtr<ComponentSyntaxNode> VisitComponent(ComponentSyntaxNode *) override
			{
				throw NotImplementedException();
			}
			void VisitComponent(ComponentDefinitionIR * comp)
			{
				currentComponent = comp;
				String varName = EscapeDoubleUnderscore(currentComponent->OriginalName);
				RefPtr<ILType> type = TranslateExpressionType(currentComponent->Type, &recordTypes);

				if (comp->SyntaxNode->IsInput)
				{
					auto loadInput = new LoadInputInstruction(type.Ptr(), comp->UniqueName);
					codeWriter.Insert(loadInput);
					variables.Add(currentComponent->UniqueName, loadInput);
					return;
				}

				ILOperand * componentVar = nullptr;
				
				if (currentComponent->SyntaxNode->Expression)
				{
					currentComponent->SyntaxNode->Expression->Accept(this);
					componentVar = exprStack.Last();
					if (currentWorld->OutputType->Members.ContainsKey(currentComponent->UniqueName))
					{
						auto exp = new ExportInstruction(currentComponent->UniqueName, currentWorld, componentVar);
						codeWriter.Insert(exp);
					}
					exprStack.Clear();
				}
				else if (currentComponent->SyntaxNode->BlockStatement)
				{
					returnRegister = nullptr;
					currentComponent->SyntaxNode->BlockStatement->Accept(this);
					componentVar = returnRegister;
				}

				/*if (!currentComponent->Type->IsTexture() && !currentComponent->Type->IsArray())
				{
					auto vartype = TranslateExpressionType(currentComponent->Type.Ptr(), &recordTypes);
					auto var = codeWriter.AllocVar(vartype, result.Program->ConstantPool->CreateConstant(1));
					var->Name = varName;
					codeWriter.Store(var, componentVar);
					componentVar = var;
				}
				else*/
					componentVar->Name = varName;
				currentWorld->Components[currentComponent->UniqueName] = componentVar;
				variables.Add(currentComponent->UniqueName, componentVar);
				currentComponent = nullptr;
			}
			virtual RefPtr<FunctionSyntaxNode> VisitFunction(FunctionSyntaxNode* function) override
			{
				if (function->IsExtern)
					return function;
				RefPtr<ILFunction> func = new ILFunction();
				result.Program->Functions.Add(function->InternalName, func);
				func->Name = function->InternalName;
				func->ReturnType = TranslateExpressionType(function->ReturnType);
				variables.PushScope();
				codeWriter.PushNode();
				int id = 0;
				for (auto &param : function->Parameters)
				{
					func->Parameters.Add(param->Name, TranslateExpressionType(param->Type));
					auto op = FetchArg(param->Type.Ptr(), ++id);
					op->Name = EscapeDoubleUnderscore(String(L"p_") + param->Name);
					variables.Add(param->Name, op);
				}
				function->Body->Accept(this);
				func->Code = codeWriter.PopNode();
				variables.PopScope();
				return function;
			}
			virtual RefPtr<StatementSyntaxNode> VisitBlockStatement(BlockStatementSyntaxNode* stmt) override
			{
				variables.PushScope();
				for (auto & subStmt : stmt->Statements)
					subStmt->Accept(this);
				variables.PopScope();
				return stmt;
			}
			virtual RefPtr<StatementSyntaxNode> VisitWhileStatement(WhileStatementSyntaxNode* stmt) override
			{
				RefPtr<WhileInstruction> instr = new WhileInstruction();
				variables.PushScope();
				codeWriter.PushNode();
				stmt->Predicate->Accept(this);
				codeWriter.Insert(new ReturnInstruction(PopStack()));
				instr->ConditionCode = codeWriter.PopNode();
				codeWriter.PushNode();
				stmt->Statement->Accept(this);
				instr->BodyCode = codeWriter.PopNode();
				codeWriter.Insert(instr.Release());
				variables.PopScope();
				return stmt;
			}
			virtual RefPtr<StatementSyntaxNode> VisitDoWhileStatement(DoWhileStatementSyntaxNode* stmt) override
			{
				RefPtr<DoInstruction> instr = new DoInstruction();
				variables.PushScope();
				codeWriter.PushNode();
				stmt->Predicate->Accept(this);
				codeWriter.Insert(new ReturnInstruction(PopStack()));
				instr->ConditionCode = codeWriter.PopNode();
				codeWriter.PushNode();
				stmt->Statement->Accept(this);
				instr->BodyCode = codeWriter.PopNode();
				codeWriter.Insert(instr.Release());
				variables.PopScope();
				return stmt;
			}
			virtual RefPtr<StatementSyntaxNode> VisitForStatement(ForStatementSyntaxNode* stmt) override
			{
				RefPtr<ForInstruction> instr = new ForInstruction();
				variables.PushScope();
				if (stmt->TypeDef)
				{
					AllocVarInstruction * varOp = AllocVar(stmt->IterationVariableType.Ptr());
					varOp->Name = EscapeDoubleUnderscore(stmt->IterationVariable.Content);
					variables.Add(stmt->IterationVariable.Content, varOp);
				}
				ILOperand * iterVar = nullptr;
				if (stmt->IterationVariable.Content.Length() && !variables.TryGetValue(stmt->IterationVariable.Content, iterVar))
					throw InvalidProgramException(L"Iteration variable not found in variables dictionary. This should have been checked by semantics analyzer.");
				if (stmt->InitialExpression)
				{
					codeWriter.PushNode();
					stmt->InitialExpression->Accept(this);
					PopStack();
					instr->InitialCode = codeWriter.PopNode();
				}

				if (stmt->PredicateExpression)
				{
					codeWriter.PushNode();
					stmt->PredicateExpression->Accept(this);
					PopStack();
					instr->ConditionCode = codeWriter.PopNode();
				}
			
				if (stmt->SideEffectExpression)
				{
					codeWriter.PushNode();
					stmt->SideEffectExpression->Accept(this);
					PopStack();
					instr->SideEffectCode = codeWriter.PopNode();
				}

				codeWriter.PushNode();
				stmt->Statement->Accept(this);
				instr->BodyCode = codeWriter.PopNode();
				codeWriter.Insert(instr.Release());
				variables.PopScope();
				return stmt;
			}
			virtual RefPtr<StatementSyntaxNode> VisitIfStatement(IfStatementSyntaxNode* stmt) override
			{
				RefPtr<IfInstruction> instr = new IfInstruction();
				variables.PushScope();
				stmt->Predicate->Accept(this);
				instr->Operand = PopStack();
				codeWriter.PushNode();
				stmt->PositiveStatement->Accept(this);
				instr->TrueCode = codeWriter.PopNode();
				if (stmt->NegativeStatement)
				{
					codeWriter.PushNode();
					stmt->NegativeStatement->Accept(this);
					instr->FalseCode = codeWriter.PopNode();
				}
				codeWriter.Insert(instr.Release());
				variables.PopScope();
				return stmt;
			}
			virtual RefPtr<StatementSyntaxNode> VisitReturnStatement(ReturnStatementSyntaxNode* stmt) override
			{
				returnRegister = nullptr;
				if (currentWorld != nullptr && currentComponent != nullptr && !currentImportDef)
				{
					if (stmt->Expression)
					{
						stmt->Expression->Accept(this);
						returnRegister = PopStack();
						if (currentComponent->SyntaxNode->Parameters.Count() == 0)
						{
							if (currentWorld->OutputType->Members.ContainsKey(currentComponent->UniqueName))
							{
								auto exp = new ExportInstruction(currentComponent->UniqueName, currentWorld, returnRegister);
								codeWriter.Insert(exp);
							}
						}
						else
						{
							codeWriter.Insert(new ReturnInstruction(returnRegister));
						}
					}
				}
				else
				{
					if (stmt->Expression)
					{
						stmt->Expression->Accept(this);
						returnRegister = PopStack();
					}
					codeWriter.Insert(new ReturnInstruction(returnRegister));
				}
				return stmt;
			}
			virtual RefPtr<StatementSyntaxNode> VisitBreakStatement(BreakStatementSyntaxNode* stmt) override
			{
				codeWriter.Insert(new BreakInstruction());
				return stmt;
			}
			virtual RefPtr<StatementSyntaxNode> VisitContinueStatement(ContinueStatementSyntaxNode* stmt) override
			{
				codeWriter.Insert(new ContinueInstruction());
				return stmt;
			}
			virtual RefPtr<ExpressionSyntaxNode> VisitSelectExpression(SelectExpressionSyntaxNode * expr) override
			{
				expr->SelectorExpr->Accept(this);
				auto predOp = PopStack();
				expr->Expr0->Accept(this);
				auto v0 = PopStack();
				expr->Expr1->Accept(this);
				auto v1 = PopStack();
				PushStack(codeWriter.Select(predOp, v0, v1));
				return expr;
			}
			ILOperand * EnsureBoolType(ILOperand * op, RefPtr<ExpressionType> type)
			{
				if (!type->Equals(ExpressionType::Bool.Ptr()))
				{
					auto cmpeq = new CmpneqInstruction();
					cmpeq->Operands[0] = op;
					cmpeq->Operands[1] = result.Program->ConstantPool->CreateConstant(0);
					cmpeq->Type = new ILBasicType(ILBaseType::Int);
					codeWriter.Insert(cmpeq);
					return cmpeq;
				}
				else
					return op;
			}
			virtual RefPtr<StatementSyntaxNode> VisitDiscardStatement(DiscardStatementSyntaxNode * stmt) override
			{
				codeWriter.Discard();
				return stmt;
			}
			virtual RefPtr<StatementSyntaxNode> VisitVarDeclrStatement(VarDeclrStatementSyntaxNode* stmt) override
			{
				for (auto & v : stmt->Variables)
				{
					AllocVarInstruction * varOp = AllocVar(stmt->Type.Ptr());
					varOp->Name = EscapeDoubleUnderscore(v->Name);
					variables.Add(v->Name, varOp);
					if (v->Expression)
					{
						v->Expression->Accept(this);
						Assign(varOp, PopStack());
					}
				}
				return stmt;
			}
			virtual RefPtr<StatementSyntaxNode> VisitExpressionStatement(ExpressionStatementSyntaxNode* stmt) override
			{
				stmt->Expression->Accept(this);
				PopStack();
				return stmt;
			}
			void Assign(ILOperand * left, ILOperand * right)
			{
				if (auto add = dynamic_cast<AddInstruction*>(left))
				{
					auto baseOp = add->Operands[0].Ptr();
					codeWriter.Update(baseOp, add->Operands[1].Ptr(), right);
					add->Erase();
				}
				else if (auto swizzle = dynamic_cast<SwizzleInstruction*>(left))
				{
					auto baseOp = swizzle->Operand.Ptr();
					int index = 0;
					for (int i = 0; i < swizzle->SwizzleString.Length(); i++)
					{
						switch (swizzle->SwizzleString[i])
						{
						case L'r':
						case L'x':
							index = 0;
							break;
						case L'g':
						case L'y':
							index = 1;
							break;
						case L'b':
						case L'z':
							index = 2;
							break;
						case L'a':
						case L'w':
							index = 3;
							break;
						}
						codeWriter.Update(baseOp, result.Program->ConstantPool->CreateConstant(index),
							codeWriter.Retrieve(right, result.Program->ConstantPool->CreateConstant(i)));
					}
					swizzle->Erase();
				}
				else
					codeWriter.Store(left, right);
			}
			virtual RefPtr<ExpressionSyntaxNode> VisitBinaryExpression(BinaryExpressionSyntaxNode* expr) override
			{
				expr->RightExpression->Accept(this);
				auto right = PopStack();
				if (expr->Operator == Operator::Assign)
				{
					expr->LeftExpression->Access = ExpressionAccess::Write;
					expr->LeftExpression->Accept(this);
					auto left = PopStack();
					Assign(left, right);
					PushStack(left);
				}
				else
				{
					expr->LeftExpression->Access = ExpressionAccess::Read;
					expr->LeftExpression->Accept(this);
					auto left = PopStack();
					BinaryInstruction * rs = 0;
					switch (expr->Operator)
					{
					case Operator::Add:
					case Operator::AddAssign:
						rs = new AddInstruction();
						break;
					case Operator::Sub:
					case Operator::SubAssign:
						rs = new SubInstruction();
						break;
					case Operator::Mul:
					case Operator::MulAssign:
						rs = new MulInstruction();
						break;
					case Operator::Mod:
					case Operator::ModAssign:
						rs = new ModInstruction();
						break;
					case Operator::Div:
					case Operator::DivAssign:
						rs = new DivInstruction();
						break;
					case Operator::And:
						rs = new AndInstruction();
						break;
					case Operator::Or:
						rs = new OrInstruction();
						break;
					case Operator::BitAnd:
					case Operator::AndAssign:
						rs = new BitAndInstruction();
						break;
					case Operator::BitOr:
					case Operator::OrAssign:
						rs = new BitOrInstruction();
						break;
					case Operator::BitXor:
					case Operator::XorAssign:
						rs = new BitXorInstruction();
						break;
					case Operator::Lsh:
					case Operator::LshAssign:
						rs = new ShlInstruction();
						break;
					case Operator::Rsh:
					case Operator::RshAssign:
						rs = new ShrInstruction();
						break;
					case Operator::Eql:
						rs = new CmpeqlInstruction();
						break;
					case Operator::Neq:
						rs = new CmpneqInstruction();
						break;
					case Operator::Greater:
						rs = new CmpgtInstruction();
						break;
					case Operator::Geq:
						rs = new CmpgeInstruction();
						break;
					case Operator::Leq:
						rs = new CmpleInstruction();
						break;
					case Operator::Less:
						rs = new CmpltInstruction();
						break;
					default:
						throw NotImplementedException(L"Code gen not implemented for this operator.");
					}
					rs->Operands.SetSize(2);
					rs->Operands[0] = left;
					rs->Operands[1] = right;
					rs->Type = TranslateExpressionType(expr->Type, &recordTypes);
					codeWriter.Insert(rs);
					switch (expr->Operator)
					{
					case Operator::AddAssign:
					case Operator::SubAssign:
					case Operator::MulAssign:
					case Operator::DivAssign:
					case Operator::ModAssign:
					case Operator::LshAssign:
					case Operator::RshAssign:
					case Operator::AndAssign:
					case Operator::OrAssign:
					case Operator::XorAssign:
					{
						expr->LeftExpression->Access = ExpressionAccess::Write;
						expr->LeftExpression->Accept(this);
						auto target = PopStack();
						Assign(target, rs);
						break;
					}
					default:
						break;
					}
					PushStack(rs);
				}
				return expr;
			}
			virtual RefPtr<ExpressionSyntaxNode> VisitConstantExpression(ConstantExpressionSyntaxNode* expr) override
			{
				ILConstOperand * op;
				if (expr->ConstType == ConstantExpressionSyntaxNode::ConstantType::Float)
				{
					op = result.Program->ConstantPool->CreateConstant(expr->FloatValue);
				}
				else if (expr->ConstType == ConstantExpressionSyntaxNode::ConstantType::Bool)
				{
					op = result.Program->ConstantPool->CreateConstant(expr->IntValue != 0);
				}
				else
				{
					op = result.Program->ConstantPool->CreateConstant(expr->IntValue);
				}
				PushStack(op);
				return expr;
			}
			void GenerateIndexExpression(ILOperand * base, ILOperand * idx, bool read)
			{
				if (read)
				{
					auto ldInstr = codeWriter.Retrieve(base, idx);
					ldInstr->Attribute = base->Attribute;
					PushStack(ldInstr);
				}
				else
				{
					PushStack(codeWriter.Add(base, idx));
				}
			}
			virtual RefPtr<ExpressionSyntaxNode> VisitImportExpression(ImportExpressionSyntaxNode * expr) override
			{
				variables.PushScope();
				List<ILOperand*> arguments;
				for (int i = 0; i < expr->Arguments.Count(); i++)
				{
					expr->Arguments[i]->Accept(this);
					auto argOp = PopStack();
					arguments.Add(argOp);
					variables.Add(expr->ImportOperatorDef->Parameters[i]->Name, argOp);
				}
				currentImportDef = expr->ImportOperatorDef.Ptr();
				codeWriter.PushNode();
				expr->ImportOperatorDef->Body->Accept(this);
				currentImportDef = nullptr;
				auto impInstr = new ImportInstruction(expr->Arguments.Count());
				for (int i = 0; i < expr->Arguments.Count(); i++)
					impInstr->Arguments[i] = arguments[i];
				impInstr->ImportOperator = codeWriter.PopNode();
				variables.PopScope();
				impInstr->ComponentName = expr->ComponentUniqueName;
				impInstr->Type = TranslateExpressionType(expr->Type, &recordTypes);
				codeWriter.Insert(impInstr);
				PushStack(impInstr);
				return expr;
			}
			virtual RefPtr<ExpressionSyntaxNode> VisitIndexExpression(IndexExpressionSyntaxNode* expr) override
			{
				expr->BaseExpression->Access = expr->Access;
				expr->BaseExpression->Accept(this);
				auto base = PopStack();
				expr->IndexExpression->Access = ExpressionAccess::Read;
				expr->IndexExpression->Accept(this);
				auto idx = PopStack();
				GenerateIndexExpression(base, idx,
					expr->Access == ExpressionAccess::Read);
				return expr;
			}
			virtual RefPtr<ExpressionSyntaxNode> VisitMemberExpression(MemberExpressionSyntaxNode * expr) override
			{
				RefPtr<Object> refObj;
				if (expr->Tags.TryGetValue(L"ComponentReference", refObj))
				{
					if (auto refComp = refObj.As<StringObject>())
					{
						ILOperand * op;
						if (variables.TryGetValue(refComp->Content, op))
							PushStack(op);
						else
							throw InvalidProgramException(L"referencing undefined component/variable. probable cause: unchecked circular reference.");
					}
				}
				else
				{
					expr->BaseExpression->Access = expr->Access;
					expr->BaseExpression->Accept(this);
					auto base = PopStack();
					auto generateSingleMember = [&](wchar_t memberName)
					{
						int idx = 0;
						if (memberName == L'y' || memberName == L'g')
							idx = 1;
						else if (memberName == L'z' || memberName == L'b')
							idx = 2;
						else if (memberName == L'w' || memberName == L'a')
							idx = 3;

						GenerateIndexExpression(base, result.Program->ConstantPool->CreateConstant(idx),
							expr->Access == ExpressionAccess::Read);
					};
					if (expr->BaseExpression->Type->IsVectorType())
					{
						if (expr->MemberName.Length() == 1)
						{
							generateSingleMember(expr->MemberName[0]);
						}
						else
						{
							auto rs = new SwizzleInstruction();
							rs->Type = TranslateExpressionType(expr->Type.Ptr(), &recordTypes);
							rs->SwizzleString = expr->MemberName;
							rs->Operand = base;
							codeWriter.Insert(rs);
							PushStack(rs);
						}
					}
					else if (expr->BaseExpression->Type->IsStruct())
					{
						int id = expr->BaseExpression->Type->AsBasicType()->Struct->SyntaxNode->FindField(expr->MemberName);
						GenerateIndexExpression(base, result.Program->ConstantPool->CreateConstant(id),
							expr->Access == ExpressionAccess::Read);
					}
					else
						throw NotImplementedException(L"member expression codegen");
				}
				return expr;
			}
			virtual RefPtr<ExpressionSyntaxNode> VisitInvokeExpression(InvokeExpressionSyntaxNode* expr) override
			{
				List<ILOperand*> args;
				String funcName;
				if (auto basicType = expr->FunctionExpr->Type->AsBasicType())
				{
					if (basicType->Func)
						funcName = basicType->Func->SyntaxNode->IsExtern ? basicType->Func->SyntaxNode->Name : basicType->Func->SyntaxNode->InternalName;
					else if (basicType->Component)
					{
						auto funcCompName = expr->FunctionExpr->Tags[L"ComponentReference"]().As<StringObject>()->Content;
						auto funcComp = *(currentShader->DefinitionsByComponent[funcCompName]().TryGetValue(currentComponent->World));
						funcName = GetComponentFunctionName(funcComp->SyntaxNode.Ptr());
						// push additional arguments
						for (auto & dep : funcComp->GetComponentFunctionDependencyClosure())
						{
							if (dep->SyntaxNode->Parameters.Count() == 0)
							{
								ILOperand * op = nullptr;
								if (variables.TryGetValue(dep->UniqueName, op))
									args.Add(op);
								else
									throw InvalidProgramException(L"cannot resolve reference for implicit component function argument.");
							}
						}
					}
				}
				if (currentWorld)
				{
					currentWorld->ReferencedFunctions.Add(funcName);
				}
				for (auto arg : expr->Arguments)
				{
					arg->Accept(this);
					args.Add(PopStack());
				}
				auto instr = new CallInstruction(args.Count());
				instr->Function = funcName;
				for (int i = 0; i < args.Count(); i++)
					instr->Arguments[i] = args[i];
				instr->Type = TranslateExpressionType(expr->Type, &recordTypes);
				codeWriter.Insert(instr);
				PushStack(instr);
				return expr;
			}
			virtual RefPtr<ExpressionSyntaxNode> VisitTypeCastExpression(TypeCastExpressionSyntaxNode * expr) override
			{
				expr->Expression->Accept(this);
				auto base = PopStack();
				if (expr->Expression->Type == expr->Type)
				{
					PushStack(base);
				}
				else if (expr->Expression->Type == ExpressionType::Float &&
					expr->Type == ExpressionType::Int)
				{
					auto instr = new Float2IntInstruction(base);
					codeWriter.Insert(instr);
					PushStack(instr);
				}
				else if (expr->Expression->Type == ExpressionType::Int &&
					expr->Type == ExpressionType::Float)
				{
					auto instr = new Int2FloatInstruction(base);
					codeWriter.Insert(instr);
					PushStack(instr);
				}
				else
				{
					Error(40001, L"Invalid type cast: \"" + expr->Expression->Type->ToString() + L"\" to \"" +
						expr->Type->ToString() + L"\"", expr);
				}
				return expr;
			}
			virtual RefPtr<ExpressionSyntaxNode> VisitUnaryExpression(UnaryExpressionSyntaxNode* expr) override
			{
				if (expr->Operator == Operator::PostDec || expr->Operator == Operator::PostInc
					|| expr->Operator == Operator::PreDec || expr->Operator == Operator::PreInc)
				{
					expr->Expression->Access = ExpressionAccess::Read;
					expr->Expression->Accept(this);
					auto base = PopStack();
					BinaryInstruction * instr;
					if (expr->Operator == Operator::PostDec)
						instr = new SubInstruction();
					else
						instr = new AddInstruction();
					instr->Operands.SetSize(2);
					instr->Operands[0] = base;
					if (expr->Type == ExpressionType::Float)
						instr->Operands[1] = result.Program->ConstantPool->CreateConstant(1.0f);
					else
						instr->Operands[1] = result.Program->ConstantPool->CreateConstant(1);
					instr->Type = TranslateExpressionType(expr->Type, &recordTypes);
					codeWriter.Insert(instr);

					expr->Expression->Access = ExpressionAccess::Write;
					expr->Expression->Accept(this);
					auto dest = PopStack();
					auto store = new StoreInstruction(dest, instr);
					codeWriter.Insert(store);
					PushStack(base);
				}
				else if (expr->Operator == Operator::PreDec || expr->Operator == Operator::PreInc)
				{
					expr->Expression->Access = ExpressionAccess::Read;
					expr->Expression->Accept(this);
					auto base = PopStack();
					BinaryInstruction * instr;
					if (expr->Operator == Operator::PostDec)
						instr = new SubInstruction();
					else
						instr = new AddInstruction();
					instr->Operands.SetSize(2);
					instr->Operands[0] = base;
					if (expr->Type == ExpressionType::Float)
						instr->Operands[1] = result.Program->ConstantPool->CreateConstant(1.0f);
					else
						instr->Operands[1] = result.Program->ConstantPool->CreateConstant(1);
					instr->Type = TranslateExpressionType(expr->Type, &recordTypes);
					codeWriter.Insert(instr);

					expr->Expression->Access = ExpressionAccess::Write;
					expr->Expression->Accept(this);
					auto dest = PopStack();
					auto store = new StoreInstruction(dest, instr);
					codeWriter.Insert(store);
					PushStack(instr);
				}
				else
				{
					expr->Expression->Accept(this);
					auto base = PopStack();
					auto genUnaryInstr = [&](ILOperand * input)
					{
						UnaryInstruction * rs = 0;
						switch (expr->Operator)
						{
						case Operator::Not:
							input = EnsureBoolType(input, expr->Expression->Type);
							rs = new NotInstruction();
							break;
						case Operator::Neg:
							rs = new NegInstruction();
							break;
						case Operator::BitNot:
							rs = new BitNotInstruction();
							break;
						default:
							throw NotImplementedException(L"Code gen is not implemented for this operator.");
						}
						rs->Operand = input;
						rs->Type = input->Type;
						codeWriter.Insert(rs);
						return rs;
					};
					PushStack(genUnaryInstr(base));
				}
				return expr;
			}
			bool GenerateVarRef(String name, ExpressionAccess access)
			{
				ILOperand * var = 0;
				String srcName = name;
				if (!variables.TryGetValue(srcName, var))
				{
					return false;
				}
				if (access == ExpressionAccess::Read)
				{
					PushStack(var);
				}
				else
				{
					PushStack(var);
				}
				return true;
			}
			virtual RefPtr<ExpressionSyntaxNode> VisitVarExpression(VarExpressionSyntaxNode* expr) override
			{
				RefPtr<Object> refObj;
				if (expr->Tags.TryGetValue(L"ComponentReference", refObj))
				{
					if (auto refComp = refObj.As<StringObject>())
					{
						ILOperand * op;
						if (variables.TryGetValue(refComp->Content, op))
							PushStack(op);
						else
							throw InvalidProgramException(String(L"referencing undefined component/variable '") + refComp->Content + L"'. probable cause: unchecked circular reference.");
					}
				}
				else if (!GenerateVarRef(expr->Variable, expr->Access))
				{
					throw InvalidProgramException(L"identifier is neither a variable nor a recognized component.");
				}
				return expr;
			}
		private:
			CodeGenerator & operator = (const CodeGenerator & other) = delete;
		public:
			CodeGenerator(SymbolTable * symbols, ErrorWriter * pErr, CompileResult & _result)
				: ICodeGenerator(pErr), symTable(symbols), result(_result)
			{
				result.Program = new ILProgram();
				codeWriter.SetConstantPool(result.Program->ConstantPool.Ptr());
			}
		};

		ICodeGenerator * CreateCodeGenerator(SymbolTable * symbols, CompileResult & result)
		{
			return new CodeGenerator(symbols, result.GetErrorWriter(), result);
		}
	}
}

/***********************************************************************
SPIRECORE\COMPILEDPROGRAM.CPP
***********************************************************************/
namespace Spire
{
	namespace Compiler
	{
		void IndentString(StringBuilder & sb, String src)
		{
			int indent = 0;
			bool beginTrim = true;
			for (int c = 0; c < src.Length(); c++)
			{
				auto ch = src[c];
				if (ch == L'\n')
				{
					sb << L"\n";

					beginTrim = true;
				}
				else
				{
					if (beginTrim)
					{
						while (c < src.Length() - 1 && (src[c] == L'\t' || src[c] == L'\n' || src[c] == L'\r' || src[c] == L' '))
						{
							c++;
							ch = src[c];
						}
						for (int i = 0; i < indent - 1; i++)
							sb << L'\t';
						if (ch != '}' && indent > 0)
							sb << L'\t';
						beginTrim = false;
					}

					if (ch == L'{')
						indent++;
					else if (ch == L'}')
						indent--;
					if (indent < 0)
						indent = 0;

					sb << ch;
				}
			}
		}
		ShaderChoiceValue ShaderChoiceValue::Parse(String str)
		{
			ShaderChoiceValue result;
			int idx = str.IndexOf(L':');
			if (idx == -1)
				return ShaderChoiceValue(str, L"");
			return ShaderChoiceValue(str.SubString(0, idx), str.SubString(idx + 1, str.Length() - idx - 1));
		}
		
}
}

/***********************************************************************
SPIRECORE\CONSTANTPOOL.CPP
***********************************************************************/
#ifndef CONSTANT_POOL_H
#define CONSTANT_POOL_H


namespace Spire
{
	namespace Compiler
	{
		class ConstantPoolImpl
		{
		private:
			ILUndefinedOperand undefOperand;
			Dictionary<ConstKey<int>, ILConstOperand*> intConsts;
			Dictionary<ConstKey<float>, ILConstOperand*> floatConsts;
			List<RefPtr<ILConstOperand>> constants;
			RefPtr<ILConstOperand> trueConst, falseConst;
		public:
			ILUndefinedOperand * GetUndefinedOperand()
			{
				return &undefOperand;
			}
			ILOperand * CreateDefaultValue(ILType * type)
			{
				ILOperand * value = 0;
				if (type->IsFloat())
					value = CreateConstant(0.0f);
				else if (type->IsInt())
					value = CreateConstant(0);
				else if (auto baseType = dynamic_cast<ILBasicType*>(type))
				{
					if (baseType->Type == ILBaseType::Int2)
					{
						value = CreateConstant(0, 2);
					}
					else if (baseType->Type == ILBaseType::Int3)
					{
						value = CreateConstant(0, 3);
					}
					else if (baseType->Type == ILBaseType::Int4)
					{
						value = CreateConstant(0, 4);
					}
					else if (baseType->Type == ILBaseType::Float2)
					{
						value = CreateConstant(0.0f, 2);
					}
					else if (baseType->Type == ILBaseType::Float3)
					{
						value = CreateConstant(0.0f, 3);
					}
					else if (baseType->Type == ILBaseType::Float4)
					{
						value = CreateConstant(0.0f, 4);
					}
					else if (baseType->Type == ILBaseType::Float3x3)
					{
						value = CreateConstant(0.0f, 9);
					}
					else if (baseType->Type == ILBaseType::Float4x4)
					{
						value = CreateConstant(0.0f, 16);
					}
					else
						throw NotImplementedException(L"default value for this type is not implemented.");
				}
				else
					throw NotImplementedException(L"default value for this type is not implemented.");
				return value;
			}
			ILConstOperand * CreateConstantIntVec(int val, int val2)
			{
				ILConstOperand * rs = 0;
				auto key = ConstKey<int>::FromValues(val, val2);
				if (intConsts.TryGetValue(key, rs))
					return rs;
				rs = new ILConstOperand();
				rs->Type = new ILBasicType(ILBaseType::Int2);
				rs->IntValues[0] = val;
				rs->IntValues[1] = val2;
				intConsts[key] = rs;
				rs->Name = rs->ToString();
				constants.Add(rs);
				return rs;
			}

			ILConstOperand * CreateConstantIntVec(int val, int val2, int val3)
			{
				ILConstOperand * rs = 0;
				auto key = ConstKey<int>::FromValues(val, val2, val3);
				if (intConsts.TryGetValue(key, rs))
					return rs;
				rs = new ILConstOperand();
				rs->Type = new ILBasicType(ILBaseType::Int3);
				rs->IntValues[0] = val;
				rs->IntValues[1] = val2;
				rs->IntValues[2] = val3;

				intConsts[key] = rs;
				rs->Name = rs->ToString();
				constants.Add(rs);

				return rs;
			}
			ILConstOperand * CreateConstantIntVec(int val, int val2, int val3, int val4)
			{
				ILConstOperand * rs = 0;
				auto key = ConstKey<int>::FromValues(val, val2, val3, val4);
				if (intConsts.TryGetValue(key, rs))
					return rs;
				rs = new ILConstOperand();
				rs->Type = new ILBasicType(ILBaseType::Int4);
				rs->IntValues[0] = val;
				rs->IntValues[1] = val2;
				rs->IntValues[2] = val3;
				rs->IntValues[3] = val4;
				intConsts[key] = rs;
				rs->Name = rs->ToString();
				constants.Add(rs);

				return rs;
			}

			ILConstOperand * CreateConstant(ILConstOperand * c)
			{
				auto baseType = dynamic_cast<ILBasicType*>(c->Type.Ptr())->Type;
				switch (baseType)
				{
				case ILBaseType::Float:
					return CreateConstant(c->FloatValues[0]);
				case ILBaseType::Float2:
					return CreateConstant(c->FloatValues[0], c->FloatValues[1]);
				case ILBaseType::Float3:
					return CreateConstant(c->FloatValues[0], c->FloatValues[1], c->FloatValues[2]);
				case ILBaseType::Float4:
					return CreateConstant(c->FloatValues[0], c->FloatValues[1], c->FloatValues[2], c->FloatValues[3]);
				case ILBaseType::Int:
					return CreateConstant(c->IntValues[0]);
				case ILBaseType::Int2:
					return CreateConstantIntVec(c->IntValues[0], c->IntValues[1]);
				case ILBaseType::Int3:
					return CreateConstantIntVec(c->IntValues[0], c->IntValues[1], c->IntValues[2]);
				case ILBaseType::Int4:
					return CreateConstantIntVec(c->IntValues[0], c->IntValues[1], c->IntValues[2], c->IntValues[3]);
				default:
					if (constants.IndexOf(c) != -1)
						return c;
					else
					{
						auto rs = new ILConstOperand(*c);
						constants.Add(rs);
						return rs;
					}
				}
			}


			ILConstOperand * CreateConstant(bool b)
			{
				if (b) 
					return trueConst.Ptr();
				else
					return falseConst.Ptr();
			}

			ILConstOperand * CreateConstant(int val, int size = 0)
			{
				ILConstOperand * rs = 0;
				if (intConsts.TryGetValue(ConstKey<int>(val, size), rs))
					return rs;
				rs = new ILConstOperand();
				ILBaseType baseType;
				switch (size)
				{
				case 0:
				case 1:
					baseType = ILBaseType::Int;
					break;
				case 2:
					baseType = ILBaseType::Int2;
					break;
				case 3:
					baseType = ILBaseType::Int3;
					break;
				case 4:
					baseType = ILBaseType::Int4;
					break;
				default:
					throw InvalidOperationException(L"Invalid vector size.");
				}
				rs->Type = new ILBasicType(baseType);
				rs->IntValues[0] = val;
				intConsts[ConstKey<int>(val, size)] = rs;
				rs->Name = rs->ToString();
				constants.Add(rs);

				return rs;
			}

			ILConstOperand * CreateConstant(float val, int size = 0)
			{
				ILConstOperand * rs = 0;
				if (floatConsts.TryGetValue(ConstKey<float>(val, size), rs))
					return rs;
				if (Math::IsNaN(val) || Math::IsInf(val))
				{
					throw InvalidOperationException(L"Attempting to create NAN constant.");
				}
				rs = new ILConstOperand();
				ILBaseType baseType;
				switch (size)
				{
				case 0:
				case 1:
					baseType = ILBaseType::Float;
					break;
				case 2:
					baseType = ILBaseType::Float2;
					break;
				case 3:
					baseType = ILBaseType::Float3;
					break;
				case 4:
					baseType = ILBaseType::Float4;
					break;
				case 9:
					baseType = ILBaseType::Float3x3;
					break;
				case 16:
					baseType = ILBaseType::Float4x4;
					break;
				default:
					throw InvalidOperationException(L"Invalid vector size.");
				}
				rs->Type = new ILBasicType(baseType);
				for (int i = 0; i < 16; i++)
					rs->FloatValues[i] = val;
				floatConsts[ConstKey<float>(val, size)] = rs;
				rs->Name = rs->ToString();
				constants.Add(rs);

				return rs;
			}

			ILConstOperand * CreateConstant(float val, float val2)
			{
				ILConstOperand * rs = 0;
				if (Math::IsNaN(val) || Math::IsInf(val) || Math::IsNaN(val2) || Math::IsInf(val2))
				{
					throw InvalidOperationException(L"Attempting to create NAN constant.");
				}
				auto key = ConstKey<float>::FromValues(val, val2);
				if (floatConsts.TryGetValue(key, rs))
					return rs;
				rs = new ILConstOperand();
				rs->Type = new ILBasicType(ILBaseType::Float2);
				rs->FloatValues[0] = val;
				rs->FloatValues[1] = val2;
				floatConsts[key] = rs;
				rs->Name = rs->ToString();
				constants.Add(rs);

				return rs;
			}

			ILConstOperand * CreateConstant(float val, float val2, float val3)
			{
				ILConstOperand * rs = 0;
				if (Math::IsNaN(val) || Math::IsInf(val) || Math::IsNaN(val2) || Math::IsInf(val2) || Math::IsNaN(val3) || Math::IsInf(val3))
				{
					throw InvalidOperationException(L"Attempting to create NAN constant.");
				}
				auto key = ConstKey<float>::FromValues(val, val2, val3);
				if (floatConsts.TryGetValue(key, rs))
					return rs;
				rs = new ILConstOperand();
				rs->Type = new ILBasicType(ILBaseType::Float3);
				rs->FloatValues[0] = val;
				rs->FloatValues[1] = val2;
				rs->FloatValues[2] = val3;

				floatConsts[key] = rs;
				rs->Name = rs->ToString();
				constants.Add(rs);

				return rs;
			}

			ILConstOperand * CreateConstant(float val, float val2, float val3, float val4)
			{
				if (Math::IsNaN(val) || Math::IsInf(val) || Math::IsNaN(val2) || Math::IsInf(val2) || Math::IsNaN(val3) || Math::IsInf(val3) || Math::IsNaN(val4) || Math::IsInf(val4))
				{
					throw InvalidOperationException(L"Attempting to create NAN constant.");
				}
				ILConstOperand * rs = 0;
				auto key = ConstKey<float>::FromValues(val, val2, val3, val4);
				if (floatConsts.TryGetValue(key, rs))
					return rs;
				rs = new ILConstOperand();
				rs->Type = new ILBasicType(ILBaseType::Float4);
				rs->FloatValues[0] = val;
				rs->FloatValues[1] = val2;
				rs->FloatValues[2] = val3;
				rs->FloatValues[3] = val4;

				floatConsts[key] = rs;
				rs->Name = rs->ToString();
				constants.Add(rs);

				return rs;
			}

			ConstantPoolImpl()
			{
				trueConst = new ILConstOperand();
				trueConst->Type = new ILBasicType(ILBaseType::Bool);
				trueConst->IntValues[0] = trueConst->IntValues[1] = trueConst->IntValues[2] = trueConst->IntValues[3] = 1;
				trueConst->Name = L"true";

				falseConst = new ILConstOperand();
				falseConst->Type = new ILBasicType(ILBaseType::Bool);
				falseConst->IntValues[0] = falseConst->IntValues[1] = falseConst->IntValues[2] = falseConst->IntValues[3] = 0;
				trueConst->Name = L"false";

			}
		};

		ConstantPool::ConstantPool()
		{
			impl = new ConstantPoolImpl();
		}
		ConstantPool::~ConstantPool()
		{
			delete impl;
		}
		ILUndefinedOperand * ConstantPool::GetUndefinedOperand()
		{
			return impl->GetUndefinedOperand();
		}
		ILConstOperand * ConstantPool::CreateConstant(ILConstOperand * c)
		{
			return impl->CreateConstant(c);
		}
		ILConstOperand * ConstantPool::CreateConstantIntVec(int val0, int val1)
		{
			return impl->CreateConstantIntVec(val0, val1);

		}
		ILConstOperand * ConstantPool::CreateConstantIntVec(int val0, int val1, int val2)
		{
			return impl->CreateConstantIntVec(val0, val1, val2);
		}
		ILConstOperand * ConstantPool::CreateConstantIntVec(int val0, int val1, int val3, int val4)
		{
			return impl->CreateConstantIntVec(val0, val1, val3, val4);
		}
		ILConstOperand * ConstantPool::CreateConstant(bool b)
		{
			return impl->CreateConstant(b);
		}
		ILConstOperand * ConstantPool::CreateConstant(int val, int vectorSize)
		{
			return impl->CreateConstant(val, vectorSize);
		}
		ILConstOperand * ConstantPool::CreateConstant(float val, int vectorSize)
		{
			return impl->CreateConstant(val, vectorSize);
		}
		ILConstOperand * ConstantPool::CreateConstant(float val, float val1)
		{
			return impl->CreateConstant(val, val1);
		}
		ILConstOperand * ConstantPool::CreateConstant(float val, float val1, float val2)
		{
			return impl->CreateConstant(val, val1, val2);
		}
		ILConstOperand * ConstantPool::CreateConstant(float val, float val1, float val2, float val3)
		{
			return impl->CreateConstant(val, val1, val2, val3);
		}
		ILOperand * ConstantPool::CreateDefaultValue(ILType * type)
		{
			return impl->CreateDefaultValue(type);
		}
	}
}

#endif

/***********************************************************************
SPIRECORE\GLSLCODEGEN.CPP
***********************************************************************/

#include <cassert>

using namespace CoreLib::Basic;

namespace Spire
{
	namespace Compiler
	{
		class GLSLCodeGen : public CLikeCodeGen
		{
		protected:
			OutputStrategy * CreateStandardOutputStrategy(ILWorld * world, String layoutPrefix) override;
			OutputStrategy * CreatePackedBufferOutputStrategy(ILWorld * world) override;
			OutputStrategy * CreateArrayOutputStrategy(ILWorld * world, bool pIsPatch, int pArraySize, String arrayIndex) override;

			void PrintRasterPositionOutputWrite(CodeGenContext & ctx, ILOperand * operand) override
			{
				ctx.Body << L"gl_Position = ";
				PrintOp(ctx, operand);
				ctx.Body << L";\n";
			}

			void PrintUniformBufferInputReference(StringBuilder& sb, String inputName, String componentName) override
			{
				if (!currentImportInstr->Type->IsTexture() || useBindlessTexture)
					sb << L"blk" << inputName << L"." << componentName;
				else
					sb << componentName;
			}

			void PrintStorageBufferInputReference(StringBuilder& sb, String inputName, String componentName) override
			{
				sb << L"blk" << inputName << L"." << componentName;
			}

			void PrintArrayBufferInputReference(StringBuilder& sb, String inputName, String componentName) override
			{
				sb << L"blk" << inputName << L".content";
			}

			void PrintPackedBufferInputReference(StringBuilder& sb, String inputName, String componentName) override
			{
				sb << L"blk" << inputName << L".content";
			}

			void PrintStandardInputReference(StringBuilder& sb, ILRecordType* recType, String inputName, String componentName) override
			{
				String declName = componentName;
				declName = AddWorldNameSuffix(declName, recType->ToString());
				sb << declName;
			}

			void PrintPatchInputReference(StringBuilder& sb, ILRecordType* recType, String inputName, String componentName) override
			{
				String declName = componentName;
				declName = AddWorldNameSuffix(declName, recType->ToString());
				sb << declName;
			}

			void PrintDefaultInputReference(StringBuilder& sb, ILRecordType* /*recType*/, String inputName, String componentName) override
			{
				String declName = componentName;
				sb << declName;
			}

			void PrintSystemVarReference(StringBuilder& sb, String inputName, ExternComponentCodeGenInfo::SystemVarType systemVar) override
			{
				switch(systemVar)
				{
				case ExternComponentCodeGenInfo::SystemVarType::FragCoord:
					sb << L"gl_FragCoord";
					break;
				case ExternComponentCodeGenInfo::SystemVarType::TessCoord:
					sb << L"gl_TessCoord";
					break;
				case ExternComponentCodeGenInfo::SystemVarType::InvocationId:
					sb << L"gl_InvocationID";
					break;
				case ExternComponentCodeGenInfo::SystemVarType::ThreadId:
					sb << L"gl_GlobalInvocationID.x";
					break;
				case ExternComponentCodeGenInfo::SystemVarType::PatchVertexCount:
					sb << L"gl_PatchVerticesIn";
					break;
				case ExternComponentCodeGenInfo::SystemVarType::PrimitiveId:
					sb << L"gl_PrimitiveID";
					break;
				default:
					sb << inputName;
					break;
				}
			}

			void PrintTypeName(StringBuilder& sb, ILType* type) override
			{
				// Currently, all types are internally named based on their GLSL equivalent, so
				// outputting a type for GLSL is trivial.
				sb << type->ToString();
			}

			void DeclareUniformBuffer(CodeGenContext & sb, const ILObjectDefinition & input, bool /*isVertexShader*/) override
			{
				auto info = ExtractExternComponentInfo(input);
				extCompInfo[input.Name] = info;
				auto recType = ExtractRecordType(input.Type.Ptr());
				assert(recType);
				assert(info.DataStructure == ExternComponentCodeGenInfo::DataStructureType::UniformBuffer);

				int declarationStart = sb.GlobalHeader.Length();
				int itemsDeclaredInBlock = 0;

				sb.GlobalHeader << L"layout(std140";
				if (info.Binding != -1)
					sb.GlobalHeader << L", binding = " << info.Binding;
				sb.GlobalHeader << L") uniform " << input.Name << L"\n{\n";

				int index = 0;
				for (auto & field : recType->Members)
				{
					if (!useBindlessTexture && field.Value.Type->IsTexture())
						continue;
					String declName = field.Key;
					PrintDef(sb.GlobalHeader, field.Value.Type.Ptr(), declName);
					itemsDeclaredInBlock++;
					if (info.IsArray)
					{
						sb.GlobalHeader << L"[";
						if (info.ArrayLength)
							sb.GlobalHeader << String(info.ArrayLength);
						sb.GlobalHeader << L"]";
					}
					sb.GlobalHeader << L";\n";

					index++;
				}
				if (itemsDeclaredInBlock == 0)
				{
					sb.GlobalHeader.Remove(declarationStart, sb.GlobalHeader.Length() - declarationStart);
				}
				else
				{
					sb.GlobalHeader << L"} blk" << input.Name << L";\n";
				}
				if (!useBindlessTexture)
				{
					for (auto & field : recType->Members)
					{
						if (field.Value.Type->IsTexture())
						{
							if (field.Value.Attributes.ContainsKey(L"Binding"))
								sb.GlobalHeader << L"layout(binding = " << field.Value.Attributes[L"Binding"]() << L") ";
							else
							{
								sb.GlobalHeader << L"layout(binding = " << sb.TextureBindingsAllocator << L") ";
								sb.TextureBindingsAllocator++;
							}
							sb.GlobalHeader << L"uniform ";
							PrintDef(sb.GlobalHeader, field.Value.Type.Ptr(), field.Key);
							sb.GlobalHeader << L";\n";
						}
					}
				}
			}

			void DeclareStorageBuffer(CodeGenContext & sb, const ILObjectDefinition & input, bool isVertexShader) override
			{
				auto info = ExtractExternComponentInfo(input);
				extCompInfo[input.Name] = info;
				auto recType = ExtractRecordType(input.Type.Ptr());
				assert(recType);
				assert(info.DataStructure == ExternComponentCodeGenInfo::DataStructureType::StorageBuffer);

				int declarationStart = sb.GlobalHeader.Length();
				int itemsDeclaredInBlock = 0;

				sb.GlobalHeader << L"layout(std430";
				if (info.Binding != -1)
					sb.GlobalHeader << L", binding = " << info.Binding;
				sb.GlobalHeader << L") buffer " << input.Name << L"\n{\n";

				int index = 0;
				for (auto & field : recType->Members)
				{
					if (!useBindlessTexture && info.DataStructure == ExternComponentCodeGenInfo::DataStructureType::UniformBuffer &&
						field.Value.Type->IsTexture())
						continue;
					if (input.Attributes.ContainsKey(L"VertexInput"))
						sb.GlobalHeader << L"layout(location = " << index << L") ";
					if (!isVertexShader && (input.Attributes.ContainsKey(L"Flat") ||
						(info.DataStructure == ExternComponentCodeGenInfo::DataStructureType::StandardInput &&
							field.Value.Type->IsIntegral())))
						sb.GlobalHeader << L"flat ";
					if (info.DataStructure == ExternComponentCodeGenInfo::DataStructureType::StandardInput)
					{
						sb.GlobalHeader << L"in ";
					}
					else if (info.DataStructure == ExternComponentCodeGenInfo::DataStructureType::Patch)
						sb.GlobalHeader << L"patch in ";
					String declName = field.Key;
					if (info.DataStructure == ExternComponentCodeGenInfo::DataStructureType::StandardInput ||
						info.DataStructure == ExternComponentCodeGenInfo::DataStructureType::Patch)
						declName = AddWorldNameSuffix(declName, recType->ToString());
					PrintDef(sb.GlobalHeader, field.Value.Type.Ptr(), declName);
					itemsDeclaredInBlock++;
					if (info.IsArray)
					{
						sb.GlobalHeader << L"[";
						if (info.ArrayLength)
							sb.GlobalHeader << String(info.ArrayLength);
						sb.GlobalHeader << L"]";
					}
					sb.GlobalHeader << L";\n";

					index++;
				}
				if (itemsDeclaredInBlock == 0)
				{
					sb.GlobalHeader.Remove(declarationStart, sb.GlobalHeader.Length() - declarationStart);
					return;
				}

				sb.GlobalHeader << L"} blk" << input.Name << L";\n";
			}

			void DeclareArrayBuffer(CodeGenContext & sb, const ILObjectDefinition & input, bool isVertexShader) override
			{
				auto info = ExtractExternComponentInfo(input);
				extCompInfo[input.Name] = info;
				auto recType = ExtractRecordType(input.Type.Ptr());
				assert(recType);
				assert(info.DataStructure == ExternComponentCodeGenInfo::DataStructureType::ArrayBuffer);

				int itemsDeclaredInBlock = 0;
				sb.GlobalHeader << L"struct T" << input.Name << L"\n{\n";
					
				int index = 0;
				for (auto & field : recType->Members)
				{
					if (input.Attributes.ContainsKey(L"VertexInput"))
						sb.GlobalHeader << L"layout(location = " << index << L") ";
					if (!isVertexShader && (input.Attributes.ContainsKey(L"Flat")))
						sb.GlobalHeader << L"flat ";
					String declName = field.Key;
					PrintDef(sb.GlobalHeader, field.Value.Type.Ptr(), declName);
					itemsDeclaredInBlock++;
					if (info.IsArray)
					{
						sb.GlobalHeader << L"[";
						if (info.ArrayLength)
							sb.GlobalHeader << String(info.ArrayLength);
						sb.GlobalHeader << L"]";
					}
					sb.GlobalHeader << L";\n";

					index++;
				}

				sb.GlobalHeader << L"};\nlayout(std430";
				if (info.Binding != -1)
					sb.GlobalHeader << L", binding = " << info.Binding;
				sb.GlobalHeader  << ") buffer " << input.Name << L"\n{\nT" << input.Name << L"content[];\n} blk" << input.Name << L";\n";
			}

			void DeclarePackedBuffer(CodeGenContext & sb, const ILObjectDefinition & input, bool /*isVertexShader*/) override
			{
				auto info = ExtractExternComponentInfo(input);
				extCompInfo[input.Name] = info;
				auto recType = ExtractRecordType(input.Type.Ptr());
				assert(recType);
				assert(info.DataStructure == ExternComponentCodeGenInfo::DataStructureType::PackedBuffer);

				sb.GlobalHeader << L"layout(std430";
				if (info.Binding != -1)
					sb.GlobalHeader << L", binding = " << info.Binding;
				sb.GlobalHeader << L") uniform " << input.Name << L"\n{\nfloat content[];\n} blk" << input.Name << L";\n";
			}

			void DeclareTextureInputRecord(CodeGenContext & sb, const ILObjectDefinition & input, bool /*isVertexShader*/) override
			{
				auto info = ExtractExternComponentInfo(input);
				auto recType = ExtractRecordType(input.Type.Ptr());
				assert(recType);
				assert(info.DataStructure == ExternComponentCodeGenInfo::DataStructureType::Texture);

				for(auto & field : recType->Members)
				{
					if(field.Value.Type->IsFloat() || field.Value.Type->IsFloatVector() && !field.Value.Type->IsFloatMatrix())
					{
						sb.GlobalHeader << L"layout(binding = " << sb.TextureBindingsAllocator << L") uniform sampler2D " << field.Key << L";\n";
						sb.TextureBindingsAllocator++;
					}
					else
					{
						errWriter->Error(51091, L"type '" + field.Value.Type->ToString() + L"' cannot be placed in a texture.",
							field.Value.Position);
					}
				}
			}

			void DeclareStandardInputRecord(CodeGenContext & sb, const ILObjectDefinition & input, bool isVertexShader) override
			{
				auto info = ExtractExternComponentInfo(input);
				auto recType = ExtractRecordType(input.Type.Ptr());
				assert(recType);
				assert(info.DataStructure == ExternComponentCodeGenInfo::DataStructureType::StandardInput);

				int itemsDeclaredInBlock = 0;

				int index = 0;
				for (auto & field : recType->Members)
				{
					if (input.Attributes.ContainsKey(L"VertexInput"))
						sb.GlobalHeader << L"layout(location = " << index << L") ";
					if (!isVertexShader && (input.Attributes.ContainsKey(L"Flat") || field.Value.Type->IsIntegral()))
						sb.GlobalHeader << L"flat ";
					sb.GlobalHeader << L"in ";

					String declName = field.Key;
					declName = AddWorldNameSuffix(declName, recType->ToString());

					PrintDef(sb.GlobalHeader, field.Value.Type.Ptr(), declName);
					itemsDeclaredInBlock++;
					if (info.IsArray)
					{
						sb.GlobalHeader << L"[";
						if (info.ArrayLength)
							sb.GlobalHeader << String(info.ArrayLength);
						sb.GlobalHeader << L"]";
					}
					sb.GlobalHeader << L";\n";

					index++;
				}
			}

			void DeclarePatchInputRecord(CodeGenContext & sb, const ILObjectDefinition & input, bool isVertexShader) override
			{
				auto info = ExtractExternComponentInfo(input);
				auto recType = ExtractRecordType(input.Type.Ptr());
				assert(recType);
				assert(info.DataStructure == ExternComponentCodeGenInfo::DataStructureType::Patch);


				int itemsDeclaredInBlock = 0;

				int index = 0;
				for (auto & field : recType->Members)
				{
					if (!isVertexShader && (input.Attributes.ContainsKey(L"Flat")))
						sb.GlobalHeader << L"flat ";
					sb.GlobalHeader << L"patch in ";

					String declName = field.Key;
					declName = AddWorldNameSuffix(declName, recType->ToString());

					PrintDef(sb.GlobalHeader, field.Value.Type.Ptr(), declName);
					itemsDeclaredInBlock++;
					if (info.IsArray)
					{
						sb.GlobalHeader << L"[";
						if (info.ArrayLength)
							sb.GlobalHeader << String(info.ArrayLength);
						sb.GlobalHeader << L"]";
					}
					sb.GlobalHeader << L";\n";

					index++;
				}
			}

			void GenerateHeader(StringBuilder & sb, ILStage * stage)
			{
				sb << L"#version 440\n";
				if (stage->Attributes.ContainsKey(L"BindlessTexture"))
					sb << L"#extension GL_ARB_bindless_texture: require\n#extension GL_NV_gpu_shader5 : require\n";
				if (stage->Attributes.ContainsKey(L"NV_CommandList"))
					sb << L"#extension GL_NV_command_list: require\n";
			}

			StageSource GenerateSingleWorldShader(ILProgram * program, ILShader * shader, ILStage * stage) override
			{
				useBindlessTexture = stage->Attributes.ContainsKey(L"BindlessTexture");
				StageSource rs;
				CodeGenContext ctx;
				GenerateHeader(ctx.GlobalHeader, stage);
				if (stage->StageType == L"DomainShader")
					GenerateDomainShaderProlog(ctx, stage);

				GenerateStructs(ctx.GlobalHeader, program);
				StageAttribute worldName;
				RefPtr<ILWorld> world = nullptr;
				if (stage->Attributes.TryGetValue(L"World", worldName))
				{
					if (!shader->Worlds.TryGetValue(worldName.Value, world))
						errWriter->Error(50022, L"world '" + worldName.Value + L"' is not defined.", worldName.Position);
				}
				else
					errWriter->Error(50023, L"'" + stage->StageType + L"' should provide 'World' attribute.", stage->Position);
				if (!world)
					return rs;
				GenerateReferencedFunctions(ctx.GlobalHeader, program, MakeArrayView(world.Ptr()));
				extCompInfo.Clear();
				for (auto & input : world->Inputs)
				{
					DeclareInput(ctx, input, stage->StageType == L"VertexShader");
				}
		
				outputStrategy->DeclareOutput(ctx, stage);
				ctx.codeGen = this;
				world->Code->NameAllInstructions();
				GenerateCode(ctx, world->Code.Ptr());
				if (stage->StageType == L"VertexShader" || stage->StageType == L"DomainShader")
					GenerateVertexShaderEpilog(ctx, world.Ptr(), stage);

				StringBuilder sb;
				sb << ctx.GlobalHeader.ProduceString();
				sb << L"void main()\n{\n";
				sb << ctx.Header.ProduceString() << ctx.Body.ProduceString();
				sb << L"}";
				rs.MainCode = sb.ProduceString();
				return rs;
			}

			StageSource GenerateHullShader(ILProgram * program, ILShader * shader, ILStage * stage) override
			{
				useBindlessTexture = stage->Attributes.ContainsKey(L"BindlessTexture");

				StageSource rs;
				StageAttribute patchWorldName, controlPointWorldName, cornerPointWorldName, domain, innerLevel, outerLevel, numControlPoints;
				RefPtr<ILWorld> patchWorld, controlPointWorld, cornerPointWorld;
				if (!stage->Attributes.TryGetValue(L"PatchWorld", patchWorldName))
				{
					errWriter->Error(50052, L"'HullShader' requires attribute 'PatchWorld'.", stage->Position);
					return rs;
				}
				if (!shader->Worlds.TryGetValue(patchWorldName.Value, patchWorld))
					errWriter->Error(50022, L"world '" + patchWorldName.Value + L"' is not defined.", patchWorldName.Position);
				if (!stage->Attributes.TryGetValue(L"ControlPointWorld", controlPointWorldName))
				{
					errWriter->Error(50052, L"'HullShader' requires attribute 'ControlPointWorld'.", stage->Position); 
					return rs;
				}
				if (!shader->Worlds.TryGetValue(controlPointWorldName.Value, controlPointWorld))
					errWriter->Error(50022, L"world '" + controlPointWorldName.Value + L"' is not defined.", controlPointWorldName.Position);
				if (!stage->Attributes.TryGetValue(L"CornerPointWorld", cornerPointWorldName))
				{
					errWriter->Error(50052, L"'HullShader' requires attribute 'CornerPointWorld'.", stage->Position);
					return rs;
				}
				if (!shader->Worlds.TryGetValue(cornerPointWorldName.Value, cornerPointWorld))
					errWriter->Error(50022, L"world '" + cornerPointWorldName.Value + L"' is not defined.", cornerPointWorldName.Position);
				if (!stage->Attributes.TryGetValue(L"Domain", domain))
				{
					errWriter->Error(50052, L"'HullShader' requires attribute 'Domain'.", stage->Position);
					return rs;
				}
				if (domain.Value != L"triangles" && domain.Value != L"quads")
				{
					errWriter->Error(50053, L"'Domain' should be either 'triangles' or 'quads'.", domain.Position);
					return rs;
				}
				if (!stage->Attributes.TryGetValue(L"TessLevelOuter", outerLevel))
				{
					errWriter->Error(50052, L"'HullShader' requires attribute 'TessLevelOuter'.", stage->Position);
					return rs;
				}
				if (!stage->Attributes.TryGetValue(L"TessLevelInner", innerLevel))
				{
					errWriter->Error(50052, L"'HullShader' requires attribute 'TessLevelInner'.", stage->Position);
					return rs;
				}
				if (!stage->Attributes.TryGetValue(L"ControlPointCount", numControlPoints))
				{
					errWriter->Error(50052, L"'HullShader' requires attribute 'ControlPointCount'.", stage->Position);
					return rs;
				}
				CodeGenContext ctx;
				ctx.codeGen = this;
				List<ILWorld*> worlds;
				worlds.Add(patchWorld.Ptr());
				worlds.Add(controlPointWorld.Ptr());
				worlds.Add(cornerPointWorld.Ptr());
				GenerateHeader(ctx.GlobalHeader, stage);
				ctx.GlobalHeader << L"layout(vertices = " << numControlPoints.Value << L") out;\n";
				GenerateStructs(ctx.GlobalHeader, program);
				GenerateReferencedFunctions(ctx.GlobalHeader, program, worlds.GetArrayView());
				extCompInfo.Clear();

				HashSet<String> declaredInputs;

				patchWorld->Code->NameAllInstructions();
				outputStrategy = CreateStandardOutputStrategy(patchWorld.Ptr(), L"patch");
				for (auto & input : patchWorld->Inputs)
				{
					if (declaredInputs.Add(input.Name))
						DeclareInput(ctx, input, false);
				}
				outputStrategy->DeclareOutput(ctx, stage);
				GenerateCode(ctx, patchWorld->Code.Ptr());

				controlPointWorld->Code->NameAllInstructions();
				outputStrategy = CreateArrayOutputStrategy(controlPointWorld.Ptr(), false, 0, L"gl_InvocationID");
				for (auto & input : controlPointWorld->Inputs)
				{
					if (declaredInputs.Add(input.Name))
						DeclareInput(ctx, input, false);
				}
				outputStrategy->DeclareOutput(ctx, stage);
				GenerateCode(ctx, controlPointWorld->Code.Ptr());

				cornerPointWorld->Code->NameAllInstructions();
				outputStrategy = CreateArrayOutputStrategy(cornerPointWorld.Ptr(), true, (domain.Value == L"triangles" ? 3 : 4), L"sysLocalIterator");
				for (auto & input : cornerPointWorld->Inputs)
				{
					if (declaredInputs.Add(input.Name))
						DeclareInput(ctx, input, false);
				}
				outputStrategy->DeclareOutput(ctx, stage);
				ctx.Body << L"for (int sysLocalIterator = 0; sysLocalIterator < gl_PatchVerticesIn; sysLocalIterator++)\n{\n";
				GenerateCode(ctx, cornerPointWorld->Code.Ptr());
				auto debugStr = cornerPointWorld->Code->ToString();
				ctx.Body << L"}\n";

				// generate epilog
				bool found = false;
				for (auto & world : worlds)
				{
					ILOperand * operand;
					if (world->Components.TryGetValue(innerLevel.Value, operand))
					{
						for (int i = 0; i < 2; i++)
						{
							ctx.Body << L"gl_TessLevelInner[" << i << L"] = ";
							PrintOp(ctx, operand);
							ctx.Body << L"[" << i << L"];\n";
						}
						found = true;
						break;
					}
				}
				if (!found)
					errWriter->Error(50041, L"'" + innerLevel.Value + L"': component not defined.",
						innerLevel.Position);

				found = false;
				for (auto & world : worlds)
				{
					ILOperand * operand;
					if (world->Components.TryGetValue(outerLevel.Value, operand))
					{
						for (int i = 0; i < 4; i++)
						{
							ctx.Body << L"gl_TessLevelOuter[" << i << L"] = ";
							PrintOp(ctx, operand);
							ctx.Body << L"[" << i << L"];\n";
						}
						found = true;
						break;
					}

				}
				if (!found)
					errWriter->Error(50041, L"'" + outerLevel.Value + L"': component not defined.",
						outerLevel.Position);

				StringBuilder sb;
				sb << ctx.GlobalHeader.ProduceString();
				sb << L"void main()\n{\n" << ctx.Header.ProduceString() << ctx.Body.ProduceString() << L"}";
				rs.MainCode = sb.ProduceString();
				return rs;
			}

		};


		class StandardOutputStrategy : public OutputStrategy
		{
		private:
			String declPrefix;
		public:
			StandardOutputStrategy(GLSLCodeGen * pCodeGen, ILWorld * world, String prefix)
				: OutputStrategy(pCodeGen, world), declPrefix(prefix)
			{}
			virtual void DeclareOutput(CodeGenContext & ctx, ILStage *) override
			{
				for (auto & field : world->OutputType->Members)
				{
					if (declPrefix.Length())
						ctx.GlobalHeader << declPrefix << L" ";
					if (field.Value.Type->IsIntegral())
						ctx.GlobalHeader << L"flat ";
					ctx.GlobalHeader << L"out ";
					String declName = field.Key;
					codeGen->PrintDef(ctx.GlobalHeader, field.Value.Type.Ptr(), AddWorldNameSuffix(declName, world->OutputType->TypeName));
					ctx.GlobalHeader << L";\n";
				}
			}
			virtual void ProcessExportInstruction(CodeGenContext & ctx, ExportInstruction * instr) override
			{
				ctx.Body << AddWorldNameSuffix(instr->ComponentName, world->OutputType->TypeName) << L" = ";
				codeGen->PrintOp(ctx, instr->Operand.Ptr());
				ctx.Body << L";\n";
			}
		};

		class ArrayOutputStrategy : public OutputStrategy
		{
		protected:
			bool isPatch = false;
			int arraySize = 0;
		public:
			String outputIndex;
			ArrayOutputStrategy(GLSLCodeGen * pCodeGen, ILWorld * world, bool pIsPatch, int pArraySize, String pOutputIndex)
				: OutputStrategy(pCodeGen, world)
			{
				isPatch = pIsPatch;
				arraySize = pArraySize;
				outputIndex = pOutputIndex;
			}
			virtual void DeclareOutput(CodeGenContext & ctx, ILStage *) override
			{
				for (auto & field : world->OutputType->Members)
				{
					if (isPatch)
						ctx.GlobalHeader << L"patch ";
					ctx.GlobalHeader << L"out ";
					codeGen->PrintDef(ctx.GlobalHeader, field.Value.Type.Ptr(), AddWorldNameSuffix(field.Key, world->Name));
					ctx.GlobalHeader << L"[";
					if (arraySize != 0)
						ctx.GlobalHeader << arraySize;
					ctx.GlobalHeader<<L"]; \n";
				}
			}
			virtual void ProcessExportInstruction(CodeGenContext & ctx, ExportInstruction * instr) override
			{
				ctx.Body << AddWorldNameSuffix(instr->ComponentName, world->Name) << L"[" << outputIndex << L"] = ";
				codeGen->PrintOp(ctx, instr->Operand.Ptr());
				ctx.Body << L";\n";
			}
		};

		class PackedBufferOutputStrategy : public OutputStrategy
		{
		public:
			PackedBufferOutputStrategy(GLSLCodeGen * pCodeGen, ILWorld * world)
				: OutputStrategy(pCodeGen, world)
			{}
			virtual void DeclareOutput(CodeGenContext & ctx, ILStage *) override
			{
				for (auto & field : world->OutputType->Members)
				{
					ctx.GlobalHeader << L"out ";
					codeGen->PrintDef(ctx.GlobalHeader, field.Value.Type.Ptr(), field.Key);
					ctx.GlobalHeader << L";\n";
				}
			}
			virtual void ProcessExportInstruction(CodeGenContext & ctx, ExportInstruction * exportInstr) override
			{
				String conversionFunction;
				int size = 0;
				String typeName = exportInstr->Type->ToString();
				if (typeName == L"int")
				{
					conversionFunction = L"intBitsToFloat";
					size = 1;
				}
				else if (typeName == L"ivec2")
				{
					conversionFunction = L"intBitsToFloat";
					size = 2;
				}
				else if (typeName == L"ivec3")
				{
					conversionFunction = L"intBitsToFloat";
					size = 3;
				}
				else if (typeName == L"ivec4")
				{
					conversionFunction = L"intBitsToFloat";
					size = 4;
				}
				else if (typeName == L"uint")
				{
					conversionFunction = L"uintBitsToFloat";
					size = 1;
				}
				else if (typeName == L"uvec2")
				{
					conversionFunction = L"uintBitsToFloat";
					size = 2;
				}
				else if (typeName == L"uvec3")
				{
					conversionFunction = L"uintBitsToFloat";
					size = 3;
				}
				else if (typeName == L"uvec4")
				{
					conversionFunction = L"uintBitsToFloat";
					size = 4;
				}
				else if (typeName == L"float")
				{
					conversionFunction = L"";
					size = 1;
				}
				else if (typeName == L"vec2")
				{
					conversionFunction = L"";
					size = 2;
				}
				else if (typeName == L"vec3")
				{
					conversionFunction = L"";
					size = 3;
				}
				else if (typeName == L"vec4")
				{
					conversionFunction = L"";
					size = 4;
				}
				else if (typeName == L"mat3")
				{
					conversionFunction = L"";
					size = 9;
				}
				else if (typeName == L"mat4")
				{
					conversionFunction = L"";
					size = 16;
				}
				else
				{
					codeGen->Error(50082, L"importing type '" + typeName + L"' from PackedBuffer is not supported by the GLSL backend.",
						CodePosition());
				}
				auto recType = world->OutputType.Ptr();
				int recTypeSize = 0;
				EnumerableDictionary<String, int> memberOffsets;
				for (auto & member : recType->Members)
				{
					memberOffsets[member.Key] = recTypeSize;
					recTypeSize += member.Value.Type->GetVectorSize();
				}
				for (int i = 0; i < size; i++)
				{
					ctx.Body << L"sysOutputBuffer.content[gl_InvocationId.x * " << recTypeSize << L" + " + memberOffsets[exportInstr->ComponentName]()
						<< L"] = " << conversionFunction << L"(";
					codeGen->PrintOp(ctx, exportInstr->Operand.Ptr());
					if (size <= 4)
						ctx.Body << L"[" << i << L"]";
					else
					{
						int width = size == 9 ? 3 : 4;
						ctx.Body << L"[" << i / width << L"][" << i % width << L"]";
					}
					ctx.Body << L");\n";
				}
			}
		};

		OutputStrategy * GLSLCodeGen::CreateStandardOutputStrategy(ILWorld * world, String layoutPrefix)
		{
			return new StandardOutputStrategy(this, world, layoutPrefix);
		}
		OutputStrategy * GLSLCodeGen::CreatePackedBufferOutputStrategy(ILWorld * world)
		{
			return new PackedBufferOutputStrategy(this, world);
		}
		OutputStrategy * GLSLCodeGen::CreateArrayOutputStrategy(ILWorld * world, bool pIsPatch, int pArraySize, String arrayIndex)
		{
			return new ArrayOutputStrategy(this, world, pIsPatch, pArraySize, arrayIndex);
		}

		CodeGenBackend * CreateGLSLCodeGen()
		{
			return new GLSLCodeGen();
		}
	}
}

/***********************************************************************
SPIRECORE\HLSLCODEGEN.CPP
***********************************************************************/


using namespace CoreLib::Basic;

namespace Spire
{
	namespace Compiler
	{
		class HLSLCodeGen : public CLikeCodeGen
		{
		protected:
			OutputStrategy * CreateStandardOutputStrategy(ILWorld * world, String layoutPrefix) override;
			OutputStrategy * CreatePackedBufferOutputStrategy(ILWorld * world) override;
			OutputStrategy * CreateArrayOutputStrategy(ILWorld * world, bool pIsPatch, int pArraySize, String arrayIndex) override;

			void PrintRasterPositionOutputWrite(CodeGenContext & ctx, ILOperand * operand) override
			{
				ctx.Body << L"stage_output.sv_position = ";
				PrintOp(ctx, operand);
				ctx.Body << L";\n";
			}

			void PrintMatrixMulInstrExpr(CodeGenContext & ctx, ILOperand* op0, ILOperand* op1) override
			{
				ctx.Body << L"mul(";
				PrintOp(ctx, op0);
				ctx.Body << L", ";
				PrintOp(ctx, op1);
				ctx.Body << L")";
			}

			void PrintUniformBufferInputReference(StringBuilder& sb, String inputName, String componentName) override
			{
				if (!currentImportInstr->Type->IsTexture() || useBindlessTexture)
					sb << L"blk" << inputName << L"." << componentName;
				else
					sb << componentName;
			}

			void PrintStorageBufferInputReference(StringBuilder& sb, String inputName, String componentName) override
			{
				sb << componentName;
			}

			void PrintArrayBufferInputReference(StringBuilder& sb, String inputName, String componentName) override
			{
				sb << L"blk" << inputName << L".content";
			}

			void PrintPackedBufferInputReference(StringBuilder& sb, String inputName, String componentName) override
			{
				sb << L"blk" << inputName << L".content";
			}

			void PrintStandardInputReference(StringBuilder& sb, ILRecordType* /*recType*/, String inputName, String componentName) override
			{
				String declName = componentName;
				sb << L"stage_input." << declName;
			}

			void PrintPatchInputReference(StringBuilder& sb, ILRecordType* recType, String inputName, String componentName) override
			{
				String declName = componentName;
				declName = AddWorldNameSuffix(declName, recType->ToString());
				sb << declName;
			}

			void PrintDefaultInputReference(StringBuilder& sb, ILRecordType* /*recType*/, String inputName, String componentName) override
			{
				String declName = componentName;
				sb << declName;
			}

			void PrintSystemVarReference(StringBuilder& sb, String inputName, ExternComponentCodeGenInfo::SystemVarType systemVar) override
			{
				switch(systemVar)
				{
				case ExternComponentCodeGenInfo::SystemVarType::FragCoord:
					sb << L"gl_FragCoord";
					break;
				case ExternComponentCodeGenInfo::SystemVarType::TessCoord:
					sb << L"gl_TessCoord";
					break;
				case ExternComponentCodeGenInfo::SystemVarType::InvocationId:
					sb << L"gl_InvocationID";
					break;
				case ExternComponentCodeGenInfo::SystemVarType::ThreadId:
					sb << L"gl_GlobalInvocationID.x";
					break;
				case ExternComponentCodeGenInfo::SystemVarType::PatchVertexCount:
					sb << L"gl_PatchVerticesIn";
					break;
				case ExternComponentCodeGenInfo::SystemVarType::PrimitiveId:
					sb << L"gl_PrimitiveID";
					break;
				default:
					sb << inputName;
					break;
				}
			}

			String RemapFuncNameForTarget(String name) override
			{
				// Currently, all types are internally named based on their GLSL equivalent, so
				// for HLSL output we go ahead and maintain a big table to remap the names.
				//
				// Note: for right now, this is just a linear array, with no particular sorting.
				// Eventually it should be turned into a hash table for performance, or at least
				// just be kept sorted so that we can use a binary search.
				//
				// Note 2: Well, actually, the Right Answer is for the type representation to
				// be better than just a string, so that we don't have to do this string->string map.
				static const struct {
					wchar_t const* glslName;
					wchar_t const* hlslName;
				} kNameRemaps[] =
				{
					{ L"vec2", L"float2" },
					{ L"vec3", L"float3" },
					{ L"vec4", L"float4" },

					{ L"ivec2", L"int2" },
					{ L"ivec3", L"int3" },
					{ L"ivec4", L"int4" },

					{ L"uvec2", L"uint2" },
					{ L"uvec3", L"uint3" },
					{ L"uvec4", L"uint4" },

					{ L"mat3", L"float3x3" },
					{ L"mat4", L"float4x4" },
				};

				for(auto remap : kNameRemaps)
				{
					if(wcscmp(name.Buffer(), remap.glslName) == 0)
					{
						return remap.hlslName;
					}
				}

				return name;
			}



			void PrintTypeName(StringBuilder& sb, ILType* type) override
			{
				// Currently, all types are internally named based on their GLSL equivalent, so
				// for HLSL output we go ahead and maintain a big table to remap the names.
				//
				// Note: for right now, this is just a linear array, with no particular sorting.
				// Eventually it should be turned into a hash table for performance, or at least
				// just be kept sorted so that we can use a binary search.
				//
				// Note 2: Well, actually, the Right Answer is for the type representation to
				// be better than just a string, so that we don't have to do this string->string map.
				static const struct {
					wchar_t const* glslName;
					wchar_t const* hlslName;
				} kNameRemaps[] =
				{
					{ L"vec2", L"float2" },
					{ L"vec3", L"float3" },
					{ L"vec4", L"float4" },

					{ L"ivec2", L"int2" },
					{ L"ivec3", L"int3" },
					{ L"ivec4", L"int4" },

					{ L"uvec2", L"uint2" },
					{ L"uvec3", L"uint3" },
					{ L"uvec4", L"uint4" },

					{ L"mat3", L"float3x3" },
					{ L"mat4", L"float4x4" },
				};

				String typeName = type->ToString();
				for(auto remap : kNameRemaps)
				{
					if(wcscmp(typeName.Buffer(), remap.glslName) == 0)
					{
						sb << remap.hlslName;
						return;
					}
				}

				// If we don't find the type in our map, then that either means we missed a case,
				// or this is a user-defined type. I don't see an obvious way to check which of
				// those cases we are in, so we will just fall back to outputting the "GLSL name" here.
				sb << type->ToString();
			}

			void DeclareUniformBuffer(CodeGenContext & sb, const ILObjectDefinition & input, bool /*isVertexShader*/) override
			{
				auto info = ExtractExternComponentInfo(input);
				extCompInfo[input.Name] = info;
				auto recType = ExtractRecordType(input.Type.Ptr());
				assert(recType);
				assert(info.DataStructure == ExternComponentCodeGenInfo::DataStructureType::UniformBuffer);

				int declarationStart = sb.GlobalHeader.Length();
				int itemsDeclaredInBlock = 0;

				sb.GlobalHeader << L"cbuffer " << input.Name;
				if (info.Binding != -1)
					sb.GlobalHeader << L" : register(b" << info.Binding << L")";
				sb.GlobalHeader << L"\n{\n";

				// We declare an inline struct inside the `cbuffer` to ensure that
				// the members have an appropriate prefix on their name.
				sb.GlobalHeader << L"struct {\n";

				int index = 0;
				for (auto & field : recType->Members)
				{
					if (field.Value.Type->IsTexture())
						continue;
					String declName = field.Key;
					PrintDef(sb.GlobalHeader, field.Value.Type.Ptr(), declName);
					itemsDeclaredInBlock++;
					if (info.IsArray)
					{
						sb.GlobalHeader << L"[";
						if (info.ArrayLength)
							sb.GlobalHeader << String(info.ArrayLength);
						sb.GlobalHeader << L"]";
					}
					sb.GlobalHeader << L";\n";

					index++;
				}

				if (itemsDeclaredInBlock == 0)
				{
					sb.GlobalHeader.Remove(declarationStart, sb.GlobalHeader.Length() - declarationStart);
					return;
				}

				sb.GlobalHeader << L"} blk" << input.Name << L";\n";
				sb.GlobalHeader << L"};\n";

				for (auto & field : recType->Members)
				{
					if (field.Value.Type->IsTexture())
					{
						if (field.Value.Attributes.ContainsKey(L"Binding"))
							sb.GlobalHeader << L"layout(binding = " << field.Value.Attributes[L"Binding"]() << L") ";
						else
						{
							sb.GlobalHeader << L"layout(binding = " << sb.TextureBindingsAllocator << L") ";
							sb.TextureBindingsAllocator++;
						}
						sb.GlobalHeader << L"uniform ";
						PrintDef(sb.GlobalHeader, field.Value.Type.Ptr(), field.Key);
						sb.GlobalHeader << L";\n";
					}
				}
			}

			void DeclareStorageBuffer(CodeGenContext & /*sb*/, const ILObjectDefinition & /*input*/, bool /*isVertexShader*/) override
			{
				// TODO: HLSL does not make it easy to declare a UAV with an interesting type...
			}
			void DeclareArrayBuffer(CodeGenContext & /*sb*/, const ILObjectDefinition & /*input*/, bool /*isVertexShader*/) override
			{

			}
			void DeclarePackedBuffer(CodeGenContext & /*sb*/, const ILObjectDefinition & /*input*/, bool /*isVertexShader*/) override
			{

			}

			void DeclareTextureInputRecord(CodeGenContext & sb, const ILObjectDefinition & input, bool /*isVertexShader*/) override
			{
				auto info = ExtractExternComponentInfo(input);
				auto recType = ExtractRecordType(input.Type.Ptr());
				assert(recType);
				assert(info.DataStructure == ExternComponentCodeGenInfo::DataStructureType::Texture);

				for(auto & field : recType->Members)
				{
					if(field.Value.Type->IsFloat() || field.Value.Type->IsFloatVector() && !field.Value.Type->IsFloatMatrix())
					{
						// TODO(tfoley): texture binding allocation needs to be per-stage in D3D11, but should be global for D3D12
						int slotIndex = sb.TextureBindingsAllocator++;

						sb.GlobalHeader << L"Texture2D " << field.Key;
						sb.GlobalHeader << L" : register(t" << slotIndex << L")";
						sb.GlobalHeader << L";\n";

						sb.GlobalHeader << L"SamplerState " << field.Key << "_sampler";
						sb.GlobalHeader << L" : register(s" << slotIndex << L")";
						sb.GlobalHeader << L";\n";
					}
					else
					{
						errWriter->Error(51091, L"type '" + field.Value.Type->ToString() + L"' cannot be placed in a texture.",
							field.Value.Position);
					}
				}
			}

			void DeclareStandardInputRecord(CodeGenContext & sb, const ILObjectDefinition & input, bool isVertexShader) override
			{
				auto info = ExtractExternComponentInfo(input);
				extCompInfo[input.Name] = info;
				auto recType = ExtractRecordType(input.Type.Ptr());
				assert(recType);

				// In order to handle ordinary per-stage shader inputs, we need to
				// declare a `struct` type over all the fields.

				sb.GlobalHeader << L"struct T" << recType->TypeName << L"\n{\n";

				int index = 0;
				for (auto & field : recType->Members)
				{
					if (!isVertexShader && (input.Attributes.ContainsKey(L"Flat") || field.Value.Type->IsIntegral()))
						sb.GlobalHeader << L"noperspective ";

					String declName = field.Key;
					PrintDef(sb.GlobalHeader, field.Value.Type.Ptr(), declName);
					if (info.IsArray)
					{
						sb.GlobalHeader << L"[";
						if (info.ArrayLength)
							sb.GlobalHeader << String(info.ArrayLength);
						sb.GlobalHeader << L"]";
					}

					// We synthesize a dummy semantic for every component, just to make things easy
					// TODO(tfoley): This won't work in presence of `struct`-type fields
					sb.GlobalHeader << " : A" << index;

					sb.GlobalHeader << L";\n";

					index++;
				}

				sb.GlobalHeader << L"};\n";
			}

			void DeclarePatchInputRecord(CodeGenContext & sb, const ILObjectDefinition & input, bool isVertexShader) override
			{
				// In HLSL, both standard input/output and per-patch input/output are passed as ordinary `struct` types.
				DeclareStandardInputRecord(sb, input, isVertexShader);
			}


			StageSource GenerateSingleWorldShader(ILProgram * program, ILShader * shader, ILStage * stage) override
			{
				useBindlessTexture = stage->Attributes.ContainsKey(L"BindlessTexture");
				StageSource rs;
				CodeGenContext ctx;

				if (stage->StageType == L"DomainShader")
					GenerateDomainShaderProlog(ctx, stage);

				GenerateStructs(ctx.GlobalHeader, program);
				StageAttribute worldName;
				RefPtr<ILWorld> world = nullptr;
				if (stage->Attributes.TryGetValue(L"World", worldName))
				{
					if (!shader->Worlds.TryGetValue(worldName.Value, world))
						errWriter->Error(50022, L"world '" + worldName.Value + L"' is not defined.", worldName.Position);
				}
				else
					errWriter->Error(50023, L"'" + stage->StageType + L"' should provide 'World' attribute.", stage->Position);
				if (!world)
					return rs;
				GenerateReferencedFunctions(ctx.GlobalHeader, program, MakeArrayView(world.Ptr()));
				extCompInfo.Clear();
				ILRecordType* stageInputType = nullptr;
				for (auto & input : world->Inputs)
				{
					DeclareInput(ctx, input, stage->StageType == L"VertexShader");

					// We need to detect the world that represents the ordinary stage input...
					// TODO(tfoley): It seems like this is logically part of the stage definition.
					auto info = ExtractExternComponentInfo(input);
					if(info.DataStructure == ExternComponentCodeGenInfo::DataStructureType::StandardInput)
					{
						auto recType = ExtractRecordType(input.Type.Ptr());
						stageInputType = recType;
					}
				}
				if(!stageInputType)
				{
					errWriter->Error(99999, L"'" + stage->StageType + L"' doesn't appear to have any input world", stage->Position);
				}
		
				outputStrategy->DeclareOutput(ctx, stage);
				ctx.codeGen = this;
				world->Code->NameAllInstructions();
				GenerateCode(ctx, world->Code.Ptr());
				if (stage->StageType == L"VertexShader" || stage->StageType == L"DomainShader")
					GenerateVertexShaderEpilog(ctx, world.Ptr(), stage);

				StringBuilder sb;
				sb << ctx.GlobalHeader.ProduceString();

				sb << L"struct T" << world->OutputType->TypeName << "Ext\n{\n";
				sb << L"T" << world->OutputType->TypeName << " user;\n";
				if(stage->Attributes.TryGetValue(L"Position"))
				{
					sb << L"float4 sv_position : SV_Position;\n";
				}
				sb << L"};\n";

				sb << L"T" << world->OutputType->TypeName << L"Ext main(";
				sb << L"T" << stageInputType->TypeName << " stage_input";
				sb << ")\n{ \n";
				sb << "T" << world->OutputType->TypeName << "Ext stage_output;\n";
				sb << ctx.Header.ProduceString() << ctx.Body.ProduceString();
				sb << "return stage_output;\n";
				sb << L"}";
				rs.MainCode = sb.ProduceString();
				return rs;
			}

			StageSource GenerateHullShader(ILProgram * program, ILShader * shader, ILStage * stage) override
			{
				// TODO(tfoley): This is just copy-pasted from the GLSL case, and needs a lot of work

				StageSource rs;
				StageAttribute patchWorldName, controlPointWorldName, cornerPointWorldName, domain, innerLevel, outerLevel, numControlPoints;
				RefPtr<ILWorld> patchWorld, controlPointWorld, cornerPointWorld;
				if (!stage->Attributes.TryGetValue(L"PatchWorld", patchWorldName))
				{
					errWriter->Error(50052, L"'HullShader' requires attribute 'PatchWorld'.", stage->Position);
					return rs;
				}
				if (!shader->Worlds.TryGetValue(patchWorldName.Value, patchWorld))
					errWriter->Error(50022, L"world '" + patchWorldName.Value + L"' is not defined.", patchWorldName.Position);
				if (!stage->Attributes.TryGetValue(L"ControlPointWorld", controlPointWorldName))
				{
					errWriter->Error(50052, L"'HullShader' requires attribute 'ControlPointWorld'.", stage->Position); 
					return rs;
				}
				if (!shader->Worlds.TryGetValue(controlPointWorldName.Value, controlPointWorld))
					errWriter->Error(50022, L"world '" + controlPointWorldName.Value + L"' is not defined.", controlPointWorldName.Position);
				if (!stage->Attributes.TryGetValue(L"CornerPointWorld", cornerPointWorldName))
				{
					errWriter->Error(50052, L"'HullShader' requires attribute 'CornerPointWorld'.", stage->Position);
					return rs;
				}
				if (!shader->Worlds.TryGetValue(cornerPointWorldName.Value, cornerPointWorld))
					errWriter->Error(50022, L"world '" + cornerPointWorldName.Value + L"' is not defined.", cornerPointWorldName.Position);
				if (!stage->Attributes.TryGetValue(L"Domain", domain))
				{
					errWriter->Error(50052, L"'HullShader' requires attribute 'Domain'.", stage->Position);
					return rs;
				}
				if (domain.Value != L"triangles" && domain.Value != L"quads")
				{
					errWriter->Error(50053, L"'Domain' should be either 'triangles' or 'quads'.", domain.Position);
					return rs;
				}
				if (!stage->Attributes.TryGetValue(L"TessLevelOuter", outerLevel))
				{
					errWriter->Error(50052, L"'HullShader' requires attribute 'TessLevelOuter'.", stage->Position);
					return rs;
				}
				if (!stage->Attributes.TryGetValue(L"TessLevelInner", innerLevel))
				{
					errWriter->Error(50052, L"'HullShader' requires attribute 'TessLevelInner'.", stage->Position);
					return rs;
				}
				if (!stage->Attributes.TryGetValue(L"ControlPointCount", numControlPoints))
				{
					errWriter->Error(50052, L"'HullShader' requires attribute 'ControlPointCount'.", stage->Position);
					return rs;
				}
				CodeGenContext ctx;
				ctx.codeGen = this;
				List<ILWorld*> worlds;
				worlds.Add(patchWorld.Ptr());
				worlds.Add(controlPointWorld.Ptr());
				worlds.Add(cornerPointWorld.Ptr());

				//GenerateHeader(ctx.GlobalHeader, stage);

				ctx.GlobalHeader << L"layout(vertices = " << numControlPoints.Value << L") out;\n";
				GenerateStructs(ctx.GlobalHeader, program);
				GenerateReferencedFunctions(ctx.GlobalHeader, program, worlds.GetArrayView());
				extCompInfo.Clear();

				HashSet<String> declaredInputs;

				patchWorld->Code->NameAllInstructions();
				outputStrategy = CreateStandardOutputStrategy(patchWorld.Ptr(), L"patch");
				for (auto & input : patchWorld->Inputs)
				{
					if (declaredInputs.Add(input.Name))
						DeclareInput(ctx, input, false);
				}
				outputStrategy->DeclareOutput(ctx, stage);
				GenerateCode(ctx, patchWorld->Code.Ptr());

				controlPointWorld->Code->NameAllInstructions();
				outputStrategy = CreateArrayOutputStrategy(controlPointWorld.Ptr(), false, 0, L"gl_InvocationID");
				for (auto & input : controlPointWorld->Inputs)
				{
					if (declaredInputs.Add(input.Name))
						DeclareInput(ctx, input, false);
				}
				outputStrategy->DeclareOutput(ctx, stage);
				GenerateCode(ctx, controlPointWorld->Code.Ptr());

				cornerPointWorld->Code->NameAllInstructions();
				outputStrategy = CreateArrayOutputStrategy(cornerPointWorld.Ptr(), true, (domain.Value == L"triangles" ? 3 : 4), L"sysLocalIterator");
				for (auto & input : cornerPointWorld->Inputs)
				{
					if (declaredInputs.Add(input.Name))
						DeclareInput(ctx, input, false);
				}
				outputStrategy->DeclareOutput(ctx, stage);
				ctx.Body << L"for (int sysLocalIterator = 0; sysLocalIterator < gl_PatchVerticesIn; sysLocalIterator++)\n{\n";
				GenerateCode(ctx, cornerPointWorld->Code.Ptr());
				auto debugStr = cornerPointWorld->Code->ToString();
				ctx.Body << L"}\n";

				// generate epilog
				bool found = false;
				for (auto & world : worlds)
				{
					ILOperand * operand;
					if (world->Components.TryGetValue(innerLevel.Value, operand))
					{
						for (int i = 0; i < 2; i++)
						{
							ctx.Body << L"gl_TessLevelInner[" << i << L"] = ";
							PrintOp(ctx, operand);
							ctx.Body << L"[" << i << L"];\n";
						}
						found = true;
						break;
					}
				}
				if (!found)
					errWriter->Error(50041, L"'" + innerLevel.Value + L"': component not defined.",
						innerLevel.Position);

				found = false;
				for (auto & world : worlds)
				{
					ILOperand * operand;
					if (world->Components.TryGetValue(outerLevel.Value, operand))
					{
						for (int i = 0; i < 4; i++)
						{
							ctx.Body << L"gl_TessLevelOuter[" << i << L"] = ";
							PrintOp(ctx, operand);
							ctx.Body << L"[" << i << L"];\n";
						}
						found = true;
						break;
					}

				}
				if (!found)
					errWriter->Error(50041, L"'" + outerLevel.Value + L"': component not defined.",
						outerLevel.Position);

				StringBuilder sb;
				sb << ctx.GlobalHeader.ProduceString();
				sb << L"void main()\n{\n" << ctx.Header.ProduceString() << ctx.Body.ProduceString() << L"}";
				rs.MainCode = sb.ProduceString();
				return rs;
			}
		};

		class HLSLStandardOutputStrategy : public OutputStrategy
		{
		private:
			String declPrefix;
		public:
			HLSLStandardOutputStrategy(HLSLCodeGen * pCodeGen, ILWorld * world, String prefix)
				: OutputStrategy(pCodeGen, world), declPrefix(prefix)
			{}
			virtual void DeclareOutput(CodeGenContext & ctx, ILStage * stage) override
			{
				ctx.GlobalHeader << L"struct T" << world->OutputType->TypeName << L"\n{\n";
				int index = 0;
				for (auto & field : world->OutputType->Members)
				{
					if (declPrefix.Length())
						ctx.GlobalHeader << declPrefix << L" ";
					if (field.Value.Type->IsIntegral())
						ctx.GlobalHeader << L"noperspective ";
					String declName = field.Key;
					codeGen->PrintDef(ctx.GlobalHeader, field.Value.Type.Ptr(), AddWorldNameSuffix(declName, world->OutputType->TypeName));

					// We synthesize a dummy semantic for every component, just to make things easy
					// TODO(tfoley): This won't work in presence of `struct`-type fields

					// Note(tfoley): The fragment shader outputs needs to use the `SV_Target` semantic
					// instead of a user-defined semantic. This is annoyingly non-orthogonal.
					if(stage->StageType == L"FragmentShader")
					{
						ctx.GlobalHeader << " : SV_Target" << index;
					}
					else
					{
						ctx.GlobalHeader << " : A" << index;
					}

					ctx.GlobalHeader << L";\n";

					index++;
				}
				ctx.GlobalHeader << L"};\n";
			}
			virtual void ProcessExportInstruction(CodeGenContext & ctx, ExportInstruction * instr) override
			{
				ctx.Body << "stage_output.user." << AddWorldNameSuffix(instr->ComponentName, world->OutputType->TypeName) << L" = ";
				codeGen->PrintOp(ctx, instr->Operand.Ptr());
				ctx.Body << L";\n";
			}
		};

		class HLSLArrayOutputStrategy : public OutputStrategy
		{
		protected:
			bool isPatch = false;
			int arraySize = 0;
		public:
			String outputIndex;
			HLSLArrayOutputStrategy(HLSLCodeGen * pCodeGen, ILWorld * world, bool pIsPatch, int pArraySize, String pOutputIndex)
				: OutputStrategy(pCodeGen, world)
			{
				isPatch = pIsPatch;
				arraySize = pArraySize;
				outputIndex = pOutputIndex;
			}
			virtual void DeclareOutput(CodeGenContext & ctx, ILStage *) override
			{
				for (auto & field : world->OutputType->Members)
				{
					if (isPatch)
						ctx.GlobalHeader << L"patch ";
					ctx.GlobalHeader << L"out ";
					codeGen->PrintDef(ctx.GlobalHeader, field.Value.Type.Ptr(), AddWorldNameSuffix(field.Key, world->Name));
					ctx.GlobalHeader << L"[";
					if (arraySize != 0)
						ctx.GlobalHeader << arraySize;
					ctx.GlobalHeader<<L"]; \n";
				}
			}
			virtual void ProcessExportInstruction(CodeGenContext & ctx, ExportInstruction * instr) override
			{
				ctx.Body << AddWorldNameSuffix(instr->ComponentName, world->Name) << L"[" << outputIndex << L"] = ";
				codeGen->PrintOp(ctx, instr->Operand.Ptr());
				ctx.Body << L";\n";
			}
		};

		class HLSLPackedBufferOutputStrategy : public OutputStrategy
		{
		public:
			HLSLPackedBufferOutputStrategy(HLSLCodeGen * pCodeGen, ILWorld * world)
				: OutputStrategy(pCodeGen, world)
			{}
			virtual void DeclareOutput(CodeGenContext & ctx, ILStage *) override
			{
				for (auto & field : world->OutputType->Members)
				{
					ctx.GlobalHeader << L"out ";
					codeGen->PrintDef(ctx.GlobalHeader, field.Value.Type.Ptr(), field.Key);
					ctx.GlobalHeader << L";\n";
				}
			}
			virtual void ProcessExportInstruction(CodeGenContext & ctx, ExportInstruction * exportInstr) override
			{
				String conversionFunction;
				int size = 0;
				String typeName = exportInstr->Type->ToString();
				if (typeName == L"int")
				{
					conversionFunction = L"intBitsToFloat";
					size = 1;
				}
				else if (typeName == L"ivec2")
				{
					conversionFunction = L"intBitsToFloat";
					size = 2;
				}
				else if (typeName == L"ivec3")
				{
					conversionFunction = L"intBitsToFloat";
					size = 3;
				}
				else if (typeName == L"ivec4")
				{
					conversionFunction = L"intBitsToFloat";
					size = 4;
				}
				else if (typeName == L"uint")
				{
					conversionFunction = L"uintBitsToFloat";
					size = 1;
				}
				else if (typeName == L"uvec2")
				{
					conversionFunction = L"uintBitsToFloat";
					size = 2;
				}
				else if (typeName == L"uvec3")
				{
					conversionFunction = L"uintBitsToFloat";
					size = 3;
				}
				else if (typeName == L"uvec4")
				{
					conversionFunction = L"uintBitsToFloat";
					size = 4;
				}
				else if (typeName == L"float")
				{
					conversionFunction = L"";
					size = 1;
				}
				else if (typeName == L"vec2")
				{
					conversionFunction = L"";
					size = 2;
				}
				else if (typeName == L"vec3")
				{
					conversionFunction = L"";
					size = 3;
				}
				else if (typeName == L"vec4")
				{
					conversionFunction = L"";
					size = 4;
				}
				else if (typeName == L"mat3")
				{
					conversionFunction = L"";
					size = 9;
				}
				else if (typeName == L"mat4")
				{
					conversionFunction = L"";
					size = 16;
				}
				else
				{
					codeGen->Error(50082, L"importing type '" + typeName + L"' from PackedBuffer is not supported by the GLSL backend.",
						CodePosition());
				}
				auto recType = world->OutputType.Ptr();
				int recTypeSize = 0;
				EnumerableDictionary<String, int> memberOffsets;
				for (auto & member : recType->Members)
				{
					memberOffsets[member.Key] = recTypeSize;
					recTypeSize += member.Value.Type->GetVectorSize();
				}
				for (int i = 0; i < size; i++)
				{
					ctx.Body << L"sysOutputBuffer.content[gl_InvocationId.x * " << recTypeSize << L" + " + memberOffsets[exportInstr->ComponentName]()
						<< L"] = " << conversionFunction << L"(";
					codeGen->PrintOp(ctx, exportInstr->Operand.Ptr());
					if (size <= 4)
						ctx.Body << L"[" << i << L"]";
					else
					{
						int width = size == 9 ? 3 : 4;
						ctx.Body << L"[" << i / width << L"][" << i % width << L"]";
					}
					ctx.Body << L");\n";
				}
			}
		};

		OutputStrategy * HLSLCodeGen::CreateStandardOutputStrategy(ILWorld * world, String layoutPrefix)
		{
			return new HLSLStandardOutputStrategy(this, world, layoutPrefix);
		}
		OutputStrategy * HLSLCodeGen::CreatePackedBufferOutputStrategy(ILWorld * world)
		{
			return new HLSLPackedBufferOutputStrategy(this, world);
		}
		OutputStrategy * HLSLCodeGen::CreateArrayOutputStrategy(ILWorld * world, bool pIsPatch, int pArraySize, String arrayIndex)
		{
			return new HLSLArrayOutputStrategy(this, world, pIsPatch, pArraySize, arrayIndex);
		}

		CodeGenBackend * CreateHLSLCodeGen()
		{
			return new HLSLCodeGen();
		}
	}
}

/***********************************************************************
SPIRECORE\IL.CPP
***********************************************************************/

namespace Spire
{
	namespace Compiler
	{
		using namespace CoreLib::IO;

		RefPtr<ILType> BaseTypeFromString(CoreLib::Text::Parser & parser)
		{
			if (parser.LookAhead(L"int"))
				return new ILBasicType(ILBaseType::Int);
			else if (parser.LookAhead(L"uint"))
				return new ILBasicType(ILBaseType::UInt);
			else if (parser.LookAhead(L"uvec2"))
				return new ILBasicType(ILBaseType::UInt2);
			else if (parser.LookAhead(L"uvec3"))
				return new ILBasicType(ILBaseType::UInt3);
			else if (parser.LookAhead(L"uvec4"))
				return new ILBasicType(ILBaseType::UInt4);
			if (parser.LookAhead(L"float"))
				return new ILBasicType(ILBaseType::Float);
			if (parser.LookAhead(L"vec2"))
				return new ILBasicType(ILBaseType::Float2);
			if (parser.LookAhead(L"vec3"))
				return new ILBasicType(ILBaseType::Float3);
			if (parser.LookAhead(L"vec4"))
				return new ILBasicType(ILBaseType::Float4);
			if (parser.LookAhead(L"ivec2"))
				return new ILBasicType(ILBaseType::Int2);
			if (parser.LookAhead(L"mat3"))
				return new ILBasicType(ILBaseType::Float3x3);
			if (parser.LookAhead(L"mat4"))
				return new ILBasicType(ILBaseType::Float4x4);
			if (parser.LookAhead(L"ivec3"))
				return new ILBasicType(ILBaseType::Int3);
			if (parser.LookAhead(L"ivec4"))
				return new ILBasicType(ILBaseType::Int4);
			if (parser.LookAhead(L"sampler2D"))
				return new ILBasicType(ILBaseType::Texture2D);
			if (parser.LookAhead(L"sampler2DShadow"))
				return new ILBasicType(ILBaseType::TextureShadow);
			if (parser.LookAhead(L"samplerCube"))
				return new ILBasicType(ILBaseType::TextureCube);
			if (parser.LookAhead(L"samplerCubeShadow"))
				return new ILBasicType(ILBaseType::TextureCubeShadow);
			if (parser.LookAhead(L"bool"))
				return new ILBasicType(ILBaseType::Bool);
			return nullptr;
		}

		RefPtr<ILType> TypeFromString(CoreLib::Text::Parser & parser)
		{
			auto result = BaseTypeFromString(parser);
			parser.ReadToken();
			while (parser.LookAhead(L"["))
			{
				parser.ReadToken();
				RefPtr<ILArrayType> newResult = new ILArrayType();
				newResult->BaseType = result;
				if (!parser.LookAhead(L"]"))
					newResult->ArrayLength = parser.ReadInt();
				result = newResult;
				parser.Read(L"]");
			}
			return result;
		}

		int RoundToAlignment(int offset, int alignment)
		{
			int remainder = offset % alignment;
			if (remainder == 0)
				return offset;
			else
				return offset + (alignment - remainder);
		}

		int SizeofBaseType(ILBaseType type)
		{
			if (type == ILBaseType::Int)
				return 4;
			if (type == ILBaseType::UInt)
				return 4;
			if (type == ILBaseType::UInt2)
				return 8;
			if (type == ILBaseType::UInt3)
				return 12;
			if (type == ILBaseType::UInt4)
				return 16;
			else if (type == ILBaseType::Int2)
				return 8;
			else if (type == ILBaseType::Int3)
				return 12;
			else if (type == ILBaseType::Int4)
				return 16;
			else if (type == ILBaseType::Float)
				return 4;
			else if (type == ILBaseType::Float2)
				return 8;
			else if (type == ILBaseType::Float3)
				return 12;
			else if (type == ILBaseType::Float4)
				return 16;
			else if (type == ILBaseType::Float3x3)
				return 48;
			else if (type == ILBaseType::Float4x4)
				return 64;
			else if (type == ILBaseType::Texture2D)
				return 8;
			else if (type == ILBaseType::TextureCube)
				return 8;
			else if (type == ILBaseType::TextureCubeShadow)
				return 8;
			else if (type == ILBaseType::TextureShadow)
				return 8;
			else if (type == ILBaseType::Bool)
				return 4;
			else
				return 0;
		}

		bool ILType::IsBool()
		{
			auto basicType = dynamic_cast<ILBasicType*>(this);
			if (basicType)
				return basicType->Type == ILBaseType::Bool;
			else
				return false;
		}

		bool ILType::IsInt()
		{
			auto basicType = dynamic_cast<ILBasicType*>(this);
			if (basicType)
				return basicType->Type == ILBaseType::Int;
			else
				return false;
		}

		bool ILType::IsUInt()
		{
			auto basicType = dynamic_cast<ILBasicType*>(this);
			if (basicType)
				return basicType->Type == ILBaseType::UInt;
			else
				return false;
		}

		bool ILType::IsIntegral()
		{
			auto basicType = dynamic_cast<ILBasicType*>(this);
			if (basicType)
				return basicType->Type == ILBaseType::Int || basicType->Type == ILBaseType::Int2 || basicType->Type == ILBaseType::Int3 || basicType->Type == ILBaseType::Int4 
				|| basicType->Type == ILBaseType::UInt || basicType->Type == ILBaseType::UInt2 || basicType->Type == ILBaseType::UInt3 || basicType->Type == ILBaseType::UInt4 ||
				basicType->Type == ILBaseType::Bool;
			else
				return false;
		}

		bool ILType::IsFloat()
		{
			auto basicType = dynamic_cast<ILBasicType*>(this);
			if (basicType)
				return basicType->Type == ILBaseType::Float;
			else
				return false;
		}

		bool ILType::IsBoolVector()
		{
			auto basicType = dynamic_cast<ILBasicType*>(this);
			if (basicType)
				return basicType->Type == ILBaseType::Bool2 || basicType->Type == ILBaseType::Bool3 || basicType->Type == ILBaseType::Bool4;
			else
				return false;
		}

		bool ILType::IsIntVector()
		{
			auto basicType = dynamic_cast<ILBasicType*>(this);
			if (basicType)
				return basicType->Type == ILBaseType::Int2 || basicType->Type == ILBaseType::Int3 || basicType->Type == ILBaseType::Int4;
			else
				return false;
		}

		bool ILType::IsUIntVector()
		{
			auto basicType = dynamic_cast<ILBasicType*>(this);
			if (basicType)
				return basicType->Type == ILBaseType::UInt2 || basicType->Type == ILBaseType::UInt3 || basicType->Type == ILBaseType::UInt4;
			else
				return false;
		}

		bool ILType::IsFloatVector()
		{
			auto basicType = dynamic_cast<ILBasicType*>(this);
			if (basicType)
				return basicType->Type == ILBaseType::Float2 || basicType->Type == ILBaseType::Float3 || basicType->Type == ILBaseType::Float4 ||
					basicType->Type == ILBaseType::Float3x3 || basicType->Type == ILBaseType::Float4x4;
			else
				return false;
		}

		bool ILType::IsFloatMatrix()
		{
			auto basicType = dynamic_cast<ILBasicType*>(this);
			if (basicType)
				return basicType->Type == ILBaseType::Float3x3 || basicType->Type == ILBaseType::Float4x4;
			else
				return false;
		}

		bool ILType::IsNonShadowTexture()
		{
			auto basicType = dynamic_cast<ILBasicType*>(this);
			if (basicType)
				return basicType->Type == ILBaseType::Texture2D || basicType->Type == ILBaseType::TextureCube;
			else
				return false;
		}

		bool ILType::IsTexture()
		{
			auto basicType = dynamic_cast<ILBasicType*>(this);
			if (basicType)
				return basicType->Type == ILBaseType::Texture2D || basicType->Type == ILBaseType::TextureCube || basicType->Type == ILBaseType::TextureCubeShadow ||
				basicType->Type == ILBaseType::TextureShadow;
			else
				return false;
		}

		int ILType::GetVectorSize()
		{
			if (auto basicType = dynamic_cast<ILBasicType*>(this))
			{
				switch (basicType->Type)
				{
				case ILBaseType::Int2:
				case ILBaseType::Float2:
				case ILBaseType::UInt2:
					return 2;
				case ILBaseType::Int3:
				case ILBaseType::Float3:
				case ILBaseType::UInt3:
					return 3;
				case ILBaseType::Int4:
				case ILBaseType::Float4:
				case ILBaseType::UInt4:
					return 4;
				case ILBaseType::Float3x3:
					return 9;
				case ILBaseType::Float4x4:
					return 16;
				default:
					return 1;
				}
			}
			return 1;
		}

		bool CFGNode::HasPhiInstruction()
		{
			return headInstr && headInstr->GetNext() && headInstr->GetNext()->Is<PhiInstruction>();
		}

		ILInstruction * CFGNode::GetFirstNonPhiInstruction()
		{
			for (auto & instr : *this)
			{
				if (!instr.Is<PhiInstruction>())
					return &instr;
			}
			return tailInstr;
		}

		int NamingCounter = 0;

		void CFGNode::NameAllInstructions()
		{
			// name all operands
			StringBuilder numBuilder;
			for (auto & instr : GetAllInstructions())
			{
				numBuilder.Clear();
				for (auto & c : instr.Name)
				{
					if (c >= L'0' && c <= '9')
						numBuilder.Append(c);
					else
						numBuilder.Clear();
				}
				auto num = numBuilder.ToString();
				if (num.Length())
				{
					int id = StringToInt(num);
					NamingCounter = Math::Max(NamingCounter, id + 1);
				}
			}
			HashSet<String> existingNames;
			for (auto & instr : GetAllInstructions())
			{
				if (instr.Name.Length() == 0)
					instr.Name = String(L"t") + String(NamingCounter++, 16);
				else
				{
					int counter = 1;
					String newName = instr.Name;
					while (existingNames.Contains(newName))
					{
						newName = instr.Name + String(counter);
						counter++;
					}
					instr.Name = newName;
				}
				existingNames.Add(instr.Name);
			}
		}

		void CFGNode::DebugPrint()
		{
			printf("===========\n");
			for (auto& instr : *this)
			{
				printf("%s\n", instr.ToString().ToMultiByteString());
			}
			printf("===========\n");
		}

		LoadInstruction::LoadInstruction(ILOperand * dest)
		{
			Deterministic = false;
			Operand = dest;
			Type = dest->Type->Clone();
			if (!Spire::Compiler::Is<AllocVarInstruction>(dest) && !Spire::Compiler::Is<FetchArgInstruction>(dest))
				throw L"invalid address operand";
		}
		void MemberUpdateInstruction::Accept(InstructionVisitor * visitor)
		{
			visitor->VisitMemberUpdateInstruction(this);
		}
		void SubInstruction::Accept(InstructionVisitor * visitor)
		{
			visitor->VisitSubInstruction(this);
		}
		void MulInstruction::Accept(InstructionVisitor * visitor)
		{
			visitor->VisitMulInstruction(this);
		}
		void DivInstruction::Accept(InstructionVisitor * visitor)
		{
			visitor->VisitDivInstruction(this);
		}
		void ModInstruction::Accept(InstructionVisitor * visitor)
		{
			visitor->VisitModInstruction(this);
		}
		void AndInstruction::Accept(InstructionVisitor * visitor)
		{
			visitor->VisitAndInstruction(this);
		}
		void OrInstruction::Accept(InstructionVisitor * visitor)
		{
			visitor->VisitOrInstruction(this);
		}
		void BitAndInstruction::Accept(InstructionVisitor * visitor)
		{
			visitor->VisitBitAndInstruction(this);
		}
		void BitOrInstruction::Accept(InstructionVisitor * visitor)
		{
			visitor->VisitBitOrInstruction(this);
		}
		void BitXorInstruction::Accept(InstructionVisitor * visitor)
		{
			visitor->VisitBitXorInstruction(this);
		}
		void ShlInstruction::Accept(InstructionVisitor * visitor)
		{
			visitor->VisitShlInstruction(this);
		}
		void ShrInstruction::Accept(InstructionVisitor * visitor)
		{
			visitor->VisitShrInstruction(this);
		}
		void CmpgtInstruction::Accept(InstructionVisitor * visitor)
		{
			visitor->VisitCmpgtInstruction(this);
		}
		void CmpgeInstruction::Accept(InstructionVisitor * visitor)
		{
			visitor->VisitCmpgeInstruction(this);
		}
		void CmpltInstruction::Accept(InstructionVisitor * visitor)
		{
			visitor->VisitCmpltInstruction(this);
		}
		void CmpleInstruction::Accept(InstructionVisitor * visitor)
		{
			visitor->VisitCmpleInstruction(this);
		}
		void CmpeqlInstruction::Accept(InstructionVisitor * visitor)
		{
			visitor->VisitCmpeqlInstruction(this);
		}
		void CmpneqInstruction::Accept(InstructionVisitor * visitor)
		{
			visitor->VisitCmpneqInstruction(this);
		}
		void Float2IntInstruction::Accept(InstructionVisitor * visitor)
		{
			visitor->VisitFloat2IntInstruction(this);
		}
		void Int2FloatInstruction::Accept(InstructionVisitor * visitor)
		{
			visitor->VisitInt2FloatInstruction(this);
		}
		void CopyInstruction::Accept(InstructionVisitor * visitor)
		{
			visitor->VisitCopyInstruction(this);
		}
		void LoadInstruction::Accept(InstructionVisitor * visitor)
		{
			visitor->VisitLoadInstruction(this);
		}
		void StoreInstruction::Accept(InstructionVisitor * visitor)
		{
			visitor->VisitStoreInstruction(this);
		}
		void AllocVarInstruction::Accept(InstructionVisitor * visitor)
		{
			visitor->VisitAllocVarInstruction(this);
		}
		void FetchArgInstruction::Accept(InstructionVisitor * visitor)
		{
			visitor->VisitFetchArgInstruction(this);
		}
		void PhiInstruction::Accept(InstructionVisitor * visitor)
		{
			visitor->VisitPhiInstruction(this);
		}
		void SelectInstruction::Accept(InstructionVisitor * visitor)
		{
			visitor->VisitSelectInstruction(this);
		}
		void CallInstruction::Accept(InstructionVisitor * visitor)
		{
			visitor->VisitCallInstruction(this);
		}
		void SwitchInstruction::Accept(InstructionVisitor * visitor)
		{
			visitor->VisitSwitchInstruction(this);
		}
		void NotInstruction::Accept(InstructionVisitor * visitor)
		{
			visitor->VisitNotInstruction(this);
		}
		void NegInstruction::Accept(InstructionVisitor * visitor)
		{
			visitor->VisitNegInstruction(this);
		}
		void BitNotInstruction::Accept(InstructionVisitor * visitor)
		{
			visitor->VisitBitNotInstruction(this);
		}
		void AddInstruction::Accept(InstructionVisitor * visitor)
		{
			visitor->VisitAddInstruction(this);
		}
		void MemberLoadInstruction::Accept(InstructionVisitor * visitor)
		{
			visitor->VisitMemberLoadInstruction(this);
		}
		AllInstructionsIterator & AllInstructionsIterator::operator++()
		{
			if (subBlockPtr < curInstr->GetSubBlockCount())
			{
				StackItem item;
				item.instr = curInstr;
				item.subBlockPtr = subBlockPtr + 1;
				stack.Add(item);
				curInstr = curInstr->GetSubBlock(subBlockPtr)->begin().Current;
				subBlockPtr = 0;
			}
			else
				curInstr = curInstr->GetNext();
			while (curInstr->GetNext() == nullptr && stack.Count() > 0)
			{
				auto item = stack.Last();
				stack.RemoveAt(stack.Count() - 1);
				curInstr = item.instr;
				subBlockPtr = item.subBlockPtr;
				if (subBlockPtr >= curInstr->GetSubBlockCount())
				{
					subBlockPtr = 0;
					curInstr = curInstr->GetNext();
				}
			}
			return *this;
		}
		AllInstructionsIterator AllInstructionsCollection::begin()
		{
			return AllInstructionsIterator(node->begin().Current);
		}
		AllInstructionsIterator AllInstructionsCollection::end()
		{
			return AllInstructionsIterator(node->end().Current);
		}
		String ImportInstruction::ToString()
		{
			StringBuilder rs;
			rs << Name << L" = import [" << ComponentName << L"](";
			for (auto & arg : Arguments)
			{
				rs << arg->ToString() << L", ";
			}
			rs << L")";
			rs << L"\n{";
			rs << ImportOperator->ToString() << L"}\n";
			return rs.ProduceString();
		}
		String ImportInstruction::GetOperatorString()
		{
			return L"import";
		}
		void ImportInstruction::Accept(InstructionVisitor * visitor)
		{
			visitor->VisitImportInstruction(this);
		}
		void ExportInstruction::Accept(InstructionVisitor * visitor)
		{
			visitor->VisitExportInstruction(this);
		}
		ILType * ILStructType::Clone()
		{
			auto rs = new ILStructType(*this);
			rs->Members.Clear();
			for (auto & m : Members)
			{
				ILStructField f;
				f.FieldName = m.FieldName;
				f.Type = m.Type->Clone();
				rs->Members.Add(f);
			}
			return rs;
		}
		String ILStructType::ToString()
		{
			return TypeName;
		}
		bool ILStructType::Equals(ILType * type)
		{
			auto st = dynamic_cast<ILStructType*>(type);
			if (st && st->TypeName == this->TypeName)
				return true;
			return false;
		}
		void Align(int & ptr, int alignment)
		{
			if (ptr % alignment != 0)
			{
				ptr = (ptr / alignment + 1) * alignment;
			}
		}
		int ILStructType::GetSize(LayoutRule rule)
		{
			int rs = 0;
			for (auto & m : Members)
			{
				int size = m.Type->GetSize(rule);
				int alignment = m.Type->GetAlignment(rule);
				Align(rs, alignment);
				rs += size;
			}
			return rs;
		}
		int ILStructType::GetAlignment(LayoutRule rule)
		{
			int rs = 1;
			for (auto & m : Members)
			{
				int alignment = m.Type->GetAlignment(rule);
				rs = Math::Max(rs, alignment);
			}
			return rs;
		}

		ILType * ILRecordType::Clone()
		{
			auto rs = new ILRecordType(*this);
			rs->Members.Clear();
			for (auto & m : Members)
			{
				ILObjectDefinition f;
				f.Type = m.Value.Type->Clone();
				f.Name = m.Value.Name;
				f.Attributes = m.Value.Attributes;
				rs->Members.Add(m.Key, f);
			}
			return rs;
		}
		String ILRecordType::ToString()
		{
			return TypeName;
		}
		bool ILRecordType::Equals(ILType * type)
		{
			auto recType = dynamic_cast<ILRecordType*>(type);
			if (recType)
				return TypeName == recType->TypeName;
			else
				return false;
		}
		int ILRecordType::GetSize(LayoutRule /*rule*/)
		{
			return 0;
		}
		int ILRecordType::GetAlignment(LayoutRule /*rule*/)
		{
			return 0;
		}
		void DiscardInstruction::Accept(InstructionVisitor * visitor)
		{
			visitor->VisitDiscardInstruction(this);
		}
		void LoadInputInstruction::Accept(InstructionVisitor * visitor)
		{
			visitor->VisitLoadInputInstruction(this);
		}
		void SwizzleInstruction::Accept(InstructionVisitor * visitor)
		{
			visitor->VisitSwizzleInstruction(this);
		}
}
}

/***********************************************************************
SPIRECORE\INSERTIMPLICITIMPORTOPERATOR.CPP
***********************************************************************/

namespace Spire
{
	namespace Compiler
	{
		class InsertImplicitImportOperatorVisitor : public SyntaxVisitor
		{
		private:
			ShaderIR * shaderIR;
		public:
			ComponentDefinitionIR * currentCompDef = nullptr;
			EnumerableDictionary<String, RefPtr<ComponentDefinitionIR>> passThroughComponents;
		public:
			InsertImplicitImportOperatorVisitor(ShaderIR * ir, ErrorWriter* err)
				: SyntaxVisitor(err), shaderIR(ir)
			{}

			ComponentDefinitionIR * MakeComponentAvailableAtWorld(String componentUniqueName, String world)
			{
				HashSet<String> visitedComponents;
				return MakeComponentAvailableAtWorldInternal(visitedComponents, componentUniqueName, world);
			}

			ComponentDefinitionIR * MakeComponentAvailableAtWorldInternal(HashSet<String> & visitedComponents, String componentUniqueName, String world)
			{
				RefPtr<ComponentDefinitionIR> refDef;
				if (passThroughComponents.TryGetValue(EscapeDoubleUnderscore(componentUniqueName + L"_" + world), refDef))
					return refDef.Ptr();
				if (visitedComponents.Contains(componentUniqueName + "@" + world))
				{
					StringBuilder refs;
					int count = 0;
					for (auto & comp : visitedComponents)
					{
						refs << comp;
						if (count != visitedComponents.Count() - 1)
							refs << L", ";
						count++;
					}
					Error(34062, L"cyclic reference: " + refs.ProduceString(), currentCompDef->SyntaxNode.Ptr());
					return nullptr;
				}
				visitedComponents.Add(componentUniqueName);
				ImportPath importPath;
				int currentPathLength = 1 << 30;
				ComponentDefinitionIR * referencedDef = nullptr;
				for (auto & compDef : shaderIR->DefinitionsByComponent[componentUniqueName]())
				{
					if (compDef.Value->World == world)
						return compDef.Value;
				}
				for (auto & compDef : shaderIR->DefinitionsByComponent[componentUniqueName]())
				{
					auto path = shaderIR->SymbolTable->FindImplicitImportOperatorChain(shaderIR->Shader->Pipeline, compDef.Value->World, world, compDef.Value->Type);
					if (path.Count() && path.First().Nodes.Count() < currentPathLength)
					{
						importPath = path.First();
						currentPathLength = importPath.Nodes.Count();
						referencedDef = compDef.Value;
					}
				}
				if (referencedDef)
				{
					auto & node = importPath.Nodes.Last();
					RefPtr<ComponentDefinitionIR> thruDef;
					auto thruDefName = EscapeDoubleUnderscore(componentUniqueName + L"_" + node.TargetWorld);
					if (!passThroughComponents.TryGetValue(thruDefName, thruDef))
					{
						auto srcDef = MakeComponentAvailableAtWorldInternal(visitedComponents, componentUniqueName, node.ImportOperator->SourceWorld.Content);
						thruDef = new ComponentDefinitionIR();
						thruDef->World = world;
						thruDef->Dependency.Add(srcDef);
						srcDef->Users.Add(thruDef.Ptr());
						thruDef->OriginalName = referencedDef->OriginalName;
						thruDef->UniqueName = thruDefName;
						thruDef->UniqueKey = referencedDef->UniqueKey + L"@" + node.TargetWorld;
						thruDef->IsEntryPoint = false;
						thruDef->SyntaxNode = new ComponentSyntaxNode();
						thruDef->SyntaxNode->Type = thruDef->Type = srcDef->SyntaxNode->Type;
						thruDef->SyntaxNode->Rate = new RateSyntaxNode();
						thruDef->SyntaxNode->Rate->Worlds.Add(RateWorld(node.TargetWorld));
						thruDef->SyntaxNode->Name.Content = thruDefName;
						CloneContext cloneCtx;
						thruDef->SyntaxNode->TypeNode = srcDef->SyntaxNode->TypeNode->Clone(cloneCtx);
						auto importExpr = new ImportExpressionSyntaxNode();
						importExpr->Type = thruDef->Type;
						importExpr->ImportOperatorDef = node.ImportOperator->Clone(cloneCtx);
						importExpr->ImportOperatorDef->Scope->Parent = thruDef->SyntaxNode->Scope.Ptr();
						importExpr->ComponentUniqueName = srcDef->UniqueName;
						for (auto & arg : importExpr->Arguments)
							arg->Accept(this);
						importExpr->ImportOperatorDef->Body->Accept(this);
						thruDef->SyntaxNode->Expression = importExpr;
						passThroughComponents[thruDefName] = thruDef;
					}
					visitedComponents.Remove(componentUniqueName + "@" + world);
					return thruDef.Ptr();
				}
				else
				{
					throw InvalidProgramException(L"import operator not found, should have been checked in semantics pass.");
				}
			}

			RefPtr<ExpressionSyntaxNode> ProcessComponentReference(String componentUniqueName)
			{
				auto refDef = MakeComponentAvailableAtWorld(componentUniqueName, currentCompDef->World);
				auto refNode = new VarExpressionSyntaxNode();
				if (refDef)
				{
					refNode->Variable = refDef->UniqueName;
					refNode->Type = refDef->Type;
					refNode->Tags[L"ComponentReference"] = new StringObject(refDef->UniqueName);
					currentCompDef->Dependency.Add(refDef);
					refDef->Users.Add(currentCompDef);
				}
				return refNode;
			}
			RefPtr<ExpressionSyntaxNode> VisitVarExpression(VarExpressionSyntaxNode * var) override
			{
				RefPtr<Object> refCompObj;
				if (var->Tags.TryGetValue(L"ComponentReference", refCompObj))
				{
					auto refComp = refCompObj.As<StringObject>().Ptr();
					return ProcessComponentReference(refComp->Content);
				}
				return var;
			}

			RefPtr<ExpressionSyntaxNode> VisitMemberExpression(MemberExpressionSyntaxNode * member) override
			{
				RefPtr<Object> refCompObj;
				if (member->Tags.TryGetValue(L"ComponentReference", refCompObj))
				{
					auto refComp = refCompObj.As<StringObject>().Ptr();
					return ProcessComponentReference(refComp->Content);
				}
				else
					member->BaseExpression = member->BaseExpression->Accept(this).As<ExpressionSyntaxNode>();
				return member;
			}
			RefPtr<ExpressionSyntaxNode> VisitImportExpression(ImportExpressionSyntaxNode * import) override
			{
				auto refDef = MakeComponentAvailableAtWorld(import->ComponentUniqueName, import->ImportOperatorDef->SourceWorld.Content);
				if (refDef)
					import->ComponentUniqueName = refDef->UniqueName;
				return import;
			}
		};
		void InsertImplicitImportOperators(ShaderIR * shader)
		{
			InsertImplicitImportOperatorVisitor visitor(shader, nullptr);
			for (auto & comp : shader->Definitions)
			{
				for (auto & dep : comp->Dependency)
					dep->Users.Remove(comp.Ptr());
				comp->ClearDependency();
			}
			for (auto & comp : shader->Definitions)
			{
				visitor.currentCompDef = comp.Ptr();
				comp->SyntaxNode->Accept(&visitor);
			}
			for (auto & comp : visitor.passThroughComponents)
			{
				shader->Definitions.Add(comp.Value);
				EnumerableDictionary<String, ComponentDefinitionIR*> defs;
				defs[comp.Value->World] = comp.Value.Ptr();
				shader->DefinitionsByComponent[comp.Key] = defs;
			}
		}
	}
}

/***********************************************************************
SPIRECORE\KEYHOLEMATCHING.CPP
***********************************************************************/

namespace Spire
{
	namespace Compiler
	{
		RefPtr<KeyHoleNode> ParseInternal(CoreLib::Text::Parser & parser)
		{
			RefPtr<KeyHoleNode> result = new KeyHoleNode();
			result->NodeType = parser.ReadWord();
			if (parser.LookAhead(L"<"))
			{
				parser.ReadToken();
				result->CaptureId = parser.ReadInt();
				parser.ReadToken();
			}
			if (parser.LookAhead(L"("))
			{
				while (!parser.LookAhead(L")"))
				{
					result->Children.Add(ParseInternal(parser));
					if (parser.LookAhead(L","))
						parser.ReadToken();
					else
					{
						break;
					}
				}
				parser.Read(L")");
			}
			return result;
		}

		RefPtr<KeyHoleNode> KeyHoleNode::Parse(String format)
		{
			CoreLib::Text::Parser parser(format);
			return ParseInternal(parser);
		}

		bool KeyHoleNode::Match(List<ILOperand*> & matchResult, ILOperand * instr)
		{
			bool matches = false;
			if (NodeType == L"store")
				matches = dynamic_cast<StoreInstruction*>(instr) != nullptr;
			else if (NodeType == L"op")
				matches = true;
			else if (NodeType == L"load")
				matches = dynamic_cast<LoadInstruction*>(instr) != nullptr;
			else if (NodeType == L"add")
				matches = dynamic_cast<AddInstruction*>(instr) != nullptr;
			else if (NodeType == L"mul")
				matches = dynamic_cast<MulInstruction*>(instr) != nullptr;
			else if (NodeType == L"sub")
				matches = dynamic_cast<SubInstruction*>(instr) != nullptr;
			else if (NodeType == L"call")
				matches = dynamic_cast<CallInstruction*>(instr) != nullptr;
			else if (NodeType == L"switch")
				matches = dynamic_cast<SwitchInstruction*>(instr) != nullptr;
			if (matches)
			{
				if (Children.Count() > 0)
				{
					ILInstruction * cinstr = dynamic_cast<ILInstruction*>(instr);
					if (cinstr != nullptr)
					{
						int opId = 0;
						for (auto & op : *cinstr)
						{
							if (opId >= Children.Count())
							{
								matches = false;
								break;
							}
							matches = matches && Children[opId]->Match(matchResult, &op);
							opId++;
						}
						if (opId != Children.Count())
							matches = false;
					}
					else
						matches = false;
				}
			}
			if (matches && CaptureId != -1)
			{
				matchResult.SetSize(Math::Max(matchResult.Count(), CaptureId + 1));
				matchResult[CaptureId] = instr;
			}
			return matches;
		}
	}
}

/***********************************************************************
SPIRECORE\LEXER.CPP
***********************************************************************/

namespace Spire
{
	namespace Compiler
	{
		enum class State
		{
			Start, Identifier, Operator, Int, Fixed, Double, Char, String, MultiComment, SingleComment
		};

		bool IsLetter(wchar_t ch)
		{
			return ((ch >= L'a' && ch <= L'z') ||
				(ch >= L'A' && ch <= L'Z') || ch == L'_' || ch == L'#');
		}

		bool IsDigit(wchar_t ch)
		{
			return ch >= L'0' && ch <= L'9';
		}

		bool IsPunctuation(wchar_t ch)
		{
			return  ch == L'+' || ch == L'-' || ch == L'*' || ch == L'/' || ch == L'%' ||
					ch == L'!' || ch == L'^' || ch == L'&' || ch == L'(' || ch == L')' ||
					ch == L'=' || ch == L'{' || ch == L'}' || ch == L'[' || ch == L']' ||
					ch == L'|' || ch == L';' || ch == L',' || ch == L'.' || ch == L'<' ||
					ch == L'>' || ch == L'~' || ch == L'@' || ch == L':' || ch == L'?';
		}

		TokenType GetKeywordTokenType(const String & str)
		{
			if (str == L"return")
				return TokenType::KeywordReturn;
			else if (str == L"break")
				return TokenType::KeywordBreak;
			else if (str == L"continue")
				return TokenType::KeywordContinue;
			else if (str == L"if")
				return TokenType::KeywordIf;
			else if (str == L"else")
				return TokenType::KeywordElse;
			else if (str == L"for")
				return TokenType::KeywordFor;
			else if (str == L"while")
				return TokenType::KeywordWhile;
			else if (str == L"do")
				return TokenType::KeywordDo;
			else
				return TokenType::Identifier;
		}

		void ParseOperators(const String & str, List<Token> & tokens, int line, int col, String fileName)
		{
			int pos = 0;
			while (pos < str.Length())
			{
				wchar_t curChar = str[pos];
				wchar_t nextChar = (pos < str.Length()-1)? str[pos + 1] : L'\0';
				wchar_t nextNextChar = (pos < str.Length() - 2) ? str[pos + 2] : L'\0';
				auto InsertToken = [&](TokenType type, const String & ct)
				{
					tokens.Add(Token(type, ct, line, col + pos, fileName));
				};
				switch(curChar)
				{
				case L'+':
					if (nextChar == L'+')
					{
						InsertToken(TokenType::OpInc, L"++");
						pos += 2;
					}
					else if (nextChar == L'=')
					{
						InsertToken(TokenType::OpAddAssign, L"+=");
						pos += 2;
					}
					else
					{
						InsertToken(TokenType::OpAdd, L"+");
						pos++;
					}
					break;
				case L'-':
					if (nextChar == L'-')
					{
						InsertToken(TokenType::OpDec, L"--");
						pos += 2;
					}
					else if (nextChar == L'=')
					{
						InsertToken(TokenType::OpSubAssign, L"-=");
						pos += 2;
					}
					else if (nextChar == L'>')
					{
						InsertToken(TokenType::RightArrow, L"->");
						pos += 2;
					}
					else
					{
						InsertToken(TokenType::OpSub, L"-");
						pos++;
					}
					break;
				case L'*':
					if (nextChar == L'=')
					{
						InsertToken(TokenType::OpMulAssign, L"*=");
						pos += 2;
					}
					else
					{
						InsertToken(TokenType::OpMul, L"*");
						pos++;
					}
					break;
				case L'/':
					if (nextChar == L'=')
					{
						InsertToken(TokenType::OpDivAssign, L"/=");
						pos += 2;
					}
					else
					{
						InsertToken(TokenType::OpDiv, L"/");
						pos++;
					}
					break;
				case L'%':
					if (nextChar == L'=')
					{
						InsertToken(TokenType::OpModAssign, L"%=");
						pos += 2;
					}
					else
					{
						InsertToken(TokenType::OpMod, L"%");
						pos++;
					}
					break;
				case L'|':
					if (nextChar == L'|')
					{
						InsertToken(TokenType::OpOr, L"||");
						pos += 2;
					}
					else if (nextChar == L'=')
					{
						InsertToken(TokenType::OpOrAssign, L"|=");
						pos += 2;
					}
					else
					{
						InsertToken(TokenType::OpBitOr, L"|");
						pos++;
					}
					break;
				case L'&':
					if (nextChar == L'&')
					{
						InsertToken(TokenType::OpAnd, L"&&");
						pos += 2;
					}
					else if (nextChar == L'=')
					{
						InsertToken(TokenType::OpAndAssign, L"&=");
						pos += 2;
					}
					else
					{
						InsertToken(TokenType::OpBitAnd, L"&");
						pos++;
					}
					break;
				case L'^':
					if (nextChar == L'=')
					{
						InsertToken(TokenType::OpXorAssign, L"^=");
						pos += 2;
					}
					else
					{
						InsertToken(TokenType::OpBitXor, L"^");
						pos++;
					}
					break;
				case L'>':
					if (nextChar == L'>')
					{
						if (nextNextChar == L'=')
						{
							InsertToken(TokenType::OpShrAssign, L">>=");
							pos += 3;
						}
						else
						{
							InsertToken(TokenType::OpRsh, L">>");
							pos += 2;
						}
					}
					else if (nextChar == L'=')
					{
						InsertToken(TokenType::OpGeq, L">=");
						pos += 2;
					}
					else
					{
						InsertToken(TokenType::OpGreater, L">");
						pos++;
					}
					break;
				case L'<':
					if (nextChar == L'<')
					{
						if (nextNextChar == L'=')
						{
							InsertToken(TokenType::OpShlAssign, L"<<=");
							pos += 3;
						}
						else
						{
							InsertToken(TokenType::OpLsh, L"<<");
							pos += 2;
						}
					}
					else if (nextChar == L'=')
					{
						InsertToken(TokenType::OpLeq, L"<=");
						pos += 2;
					}
					else
					{
						InsertToken(TokenType::OpLess, L"<");
						pos++;
					}
					break;
				case L'=':
					if (nextChar == L'=')
					{
						InsertToken(TokenType::OpEql, L"==");
						pos += 2;
					}
					else
					{
						InsertToken(TokenType::OpAssign, L"=");
						pos++;
					}
					break;
				case L'!':
					if (nextChar == L'=')
					{
						InsertToken(TokenType::OpNeq, L"!=");
						pos += 2;
					}
					else
					{
						InsertToken(TokenType::OpNot, L"!");
						pos++;
					}
					break;
				case L'?':
					InsertToken(TokenType::QuestionMark, L"?");
					pos++;
					break;
				case L'@':
					InsertToken(TokenType::At, L"@");
					pos++;
					break;
				case L':':
					InsertToken(TokenType::Colon, L":");
					pos++;
					break;
				case L'~':
					InsertToken(TokenType::OpBitNot, L"~");
					pos++;
					break;
				case L';':
					InsertToken(TokenType::Semicolon, L";");
					pos++;
					break;
				case L',':
					InsertToken(TokenType::Comma, L","); 
					pos++;
					break;
				case L'.':
					InsertToken(TokenType::Dot, L".");
					pos++;
					break;
				case L'{':
					InsertToken(TokenType::LBrace, L"{"); 
					pos++;
					break;
				case L'}':
					InsertToken(TokenType::RBrace, L"}"); 
					pos++;
					break;
				case L'[':
					InsertToken(TokenType::LBracket, L"["); 
					pos++;
					break;
				case L']':
					InsertToken(TokenType::RBracket, L"]"); 
					pos++;
					break;
				case L'(':
					InsertToken(TokenType::LParent, L"("); 
					pos++;
					break;
				case L')':
					InsertToken(TokenType::RParent, L")"); 
					pos++;
					break;
				}
			}
		}

		enum class LexDerivative
		{
			None, Line, File
		};

		List<Token> Lexer::Parse(const String & fileName, const String & str, List<CompileError> & errorList)
		{
			int lastPos = 0, pos = 0;
			int line = 1, col = 0;
			String file = fileName;
			State state = State::Start;
			StringBuilder tokenBuilder;
			int tokenLine, tokenCol;
			List<Token> tokenList;
			LexDerivative derivative = LexDerivative::None;
			auto InsertToken = [&](TokenType type)
			{
				derivative = LexDerivative::None;
				tokenList.Add(Token(type, tokenBuilder.ToString(), tokenLine, tokenCol, file));
				tokenBuilder.Clear();
			};
			auto ProcessTransferChar = [&](wchar_t nextChar)
			{
				switch(nextChar)
				{
				case L'\\':
				case L'\"':
				case L'\'':
					tokenBuilder.Append(nextChar);
					break;
				case L't':
					tokenBuilder.Append('\t');
					break;
				case L's':
					tokenBuilder.Append(' ');
					break;
				case L'n':
					tokenBuilder.Append('\n');
					break;
				case L'r':
					tokenBuilder.Append('\r');
					break;
				case L'b':
					tokenBuilder.Append('\b');
					break;
				}
			};
			while (pos <= str.Length())
			{
				wchar_t curChar = (pos < str.Length()?str[pos]:L' ');
				wchar_t nextChar = (pos < str.Length()-1)? str[pos + 1] : L'\0';
				if (lastPos != pos)
				{
					if (curChar == L'\n')
					{
						line++;
						col = 0;
					}
					else
						col++;
					lastPos = pos;
				}

				switch (state)
				{
				case State::Start:
					if (IsLetter(curChar))
					{
						state = State::Identifier;
						tokenLine = line;
						tokenCol = col;
					}
					else if (IsDigit(curChar))
					{
						state = State::Int;
						tokenLine = line;
						tokenCol = col;
					}
					else if (curChar == L'\'')
					{
						state = State::Char;
						pos++;
						tokenLine = line;
						tokenCol = col;
					}
					else if (curChar == L'"')
					{
						state = State::String;
						pos++;
						tokenLine = line;
						tokenCol = col;
					}
					else if (curChar == L' ' || curChar == L'\t' || curChar == L'\r' || curChar == L'\n' || curChar == 160) // 160:non-break space
						pos++;
					else if (curChar == L'/' && nextChar == L'/')
					{
						state = State::SingleComment;
						pos += 2;
					}
					else if (curChar == L'/' && nextChar == L'*')
					{
						pos += 2;
						state = State::MultiComment;
					}
					else if (IsPunctuation(curChar))
					{
						state = State::Operator;
						tokenLine = line;
						tokenCol = col;
					}
					else
					{
						errorList.Add(CompileError(L"Illegal character '" + String(curChar) + L"'", 10000, CodePosition(line, col, file)));
						pos++;
					}
					break;
				case State::Identifier:
					if (IsLetter(curChar) || IsDigit(curChar))
					{
						tokenBuilder.Append(curChar);
						pos++;
					}
					else
					{
						auto tokenStr = tokenBuilder.ToString();
						if (tokenStr == L"#line_reset#")
						{
							line = 0;
							col = 0;
							tokenBuilder.Clear();
						}
						else if (tokenStr == L"#line")
						{
							derivative = LexDerivative::Line;
							tokenBuilder.Clear();
						}
						else if (tokenStr == L"#file")
						{
							derivative = LexDerivative::File;
							tokenBuilder.Clear();
							line = 0;
							col = 0;
						}
						else
							InsertToken(GetKeywordTokenType(tokenStr));
						state = State::Start;
					}
					break;
				case State::Operator:
					if (IsPunctuation(curChar) && !((curChar == L'/' && nextChar == L'/') || (curChar == L'/' && nextChar == L'*')))
					{
						tokenBuilder.Append(curChar);
						pos++;
					}
					else
					{
						//do token analyze
						ParseOperators(tokenBuilder.ToString(), tokenList, tokenLine, tokenCol, file);
						tokenBuilder.Clear();
						state = State::Start;
					}
					break;
				case State::Int:
					if (IsDigit(curChar))
					{
						tokenBuilder.Append(curChar);
						pos++;
					}
					else if (curChar == L'.')
					{
						state = State::Fixed;
						tokenBuilder.Append(curChar);
						pos++;
					}
					else if (curChar == L'e' || curChar == L'E')
					{
						state = State::Double;
						tokenBuilder.Append(curChar);
						if (nextChar == L'-' || nextChar == L'+')
						{
							tokenBuilder.Append(nextChar);
							pos++;
						}
						pos++;
					}
					else
					{
						if (derivative == LexDerivative::Line)
						{
							derivative = LexDerivative::None;
							line = StringToInt(tokenBuilder.ToString()) - 1;
							col = 0;
							tokenBuilder.Clear();
						}
						else
						{
							InsertToken(TokenType::IntLiterial);
						}
						state = State::Start;
					}
					break;
				case State::Fixed:
					if (IsDigit(curChar))
					{
						tokenBuilder.Append(curChar);
						pos++;
					}
					else if (curChar == L'e' || curChar == L'E')
					{
						state = State::Double;
						tokenBuilder.Append(curChar);
						if (nextChar == L'-' || nextChar == L'+')
						{
							tokenBuilder.Append(nextChar);
							pos++;
						}
						pos++;
					}
					else
					{
						if (curChar == L'f')
							pos++;
						InsertToken(TokenType::DoubleLiterial);
						state = State::Start;
					}
					break;
				case State::Double:
					if (IsDigit(curChar))
					{
						tokenBuilder.Append(curChar);
						pos++;
					}
					else
					{
						if (curChar == L'f')
							pos++;
						InsertToken(TokenType::DoubleLiterial);
						state = State::Start;
					}
					break;
				case State::String:
					if (curChar != L'"')
					{
						if (curChar == L'\\')
						{
							ProcessTransferChar(nextChar);
							pos++;
						}
						else
							tokenBuilder.Append(curChar);
					}
					else
					{
						if (derivative == LexDerivative::File)
						{
							derivative = LexDerivative::None;
							file = tokenBuilder.ToString();
							tokenBuilder.Clear();
						}
						else
						{
							InsertToken(TokenType::StringLiterial);
						}
						state = State::Start;
					}
					pos++;
					break;
				case State::Char:
					if (curChar != L'\'')
					{
						if (curChar == L'\\')
						{
							ProcessTransferChar(nextChar);
							pos++;
						}
						else
							tokenBuilder.Append(curChar);
					}
					else
					{
						if (tokenBuilder.Length() > 1)
							errorList.Add(CompileError(L"Illegal character literial.", 10001, CodePosition(line, col-tokenBuilder.Length(), file)));
						InsertToken(TokenType::CharLiterial);
						state = State::Start;
					}
					pos++;
					break;
				case State::SingleComment:
					if (curChar == L'\n')
						state = State::Start;
					pos++;
					break;
				case State::MultiComment:
					if (curChar == L'*' && nextChar == '/')
					{
						state = State::Start;
						pos += 2;
					}
					else
						pos++;
					break;
				}
			}
			return tokenList;
		}

		String TokenTypeToString(TokenType type)
		{
			switch (type)
			{
			case TokenType::Unkown:
				return L"UnknownToken";
			case TokenType::Identifier:
				return L"Identifier";

			case TokenType::KeywordReturn:
				return L"\"return\"";
			case TokenType::KeywordBreak:
				return L"\"break\"";
			case TokenType::KeywordContinue:
				return L"\"continue\"";
			case TokenType::KeywordIf:
				return L"\"if\"";
			case TokenType::KeywordElse:
				return L"\"else\"";
			case TokenType::KeywordFor:
				return L"\"for\"";
			case TokenType::KeywordWhile:
				return L"\"while\"";
			case TokenType::KeywordDo:
				return L"\"do\"";
			case TokenType::IntLiterial:
				return L"Int Literial";
			case TokenType::DoubleLiterial:
				return L"Double Literial";
			case TokenType::StringLiterial:
				return L"String Literial";
			case TokenType::CharLiterial:
				return L"CharLiterial";
			case TokenType::QuestionMark:
				return L"'?'";
			case TokenType::Colon:
				return L"':'";
			case TokenType::Semicolon:
				return L"';'";
			case TokenType::Comma:
				return L"','";
			case TokenType::LBrace:
				return L"'{'";
			case TokenType::RBrace:
				return L"'}'";
			case TokenType::LBracket:
				return L"'['";
			case TokenType::RBracket:
				return L"']'";
			case TokenType::LParent:
				return L"'('";
			case TokenType::RParent:
				return L"')'";
			case TokenType::At:
				return L"'@'";
			case TokenType::OpAssign:
				return L"'='";
			case TokenType::OpAdd:
				return L"'+'";
			case TokenType::OpSub:
				return L"'-'";
			case TokenType::OpMul:
				return L"'*'";
			case TokenType::OpDiv:
				return L"'/'";
			case TokenType::OpMod:
				return L"'%'";
			case TokenType::OpNot:
				return L"'!'";
			case TokenType::OpLsh:
				return L"'<<'";
			case TokenType::OpRsh:
				return L"'>>'";
			case TokenType::OpAddAssign:
				return L"'+='";
			case TokenType::OpSubAssign:
				return L"'-='";
			case TokenType::OpMulAssign:
				return L"'*='";
			case TokenType::OpDivAssign:
				return L"'/='";
			case TokenType::OpModAssign:
				return L"'%='";
			case TokenType::OpEql:
				return L"'=='";
			case TokenType::OpNeq:
				return L"'!='";
			case TokenType::OpGreater:
				return L"'>'";
			case TokenType::OpLess:
				return L"'<'";
			case TokenType::OpGeq:
				return L"'>='";
			case TokenType::OpLeq:
				return L"'<='";
			case TokenType::OpAnd:
				return L"'&&'";
			case TokenType::OpOr:
				return L"'||'";
			case TokenType::OpBitXor:
				return L"'^'";
			case TokenType::OpBitAnd:
				return L"'&'";
			case TokenType::OpBitOr:
				return L"'|'";
			case TokenType::OpInc:
				return L"'++'";
			case TokenType::OpDec:
				return L"'--'";
			default:
				return L"";
			}
		}
		
	}
}

/***********************************************************************
SPIRECORE\NAMING.CPP
***********************************************************************/

namespace Spire
{
	namespace Compiler
	{
		using namespace CoreLib;

		String EscapeDoubleUnderscore(String str)
		{
			StringBuilder sb;
			bool isUnderScore = false;
			for (auto ch : str)
			{
				if (ch == L'_')
				{
					if (isUnderScore)
						sb << L"I_";
					else
						sb << L"_";
					isUnderScore = true;
				}
				else
				{
					isUnderScore = false;
					sb << ch;
				}
			}
			if (isUnderScore)
				sb << L"I";
			return sb.ProduceString();
		}

	}
}

/***********************************************************************
SPIRECORE\NEWSPIRVCODEGEN.CPP
***********************************************************************/
#include <vector>
#include <fstream>

using namespace CoreLib::Basic;

namespace Spire
{
	namespace Compiler
	{
		void PrintILShader(ILShader * shader)
		{
			printf("%S\n", shader->Name.Buffer());
			printf("%S\n", shader->Position.ToString().Buffer());
			printf("\n---\n\n");

			for (auto& stage : shader->Stages)
			{
				printf("Stage: %S\n", stage.Key.Buffer());
				auto& stageIL = stage.Value;

				int maxAttrNameLength = 0;
				int maxAttrValueLength = 0;
				for (auto& attr : stageIL->Attributes)
				{
					if (attr.Value.Name.Length() > maxAttrNameLength)
						maxAttrNameLength = attr.Value.Name.Length();

					if (attr.Value.Value.Length() > maxAttrValueLength)
						maxAttrValueLength = attr.Value.Value.Length();
				}

				for (auto& attr : stageIL->Attributes)
				{
					printf("\t%-*S = %-*S (%S)\n",
						maxAttrNameLength, attr.Value.Name.Buffer(),
						maxAttrValueLength, attr.Value.Value.Buffer(),
						attr.Value.Position.ToString().Buffer());
				}

				printf("\n");
			}

			printf("\n---\n\n");

			for (auto& world : shader->Worlds)
			{
				printf("World: %S\n", world.Key.Buffer());
				//auto& worldIL = world.Value;
			}
		}

		class SpirVCodeGen : public CodeGenBackend
		{
		public:
			virtual CompiledShaderSource GenerateShader(CompileResult & /*result*/, SymbolTable * /*symbols*/, ILShader * shader, ErrorWriter * /*err*/) override
			{
				PrintILShader(shader);
				system("pause");
				return CompiledShaderSource();
			}
		};

		CodeGenBackend * CreateSpirVCodeGen()
		{
			return new SpirVCodeGen();
		}
	}
}

/***********************************************************************
SPIRECORE\PARSER.CPP
***********************************************************************/

namespace Spire
{
	namespace Compiler
	{
		Token & Parser::ReadToken(const wchar_t * string)
		{
			if (pos >= tokens.Count())
			{
				errors.Add(CompileError(String(L"\"") + string + String(L"\" expected but end of file encountered."), 20001, CodePosition(0, 0, fileName)));
				throw 0;
			}
			else if (tokens[pos].Content != string)
			{
				errors.Add(CompileError(String(L"\"") + string + String(L"\" expected"), 20001, tokens[pos].Position));
				throw 20001;
			}
			return tokens[pos++];
		}

		Token & Parser::ReadToken()
		{
			if (pos >= tokens.Count())
			{
				errors.Add(CompileError(String(L" Unexpected end of file."), 20001, CodePosition(0, 0, fileName)));
				throw 0;
			}
			return tokens[pos++];
		}

		Token & Parser::ReadToken(TokenType type)
		{
			if (pos >= tokens.Count())
			{
				errors.Add(CompileError(TokenTypeToString(type) + String(L" expected but end of file encountered."), 20001, CodePosition(0, 0, fileName)));
				throw 0;
			}
			else if(tokens[pos].Type != type)
			{
				errors.Add(CompileError(TokenTypeToString(type) + String(L" expected"), 20001, tokens[pos].Position));
				throw 20001;
			}
			return tokens[pos++];
		}

		bool Parser::LookAheadToken(const wchar_t * string, int offset)
		{
			if (pos + offset >= tokens.Count())
			{
				errors.Add(CompileError(String(L"\'") + string + String(L"\' expected but end of file encountered."), 20001, CodePosition(0, 0, fileName)));
				return false;
			}
			else
			{
				if (tokens[pos + offset].Content == string)
					return true;
				else
					return false;
			}
		}

		bool Parser::LookAheadToken(TokenType type, int offset)
		{
			if (pos + offset >= tokens.Count())
			{
				errors.Add(CompileError(TokenTypeToString(type) + String(L" expected but end of file encountered."), 20001, CodePosition(0, 0, fileName)));
				return false;
			}
			else
			{
				if(tokens[pos + offset].Type == type)
					return true;
				else
					return false;
			}
		}

		Token & Parser::ReadTypeKeyword()
		{
			if (pos >= tokens.Count())
			{
				errors.Add(CompileError(String(L"type name expected but end of file encountered."), 20001, CodePosition(0, 0, fileName)));
				throw 0;
			}
			if(!IsTypeKeyword())
			{
				errors.Add(CompileError(String(L"type name expected but '" + tokens[pos].Content + L"' encountered."), 20001, tokens[pos].Position));
				throw 20001;
			}
			return tokens[pos++];
		}

		bool Parser::IsTypeKeyword()
		{
			if (pos >= tokens.Count())
			{
				errors.Add(CompileError(String(L"Unexpected end of file."), 20001, tokens[pos].Position));
				throw 0;
			}

			return typeNames.Contains(tokens[pos].Content);
		}

		RefPtr<ProgramSyntaxNode> Parser::Parse()
		{
			return ParseProgram();
		}

		EnumerableDictionary<String, String> Parser::ParseAttribute()
		{
			EnumerableDictionary<String, String> rs;
			while (LookAheadToken(TokenType::LBracket))
			{
				ReadToken(TokenType::LBracket);
				auto name = ReadToken(TokenType::Identifier).Content;
				String value;
				if (LookAheadToken(L":"))
				{
					ReadToken(L":");
					value = ReadToken(TokenType::StringLiterial).Content;
				}
				rs[name] = value;
				ReadToken(TokenType::RBracket);
			}
			return rs;
		}

		RefPtr<ProgramSyntaxNode> Parser::ParseProgram()
		{
			scopeStack.Add(new Scope());
			RefPtr<ProgramSyntaxNode> program = new ProgramSyntaxNode();
			program->Position = CodePosition(0, 0, fileName);
			program->Scope = scopeStack.Last();
			try
			{
				int lastPosBeforeError = 0;
				while (pos < tokens.Count())
				{
					try
					{
						if (LookAheadToken(L"shader") || LookAheadToken(L"module"))
							program->Shaders.Add(ParseShader());
						else if (LookAheadToken(L"pipeline"))
							program->Pipelines.Add(ParsePipeline());
						else if (LookAheadToken(L"struct"))
							program->Structs.Add(ParseStruct());
						else if (LookAheadToken(L"using"))
						{
							ReadToken(L"using");
							program->Usings.Add(ReadToken(TokenType::StringLiterial));
							ReadToken(TokenType::Semicolon);
						}
						else if (IsTypeKeyword() || LookAheadToken(L"inline") || LookAheadToken(L"extern")
							|| LookAheadToken(L"__intrinsic") || LookAheadToken(TokenType::Identifier))
							program->Functions.Add(ParseFunction());
						else if (LookAheadToken(TokenType::Semicolon))
							ReadToken(TokenType::Semicolon);
						else
						{
							if (lastPosBeforeError == 0 && pos < tokens.Count())
								errors.Add(CompileError(L"unexpected token \'" + tokens[pos].Content + L"\'.", 20003, tokens[pos].Position));
							throw 0;
						}
					}
					catch (int)
					{
						if (pos == lastPosBeforeError)
							pos++;
						lastPosBeforeError = pos;
					}
				}
			}
			catch(int)
			{}
			scopeStack.Clear();
			return program;
		}

		RefPtr<ShaderSyntaxNode> Parser::ParseShader()
		{
			RefPtr<ShaderSyntaxNode> shader = new ShaderSyntaxNode();
			if (LookAheadToken(L"module"))
			{
				shader->IsModule = true;
				ReadToken(L"module");
			}
			else
				ReadToken(L"shader");
			PushScope();
			FillPosition(shader.Ptr());
			shader->Name = ReadToken(TokenType::Identifier);
			try
			{
				if (LookAheadToken(L":"))
				{
					ReadToken(L":");
					shader->Pipeline = ReadToken(TokenType::Identifier);
				}
			}
			catch (int)
			{
			}
			
			ReadToken(TokenType::LBrace);
			int lastErrorPos = 0;
			while (!LookAheadToken(TokenType::RBrace))
			{
				try
				{
					if (LookAheadToken(L"inline") || (LookAheadToken(L"public") && !LookAheadToken(L"using", 1)) ||
						LookAheadToken(L"out") || LookAheadToken(L"@") || IsTypeKeyword()
						|| LookAheadToken(L"[") || LookAheadToken(L"require") || LookAheadToken(L"extern"))
					{
						auto comp = ParseComponent();
						comp->ParentModuleName = shader->Name;
						shader->Members.Add(comp);
					}
					else if (LookAheadToken(L"using") || (LookAheadToken(L"public") && LookAheadToken(L"using", 1)))
					{
						auto imp = ParseImport();
						imp->ParentModuleName = shader->Name;
						shader->Members.Add(imp);
					}
					else
					{
						if (lastErrorPos == 0 && pos < tokens.Count())
							errors.Add(CompileError(L"unexpected token \'" + tokens[pos].Content + L"\', only component definitions are allowed in a shader scope.", 
								20004, tokens[pos].Position));
						throw 0;
					}
				}
				catch (int)
				{
					if (pos == lastErrorPos)
						pos++;
					lastErrorPos = pos;
				}
			}
			ReadToken(TokenType::RBrace);
			
			PopScope();
			return shader;
		}

		RefPtr<PipelineSyntaxNode> Parser::ParsePipeline()
		{
			RefPtr<PipelineSyntaxNode> pipeline = new PipelineSyntaxNode();
			ReadToken(L"pipeline");
			PushScope();
			FillPosition(pipeline.Ptr());
			pipeline->Name = ReadToken(TokenType::Identifier);
			if (LookAheadToken(TokenType::Colon))
			{
				ReadToken(TokenType::Colon);
				pipeline->ParentPipeline = ReadToken(TokenType::Identifier);
			}
			ReadToken(TokenType::LBrace);
			while (!LookAheadToken(TokenType::RBrace))
			{
				auto attribs = ParseAttribute();
				if (LookAheadToken(L"input") || LookAheadToken(L"world"))
				{
					auto w = ParseWorld();
					w->LayoutAttributes = attribs;
					pipeline->Worlds.Add(w);
				}
				else if (LookAheadToken(L"import"))
				{
					auto op = ParseImportOperator();
					op->LayoutAttributes = attribs;
					pipeline->ImportOperators.Add(op);
				}
				else if (LookAheadToken(L"stage"))
				{
					pipeline->Stages.Add(ParseStage());
				}
				else
				{
					auto comp = ParseComponent();
					comp->LayoutAttributes = attribs;
					pipeline->AbstractComponents.Add(comp);
				}
			}
			ReadToken(TokenType::RBrace);
			PopScope();
			return pipeline;
		}

		RefPtr<StageSyntaxNode> Parser::ParseStage()
		{
			RefPtr<StageSyntaxNode> stage = new StageSyntaxNode();
			ReadToken(L"stage");
			stage->Name = ReadToken(TokenType::Identifier);
			FillPosition(stage.Ptr());
			ReadToken(TokenType::Colon);
			stage->StageType = ReadToken(TokenType::Identifier);
			ReadToken(TokenType::LBrace);
			while (!LookAheadToken(TokenType::RBrace))
			{
				auto attribName = ReadToken(TokenType::Identifier);
				ReadToken(TokenType::Colon);
				Token attribValue;
				if (LookAheadToken(TokenType::StringLiterial) || LookAheadToken(TokenType::DoubleLiterial) || LookAheadToken(TokenType::IntLiterial))
					attribValue = ReadToken();
				else
					attribValue = ReadToken(TokenType::Identifier);
				stage->Attributes[attribName.Content] = attribValue;
				ReadToken(TokenType::Semicolon);
			}
			ReadToken(TokenType::RBrace);
			return stage;
		}

		RefPtr<ComponentSyntaxNode> Parser::ParseComponent()
		{
			RefPtr<ComponentSyntaxNode> component = new ComponentSyntaxNode();
			PushScope();
			component->LayoutAttributes = ParseAttribute();
			while (LookAheadToken(L"inline") || LookAheadToken(L"out") || LookAheadToken(L"require") || LookAheadToken(L"public") ||
				LookAheadToken(L"extern"))
			{
				if (LookAheadToken(L"inline"))
				{
					component->IsInline = true;
					ReadToken(L"inline");
				}
				else if (LookAheadToken(L"out"))
				{
					component->IsOutput = true;
					ReadToken(L"out");
				}
				else if (LookAheadToken(L"public"))
				{
					component->IsPublic = true;
					ReadToken(L"public");
				}
				else if (LookAheadToken(L"require"))
				{
					component->IsParam = true;
					ReadToken(L"require");
				}
				else if (LookAheadToken(L"extern"))
				{
					component->IsInput = true;
					ReadToken(L"extern");
				}
				else
					break;
			}
			if (LookAheadToken(L"@"))
				component->Rate = ParseRate();
			component->TypeNode = ParseType();
			FillPosition(component.Ptr());
			component->Name = ReadToken(TokenType::Identifier);
			if (LookAheadToken(L":"))
			{
				ReadToken(L":");
				component->AlternateName = ReadToken(TokenType::Identifier);
			}
			if (LookAheadToken(TokenType::LParent))
			{
				ReadToken(TokenType::LParent);
				while (!LookAheadToken(TokenType::RParent))
				{
					component->Parameters.Add(ParseParameter());
					if (LookAheadToken(TokenType::Comma))
						ReadToken(TokenType::Comma);
					else
						break;
				}
				ReadToken(TokenType::RParent);
			}
			if (LookAheadToken(TokenType::OpAssign))
			{
				ReadToken(TokenType::OpAssign);
				component->Expression = ParseExpression();
				ReadToken(TokenType::Semicolon);
			}
			else if (LookAheadToken(TokenType::LBrace))
			{
				component->BlockStatement = ParseBlockStatement();
			}
			else
				ReadToken(TokenType::Semicolon);
			PopScope();
			return component;
		}

		RefPtr<WorldSyntaxNode> Parser::ParseWorld()
		{
			RefPtr<WorldSyntaxNode> world = new WorldSyntaxNode();
			world->LayoutAttributes = ParseAttribute();
			world->IsAbstract = LookAheadToken(L"input");
			if (world->IsAbstract)
				ReadToken(L"input");
			ReadToken(L"world");
			FillPosition(world.Ptr());
			world->Name = ReadToken(TokenType::Identifier);
			ReadToken(TokenType::Semicolon);
			return world;
		}

		RefPtr<RateSyntaxNode> Parser::ParseRate()
		{
			RefPtr<RateSyntaxNode> rate = new RateSyntaxNode();
			FillPosition(rate.Ptr());
			ReadToken(TokenType::At);
			auto readWorldRate = [this]()
			{
				RateWorld rw;
				rw.World = ReadToken(TokenType::Identifier);
				if (LookAheadToken(TokenType::OpMul))
				{
					ReadToken(TokenType::OpMul);
					rw.Pinned = true;
				}
				return rw;
			};
			if (LookAheadToken(TokenType::LParent))
			{
				ReadToken(TokenType::LParent);
				while (!LookAheadToken(TokenType::RParent))
				{
					RateWorld rw = readWorldRate();
					rate->Worlds.Add(rw);
					if (LookAheadToken(TokenType::Comma))
					{
						ReadToken(TokenType::Comma);
					}
					else
						break;
				}
				ReadToken(TokenType::RParent);
			}
			else
				rate->Worlds.Add(readWorldRate());
			return rate;
		}

		RefPtr<ImportSyntaxNode> Parser::ParseImport()
		{
			RefPtr<ImportSyntaxNode> rs = new ImportSyntaxNode();
			if (LookAheadToken(L"public"))
			{
				rs->IsPublic = true;
				ReadToken(L"public");
			}
			ReadToken(L"using");
			rs->IsInplace = !LookAheadToken(TokenType::OpAssign, 1);
			if (!rs->IsInplace)
			{
				rs->ObjectName = ReadToken(TokenType::Identifier);
				ReadToken(TokenType::OpAssign);
			}
			FillPosition(rs.Ptr());
			rs->ShaderName = ReadToken(TokenType::Identifier);
			if (LookAheadToken(TokenType::Semicolon))
				ReadToken(TokenType::Semicolon);
			else
			{
				ReadToken(TokenType::LParent);
				while (!LookAheadToken(TokenType::RParent))
				{
					RefPtr<ImportArgumentSyntaxNode> arg = new ImportArgumentSyntaxNode();
					FillPosition(arg.Ptr());
					auto expr = ParseExpression();
					if (LookAheadToken(L":"))
					{
						if (auto varExpr = dynamic_cast<VarExpressionSyntaxNode*>(expr.Ptr()))
						{
							arg->ArgumentName.Content = varExpr->Variable;
							arg->ArgumentName.Position = varExpr->Position;
						}
						else
							errors.Add(CompileError(L"unexpected ':'.", 20011, pos < tokens.Count() ? tokens[pos].Position : CodePosition(0, 0, fileName)));
						ReadToken(L":");
						arg->Expression = ParseExpression();
					}
					else
						arg->Expression = expr;
					rs->Arguments.Add(arg);
					if (LookAheadToken(TokenType::Comma))
						ReadToken(TokenType::Comma);
					else
						break;
				}
				ReadToken(TokenType::RParent);
				ReadToken(TokenType::Semicolon);
			}
			return rs;
		}

		RefPtr<ImportStatementSyntaxNode> Parser::ParseImportStatement()
		{
			RefPtr<ImportStatementSyntaxNode> rs = new ImportStatementSyntaxNode();
			FillPosition(rs.Ptr());
			rs->Import = ParseImport();
			return rs;
		}

		RefPtr<ImportOperatorDefSyntaxNode> Parser::ParseImportOperator()
		{
			RefPtr<ImportOperatorDefSyntaxNode> op = new ImportOperatorDefSyntaxNode();
			PushScope();
			FillPosition(op.Ptr());
			ReadToken(L"import");
			ReadToken(TokenType::LParent);
			op->SourceWorld = ReadToken(TokenType::Identifier);
			ReadToken(TokenType::RightArrow);
			op->DestWorld = ReadToken(TokenType::Identifier);
			ReadToken(TokenType::RParent);
			FillPosition(op.Ptr());
			op->Name = ReadToken(TokenType::Identifier);
			ReadToken(TokenType::LParent);
			while (!LookAheadToken(TokenType::RParent))
			{
				op->Parameters.Add(ParseParameter());
				if (LookAheadToken(TokenType::Comma))
					ReadToken(TokenType::Comma);
				else
					break;
			}
			ReadToken(TokenType::RParent);
			while (LookAheadToken(L"require"))
			{
				ReadToken(L"require");
				op->Requirements.Add(ParseFunction(false));
			}
			op->Body = ParseBlockStatement();
			PopScope();
			return op;
		}

		RefPtr<FunctionSyntaxNode> Parser::ParseFunction(bool parseBody)
		{
			anonymousParamCounter = 0;
			RefPtr<FunctionSyntaxNode> function = new FunctionSyntaxNode();
			if (LookAheadToken(L"__intrinsic"))
			{
				function->HasSideEffect = false;
				function->IsExtern = true;
				pos++;
			}
			else if (LookAheadToken(L"extern"))
			{
				function->IsExtern = true;
				pos++;
			}
			else
				function->IsExtern = false;
			function->IsInline = true;
			if (LookAheadToken(L"inline"))
			{
				function->IsInline = true;
				pos++;
			}
			
			PushScope();
			function->ReturnTypeNode = ParseType();
			try
			{
				FillPosition(function.Ptr());
				Token name;
				if (LookAheadToken(L"operator"))
				{
					ReadToken();
					name = ReadToken();
					switch (name.Type)
					{
					case TokenType::OpAdd: case TokenType::OpSub: case TokenType::OpMul: case TokenType::OpDiv:
					case TokenType::OpMod: case TokenType::OpNot: case TokenType::OpBitNot: case TokenType::OpLsh: case TokenType::OpRsh:
					case TokenType::OpEql: case TokenType::OpNeq: case TokenType::OpGreater: case TokenType::OpLess: case TokenType::OpGeq:
					case TokenType::OpLeq: case TokenType::OpAnd: case TokenType::OpOr: case TokenType::OpBitXor: case TokenType::OpBitAnd:
					case TokenType::OpBitOr: case TokenType::OpInc: case TokenType::OpDec:
						break;
					default:
						errors.Add(CompileError(L"invalid operator '" + name.Content + L"'.", 20008, name.Position));
						break;
					}
				}
				else
				{
					name = ReadToken(TokenType::Identifier);
				}
				function->Name = name.Content;
				ReadToken(TokenType::LParent);
				while(pos < tokens.Count() && tokens[pos].Type != TokenType::RParent)
				{
					function->Parameters.Add(ParseParameter());
					if (LookAheadToken(TokenType::Comma))
						ReadToken(TokenType::Comma);
					else
						break;
				}
				ReadToken(TokenType::RParent);
			}
			catch(int e)
			{
				if (e == 0)
					return function;
				while (pos < tokens.Count() && tokens[pos].Type != TokenType::LBrace)
				{
					pos++;
				}
			}
			if (parseBody)
			{
				if (!function->IsExtern)
					function->Body = ParseBlockStatement();
				else
					ReadToken(TokenType::Semicolon);
			}
			PopScope();
			return function;
		}

		RefPtr<StructSyntaxNode> Parser::ParseStruct()
		{
			RefPtr<StructSyntaxNode> rs = new StructSyntaxNode();
			FillPosition(rs.Ptr());
			ReadToken(L"struct");
			rs->Name = ReadToken(TokenType::Identifier);
			if (LookAheadToken(L"__intrinsic"))
			{
				ReadToken();
				rs->IsIntrinsic = true;
			}
			ReadToken(L"{");
			while (!LookAheadToken(L"}") && pos < tokens.Count())
			{
				RefPtr<TypeSyntaxNode> type = ParseType();
				do
				{
					RefPtr<StructField> field = new StructField();
					FillPosition(field.Ptr());
					field->TypeNode = type;
					field->Name = ReadToken(TokenType::Identifier);
					rs->Fields.Add(field);
					if (!LookAheadToken(TokenType::Comma))
						break;
					ReadToken(TokenType::Comma);
				} while (pos < tokens.Count());
				ReadToken(TokenType::Semicolon);
			}
			ReadToken(L"}");
			return rs;
		}

		RefPtr<StatementSyntaxNode> Parser::ParseStatement()
		{
			RefPtr<StatementSyntaxNode> statement;
			if (LookAheadToken(TokenType::LBrace))
				statement = ParseBlockStatement();
			else if (IsTypeKeyword() || LookAheadToken(L"const"))
				statement = ParseVarDeclrStatement();
			else if (LookAheadToken(TokenType::KeywordIf))
				statement = ParseIfStatement();
			else if (LookAheadToken(TokenType::KeywordFor))
				statement = ParseForStatement();
			else if (LookAheadToken(TokenType::KeywordWhile))
				statement = ParseWhileStatement();
			else if (LookAheadToken(TokenType::KeywordDo))
				statement = ParseDoWhileStatement();
			else if (LookAheadToken(TokenType::KeywordBreak))
				statement = ParseBreakStatement();
			else if (LookAheadToken(TokenType::KeywordContinue))
				statement = ParseContinueStatement();
			else if (LookAheadToken(TokenType::KeywordReturn))
				statement = ParseReturnStatement();
			else if (LookAheadToken(L"using") || (LookAheadToken(L"public") && LookAheadToken(L"using", 1)))
				statement = ParseImportStatement();
			else if (LookAheadToken(L"discard"))
			{
				statement = new DiscardStatementSyntaxNode();
				FillPosition(statement.Ptr());
				ReadToken(L"discard");
				ReadToken(TokenType::Semicolon);
			}
			else if (LookAheadToken(TokenType::Identifier))
			{
				int startPos = pos;
				bool isVarDeclr = false;
				try
				{
					RefPtr<TypeSyntaxNode> type = ParseType();
					if (LookAheadToken(TokenType::Identifier))
					{
						type = nullptr;
						pos = startPos;
						statement = ParseVarDeclrStatement();
						isVarDeclr = true;
					}
				}
				catch (...)
				{
				}
				if (!isVarDeclr)
				{
					pos = startPos;
					statement = ParseExpressionStatement();
				}
			}
			else if (LookAheadToken(TokenType::Semicolon))
			{
				statement = new EmptyStatementSyntaxNode();
				FillPosition(statement.Ptr());
				ReadToken(TokenType::Semicolon);
			}
			else
			{
				errors.Add(CompileError(String(L"syntax error."), 20002, tokens[pos].Position));
				throw 20002;
			}
			return statement;
		}

		RefPtr<BlockStatementSyntaxNode> Parser::ParseBlockStatement()
		{
			RefPtr<BlockStatementSyntaxNode> blockStatement = new BlockStatementSyntaxNode();
			PushScope();
			ReadToken(TokenType::LBrace);
			if(pos < tokens.Count())
			{
				FillPosition(blockStatement.Ptr());
			}
			int lastErrorPos = 0;
			while (pos < tokens.Count() && !LookAheadToken(TokenType::RBrace))
			{
				try
				{
					blockStatement->Statements.Add(ParseStatement());
				}
				catch (int)
				{
					if (pos == lastErrorPos)
						pos++;
					lastErrorPos = pos;
				}
			}
			ReadToken(TokenType::RBrace);
			PopScope();
			return blockStatement;
		}

		VariableModifier Parser::ReadVariableModifier()
		{
			auto & token = ReadToken(TokenType::Identifier);
			if (token.Content == L"in")
				return VariableModifier::In;
			else if (token.Content == L"out")
				return VariableModifier::Out;
			else if (token.Content == L"uniform")
				return VariableModifier::Uniform;
			else if (token.Content == L"parameter")
				return VariableModifier::Parameter;
			else if (token.Content == L"const")
				return VariableModifier::Const;
			else if (token.Content == L"centroid")
				return VariableModifier::Centroid;
			else if (token.Content == L"instance")
				return VariableModifier::Instance;
			else if (token.Content == L"__builtin")
				return VariableModifier::Builtin;
			return VariableModifier::None; 
		}

		RefPtr<VarDeclrStatementSyntaxNode> Parser::ParseVarDeclrStatement()
		{
			RefPtr<VarDeclrStatementSyntaxNode>varDeclrStatement = new VarDeclrStatementSyntaxNode();
		
			if (pos < tokens.Count())
				FillPosition(varDeclrStatement.Ptr());
			while (pos < tokens.Count())
			{
				if (LookAheadToken(L"layout"))
				{
					ReadToken(L"layout");
					ReadToken(TokenType::LParent);
					StringBuilder layoutSB;
					while (!LookAheadToken(TokenType::RParent))
					{
						layoutSB.Append(ReadToken(TokenType::Identifier).Content);
						if (LookAheadToken(TokenType::OpAssign))
						{
							layoutSB.Append(ReadToken(TokenType::OpAssign).Content);
							layoutSB.Append(ReadToken(TokenType::IntLiterial).Content);
						}
						if (!LookAheadToken(TokenType::Comma))
							break;
						else
							layoutSB.Append(L", ");
					}
					ReadToken(TokenType::RParent);
					varDeclrStatement->LayoutString = layoutSB.ProduceString();
				}
				else
					break;
			}
			varDeclrStatement->TypeNode = ParseType();
			while (pos < tokens.Count())
			{
				RefPtr<Variable> var = new Variable();
				FillPosition(var.Ptr());
				Token & name = ReadToken(TokenType::Identifier);
				var->Name = name.Content;
				if (LookAheadToken(TokenType::OpAssign))
				{
					ReadToken(TokenType::OpAssign);
					var->Expression = ParseExpression();
				}

				varDeclrStatement->Variables.Add(var);
				if (LookAheadToken(TokenType::Comma))
					ReadToken(TokenType::Comma);
				else
					break;
			}
			ReadToken(TokenType::Semicolon);
			
			return varDeclrStatement;
		}

		RefPtr<IfStatementSyntaxNode> Parser::ParseIfStatement()
		{
			RefPtr<IfStatementSyntaxNode> ifStatement = new IfStatementSyntaxNode();
			FillPosition(ifStatement.Ptr());
			ReadToken(TokenType::KeywordIf);
			ReadToken(TokenType::LParent);
			ifStatement->Predicate = ParseExpression();
			ReadToken(TokenType::RParent);
			ifStatement->PositiveStatement = ParseStatement();
			if (LookAheadToken(TokenType::KeywordElse))
			{
				ReadToken(TokenType::KeywordElse);
				ifStatement->NegativeStatement = ParseStatement();
			}
			return ifStatement;
		}

		RefPtr<ForStatementSyntaxNode> Parser::ParseForStatement()
		{
			RefPtr<ForStatementSyntaxNode> stmt = new ForStatementSyntaxNode();
			PushScope();
			FillPosition(stmt.Ptr());
			ReadToken(TokenType::KeywordFor);
			ReadToken(TokenType::LParent);
			if (IsTypeKeyword())
			{
				stmt->TypeDef = ParseType();
				stmt->IterationVariable = ReadToken(TokenType::Identifier);
				ReadToken(TokenType::OpAssign);
				stmt->InitialExpression = ParseExpression();
				RefPtr<BinaryExpressionSyntaxNode> assignment = new BinaryExpressionSyntaxNode();
				assignment->Operator = Operator::Assign;
				FillPosition(assignment.Ptr());
				assignment->Position = stmt->IterationVariable.Position;
				RefPtr<VarExpressionSyntaxNode> varExpr = new VarExpressionSyntaxNode();
				FillPosition(varExpr.Ptr());
				varExpr->Position = stmt->IterationVariable.Position;
				varExpr->Variable = stmt->IterationVariable.Content;
				assignment->LeftExpression = varExpr;
				assignment->RightExpression = stmt->InitialExpression;
				stmt->InitialExpression = assignment;
			}
			else
			{
				if (!LookAheadToken(TokenType::Semicolon))
					stmt->InitialExpression = ParseExpression();
			}
			ReadToken(TokenType::Semicolon);
			if (!LookAheadToken(TokenType::Semicolon))
				stmt->PredicateExpression = ParseExpression();
			ReadToken(TokenType::Semicolon);
			if (!LookAheadToken(TokenType::RParent))
				stmt->SideEffectExpression = ParseExpression();
			ReadToken(TokenType::RParent);
			stmt->Statement = ParseStatement();
			PopScope();
			return stmt;
		}

		RefPtr<WhileStatementSyntaxNode> Parser::ParseWhileStatement()
		{
			RefPtr<WhileStatementSyntaxNode> whileStatement = new WhileStatementSyntaxNode();
			PushScope();
			FillPosition(whileStatement.Ptr());
			ReadToken(TokenType::KeywordWhile);
			ReadToken(TokenType::LParent);
			whileStatement->Predicate = ParseExpression();
			ReadToken(TokenType::RParent);
			whileStatement->Statement = ParseStatement();
			PopScope();
			return whileStatement;
		}

		RefPtr<DoWhileStatementSyntaxNode> Parser::ParseDoWhileStatement()
		{
			RefPtr<DoWhileStatementSyntaxNode> doWhileStatement = new DoWhileStatementSyntaxNode();
			PushScope();
			FillPosition(doWhileStatement.Ptr());
			ReadToken(TokenType::KeywordDo);
			doWhileStatement->Statement = ParseStatement();
			ReadToken(TokenType::KeywordWhile);
			ReadToken(TokenType::LParent);
			doWhileStatement->Predicate = ParseExpression();
			ReadToken(TokenType::RParent);
			ReadToken(TokenType::Semicolon);
			PopScope();
			return doWhileStatement;
		}

		RefPtr<BreakStatementSyntaxNode> Parser::ParseBreakStatement()
		{
			RefPtr<BreakStatementSyntaxNode> breakStatement = new BreakStatementSyntaxNode();
			FillPosition(breakStatement.Ptr());
			ReadToken(TokenType::KeywordBreak);
			ReadToken(TokenType::Semicolon);
			return breakStatement;
		}

		RefPtr<ContinueStatementSyntaxNode>	Parser::ParseContinueStatement()
		{
			RefPtr<ContinueStatementSyntaxNode> continueStatement = new ContinueStatementSyntaxNode();
			FillPosition(continueStatement.Ptr());
			ReadToken(TokenType::KeywordContinue);
			ReadToken(TokenType::Semicolon);
			return continueStatement;
		}

		RefPtr<ReturnStatementSyntaxNode> Parser::ParseReturnStatement()
		{
			RefPtr<ReturnStatementSyntaxNode> returnStatement = new ReturnStatementSyntaxNode();
			FillPosition(returnStatement.Ptr());
			ReadToken(TokenType::KeywordReturn);
			if (!LookAheadToken(TokenType::Semicolon))
				returnStatement->Expression = ParseExpression();
			ReadToken(TokenType::Semicolon);
			return returnStatement;
		}

		RefPtr<ExpressionStatementSyntaxNode> Parser::ParseExpressionStatement()
		{
			RefPtr<ExpressionStatementSyntaxNode> statement = new ExpressionStatementSyntaxNode();
			
			FillPosition(statement.Ptr());
			statement->Expression = ParseExpression();
			
			ReadToken(TokenType::Semicolon);
			return statement;
		}

		RefPtr<ParameterSyntaxNode> Parser::ParseParameter()
		{
			RefPtr<ParameterSyntaxNode> parameter = new ParameterSyntaxNode();
			
			parameter->TypeNode = ParseType();
			if (LookAheadToken(TokenType::Identifier))
			{
				Token & name = ReadToken(TokenType::Identifier);
				parameter->Name = name.Content;
			}
			else
				parameter->Name = L"_anonymousParam" + String(anonymousParamCounter++);
			FillPosition(parameter.Ptr());
			return parameter;
		}

		RefPtr<TypeSyntaxNode> Parser::ParseType()
		{
			Token typeName;
			if (LookAheadToken(TokenType::Identifier))
				typeName = ReadToken(TokenType::Identifier);
			else
				typeName = ReadTypeKeyword();
			RefPtr<TypeSyntaxNode> rs;
			if (LookAheadToken(TokenType::OpLess))
			{
				RefPtr<GenericTypeSyntaxNode> gtype = new GenericTypeSyntaxNode();
				gtype->Position = typeName.Position;
				gtype->GenericTypeName = typeName.Content;
				ReadToken(TokenType::OpLess);
				gtype->BaseType = ParseType();
				ReadToken(TokenType::OpGreater);
				rs = gtype;
			}
			else
			{
				auto basicType = new BasicTypeSyntaxNode();
				basicType->Position = typeName.Position;
				basicType->TypeName = typeName.Content;
				rs = basicType;
			}
			while (LookAheadToken(TokenType::LBracket))
			{
				RefPtr<ArrayTypeSyntaxNode> arrType = new ArrayTypeSyntaxNode();
				arrType->Position = rs->Position;
				arrType->BaseType = rs;
				ReadToken(TokenType::LBracket);
				if (LookAheadToken(TokenType::IntLiterial))
					arrType->ArrayLength = atoi(ReadToken(TokenType::IntLiterial).Content.ToMultiByteString());
				else
					arrType->ArrayLength = 0;
				ReadToken(TokenType::RBracket);
				rs = arrType;
			}
			return rs;
		}

		enum class Associativity
		{
			Left, Right
		};

		Associativity GetAssociativityFromLevel(int level)
		{
			if (level == 0)
				return Associativity::Right;
			else
				return Associativity::Left;
		}

		int GetOpLevel(TokenType type)
		{
			switch(type)
			{
			case TokenType::OpAssign:
			case TokenType::OpMulAssign:
			case TokenType::OpDivAssign:
			case TokenType::OpAddAssign:
			case TokenType::OpSubAssign:
			case TokenType::OpModAssign:
			case TokenType::OpShlAssign:
			case TokenType::OpShrAssign:
			case TokenType::OpOrAssign:
			case TokenType::OpAndAssign:
			case TokenType::OpXorAssign:
				return 0;
			case TokenType::OpOr:
				return 2;
			case TokenType::OpAnd:
				return 3;
			case TokenType::OpBitOr:
				return 4;
			case TokenType::OpBitXor:
				return 5;
			case TokenType::OpBitAnd:
				return 6;
			case TokenType::OpEql:
			case TokenType::OpNeq:
				return 7;
			case TokenType::OpGeq:
			case TokenType::OpLeq:
			case TokenType::OpGreater:
			case TokenType::OpLess:
				return 8;
			case TokenType::OpLsh:
			case TokenType::OpRsh:
				return 9;
			case TokenType::OpAdd:
			case TokenType::OpSub:
				return 10;
			case TokenType::OpMul:
			case TokenType::OpDiv:
			case TokenType::OpMod:
				return 11;
			default:
				return -1;
			}
		}

		Operator GetOpFromToken(Token & token)
		{
			switch(token.Type)
			{
			case TokenType::OpAssign:
				return Operator::Assign;
			case TokenType::OpAddAssign:
				return Operator::AddAssign;
			case TokenType::OpSubAssign:
				return Operator::SubAssign;
			case TokenType::OpMulAssign:
				return Operator::MulAssign;
			case TokenType::OpDivAssign:
				return Operator::DivAssign;
			case TokenType::OpModAssign:
				return Operator::ModAssign;
			case TokenType::OpShlAssign:
				return Operator::LshAssign;
			case TokenType::OpShrAssign:
				return Operator::RshAssign;
			case TokenType::OpOrAssign:
				return Operator::OrAssign;
			case TokenType::OpAndAssign:
				return Operator::AddAssign;
			case TokenType::OpXorAssign:
				return Operator::XorAssign;
			case TokenType::OpOr:
				return Operator::Or;
			case TokenType::OpAnd:
				return Operator::And;
			case TokenType::OpBitOr:
				return Operator::BitOr;
			case TokenType::OpBitXor:
				return Operator::BitXor;
			case TokenType::OpBitAnd:
				return Operator::BitAnd;
			case TokenType::OpEql:
				return Operator::Eql;
			case TokenType::OpNeq:
				return Operator::Neq;
			case TokenType::OpGeq:
				return Operator::Geq;
			case TokenType::OpLeq:
				return Operator::Leq;
			case TokenType::OpGreater:
				return Operator::Greater;
			case TokenType::OpLess:
				return Operator::Less;
			case TokenType::OpLsh:
				return Operator::Lsh;
			case TokenType::OpRsh:
				return Operator::Rsh;
			case TokenType::OpAdd:
				return Operator::Add;
			case TokenType::OpSub:
				return Operator::Sub;
			case TokenType::OpMul:
				return Operator::Mul;
			case TokenType::OpDiv:
				return Operator::Div;
			case TokenType::OpMod:
				return Operator::Mod;
			case TokenType::OpInc:
				return Operator::PostInc;
			case TokenType::OpDec:
				return Operator::PostDec;
			case TokenType::OpNot:
				return Operator::Not;
			case TokenType::OpBitNot:
				return Operator::BitNot;
			default:
				throw L"Illegal TokenType.";
			}
		}

		RefPtr<ExpressionSyntaxNode> Parser::ParseExpression(int level)
		{
			if (level == MaxExprLevel)
				return ParseLeafExpression();
			if (level == 1)
			{
				// parse select clause
				auto condition = ParseExpression(level + 1);
				if (LookAheadToken(TokenType::QuestionMark))
				{
					RefPtr<SelectExpressionSyntaxNode> select = new SelectExpressionSyntaxNode();
					FillPosition(select.Ptr());
					ReadToken(TokenType::QuestionMark);
					select->SelectorExpr = condition;
					select->Expr0 = ParseExpression(level);
					ReadToken(TokenType::Colon);
					select->Expr1 = ParseExpression(level);
					return select;
				}
				else
					return condition;
			}
			else
			{
				if (GetAssociativityFromLevel(level) == Associativity::Left)
				{
					auto left = ParseExpression(level + 1);
					while (pos < tokens.Count() && GetOpLevel(tokens[pos].Type) == level)
					{
						RefPtr<BinaryExpressionSyntaxNode> tmp = new BinaryExpressionSyntaxNode();
						tmp->LeftExpression = left;
						FillPosition(tmp.Ptr());
						Token & opToken = ReadToken(tokens[pos].Type);
						tmp->Operator = GetOpFromToken(opToken);
						tmp->RightExpression = ParseExpression(level + 1);
						left = tmp;
					}
					return left;
				}
				else
				{
					auto left = ParseExpression(level + 1);
					if (pos < tokens.Count() && GetOpLevel(tokens[pos].Type) == level)
					{
						RefPtr<BinaryExpressionSyntaxNode> tmp = new BinaryExpressionSyntaxNode();
						tmp->LeftExpression = left;
						FillPosition(tmp.Ptr());
						Token & opToken = ReadToken(tokens[pos].Type);
						tmp->Operator = GetOpFromToken(opToken);
						tmp->RightExpression = ParseExpression(level);
						left = tmp;
					}
					return left;
				}
			}
		}

		RefPtr<ExpressionSyntaxNode> Parser::ParseLeafExpression()
		{
			RefPtr<ExpressionSyntaxNode> rs;

			if (LookAheadToken(TokenType::OpInc) ||
				LookAheadToken(TokenType::OpDec) ||
				LookAheadToken(TokenType::OpNot) ||
				LookAheadToken(TokenType::OpBitNot) ||
				LookAheadToken(TokenType::OpSub))
			{
				RefPtr<UnaryExpressionSyntaxNode> unaryExpr = new UnaryExpressionSyntaxNode();
				Token & token = tokens[pos++];
				FillPosition(unaryExpr.Ptr());
				unaryExpr->Operator = GetOpFromToken(token);
				if (unaryExpr->Operator == Operator::PostInc)
					unaryExpr->Operator = Operator::PreInc;
				else if (unaryExpr->Operator == Operator::PostDec)
					unaryExpr->Operator = Operator::PreDec;
				else if (unaryExpr->Operator == Operator::Sub)
					unaryExpr->Operator = Operator::Neg;

				unaryExpr->Expression = ParseLeafExpression();
				rs = unaryExpr;
				return rs;
			}

			if (LookAheadToken(TokenType::LParent))
			{
				ReadToken(TokenType::LParent);
				RefPtr<ExpressionSyntaxNode> expr;
				if (IsTypeKeyword() && pos + 1 < tokens.Count() && tokens[pos+1].Type == TokenType::RParent)
				{
					RefPtr<TypeCastExpressionSyntaxNode> tcexpr = new TypeCastExpressionSyntaxNode();
					FillPosition(tcexpr.Ptr());
					tcexpr->TargetType = ParseType();
					ReadToken(TokenType::RParent);
					tcexpr->Expression = ParseExpression();
					expr = tcexpr;
				}
				else
				{
					expr = ParseExpression();
					ReadToken(TokenType::RParent);
				}
				rs = expr;
			}
			else if (LookAheadToken(TokenType::IntLiterial) ||
				LookAheadToken(TokenType::DoubleLiterial))
			{
				RefPtr<ConstantExpressionSyntaxNode> constExpr = new ConstantExpressionSyntaxNode();
				auto token = tokens[pos++];
				FillPosition(constExpr.Ptr());
				if (token.Type == TokenType::IntLiterial)
				{
					constExpr->ConstType = ConstantExpressionSyntaxNode::ConstantType::Int;
					constExpr->IntValue = StringToInt(token.Content);
				}
				else if (token.Type == TokenType::DoubleLiterial)
				{
					constExpr->ConstType = ConstantExpressionSyntaxNode::ConstantType::Float;
					constExpr->FloatValue = (float)StringToDouble(token.Content);
				}
				rs = constExpr;
			}
			else if (LookAheadToken(L"true") || LookAheadToken(L"false"))
			{
				RefPtr<ConstantExpressionSyntaxNode> constExpr = new ConstantExpressionSyntaxNode();
				auto token = tokens[pos++];
				FillPosition(constExpr.Ptr());
				constExpr->ConstType = ConstantExpressionSyntaxNode::ConstantType::Bool;
				constExpr->IntValue = token.Content == L"true" ? 1 : 0;
				rs = constExpr;
			}
			else if (LookAheadToken(TokenType::Identifier))
			{
				RefPtr<VarExpressionSyntaxNode> varExpr = new VarExpressionSyntaxNode();
				FillPosition(varExpr.Ptr());
				auto & token = ReadToken(TokenType::Identifier);
				varExpr->Variable = token.Content;
				rs = varExpr;
			}

			while (pos < tokens.Count() &&
				(LookAheadToken(TokenType::OpInc) ||
				LookAheadToken(TokenType::OpDec) ||
				LookAheadToken(TokenType::Dot) ||
				LookAheadToken(TokenType::LBracket) ||
				LookAheadToken(TokenType::LParent)))
			{
				if (LookAheadToken(TokenType::OpInc))
				{
					RefPtr<UnaryExpressionSyntaxNode> unaryExpr = new UnaryExpressionSyntaxNode();
					FillPosition(unaryExpr.Ptr());
					ReadToken(TokenType::OpInc);
					unaryExpr->Operator = Operator::PostInc;
					unaryExpr->Expression = rs;
					rs = unaryExpr;
				}
				else if (LookAheadToken(TokenType::OpDec))
				{
					RefPtr<UnaryExpressionSyntaxNode> unaryExpr = new UnaryExpressionSyntaxNode();
					FillPosition(unaryExpr.Ptr());
					ReadToken(TokenType::OpDec);
					unaryExpr->Operator = Operator::PostDec;
					unaryExpr->Expression = rs;
					rs = unaryExpr;
				}
				else if (LookAheadToken(TokenType::LBracket))
				{
					RefPtr<IndexExpressionSyntaxNode> indexExpr = new IndexExpressionSyntaxNode();
					indexExpr->BaseExpression = rs;
					FillPosition(indexExpr.Ptr());
					ReadToken(TokenType::LBracket);
					indexExpr->IndexExpression = ParseExpression();
					ReadToken(TokenType::RBracket);
					rs = indexExpr;
				}
				else if (LookAheadToken(TokenType::LParent))
				{
					RefPtr<InvokeExpressionSyntaxNode> invokeExpr = new InvokeExpressionSyntaxNode();
					invokeExpr->FunctionExpr = rs;
					FillPosition(invokeExpr.Ptr());
					ReadToken(TokenType::LParent);
					while (pos < tokens.Count())
					{
						if (!LookAheadToken(TokenType::RParent))
							invokeExpr->Arguments.Add(ParseExpression());
						else
						{
							break;
						}
						if (!LookAheadToken(TokenType::Comma))
							break;
						ReadToken(TokenType::Comma);
					}
					ReadToken(TokenType::RParent);
					rs = invokeExpr;
				}
				else if (LookAheadToken(TokenType::Dot))
				{
					RefPtr<MemberExpressionSyntaxNode> memberExpr = new MemberExpressionSyntaxNode();
					FillPosition(memberExpr.Ptr());
					memberExpr->BaseExpression = rs;
					ReadToken(TokenType::Dot); 
					memberExpr->MemberName = ReadToken(TokenType::Identifier).Content;
					rs = memberExpr;
				}
			}
			if (!rs)
			{
				CodePosition codePos;
				if (pos < tokens.Count())
				{
					codePos = tokens[pos].Position;
				}
				errors.Add(CompileError(String(L"syntax error."), 20002, codePos));
				throw 20005;
			}
			return rs;
		}
	}
}

/***********************************************************************
SPIRECORE\SCHEDULE.CPP
***********************************************************************/
using namespace CoreLib::Basic;

namespace Spire
{
	namespace Compiler
	{
		class ScheduleParser
		{
		private:
			List<CompileError>& errors;
			List<Token> tokens;
			int pos;
			String fileName;
			Token & ReadToken(const wchar_t * string)
			{
				if (pos >= tokens.Count())
				{
					errors.Add(CompileError(String(L"\"") + string + String(L"\" expected but end of file encountered."), 0, CodePosition(0, 0, fileName)));
					throw 0;
				}
				else if (tokens[pos].Content != string)
				{
					errors.Add(CompileError(String(L"\"") + string + String(L"\" expected"), 0, tokens[pos].Position));
					throw 20001;
				}
				return tokens[pos++];
			}

			Token & ReadToken(TokenType type)
			{
				if (pos >= tokens.Count())
				{
					errors.Add(CompileError(TokenTypeToString(type) + String(L" expected but end of file encountered."), 0, CodePosition(0, 0, fileName)));
					throw 0;
				}
				else if (tokens[pos].Type != type)
				{
					errors.Add(CompileError(TokenTypeToString(type) + String(L" expected"), 20001, tokens[pos].Position));
					throw 20001;
				}
				return tokens[pos++];
			}

			bool LookAheadToken(const wchar_t * string)
			{
				if (pos >= tokens.Count())
				{
					errors.Add(CompileError(String(L"\'") + string + String(L"\' expected but end of file encountered."), 0, CodePosition(0, 0, fileName)));
					return false;
				}
				else
				{
					if (tokens[pos].Content == string)
						return true;
					else
						return false;
				}
			}
		public:
			ScheduleParser(List<CompileError>& _errorList)
				: errors(_errorList)
			{}
			Schedule Parse(String source, String _fileName)
			{
				this->fileName = _fileName;
				Schedule schedule;
				Lexer lex;
				tokens = lex.Parse(fileName, source, errors);
				pos = 0;
				try
				{
					while (pos < tokens.Count())
					{
						if (LookAheadToken(L"attrib"))
						{
							EnumerableDictionary<String, String> additionalAttributes;
							ReadToken(L"attrib");
							String choiceName = ReadToken(TokenType::Identifier).Content;
							while (LookAheadToken(L"."))
							{
								choiceName = choiceName + L".";
								ReadToken(TokenType::Dot);
								choiceName = choiceName + ReadToken(TokenType::Identifier).Content;
							}
							ReadToken(TokenType::OpAssign);

							while (pos < tokens.Count())
							{
								auto name = ReadToken(TokenType::Identifier).Content;
								String value;
								if (LookAheadToken(L":"))
								{
									ReadToken(L":");
									value = ReadToken(TokenType::StringLiterial).Content;
								}
								additionalAttributes[name] = value;
								if (LookAheadToken(L","))
									ReadToken(TokenType::Comma);
								else
									break;
							}
							schedule.AddtionalAttributes[choiceName] = additionalAttributes;
						}
						else
						{
							String choiceName = ReadToken(TokenType::Identifier).Content;
							while (LookAheadToken(L"."))
							{
								choiceName = choiceName + L".";
								ReadToken(TokenType::Dot);
								choiceName = choiceName + ReadToken(TokenType::Identifier).Content;
							}
							ReadToken(TokenType::OpAssign);
							List<RefPtr<ChoiceValueSyntaxNode>> worlds;
							while (pos < tokens.Count())
							{
								auto & token = ReadToken(TokenType::StringLiterial);
								RefPtr<ChoiceValueSyntaxNode> choiceValue = new ChoiceValueSyntaxNode();
								choiceValue->Position = token.Position;
								int splitterPos = token.Content.IndexOf(L':');
								if (splitterPos != -1)
								{
									choiceValue->WorldName = token.Content.SubString(0, splitterPos);
									choiceValue->AlternateName = token.Content.SubString(splitterPos + 1, token.Content.Length() - splitterPos - 1);
								}
								else
								{
									choiceValue->WorldName = token.Content;
								}
								worlds.Add(choiceValue);
								if (LookAheadToken(L","))
									ReadToken(TokenType::Comma);
								else
									break;
							}
							schedule.Choices[choiceName] = worlds;
						}
						ReadToken(TokenType::Semicolon);
					}
				}
				catch (...)
				{
				}
				return schedule;
			}
		};
	
		Schedule Schedule::Parse(String source, String fileName, List<CompileError>& errorList)
		{
			return ScheduleParser(errorList).Parse(source, fileName);
		}
	}
}

/***********************************************************************
SPIRECORE\SEMANTICSVISITOR.CPP
***********************************************************************/

namespace Spire
{
	namespace Compiler
	{
		bool IsNumeric(BaseType t)
		{
			return t == BaseType::Int || t == BaseType::Float || t == BaseType::UInt;
		}

		String GetFullComponentName(ComponentSyntaxNode * comp)
		{
			StringBuilder sb;
			sb << comp->Name.Content;
			for (auto & param : comp->Parameters)
			{
				sb << L"@" << param->Type->ToString();
			}
			return sb.ProduceString();
		}

		String TranslateHLSLTypeNames(String name)
		{
			if (name == L"float2" || name == L"half2")
				return L"vec2";
			else if (name == L"float3" || name == L"half3")
				return L"vec3";
			else if (name == L"float4" || name == L"half4")
				return L"vec4";
			else if (name == L"half")
				return L"float";
			else if (name == L"int2")
				return L"ivec2";
			else if (name == L"int3")
				return L"ivec3";
			else if (name == L"int4")
				return L"ivec4";
			else if (name == L"uint2")
				return L"uvec2";
			else if (name == L"uint3")
				return L"uvec3";
			else if (name == L"uint4")
				return L"uvec4";
			else if (name == L"float3x3" || name == L"half3x3")
				return L"mat3";
			else if (name == L"float4x4" || name == L"half4x4")
				return L"mat4";
			else
				return name;
		}

		class ComponentReferenceObject : public Object
		{
		public:
			ShaderComponentSymbol * Component = nullptr;
			ComponentReferenceObject(ShaderComponentSymbol * component)
				: Component(component)
			{}
		};

		class SemanticsVisitor : public SyntaxVisitor
		{
			ProgramSyntaxNode * program = nullptr;
			FunctionSyntaxNode * function = nullptr;
			FunctionSymbol * currentFunc = nullptr;
			ShaderSymbol * currentShader = nullptr;
			PipelineSymbol * currentPipeline = nullptr;
			ImportOperatorDefSyntaxNode * currentImportOperator = nullptr;
			ShaderComponentSymbol * currentComp = nullptr;
			ComponentSyntaxNode * currentCompNode = nullptr;
			List<SyntaxNode *> loops;
			SymbolTable * symbolTable;
		public:
			SemanticsVisitor(SymbolTable * symbols, ErrorWriter * pErr)
				:SyntaxVisitor(pErr), symbolTable(symbols)
			{
			}
			// return true if world0 depends on world1 (there exists a series of import operators that converts world1 variables to world0)
			bool IsWorldDependent(PipelineSymbol * pipeline, String world0, String world1)
			{
				HashSet<String> depWorldsSet;
				List<String> depWorlds;
				depWorlds.Add(world0);
				for (int i = 0; i < depWorlds.Count(); i++)
				{
					auto & dep = pipeline->WorldDependency[world0].GetValue();
					if (dep.Contains(world1))
						return true;
					else
					{
						for (auto w : dep)
							if (depWorldsSet.Add(w))
								depWorlds.Add(w);
					}
				}
				return false;
			}
		public:
			// Translate Types
			RefPtr<ExpressionType> typeResult;
			RefPtr<ExpressionType> TranslateTypeNode(const RefPtr<TypeSyntaxNode> & node)
			{
				node->Accept(this);
				return typeResult;
			}
			RefPtr<TypeSyntaxNode> VisitBasicType(BasicTypeSyntaxNode * typeNode) override
			{
				RefPtr<BasicExpressionType> expType = new BasicExpressionType();
				if (typeNode->TypeName == L"int")
					expType->BaseType = BaseType::Int;
				else if (typeNode->TypeName == L"uint")
					expType->BaseType = BaseType::UInt;
				else if (typeNode->TypeName == L"float" || typeNode->TypeName == L"half")
					expType->BaseType = BaseType::Float;
				else if (typeNode->TypeName == L"ivec2" || typeNode->TypeName == L"int2")
					expType->BaseType = BaseType::Int2;
				else if (typeNode->TypeName == L"ivec3" || typeNode->TypeName == L"int3")
					expType->BaseType = BaseType::Int3;
				else if (typeNode->TypeName == L"ivec4" || typeNode->TypeName == L"int4")
					expType->BaseType = BaseType::Int4;
				else if (typeNode->TypeName == L"uvec2" || typeNode->TypeName == L"uint2")
					expType->BaseType = BaseType::UInt2;
				else if (typeNode->TypeName == L"uvec3" || typeNode->TypeName == L"uint3")
					expType->BaseType = BaseType::UInt3;
				else if (typeNode->TypeName == L"uvec4" || typeNode->TypeName == L"uint4")
					expType->BaseType = BaseType::UInt4;
				else if (typeNode->TypeName == L"vec2" || typeNode->TypeName == L"float2" || typeNode->TypeName == L"half2")
					expType->BaseType = BaseType::Float2;
				else if (typeNode->TypeName == L"vec3" || typeNode->TypeName == L"float3" || typeNode->TypeName == L"half3")
					expType->BaseType = BaseType::Float3;
				else if (typeNode->TypeName == L"vec4" || typeNode->TypeName == L"float4" || typeNode->TypeName == L"half4")
					expType->BaseType = BaseType::Float4;
				else if (typeNode->TypeName == L"mat3" || typeNode->TypeName == L"mat3x3" || typeNode->TypeName == L"float3x3" || typeNode->TypeName == L"half3x3")
					expType->BaseType = BaseType::Float3x3;
				else if (typeNode->TypeName == L"mat4" || typeNode->TypeName == L"mat4x4" || typeNode->TypeName == L"float4x4" || typeNode->TypeName == L"half4x4")
					expType->BaseType = BaseType::Float4x4;
				else if (typeNode->TypeName == L"sampler2D" || typeNode->TypeName == L"Texture2D")
					expType->BaseType = BaseType::Texture2D;
				else if (typeNode->TypeName == L"samplerCube")
					expType->BaseType = BaseType::TextureCube;
				else if (typeNode->TypeName == L"sampler2DShadow")
					expType->BaseType = BaseType::TextureShadow;
				else if (typeNode->TypeName == L"samplerCubeShadow")
					expType->BaseType = BaseType::TextureCubeShadow;
				else if (typeNode->TypeName == L"void")
					expType->BaseType = BaseType::Void;
				else if (typeNode->TypeName == L"bool")
					expType->BaseType = BaseType::Bool;
				else
				{
					expType->BaseType = BaseType::Struct;
					RefPtr<StructSymbol> ssym;
					if (symbolTable->Structs.TryGetValue(typeNode->TypeName, ssym))
					{
						expType->Struct = ssym.Ptr();
					}
					else if (currentPipeline || currentShader)
					{
						PipelineSymbol * pipe = currentPipeline ? currentPipeline : currentShader->Pipeline;
						if (pipe)
						{
							if (pipe->Worlds.ContainsKey(typeNode->TypeName))
							{
								expType->BaseType = BaseType::Record;
								expType->RecordTypeName = typeNode->TypeName;
							}
							else
								Error(31040, L"undefined type name: '" + typeNode->TypeName + L"'.", typeNode);
						}
						else
							typeResult = ExpressionType::Error;
					}
					else
					{
						Error(31040, L"undefined type name: '" + typeNode->TypeName + L"'.", typeNode);
						typeResult = ExpressionType::Error;
						return typeNode;
					}
				}
				typeResult = expType;
				return typeNode;
			}
			RefPtr<TypeSyntaxNode> VisitArrayType(ArrayTypeSyntaxNode * typeNode) override
			{
				RefPtr<ArrayExpressionType> rs = new ArrayExpressionType();
				rs->ArrayLength = typeNode->ArrayLength;
				typeNode->BaseType->Accept(this);
				rs->BaseType = typeResult;
				typeResult = rs;
				return typeNode;
			}
			RefPtr<TypeSyntaxNode> VisitGenericType(GenericTypeSyntaxNode * typeNode) override
			{
				RefPtr<GenericExpressionType> rs = new GenericExpressionType();
				typeNode->BaseType->Accept(this);
				rs->BaseType = typeResult;
				rs->GenericTypeName = typeNode->GenericTypeName;
				typeResult = rs;
				return typeNode;
			}
		public:
			RefPtr<PipelineSyntaxNode> VisitPipeline(PipelineSyntaxNode * pipeline) override
			{
				RefPtr<PipelineSymbol> psymbol = new PipelineSymbol();
				psymbol->SyntaxNode = pipeline;
				if (pipeline->ParentPipeline.Content.Length())
				{
					RefPtr<PipelineSymbol> parentPipeline;
					if (symbolTable->Pipelines.TryGetValue(pipeline->ParentPipeline.Content, parentPipeline))
					{
						psymbol->ParentPipeline = parentPipeline.Ptr();
					}
					else
					{
						Error(33010, L"pipeline '" + pipeline->ParentPipeline.Content + L"' is undefined.", pipeline->ParentPipeline);
					}
				}
				currentPipeline = psymbol.Ptr();
				symbolTable->Pipelines.Add(pipeline->Name.Content, psymbol);
				for (auto world : pipeline->Worlds)
				{
					WorldSymbol worldSym;
					worldSym.IsAbstract = world->IsAbstract;
					worldSym.SyntaxNode = world.Ptr();
					if (!psymbol->Worlds.ContainsKey(world->Name.Content))
					{
						psymbol->Worlds.Add(world->Name.Content, worldSym);
						psymbol->WorldDependency.Add(world->Name.Content, EnumerableHashSet<String>());
					}
					else
					{
						Error(33001, L"world \'" + world->Name.Content + L"\' is already defined.", world.Ptr());
					}
				}
				for (auto comp : pipeline->AbstractComponents)
				{
					comp->Type = TranslateTypeNode(comp->TypeNode);
					if (comp->IsParam || comp->IsInput || (comp->Rate && comp->Rate->Worlds.Count() == 1
						&& psymbol->IsAbstractWorld(comp->Rate->Worlds.First().World.Content)))
						AddNewComponentSymbol(psymbol->Components, psymbol->FunctionComponents, comp);
					else
						Error(33003, L"cannot define components in a pipeline.",
							comp.Ptr());
				}
				for (auto & op : pipeline->ImportOperators)
				{
					psymbol->AddImportOperator(op);
				}
				// add initial world dependency edges
				for (auto op : pipeline->ImportOperators)
				{
					if (!psymbol->WorldDependency.ContainsKey(op->DestWorld.Content))
						Error(33004, L"undefined world name '" + op->DestWorld.Content + L"'.", op->DestWorld);
					else
					{
						if (psymbol->Worlds[op->DestWorld.Content].GetValue().IsAbstract)
							Error(33005, L"abstract world cannot appear as target as an import operator.", op->DestWorld);
						else if (!psymbol->WorldDependency.ContainsKey(op->SourceWorld.Content))
							Error(33006, L"undefined world name '" + op->SourceWorld.Content + L"'.", op->SourceWorld);
						else
						{
							if (IsWorldDependent(psymbol.Ptr(), op->SourceWorld.Content, op->DestWorld.Content))
							{
								Error(33007, L"import operator '" + op->Name.Content + L"' creates a circular dependency between world '" + op->SourceWorld.Content + L"' and '" + op->DestWorld.Content + L"'",
									op->Name);
							}
							else
							{
								psymbol->WorldDependency[op->DestWorld.Content].GetValue().Add(op->SourceWorld.Content);
							}
						}
					}
					
				}
				// propagate world dependency graph
				bool changed = true;
				while (changed)
				{
					changed = false;
					for (auto world : pipeline->Worlds)
					{
						EnumerableHashSet<String> & dependentWorlds = psymbol->WorldDependency[world->Name.Content].GetValue();
						List<String> loopRange;
						for (auto w : dependentWorlds)
							loopRange.Add(w);
						for (auto w : loopRange)
						{
							EnumerableHashSet<String> & ddw = psymbol->WorldDependency[w].GetValue();
							for (auto ww : ddw)
							{
								if (!dependentWorlds.Contains(ww))
								{
									dependentWorlds.Add(ww);
									changed = true;
								}
							}
						}
					}
				}

				for (auto & op : pipeline->ImportOperators)
				{
					currentImportOperator = op.Ptr();
					HashSet<String> paraNames;
					for (auto & para : op->Parameters)
					{
						if (paraNames.Contains(para->Name))
							Error(30002, L"parameter \'" + para->Name + L"\' already defined.", para.Ptr());
						else
							paraNames.Add(para->Name);
						VariableEntry varEntry;
						varEntry.Name = para->Name;
						para->Type = TranslateTypeNode(para->TypeNode);
						varEntry.Type.DataType = para->Type;
						op->Scope->Variables.AddIfNotExists(varEntry.Name, varEntry);
						if (varEntry.Type.DataType->Equals(ExpressionType::Void.Ptr()))
							Error(30016, L"'void' can not be parameter type.", para.Ptr());
					}
					auto oldSymFuncs = symbolTable->Functions;
					auto oldSymFuncOverloads = symbolTable->FunctionOverloads;
					for (auto req : op->Requirements)
					{
						VisitFunctionDeclaration(req.Ptr());
					}
					op->Body->Accept(this);
					symbolTable->Functions = oldSymFuncs;
					symbolTable->FunctionOverloads = oldSymFuncOverloads;
					currentImportOperator = nullptr;
				}
				currentPipeline = nullptr;
				return pipeline;
			}

			virtual RefPtr<ImportSyntaxNode> VisitImport(ImportSyntaxNode * import) override
			{
				RefPtr<ShaderSymbol> refShader;
				symbolTable->Shaders.TryGetValue(import->ShaderName.Content, refShader);
				if (refShader)
				{
					// type check
					List<ShaderComponentSymbol*> paramList;
					for (auto & comp : refShader->Components)
						if (comp.Value->IsParam())
							paramList.Add(comp.Value.Ptr());
					int position = 0;
					bool namedArgumentAppeared = false;
					for (auto & arg : import->Arguments)
					{
						if (arg->ArgumentName.Content.Length())
							namedArgumentAppeared = true;
						else
						{
							if (namedArgumentAppeared)
							{
								Error(33030, L"positional argument cannot appear after a named argument.", arg->Expression.Ptr());
								break;
							}
							if (position >= paramList.Count())
							{
								Error(33031, L"too many arguments.", arg->Expression.Ptr());
								break;
							}
							arg->ArgumentName.Content = paramList[position]->Name;
							arg->ArgumentName.Position = arg->Position;
						}
						position++;
						RefPtr<ShaderComponentSymbol> refComp;
						if (refShader->Components.TryGetValue(arg->ArgumentName.Content, refComp))
						{
							if (refComp->Implementations.First()->SyntaxNode->Parameters.Count()) // this is a function parameter
							{
								// construct an invocation node to resolve overloaded component function
								RefPtr<InvokeExpressionSyntaxNode> tempInvoke = new InvokeExpressionSyntaxNode();
								tempInvoke->Position = arg->Position;
								tempInvoke->Scope = arg->Scope;
								tempInvoke->FunctionExpr = arg->Expression;
								for (auto & param : refComp->Implementations.First()->SyntaxNode->Parameters)
								{
									RefPtr<VarExpressionSyntaxNode> tempArg = new VarExpressionSyntaxNode();
									tempArg->Type = param->Type;
									tempInvoke->Arguments.Add(tempArg);
								}
								auto resolvedExpr = ResolveInvoke(tempInvoke.Ptr());
								if (auto resolveInvoke = resolvedExpr.As<InvokeExpressionSyntaxNode>())
								{
									auto funcType = resolveInvoke->FunctionExpr->Type->AsBasicType();
									if (funcType->Component)
									{
										// modify function name to resolved name
										if (auto memberExpr = arg->Expression.As<MemberExpressionSyntaxNode>())
											memberExpr->MemberName = funcType->Component->Name;
										else if (auto varExpr = arg->Expression.As<VarExpressionSyntaxNode>())
											varExpr->Variable = funcType->Component->Name;
									}
									else
										Error(33042, L"ordinary functions not allowed as argument to function-typed module parameter.", arg.Ptr());
								}
								else
									Error(33041, L"invalid value for argument '" + arg->ArgumentName.Content, arg.Ptr());
							}
							else
							{
								arg->Accept(this);
								if (!refComp->Type->DataType->Equals(arg->Expression->Type.Ptr()))
								{
									Error(33027, L"argument type (" + arg->Expression->Type->ToString() + L") does not match parameter type (" + refComp->Type->DataType->ToString() + L")", arg->Expression.Ptr());
								}
								if (!refComp->IsParam())
									Error(33028, L"'" + arg->ArgumentName.Content + L"' is not a parameter of '" + import->ShaderName.Content + L"'.", arg->ArgumentName);
							}
						}
						else
							Error(33028, L"'" + arg->ArgumentName.Content + L"' is not a parameter of '" + import->ShaderName.Content + L"'.", arg->ArgumentName);
					}
				}
				return import;
			}

			class ShaderImportVisitor : public SyntaxVisitor
			{
			private:
				SymbolTable * symbolTable = nullptr;
				ShaderSymbol * currentShader = nullptr;
				ShaderComponentSymbol * currentComp = nullptr;
			public:
				ShaderImportVisitor(ErrorWriter * writer, SymbolTable * symTable)
					: SyntaxVisitor(writer), symbolTable(symTable)
				{}
				virtual RefPtr<ShaderSyntaxNode> VisitShader(ShaderSyntaxNode * shader) override
				{
					currentShader = symbolTable->Shaders[shader->Name.Content].GetValue().Ptr();
					SyntaxVisitor::VisitShader(shader);
					currentShader = nullptr;
					return shader;
				}
				virtual RefPtr<ComponentSyntaxNode> VisitComponent(ComponentSyntaxNode * comp) override
				{
					RefPtr<ShaderComponentSymbol> compSym;
					
					currentShader->Components.TryGetValue(comp->Name.Content, compSym);
					currentComp = compSym.Ptr();
					SyntaxVisitor::VisitComponent(comp);
					if (comp->Parameters.Count() > 0)
					{
						comp->IsInline = true;
					}
					if (comp->Expression || comp->BlockStatement)
					{
						if (compSym->IsParam())
							Error(33040, L"'require': cannot define computation on component requirements.", comp);
					}
					currentComp = nullptr;
					return comp;
				}
				virtual RefPtr<ImportSyntaxNode> VisitImport(ImportSyntaxNode * import) override
				{
					RefPtr<ShaderSymbol> refShader;
					symbolTable->Shaders.TryGetValue(import->ShaderName.Content, refShader);
					if (!refShader)
						Error(33015, L"undefined identifier \'" + import->ShaderName.Content + L"\'.", import->ShaderName);
					currentShader->DependentShaders.Add(refShader.Ptr());
					if (!currentComp)
					{
						ShaderUsing su;
						su.Shader = refShader.Ptr();
						su.IsPublic = import->IsPublic;
						if (import->IsInplace)
						{
							currentShader->ShaderUsings.Add(su);
						}
						else
						{
							if (currentShader->ShaderObjects.ContainsKey(import->ObjectName.Content) ||
								currentShader->Components.ContainsKey(import->ObjectName.Content))
							{
								Error(33018, L"\'" + import->ShaderName.Content + L"\' is already defined.", import->ShaderName);
							}
							currentShader->ShaderObjects[import->ObjectName.Content] = su;
						}
					}
					if (currentComp)
						Error(33016, L"'using': importing not allowed in component definition.", import->ShaderName);
					return import;
				}
			};

			// pass 1: fill components in shader symbol table
			void VisitShaderPass1(ShaderSyntaxNode * shader)
			{
				HashSet<String> inheritanceSet;
				auto curShader = shader;
				inheritanceSet.Add(curShader->Name.Content);
				auto & shaderSymbol = symbolTable->Shaders[curShader->Name.Content].GetValue();
				this->currentShader = shaderSymbol.Ptr();
				
				if (shader->Pipeline.Content.Length() == 0) // implicit pipeline
				{
					if (program->Pipelines.Count() == 1)
					{
						shader->Pipeline = shader->Name; // get line and col from shader name
						shader->Pipeline.Content = program->Pipelines.First()->Name.Content;
					}
					else if (!shader->IsModule)
					{
						// current compilation context has more than one pipeline defined,
						// in which case we do not allow implicit pipeline specification
						Error(33002, L"explicit pipeline specification required for shader '" +
							shader->Name.Content + L"' because multiple pipelines are defined in current context.", curShader->Name);
					}
				}

				auto pipelineName = shader->Pipeline.Content;
				if (pipelineName.Length())
				{
					auto pipeline = symbolTable->Pipelines.TryGetValue(pipelineName);
					if (pipeline)
						shaderSymbol->Pipeline = pipeline->Ptr();
					else
					{
						Error(33010, L"pipeline \'" + pipelineName + L"' is not defined.", shader->Pipeline);
						throw 0;
					}
				}

				if (shader->IsModule)
					shaderSymbol->IsAbstract = true;
				// add components to symbol table
				for (auto & mbr : shader->Members)
				{
					if (auto comp = dynamic_cast<ComponentSyntaxNode*>(mbr.Ptr()))
					{
						comp->Type = TranslateTypeNode(comp->TypeNode);
						if (comp->IsParam)
						{
							shaderSymbol->IsAbstract = true;
							if (!shaderSymbol->SyntaxNode->IsModule)
							{
								Error(33009, L"parameters can only be defined in modules.", shaderSymbol->SyntaxNode);
							}
						}
						for (auto & param : comp->Parameters)
							param->Type = TranslateTypeNode(param->TypeNode);
						AddNewComponentSymbol(shaderSymbol->Components, shaderSymbol->FunctionComponents, comp);
					}
				}
				// add shader objects to symbol table
				ShaderImportVisitor importVisitor(err, symbolTable);
				shader->Accept(&importVisitor);
				/* ************************************
				***************************************
				for (auto & comp : shaderSymbol->Components)
				{
					for (auto & impl : comp.Value->Implementations)
					{
						bool inAbstractWorld = false;
						if (impl->SyntaxNode->Rate)
						{
							auto & userSpecifiedWorlds = impl->SyntaxNode->Rate->Worlds;
							for (auto & world : userSpecifiedWorlds)
							{
								if (!shaderSymbol->Pipeline->WorldDependency.ContainsKey(world.World.Content))
									Error(33012, L"\'" + world.World.Content + L"' is not a defined world in '" +
										pipelineName + L"'.", world.World);
								WorldSymbol worldSym;

								if (shaderSymbol->Pipeline->Worlds.TryGetValue(world.World.Content, worldSym))
								{
									if (worldSym.IsAbstract)
									{
										inAbstractWorld = true;
										if (userSpecifiedWorlds.Count() > 1)
										{
											Error(33013, L"abstract world cannot appear with other worlds.",
												world.World);
										}
									}
								}
							}
						}
						if (!inAbstractWorld && !impl->SyntaxNode->IsParam
							&& !impl->SyntaxNode->Expression && !impl->SyntaxNode->BlockStatement)
						{
							Error(33014, L"non-abstract component must have an implementation.",
								impl->SyntaxNode.Ptr());
						}
					}
				}
				*/
				this->currentShader = nullptr;
			}
			// pass 2: type checking component definitions
			void VisitShaderPass2(ShaderSyntaxNode * shaderNode)
			{
				RefPtr<ShaderSymbol> shaderSym;
				if (!symbolTable->Shaders.TryGetValue(shaderNode->Name.Content, shaderSym))
					return;
				this->currentShader = shaderSym.Ptr();
				for (auto & comp : shaderNode->Members)
				{
					comp->Accept(this);
				}
				this->currentShader = nullptr;
			}

			bool MatchType_RecordType(String recTypeName, ExpressionType * valueType)
			{
				if (valueType->IsGenericType(L"Uniform") || valueType->IsGenericType(L"Patch"))
				{
					valueType = valueType->AsGenericType()->BaseType.Ptr();
				}
				if (auto basicType = valueType->AsBasicType())
					return basicType->RecordTypeName == recTypeName;
				return false;
			}

			bool MatchType_ValueReceiver(ExpressionType * receiverType, ExpressionType * valueType)
			{
				if (receiverType->Equals(valueType))
					return true;
				if (receiverType->IsIntegral() && valueType->Equals(ExpressionType::Int.Ptr()))
					return true;
				if (receiverType->Equals(ExpressionType::Float.Ptr()) && valueType->IsIntegral())
					return true;
				if (receiverType->IsVectorType() && valueType->IsVectorType())
				{
					auto recieverBasicType = receiverType->AsBasicType();
					auto valueBasicType = valueType->AsBasicType();
					if (GetVectorBaseType(recieverBasicType->BaseType) == BaseType::Float &&
						GetVectorSize(recieverBasicType->BaseType) == GetVectorSize(valueBasicType->BaseType))
						return true;
					if (GetVectorBaseType(recieverBasicType->BaseType) == BaseType::UInt &&
						GetVectorBaseType(valueBasicType->BaseType) == BaseType::Int &&
						GetVectorSize(recieverBasicType->BaseType) == GetVectorSize(valueBasicType->BaseType))
						return true;
				}
				return false;
			}
			virtual RefPtr<ComponentSyntaxNode> VisitComponent(ComponentSyntaxNode * comp) override
			{
				this->currentCompNode = comp;
				RefPtr<ShaderComponentSymbol> compSym;
				currentShader->Components.TryGetValue(comp->Name.Content, compSym);
				this->currentComp = compSym.Ptr();
				for (auto & param : comp->Parameters)
				{
					param->Accept(this);
					VariableEntry varEntry;
					varEntry.IsComponent = false;
					varEntry.Name = param->Name;
					varEntry.Type.DataType = param->Type;
					comp->Scope->Variables.Add(param->Name, varEntry);
				}
				if (comp->Expression)
				{
					comp->Expression = comp->Expression->Accept(this).As<ExpressionSyntaxNode>();
					if (!MatchType_ValueReceiver(compSym->Type->DataType.Ptr(), comp->Expression->Type.Ptr()) && 
						!comp->Expression->Type->Equals(ExpressionType::Error.Ptr()))
						Error(30019, L"type mismatch \'" + comp->Expression->Type->ToString() + L"\' and \'" +
							currentComp->Type->DataType->ToString() + L"\'", comp->Name);
				}
				if (comp->BlockStatement)
					comp->BlockStatement->Accept(this);
				this->currentComp = nullptr;
				this->currentCompNode = nullptr;
				return comp;
			}
			virtual RefPtr<StatementSyntaxNode> VisitImportStatement(ImportStatementSyntaxNode * importStmt) override
			{
				importStmt->Import->Accept(this);
				return importStmt;
			}
			void AddNewComponentSymbol(EnumerableDictionary<String, RefPtr<ShaderComponentSymbol>> & components, 
				EnumerableDictionary<String, List<RefPtr<ShaderComponentSymbol>>> & funcComponents,
				RefPtr<ComponentSyntaxNode> comp)
			{
				RefPtr<ShaderComponentSymbol> compSym;
				RefPtr<ShaderComponentImplSymbol> compImpl = new ShaderComponentImplSymbol();
				if (comp->Rate)
					for (auto w : comp->Rate->Worlds)
						compImpl->Worlds.Add(w.World.Content);
				compImpl->SyntaxNode = comp;
				if (compImpl->SyntaxNode->Rate)
				{
					for (auto & w : compImpl->SyntaxNode->Rate->Worlds)
						if (w.Pinned)
							compImpl->SrcPinnedWorlds.Add(w.World.Content);
				}
				if (compImpl->SyntaxNode->AlternateName.Type == TokenType::Identifier)
				{
					compImpl->AlternateName = compImpl->SyntaxNode->AlternateName.Content;
				}
				if (compImpl->SyntaxNode->IsOutput)
				{
					if (compImpl->SyntaxNode->Rate)
					{
						for (auto & w : compImpl->SyntaxNode->Rate->Worlds)
							compImpl->ExportWorlds.Add(w.World.Content);
					}
					else
					{
						Error(33019, L"component \'" + compImpl->SyntaxNode->Name.Content + L"\': definition marked as 'export' must have an explicitly specified world.",
							compImpl->SyntaxNode.Ptr());
					}
					if (compImpl->SyntaxNode->Parameters.Count() > 0)
						Error(33037, L"component '" + compImpl->SyntaxNode->Name.Content + L"\': definition marked as 'export' cannot have parameters.",
							compImpl->SyntaxNode->Name);
				}
				auto compName = GetFullComponentName(comp.Ptr());
				if (!components.TryGetValue(compName, compSym))
				{
					compSym = new ShaderComponentSymbol();
					compSym->Type = new Type();
					compSym->Name = compName;
					compSym->Type->DataType = comp->Type;
					components.Add(compName, compSym);
				}
				else
				{
					if (comp->IsParam)
						Error(33029, L"\'" + compImpl->SyntaxNode->Name.Content + L"\': requirement clash with previous definition.",
							compImpl->SyntaxNode.Ptr());
					if (compImpl->SyntaxNode->Parameters.Count())
						Error(33032, L"\'" + compImpl->SyntaxNode->Name.Content + L"\': function redefinition.\nsee previous definition at " +
							compSym->Implementations.Last()->SyntaxNode->Position.ToString(), compImpl->SyntaxNode.Ptr());
					symbolTable->CheckComponentImplementationConsistency(err, compSym.Ptr(), compImpl.Ptr());
				}
				if (compImpl->SyntaxNode->Parameters.Count())
				{
					auto list = funcComponents.TryGetValue(comp->Name.Content);
					if (!list)
					{
						funcComponents[comp->Name.Content] = List<RefPtr<ShaderComponentSymbol>>();
						list = funcComponents.TryGetValue(comp->Name.Content);
					}
					comp->Name.Content = compName;
					list->Add(compSym);
				}
				compSym->Implementations.Add(compImpl);
			}
			virtual RefPtr<ProgramSyntaxNode> VisitProgram(ProgramSyntaxNode * programNode) override
			{
				HashSet<String> funcNames;
				this->program = programNode;
				this->function = nullptr;
				for (auto & s : program->Structs)
				{
					RefPtr<StructSymbol> ssym = new StructSymbol();
					ssym->Name = s->Name.Content;
					ssym->SyntaxNode = s;
					ssym->Type = new ILStructType();
					symbolTable->Structs.Add(s->Name.Content, ssym);
				}
				for (auto & s : program->Structs)
					VisitStruct(s.Ptr());
				for (auto & func : program->Functions)
				{
					VisitFunctionDeclaration(func.Ptr());
					if (funcNames.Contains(func->InternalName))
					{
						StringBuilder argList;
						argList << L"(";
						for (auto & param : func->Parameters)
						{
							argList << param->Type->ToString();
							if (param != func->Parameters.Last())
								argList << L", ";
						}
						argList << L")";
						Error(30001, L"\'" + func->Name + argList.ProduceString() + L"\': function redefinition.", func.Ptr());
					}
					else
						funcNames.Add(func->InternalName);
				}
				for (auto & func : program->Functions)
				{
					func->Accept(this);
				}
				for (auto & pipeline : program->Pipelines)
				{
					VisitPipeline(pipeline.Ptr());
				}
				// build initial symbol table for shaders
				for (auto & shader : program->Shaders)
				{
					RefPtr<ShaderSymbol> shaderSym = new ShaderSymbol();
					shaderSym->SyntaxNode = shader.Ptr();
					if (symbolTable->Shaders.ContainsKey(shader->Name.Content))
					{
						Error(33018, L"shader '" + shader->Name.Content + "' has already been defined.", shader->Name);
					}
					symbolTable->Shaders[shader->Name.Content] = shaderSym;
				}
				for (auto & shader : program->Shaders)
				{
					VisitShaderPass1(shader.Ptr());
				}
				if (err->GetErrorCount() != 0)
					return programNode;
				// shader dependency is discovered in pass 1, we can now sort the shaders
				if (!symbolTable->SortShaders())
				{
					HashSet<ShaderSymbol*> sortedShaders;
					for (auto & shader : symbolTable->ShaderDependenceOrder)
						sortedShaders.Add(shader);
					for (auto & shader : symbolTable->Shaders)
						if (!sortedShaders.Contains(shader.Value.Ptr()))
						{
							Error(33011, L"shader '" + shader.Key + L"' involves circular reference.", shader.Value->SyntaxNode->Name);
						}
				}

				for (auto & shader : symbolTable->ShaderDependenceOrder)
				{
					if (!shader->SemanticallyChecked)
					{
						VisitShaderPass2(shader->SyntaxNode);
						shader->SemanticallyChecked = true;
					}
				}
				return programNode;
			}

			virtual RefPtr<StructSyntaxNode> VisitStruct(StructSyntaxNode * structNode) override
			{
				RefPtr<StructSymbol> st;
				if (symbolTable->Structs.TryGetValue(structNode->Name.Content, st))
				{
					st->Type->TypeName = structNode->Name.Content;
					st->Type->IsIntrinsic = structNode->IsIntrinsic;
					for (auto node : structNode->Fields)
					{
						node->Type = TranslateTypeNode(node->TypeNode);
						ILStructType::ILStructField f;
						f.FieldName = node->Name.Content;
						f.Type = TranslateExpressionType(node->Type.Ptr());
						st->Type->Members.Add(f);
					}
				}
				return structNode;
			}

			virtual RefPtr<FunctionSyntaxNode> VisitFunction(FunctionSyntaxNode *functionNode) override
			{
				if (!functionNode->IsExtern)
				{
					currentFunc = symbolTable->Functions.TryGetValue(functionNode->InternalName)->Ptr();
					this->function = functionNode;
					functionNode->Body->Accept(this);
					this->function = NULL;
					currentFunc = nullptr;
				}
				return functionNode;
			}

			void VisitFunctionDeclaration(FunctionSyntaxNode *functionNode)
			{
				this->function = functionNode;
				auto returnType = TranslateTypeNode(functionNode->ReturnTypeNode);
				functionNode->ReturnType = returnType;
				StringBuilder internalName;
				internalName << functionNode->Name;
				HashSet<String> paraNames;
				for (auto & para : functionNode->Parameters)
				{
					if (paraNames.Contains(para->Name))
						Error(30002, L"parameter \'" + para->Name + L"\' already defined.", para.Ptr());
					else
						paraNames.Add(para->Name);
					VariableEntry varEntry;
					varEntry.Name = para->Name;
					para->Type = TranslateTypeNode(para->TypeNode);
					varEntry.Type.DataType = para->Type;
					functionNode->Scope->Variables.AddIfNotExists(varEntry.Name, varEntry);
					if (varEntry.Type.DataType->Equals(ExpressionType::Void.Ptr()))
						Error(30016, L"'void' can not be parameter type.", para.Ptr());
					internalName << L"@" << varEntry.Type.DataType->ToString();
				}
				functionNode->InternalName = internalName.ProduceString();	
				RefPtr<FunctionSymbol> symbol = new FunctionSymbol();
				symbol->SyntaxNode = functionNode;
				symbolTable->Functions[functionNode->InternalName] = symbol;
				auto overloadList = symbolTable->FunctionOverloads.TryGetValue(functionNode->Name);
				if (!overloadList)
				{
					symbolTable->FunctionOverloads[functionNode->Name] = List<RefPtr<FunctionSymbol>>();
					overloadList = symbolTable->FunctionOverloads.TryGetValue(functionNode->Name);
				}
				overloadList->Add(symbol);
				this->function = NULL;
			}
			
			virtual RefPtr<StatementSyntaxNode> VisitBlockStatement(BlockStatementSyntaxNode *stmt) override
			{
				for (auto & node : stmt->Statements)
				{
					node->Accept(this);
				}
				return stmt;
			}
			virtual RefPtr<StatementSyntaxNode> VisitBreakStatement(BreakStatementSyntaxNode *stmt) override
			{
				if (!loops.Count())
					Error(30003, L"'break' must appear inside loop constructs.", stmt);
				return stmt;
			}
			virtual RefPtr<StatementSyntaxNode> VisitContinueStatement(ContinueStatementSyntaxNode *stmt) override
			{
				if (!loops.Count())
					Error(30004, L"'continue' must appear inside loop constructs.", stmt);
				return stmt;
			}
			virtual RefPtr<StatementSyntaxNode> VisitDoWhileStatement(DoWhileStatementSyntaxNode *stmt) override
			{
				loops.Add(stmt);
				if (stmt->Predicate != NULL)
					stmt->Predicate = stmt->Predicate->Accept(this).As<ExpressionSyntaxNode>();
				if (!stmt->Predicate->Type->Equals(ExpressionType::Error.Ptr()) && 
					!stmt->Predicate->Type->Equals(ExpressionType::Int.Ptr()) &&
					!stmt->Predicate->Type->Equals(ExpressionType::Bool.Ptr()))
					Error(30005, L"'while': expression must evaluate to int.", stmt);
				stmt->Statement->Accept(this);

				loops.RemoveAt(loops.Count() - 1);
				return stmt;
			}
			virtual RefPtr<StatementSyntaxNode> VisitForStatement(ForStatementSyntaxNode *stmt) override
			{
				loops.Add(stmt);
				VariableEntry iterVar;
				if (stmt->TypeDef != nullptr)
				{
					stmt->IterationVariableType = TranslateTypeNode(stmt->TypeDef);
					VariableEntry varEntry;
					varEntry.IsComponent = false;
					varEntry.Name = stmt->IterationVariable.Content;
					varEntry.Type.DataType = stmt->IterationVariableType;
					stmt->Scope->Variables.AddIfNotExists(stmt->IterationVariable.Content, varEntry);
				}
				
				if (stmt->InitialExpression)
				{
					stmt->InitialExpression = stmt->InitialExpression->Accept(this).As<ExpressionSyntaxNode>();
				}
				if (stmt->PredicateExpression)
				{
					stmt->PredicateExpression = stmt->PredicateExpression->Accept(this).As<ExpressionSyntaxNode>();
					if (!stmt->PredicateExpression->Type->Equals(ExpressionType::Bool.Ptr()) && 
						!stmt->PredicateExpression->Type->Equals(ExpressionType::Int.Ptr()) &&
						!stmt->PredicateExpression->Type->Equals(ExpressionType::UInt.Ptr()))
					{
						Error(30028, L"'for': predicate expression must evaluate to bool.", stmt->PredicateExpression.Ptr());
					}
				}
				if (stmt->SideEffectExpression)
				{
					stmt->SideEffectExpression = stmt->SideEffectExpression->Accept(this).As<ExpressionSyntaxNode>();
				}
				stmt->Statement->Accept(this);

				loops.RemoveAt(loops.Count() - 1);
				return stmt;
			}
			virtual RefPtr<StatementSyntaxNode> VisitIfStatement(IfStatementSyntaxNode *stmt) override
			{
				if (stmt->Predicate != NULL)
					stmt->Predicate = stmt->Predicate->Accept(this).As<ExpressionSyntaxNode>();
				if (!stmt->Predicate->Type->Equals(ExpressionType::Error.Ptr()) 
					&& (!stmt->Predicate->Type->Equals(ExpressionType::Int.Ptr()) && 
						!stmt->Predicate->Type->Equals(ExpressionType::Bool.Ptr())))
					Error(30006, L"'if': expression must evaluate to int.", stmt);

				if (stmt->PositiveStatement != NULL)
					stmt->PositiveStatement->Accept(this);
				
				if (stmt->NegativeStatement != NULL)
					stmt->NegativeStatement->Accept(this);
				return stmt;
			}
			virtual RefPtr<StatementSyntaxNode> VisitReturnStatement(ReturnStatementSyntaxNode *stmt) override
			{
				if (currentCompNode && currentCompNode->BlockStatement->Statements.Count() &&
					stmt != currentCompNode->BlockStatement->Statements.Last().Ptr())
				{
					Error(30026, L"'return' can only appear as the last statement in component definition.", stmt);
				}
				if (!stmt->Expression)
				{
					if (function && !function->ReturnType->Equals(ExpressionType::Void.Ptr()))
						Error(30006, L"'return' should have an expression.", stmt);
				}
				else
				{
					stmt->Expression = stmt->Expression->Accept(this).As<ExpressionSyntaxNode>();
					if (!stmt->Expression->Type->Equals(ExpressionType::Error.Ptr()))
					{
						if (function && !MatchType_ValueReceiver(function->ReturnType.Ptr(), stmt->Expression->Type.Ptr()))
							Error(30007, L"expression type '" + stmt->Expression->Type->ToString()
								+ L"' does not match function's return type '"
								+ function->ReturnType->ToString() + L"'", stmt);
						if (currentComp && !MatchType_ValueReceiver(currentComp->Type->DataType.Ptr(), stmt->Expression->Type.Ptr()))
						{
							Error(30007, L"expression type '" + stmt->Expression->Type->ToString()
								+ L"' does not match component's type '"
								+ currentComp->Type->DataType->ToString() + L"'", stmt);
						}
						if (currentImportOperator && !MatchType_RecordType(currentImportOperator->SourceWorld.Content, stmt->Expression->Type.Ptr()))
							Error(30007, L"expression type '" + stmt->Expression->Type->ToString() + L"' does not match import operator's type '" + currentImportOperator->SourceWorld.Content
								+ L"'.", stmt);
					}
				}
				return stmt;
			}
			virtual RefPtr<StatementSyntaxNode> VisitVarDeclrStatement(VarDeclrStatementSyntaxNode *stmt) override
			{
				stmt->Type = TranslateTypeNode(stmt->TypeNode);
				if (stmt->Type->IsTexture())
				{
					Error(30033, L"cannot declare a local variable of 'texture' type.", stmt);
				}
				if (stmt->Type->AsGenericType())
				{
					Error(30033, L"cannot declare a local variable of this type.", stmt);
				}
				for (auto & para : stmt->Variables)
				{
					VariableEntry varDeclr;
					varDeclr.Name = para->Name;
					if (stmt->Scope->Variables.ContainsKey(para->Name))
						Error(30008, L"variable " + para->Name + L" already defined.", para.Ptr());

					varDeclr.Type.DataType = stmt->Type;
					if (varDeclr.Type.DataType->Equals(ExpressionType::Void.Ptr()))
						Error(30009, L"invalid type 'void'.", stmt);
					if (varDeclr.Type.DataType->IsArray() && varDeclr.Type.DataType->AsArrayType()->ArrayLength <= 0)
						Error(30025, L"array size must be larger than zero.", stmt);

					stmt->Scope->Variables.AddIfNotExists(para->Name, varDeclr);
					if (para->Expression != NULL)
					{
						para->Expression = para->Expression->Accept(this).As<ExpressionSyntaxNode>();
						if (!MatchType_ValueReceiver(varDeclr.Type.DataType.Ptr(), para->Expression->Type.Ptr())
							&& !para->Expression->Type->Equals(ExpressionType::Error.Ptr()))
						{
							Error(30019, L"type mismatch \'" + para->Expression->Type->ToString() + L"\' and \'" +
								varDeclr.Type.DataType->ToString() + L"\'", para.Ptr());
						}
					}
				}
				return stmt;
			}
			virtual RefPtr<StatementSyntaxNode> VisitWhileStatement(WhileStatementSyntaxNode *stmt) override
			{
				loops.Add(stmt);
				stmt->Predicate = stmt->Predicate->Accept(this).As<ExpressionSyntaxNode>();
				if (!stmt->Predicate->Type->Equals(ExpressionType::Error.Ptr()) && 
					!stmt->Predicate->Type->Equals(ExpressionType::Int.Ptr()) &&
					!stmt->Predicate->Type->Equals(ExpressionType::Bool.Ptr()))
					Error(30010, L"'while': expression must evaluate to int.", stmt);

				stmt->Statement->Accept(this);
				loops.RemoveAt(loops.Count() - 1);
				return stmt;
			}
			virtual RefPtr<StatementSyntaxNode> VisitExpressionStatement(ExpressionStatementSyntaxNode *stmt) override
			{
				stmt->Expression = stmt->Expression->Accept(this).As<ExpressionSyntaxNode>();
				return stmt;
			}
			virtual RefPtr<ExpressionSyntaxNode> VisitBinaryExpression(BinaryExpressionSyntaxNode *expr) override
			{
				expr->LeftExpression = expr->LeftExpression->Accept(this).As<ExpressionSyntaxNode>();
				expr->RightExpression = expr->RightExpression->Accept(this).As<ExpressionSyntaxNode>();
				auto & leftType = expr->LeftExpression->Type;
				auto & rightType = expr->RightExpression->Type;
				RefPtr<ExpressionType> matchedType;
				auto checkAssign = [&]()
				{
					if (!(leftType->AsBasicType() && leftType->AsBasicType()->IsLeftValue) &&
						!leftType->Equals(ExpressionType::Error.Ptr()))
						Error(30011, L"left of '=' is not an l-value.", expr->LeftExpression.Ptr());
					if (expr->Operator == Operator::AndAssign ||
						expr->Operator == Operator::OrAssign ||
						expr->Operator == Operator::XorAssign ||
						expr->Operator == Operator::LshAssign ||
						expr->Operator == Operator::RshAssign)
					{
						if (!(leftType->IsIntegral() && rightType->IsIntegral()))
						{
							Error(30041, L"bit operation: operand must be integral type.", expr);
						}
					}
					expr->LeftExpression->Access = ExpressionAccess::Write;
					if (MatchType_ValueReceiver(leftType.Ptr(), expr->Type.Ptr()))
						expr->Type = leftType;
					else
						expr->Type = ExpressionType::Error;
				};
				if (expr->Operator == Operator::Assign)
				{
					expr->Type = rightType;
					checkAssign();
				}
				else
				{
					List<RefPtr<ExpressionType>> argTypes;
					argTypes.Add(leftType);
					argTypes.Add(rightType);
					List<RefPtr<FunctionSymbol>> * operatorOverloads = symbolTable->FunctionOverloads.TryGetValue(GetOperatorFunctionName(expr->Operator));
					auto overload = FindFunctionOverload(*operatorOverloads, [](RefPtr<FunctionSymbol> f)
					{
						return f->SyntaxNode->Parameters;
					}, argTypes);
					if (!overload)
					{
						expr->Type = ExpressionType::Error;
						if (!leftType->Equals(ExpressionType::Error.Ptr()) && !rightType->Equals(ExpressionType::Error.Ptr()))
							Error(30012, L"no overload found for operator " + OperatorToString(expr->Operator) + L" (" + leftType->ToString() + L", "
								+ rightType->ToString() + L").", expr);
					}
					else
					{
						expr->Type = overload->SyntaxNode->ReturnType;
					}
					if (expr->Operator > Operator::Assign)
						checkAssign();
				}
				return expr;
			}
			virtual RefPtr<ExpressionSyntaxNode> VisitConstantExpression(ConstantExpressionSyntaxNode *expr) override
			{
				switch (expr->ConstType)
				{
				case ConstantExpressionSyntaxNode::ConstantType::Int:
					expr->Type = ExpressionType::Int;
					break;
				case ConstantExpressionSyntaxNode::ConstantType::Bool:
					expr->Type = ExpressionType::Bool;
					break;
				case ConstantExpressionSyntaxNode::ConstantType::Float:
					expr->Type = ExpressionType::Float;
					break;
				default:
					expr->Type = ExpressionType::Error;
					throw "Invalid constant type.";
					break;
				}
				return expr;
			}
			virtual RefPtr<ExpressionSyntaxNode> VisitIndexExpression(IndexExpressionSyntaxNode *expr) override
			{
				expr->BaseExpression = expr->BaseExpression->Accept(this).As<ExpressionSyntaxNode>();
				expr->IndexExpression = expr->IndexExpression->Accept(this).As<ExpressionSyntaxNode>();
				if (expr->BaseExpression->Type->Equals(ExpressionType::Error.Ptr()))
					expr->Type = ExpressionType::Error;
				else
				{
					auto & baseExprType = expr->BaseExpression->Type;
					bool isError = baseExprType->AsGenericType() &&
							(baseExprType->AsGenericType()->GenericTypeName != L"ArrayBuffer" ||
							 baseExprType->AsGenericType()->GenericTypeName != L"PackedBuffer");
					isError = isError || (baseExprType->AsBasicType() && GetVectorSize(baseExprType->AsBasicType()->BaseType) == 0);
					if (isError)
					{
						Error(30013, L"'[]' can only index on arrays.", expr);
						expr->Type = ExpressionType::Error;
					}
					if (!expr->IndexExpression->Type->Equals(ExpressionType::Int.Ptr()) && 
						!expr->IndexExpression->Type->Equals(ExpressionType::UInt.Ptr()))
					{
						Error(30014, L"index expression must evaluate to int.", expr);
						expr->Type = ExpressionType::Error;
					}
				}
				if (expr->BaseExpression->Type->IsArray())
				{
					expr->Type = expr->BaseExpression->Type->AsArrayType()->BaseType;
				}
				else if (auto genType = expr->BaseExpression->Type->AsGenericType())
				{
					expr->Type = genType->BaseType;
				}
				else if (auto basicType = expr->BaseExpression->Type->AsBasicType())
				{
					if (basicType->BaseType == BaseType::Float3x3)
						expr->Type = ExpressionType::Float3;
					else if (basicType->BaseType == BaseType::Float4x4)
						expr->Type = ExpressionType::Float4;
					else
						expr->Type = new BasicExpressionType(GetVectorBaseType(basicType->BaseType));
				}
				expr->Type = expr->Type->Clone();
				if (auto basicType = expr->Type->AsBasicType())
				{
					basicType->IsLeftValue = true;
					basicType->IsReference = true;
				}
				return expr;
			}
			bool MatchArguments(FunctionSyntaxNode * functionNode, List <RefPtr<ExpressionSyntaxNode>> &args)
			{
				if (functionNode->Parameters.Count() != args.Count())
					return false;
				for (int i = 0; i < functionNode->Parameters.Count(); i++)
				{
					if (!functionNode->Parameters[i]->Type->Equals(args[i]->Type.Ptr()))
						return false;
				}
				return true;
			}

			template<typename GetParamFunc, typename PFuncT>
			PFuncT FindFunctionOverload(const List<PFuncT> & funcs, const GetParamFunc & getParam, const List<RefPtr<ExpressionType>> & arguments)
			{
				int bestMatchConversions = 1 << 30;
				PFuncT func = nullptr;
				for (auto & f : funcs)
				{
					auto params = getParam(f);
					if (params.Count() == arguments.Count())
					{
						int conversions = 0;
						bool match = true;
						for (int i = 0; i < arguments.Count(); i++)
						{
							auto argType = arguments[i];
							auto paramType = params[i]->Type;
							if (argType->Equals(paramType.Ptr()))
								continue;
							else if (MatchType_ValueReceiver(paramType.Ptr(), argType.Ptr()))
							{
								conversions++;
								continue;
							}
							else
							{
								match = false;
								break;
							}
						}
						if (match && conversions < bestMatchConversions)
						{
							func = f;
							bestMatchConversions = conversions;
						}
					}
				}
				return func;
			}

			ShaderComponentSymbol * ResolveFunctionComponent(ShaderSymbol * shader, String name, const List<RefPtr<ExpressionType>> & args, bool topLevel = true)
			{
				auto list = shader->FunctionComponents.TryGetValue(name);
				if (list)
				{
					auto func = FindFunctionOverload(*list, [](RefPtr<ShaderComponentSymbol> & comp)
					{
						return comp->Implementations.First()->SyntaxNode->Parameters;
					}, args);
					if (func)
					{
						return func.Ptr();
					}
				}
				for (auto & module : shader->ShaderUsings)
				{
					if (module.IsPublic || topLevel)
					{
						auto func = ResolveFunctionComponent(module.Shader, name, args, false);
						if (func)
							return func;
					}
				}
				return nullptr;
			}

			ShaderComponentSymbol * ResolveFunctionComponent(ShaderSymbol * shader, String name, const List<RefPtr<ExpressionSyntaxNode>> & args, bool topLevel = true)
			{
				return ResolveFunctionComponent(shader, name, From(args).Select([](RefPtr<ExpressionSyntaxNode> x) {return x->Type; }).ToList(), topLevel);
			}

			RefPtr<ExpressionSyntaxNode> ResolveFunctionOverload(InvokeExpressionSyntaxNode * invoke, MemberExpressionSyntaxNode* memberExpr, List<RefPtr<ExpressionSyntaxNode>> & arguments)
			{
				err->PushState();
				memberExpr->BaseExpression->Accept(this);
				err->PopState();
				if (memberExpr->BaseExpression->Type->IsShader())
				{
					auto basicType = memberExpr->BaseExpression->Type->AsBasicType();
					auto func = ResolveFunctionComponent(basicType->Shader, memberExpr->MemberName, arguments);
					if (func)
					{
						auto funcType = new BasicExpressionType();
						funcType->BaseType = BaseType::Function;
						funcType->Component = func;
						memberExpr->Type = funcType;
						memberExpr->MemberName = func->Name;
						invoke->Type = func->Implementations.First()->SyntaxNode->Type;
						return invoke;
					}
				}
				return invoke;
			}

			RefPtr<ExpressionSyntaxNode> ResolveFunctionOverload(InvokeExpressionSyntaxNode * invoke, VarExpressionSyntaxNode* varExpr, List<RefPtr<ExpressionSyntaxNode>> & arguments)
			{
				if (currentShader)
				{
					auto func = ResolveFunctionComponent(currentShader, varExpr->Variable, arguments);
					if (func)
					{
						auto funcType = new BasicExpressionType();
						funcType->BaseType = BaseType::Function;
						funcType->Component = func;
						varExpr->Type = funcType;
						invoke->Type = func->Implementations.First()->SyntaxNode->Type;
						return invoke;
					}
				}
				// check if this is an import operator call
				if (currentShader && currentCompNode && arguments.Count() > 0 && currentShader->Pipeline)
				{
					if (auto impOpList = currentShader->Pipeline->ImportOperators.TryGetValue(varExpr->Variable))
					{
						// component with explicit import operator call must be qualified with explicit rate
						if (!currentCompNode->Rate)
						{
							Error(33071, L"cannot call an import operator from an auto-placed component '" + currentCompNode->Name.Content + L"'. try qualify the component with explicit worlds.",
								varExpr);
							invoke->Type = ExpressionType::Error;
							return invoke;
						}
						// for now we do not support calling import operator from a multi-world component definition
						if (currentCompNode->Rate->Worlds.Count() > 1)
							Error(33073, L"cannot call an import operator from a multi-world component definition. consider qualify the component with only one explicit world.",
								varExpr);
						auto validOverloads = From(*impOpList).Where([&](RefPtr<ImportOperatorDefSyntaxNode> imp) { return imp->DestWorld.Content == currentCompNode->Rate->Worlds.First().World.Content; }).ToList();
						auto func = FindFunctionOverload(validOverloads, [](RefPtr<ImportOperatorDefSyntaxNode> imp)
						{
							return imp->Parameters;
						}, From(arguments).Skip(1).Select([](RefPtr<ExpressionSyntaxNode> x) {return x->Type; }).ToList());
						if (func)
						{
							RefPtr<ImportExpressionSyntaxNode> importExpr = new ImportExpressionSyntaxNode();
							importExpr->Position = varExpr->Position;
							importExpr->Component = arguments[0];
							CloneContext cloneCtx;
							importExpr->ImportOperatorDef = func->Clone(cloneCtx);
							importExpr->ImportOperatorDef->Scope->Parent = varExpr->Scope->Parent;
							importExpr->Type = arguments[0]->Type->Clone();
							importExpr->Scope = varExpr->Scope;
							importExpr->Access = ExpressionAccess::Read;
							for (int i = 1; i < arguments.Count(); i++)
								importExpr->Arguments.Add(arguments[i]);
							return importExpr;
						}
						else
						{
							StringBuilder argList;
							for (int i = 1; i < arguments.Count(); i++)
							{
								argList << arguments[i]->Type->ToString();
								if (i != arguments.Count() - 1)
									argList << L", ";
							}
							Error(33072, L"'" + varExpr->Variable + L"' is an import operator defined in pipeline '" + currentShader->Pipeline->SyntaxNode->Name.Content
								+ L"', but none of the import operator overloads matches argument list '(" +
								argList.ProduceString() + L"').",
								varExpr);
							invoke->Type = ExpressionType::Error;
						}
						return invoke;
					}
				}
				// this is not an import operator call, resolve as function call
				bool found = false;
				bool functionNameFound = false;
				RefPtr<FunctionSymbol> func;
				varExpr->Variable = TranslateHLSLTypeNames(varExpr->Variable);

				if (varExpr->Variable == L"texture" && arguments.Count() > 0 &&
					arguments[0]->Type->IsGenericType(L"Texture"))
				{
					if (arguments.Count() != 2)
					{
						invoke->Type = ExpressionType::Error;
						found = false;
					}
					else
					{
						if (auto genType = arguments[0]->Type->AsGenericType())
						{
							invoke->Type = genType->BaseType;
							if (!arguments[1]->Type->Equals(ExpressionType::Float2.Ptr()))
							{
								found = false;
								invoke->Type = ExpressionType::Error;
							}
						}
						else
						{
							invoke->Type = ExpressionType::Error;
							found = false;
						}
					}
					auto funcType = new BasicExpressionType(BaseType::Function);
					funcType->Func = symbolTable->FunctionOverloads[L"texture"]().First().Ptr();
					varExpr->Type = funcType;
				}
				else
				{
					// find function overload with implicit argument type conversions
					auto namePrefix = varExpr->Variable + L"@";
					List<RefPtr<FunctionSymbol>> * functionOverloads = symbolTable->FunctionOverloads.TryGetValue(varExpr->Variable);
					if (functionOverloads)
					{
						func = FindFunctionOverload(*functionOverloads, [](RefPtr<FunctionSymbol> f)
						{
							return f->SyntaxNode->Parameters;
						}, From(arguments).Select([](RefPtr<ExpressionSyntaxNode> x) {return x->Type; }).ToList());
						functionNameFound = true;
					}
				}
				if (func)
				{
					if (!func->SyntaxNode->IsExtern)
					{
						varExpr->Variable = func->SyntaxNode->InternalName;
						if (currentFunc)
							currentFunc->ReferencedFunctions.Add(func->SyntaxNode->InternalName);
					}
					invoke->Type = func->SyntaxNode->ReturnType;
					auto funcType = new BasicExpressionType();
					funcType->BaseType = BaseType::Function;
					funcType->Func = func.Ptr();
					varExpr->Type = funcType;
					found = true;
				}
				if (!found)
				{
					invoke->Type = ExpressionType::Error;
					StringBuilder argList;
					for (int i = 0; i < arguments.Count(); i++)
					{
						argList << arguments[i]->Type->ToString();
						if (i != arguments.Count() - 1)
							argList << L", ";
					}
					if (functionNameFound)
						Error(30021, varExpr->Variable + L": no overload takes arguments (" + argList.ProduceString() + L")", varExpr);
					else
						Error(30015, L"undefined identifier '" + varExpr->Variable + L"'.", varExpr);
				}
				return invoke;
			}

			RefPtr<ExpressionSyntaxNode> ResolveInvoke(InvokeExpressionSyntaxNode * expr)
			{
				if (auto varExpr = expr->FunctionExpr.As<VarExpressionSyntaxNode>())
				{
					return ResolveFunctionOverload(expr, varExpr.Ptr(), expr->Arguments);
				}
				else if (auto memberExpr = expr->FunctionExpr.As<MemberExpressionSyntaxNode>())
				{
					return ResolveFunctionOverload(expr, memberExpr.Ptr(), expr->Arguments);
				}
				else
				{
					Error(33070, L"expression preceding parenthesis of apparent call must have function type.", expr->FunctionExpr.Ptr());
					expr->Type = ExpressionType::Error;
				}
				return expr;
			}

			virtual RefPtr<ExpressionSyntaxNode> VisitInvokeExpression(InvokeExpressionSyntaxNode *expr) override
			{
				for (auto & arg : expr->Arguments)
					arg = arg->Accept(this).As<ExpressionSyntaxNode>();

				return ResolveInvoke(expr);
			}

			String OperatorToString(Operator op)
			{
				switch (op)
				{
				case Spire::Compiler::Operator::Neg:
					return L"-";
				case Spire::Compiler::Operator::Not:
					return L"!";
				case Spire::Compiler::Operator::PreInc:
					return L"++";
				case Spire::Compiler::Operator::PreDec:
					return L"--";
				case Spire::Compiler::Operator::PostInc:
					return L"++";
				case Spire::Compiler::Operator::PostDec:
					return L"--";
				case Spire::Compiler::Operator::Mul:
				case Spire::Compiler::Operator::MulAssign:
					return L"*";
				case Spire::Compiler::Operator::Div:
				case Spire::Compiler::Operator::DivAssign:
					return L"/";
				case Spire::Compiler::Operator::Mod:
				case Spire::Compiler::Operator::ModAssign:
					return L"%";
				case Spire::Compiler::Operator::Add:
				case Spire::Compiler::Operator::AddAssign:
					return L"+";
				case Spire::Compiler::Operator::Sub:
				case Spire::Compiler::Operator::SubAssign:
					return L"-";
				case Spire::Compiler::Operator::Lsh:
				case Spire::Compiler::Operator::LshAssign:
					return L"<<";
				case Spire::Compiler::Operator::Rsh:
				case Spire::Compiler::Operator::RshAssign:
					return L">>";
				case Spire::Compiler::Operator::Eql:
					return L"==";
				case Spire::Compiler::Operator::Neq:
					return L"!=";
				case Spire::Compiler::Operator::Greater:
					return L">";
				case Spire::Compiler::Operator::Less:
					return L"<";
				case Spire::Compiler::Operator::Geq:
					return L">=";
				case Spire::Compiler::Operator::Leq:
					return L"<=";
				case Spire::Compiler::Operator::BitAnd:
				case Spire::Compiler::Operator::AndAssign:
					return L"&";
				case Spire::Compiler::Operator::BitXor:
				case Spire::Compiler::Operator::XorAssign:
					return L"^";
				case Spire::Compiler::Operator::BitOr:
				case Spire::Compiler::Operator::OrAssign:
					return L"|";
				case Spire::Compiler::Operator::And:
					return L"&&";
				case Spire::Compiler::Operator::Or:
					return L"||";
				case Spire::Compiler::Operator::Assign:
					return L"=";
				default:
					return L"ERROR";
				}
			}
			virtual RefPtr<ExpressionSyntaxNode> VisitUnaryExpression(UnaryExpressionSyntaxNode *expr) override
			{
				expr->Expression = expr->Expression->Accept(this).As<ExpressionSyntaxNode>();
				List<RefPtr<ExpressionType>> argTypes;
				argTypes.Add(expr->Expression->Type);
				List<RefPtr<FunctionSymbol>> * operatorOverloads = symbolTable->FunctionOverloads.TryGetValue(GetOperatorFunctionName(expr->Operator));
				auto overload = FindFunctionOverload(*operatorOverloads, [](RefPtr<FunctionSymbol> f)
				{
					return f->SyntaxNode->Parameters;
				}, argTypes);
				if (!overload)
				{
					expr->Type = ExpressionType::Error;
					if (!expr->Expression->Type->Equals(ExpressionType::Error.Ptr()))
						Error(30012, L"no overload found for operator " + OperatorToString(expr->Operator) + L" (" + expr->Expression->Type->ToString() + L").", expr);
				}
				else
				{
					expr->Type = overload->SyntaxNode->ReturnType;
				}
				return expr;
			}
			virtual RefPtr<ExpressionSyntaxNode> VisitVarExpression(VarExpressionSyntaxNode *expr) override
			{
				VariableEntry variable;
				ShaderUsing shaderObj;
				expr->Type = ExpressionType::Error;
				if (expr->Scope->FindVariable(expr->Variable, variable))
				{
					expr->Type = variable.Type.DataType->Clone();
					if (auto basicType = expr->Type->AsBasicType())
						basicType->IsLeftValue = !variable.IsComponent;
				}
				else if (currentShader && currentShader->ShaderObjects.TryGetValue(expr->Variable, shaderObj))
				{
					auto basicType = new BasicExpressionType(BaseType::Shader);
					basicType->Shader = shaderObj.Shader;
					basicType->IsLeftValue = false;
					expr->Type = basicType;
				}
				else if (currentPipeline && currentImportOperator)
				{
					RefPtr<ShaderComponentSymbol> comp;
					if (currentPipeline->Components.TryGetValue(expr->Variable, comp))
					{
						currentImportOperator->Usings.Add(comp->Name);
						expr->Type = comp->Type->DataType;
					}
					else
						Error(30015, L"undefined identifier \'" + expr->Variable + L"\'", expr);
				}
				else if (currentShader)
				{
					auto compRef = currentShader->ResolveComponentReference(expr->Variable);
					if (compRef.IsAccessible)
					{
						expr->Type = compRef.Component->Type->DataType->Clone();
						if (auto basicType = expr->Type->AsBasicType())
							basicType->IsLeftValue = false;
					}
					else if (compRef.Component)
					{
						Error(30017, L"component \'" + expr->Variable + L"\' is not accessible from shader '" + currentShader->SyntaxNode->Name.Content + L"'.", expr);
					}
					else
						Error(30015, L"undefined identifier \'" + expr->Variable + L"\'", expr);
					expr->Tags[L"ComponentReference"] = new ComponentReferenceObject(compRef.Component);
				}
				else
					Error(30015, L"undefined identifier \'" + expr->Variable + L"\'", expr);

				if (expr->Type->IsGenericType(L"Uniform") || expr->Type->IsGenericType(L"Patch") || expr->Type->IsGenericType(L"StorageBuffer"))
					expr->Type = expr->Type->AsGenericType()->BaseType;

				return expr;
			}
			virtual RefPtr<ExpressionSyntaxNode> VisitTypeCastExpression(TypeCastExpressionSyntaxNode * expr) override
			{
				expr->Expression = expr->Expression->Accept(this).As<ExpressionSyntaxNode>();
				auto targetType = TranslateTypeNode(expr->TargetType);
				
				if (!expr->Expression->Type->Equals(ExpressionType::Error.Ptr()) && targetType->AsBasicType())
				{
					if (!expr->Expression->Type->AsBasicType())
						expr->Type = ExpressionType::Error;
					else if (!IsNumeric(GetVectorBaseType(expr->Expression->Type->AsBasicType()->BaseType)) 
						|| !IsNumeric(GetVectorBaseType(targetType->AsBasicType()->BaseType)))
						expr->Type = ExpressionType::Error;
					else if (targetType->AsBasicType()->BaseType == BaseType::Void || expr->Expression->Type->AsBasicType()->BaseType == BaseType::Void)
						expr->Type = ExpressionType::Error;
					else
						expr->Type = targetType;
				}
				else
					expr->Type = ExpressionType::Error;
				if (expr->Type->Equals(ExpressionType::Error.Ptr()) && !expr->Expression->Type->Equals(ExpressionType::Error.Ptr()))
				{
					Error(30022, L"invalid type cast between \"" + expr->Expression->Type->ToString() + L"\" and \"" +
						targetType->ToString() + L"\".", expr);
				}
				return expr;
			}
			virtual RefPtr<ExpressionSyntaxNode> VisitSelectExpression(SelectExpressionSyntaxNode * expr) override
			{
				expr->SelectorExpr = expr->SelectorExpr->Accept(this).As<ExpressionSyntaxNode>();
				if (!expr->SelectorExpr->Type->Equals(ExpressionType::Int.Ptr()) && !expr->SelectorExpr->Type->Equals(ExpressionType::Bool.Ptr()) 
					&& !expr->SelectorExpr->Type->Equals(ExpressionType::Error.Ptr()))
				{
					expr->Type = ExpressionType::Error;
					Error(30079, L"selector must evaluate to bool.", expr);
				}
				expr->Expr0 = expr->Expr0->Accept(this).As<ExpressionSyntaxNode>();
				expr->Expr1 = expr->Expr1->Accept(this).As<ExpressionSyntaxNode>();
				if (!expr->Expr0->Type->Equals(expr->Expr1->Type.Ptr()))
				{
					Error(30080, L"the two value expressions in a select clause must have same type.", expr);
				}
				expr->Type = expr->Expr0->Type;
				return expr;
			}
			virtual RefPtr<ExpressionSyntaxNode> VisitMemberExpression(MemberExpressionSyntaxNode * expr) override
			{
				expr->BaseExpression = expr->BaseExpression->Accept(this).As<ExpressionSyntaxNode>();
				auto & baseType = expr->BaseExpression->Type;
				if (!baseType->AsBasicType())
					expr->Type = ExpressionType::Error;
				else if (IsVector(baseType->AsBasicType()->BaseType))
				{
					Array<int, 4> children;
					if (expr->MemberName.Length() > 4)
						expr->Type = ExpressionType::Error;
					else
					{
						bool error = false;

						for (int i = 0; i < expr->MemberName.Length(); i++)
						{
							auto ch = expr->MemberName[i];
							switch (ch)
							{
							case L'x':
							case L'r':
								children.Add(0);
								break;
							case L'y':
							case L'g':
								children.Add(1);
								break;
							case L'z':
							case L'b':
								children.Add(2);
								break;
							case L'w':
							case L'a':
								children.Add(3);
								break;
							default:
								error = true;
								expr->Type = ExpressionType::Error;
								break;
							}
						}
						int vecLen = GetVectorSize(baseType->AsBasicType()->BaseType);
						for (auto m : children)
						{
							if (m >= vecLen)
							{
								error = true;
								expr->Type = ExpressionType::Error;
								break;
							}
						}
						if ((vecLen == 9 || vecLen == 16) && children.Count() > 1)
						{
							error = true;
							expr->Type = ExpressionType::Error;
						}
						if (!error)
						{
							if (vecLen == 9)
								expr->Type = new BasicExpressionType((BaseType)((int)GetVectorBaseType(baseType->AsBasicType()->BaseType) + 2));
							else if (vecLen == 16)
								expr->Type = new BasicExpressionType((BaseType)((int)GetVectorBaseType(baseType->AsBasicType()->BaseType) + 3));
							else
							{
								expr->Type = new BasicExpressionType((BaseType)((int)GetVectorBaseType(baseType->AsBasicType()->BaseType) + children.Count() - 1));
							}
							expr->Type->AsBasicType()->IsMaskedVector = true;
						}
						if (auto bt = expr->Type->AsBasicType())
						{
							bt->IsLeftValue = !baseType->AsBasicType()->IsMaskedVector;
							if (children.Count() > vecLen || children.Count() == 0)
								bt->IsLeftValue = false;
							int curMax = children[0];
							for (int i = 0; i < children.Count(); i++)
								if (children[i] < curMax)
								{
									bt->IsLeftValue = false;
									curMax = children[i];
								}
						}
					}
				}
				else if (baseType->AsBasicType()->BaseType == BaseType::Shader)
				{
					ShaderUsing shaderObj;
					auto refComp = baseType->AsBasicType()->Shader->ResolveComponentReference(expr->MemberName);
					if (refComp.IsAccessible)
						expr->Type = refComp.Component->Type->DataType;
					else if (baseType->AsBasicType()->Shader->ShaderObjects.TryGetValue(expr->MemberName, shaderObj))
					{
						if (shaderObj.IsPublic)
						{
							auto shaderType = new BasicExpressionType(BaseType::Shader);
							shaderType->Shader = shaderObj.Shader;
							expr->Type = shaderType;
						}
						else
							expr->Type = ExpressionType::Error;
					}
					else
						expr->Type = ExpressionType::Error;
					expr->Tags[L"ComponentReference"] = new ComponentReferenceObject(refComp.Component);
				}
				else if (baseType->IsStruct())
				{
					int id = baseType->AsBasicType()->Struct->SyntaxNode->FindField(expr->MemberName);
					if (id == -1)
					{
						expr->Type = ExpressionType::Error;
						Error(30027, L"\'" + expr->MemberName + L"\' is not a member of \'" +
							baseType->AsBasicType()->Struct->Name + L"\'.", expr);
					}
					else
						expr->Type = baseType->AsBasicType()->Struct->SyntaxNode->Fields[id]->Type;
					if (auto bt = expr->Type->AsBasicType())
					{
						bt->IsLeftValue = baseType->AsBasicType()->IsLeftValue;
					}
				}
				else
					expr->Type = ExpressionType::Error;
				if (!baseType->Equals(ExpressionType::Error.Ptr()) &&
					expr->Type->Equals(ExpressionType::Error.Ptr()))
				{
					Error(30023, L"\"" + baseType->ToString() + L"\" does not have public member \"" +
						expr->MemberName + L"\".", expr);
				}
				return expr;
			}
			SemanticsVisitor & operator = (const SemanticsVisitor &) = delete;
		};

		SyntaxVisitor * CreateSemanticsVisitor(SymbolTable * symbols, ErrorWriter * err)
		{
			return new SemanticsVisitor(symbols, err);
		}
		
	}
}

/***********************************************************************
SPIRECORE\SHADERCOMPILER.CPP
***********************************************************************/
// Compiler.cpp : Defines the entry point for the console application.
//

#ifdef CreateDirectory
#undef CreateDirectory
#endif

using namespace CoreLib::Basic;
using namespace CoreLib::IO;
using namespace Spire::Compiler;

namespace Spire
{
	namespace Compiler
	{
		int compilerInstances = 0;

		class ShaderCompilerImpl : public ShaderCompiler
		{
		private:
			Dictionary<String, RefPtr<CodeGenBackend>> backends;

			void ResolveAttributes(SymbolTable * symTable)
			{
				for (auto & shader : symTable->ShaderDependenceOrder)
				{
					auto comps = shader->GetComponentDependencyOrder();
					for (auto & comp : comps)
					{
						for (auto & impl : comp->Implementations)
							for (auto & attrib : impl->SyntaxNode->LayoutAttributes)
							{
								try
								{
									if (attrib.Value.StartsWith(L"%"))
									{
										CoreLib::Text::Parser parser(attrib.Value.SubString(1, attrib.Value.Length() - 1));
										auto compName = parser.ReadWord();
										parser.Read(L".");
										auto compAttrib = parser.ReadWord();
										RefPtr<ShaderComponentSymbol> compSym;
										if (shader->Components.TryGetValue(compName, compSym))
										{
											for (auto & timpl : compSym->Implementations)
											{
												String attribValue;
												if (timpl->SyntaxNode->LayoutAttributes.TryGetValue(compAttrib, attribValue))
													attrib.Value = attribValue;
											}
										}
									}
								}
								catch (Exception)
								{
								}
							}
					}
				}
			}

			/* Generate a shader variant by applying mechanic choice rules and the choice file.
			   The choice file provides "preferred" definitions, as represented in ShaderComponentSymbol::Type::PinnedWorlds
		       The process resolves the component references by picking a pinned definition if one is available, or a definition
			   with the preferred import path as defined by import operator ordering.
			   After all references are resolved, all unreferenced definitions (dead code) are eliminated, 
			   resulting a shader variant ready for code generation.
			*/
			RefPtr<ShaderIR> GenerateShaderVariantIR(CompileResult & cresult, ShaderClosure * shader, Schedule & schedule, SymbolTable * symbolTable)
			{
				RefPtr<ShaderIR> result = new ShaderIR();
				result->Shader = shader;
				result->SymbolTable = symbolTable;
				// mark pinned worlds
				for (auto & comp : shader->Components)
				{
					for (auto & impl : comp.Value->Implementations)
					{
						for (auto & w : impl->Worlds)
						{
							if (impl->SrcPinnedWorlds.Contains(w) || impl->SyntaxNode->IsInline || impl->ExportWorlds.Contains(w) || impl->SyntaxNode->IsInput)
							{
								comp.Value->Type->PinnedWorlds.Add(w);
							}
						}
					}
				}
				// apply choices
				Dictionary<String, ShaderComponentSymbol*> choiceComps;
				for (auto & comp : shader->AllComponents)
				{
					for (auto & choiceName : comp.Value->ChoiceNames)
						choiceComps[choiceName] = comp.Value;
				}
				HashSet<ShaderComponentImplSymbol*> pinnedImpl;
				for (auto & choice : schedule.Choices)
				{
					ShaderComponentSymbol * comp = nullptr;
					if (choiceComps.TryGetValue(choice.Key, comp))
					{
						comp->Type->PinnedWorlds.Clear();
						for (auto & selectedDef : choice.Value)
						{
							if (comp->Type->ConstrainedWorlds.Contains(selectedDef->WorldName))
							{
								comp->Type->PinnedWorlds.Add(selectedDef->WorldName);
								// find specified impl
								for (auto & impl : comp->Implementations)
								{
									if (impl->AlternateName == selectedDef->AlternateName && impl->Worlds.Contains(selectedDef->WorldName))
										pinnedImpl.Add(impl.Ptr());
								}
							}
							else
							{
								cresult.GetErrorWriter()->Warning(33101, L"'" + selectedDef->WorldName + L"' is not a valid choice for '" + choice.Key
									+ L"'.", selectedDef.Ptr()->Position);
							}
						}
					}
				}
				for (auto & attribs : schedule.AddtionalAttributes)
				{
					ShaderComponentSymbol * comp = nullptr;
					if (choiceComps.TryGetValue(attribs.Key, comp))
					{
						// apply attributes
						for (auto & impl : comp->Implementations)
						{
							for (auto & attrib : attribs.Value)
								impl->SyntaxNode->LayoutAttributes[attrib.Key] = attrib.Value;
						}
					}
				}
				// generate definitions
				for (auto & comp : shader->AllComponents)
				{
					EnumerableDictionary<String, ComponentDefinitionIR*> defs;
					Dictionary<String, ShaderComponentImplSymbol*> impls;
					for (auto & impl : comp.Value->Implementations)
					{
						for (auto & w : impl->Worlds)
						{
							RefPtr<ComponentDefinitionIR> def = new ComponentDefinitionIR();
							def->OriginalName = comp.Value->Name;
							def->UniqueKey = comp.Value->UniqueKey;
							def->UniqueName = comp.Value->UniqueName;
							def->Type = comp.Value->Type->DataType;
							def->IsEntryPoint = (impl->ExportWorlds.Contains(w) ||
								(shader->Pipeline->IsAbstractWorld(w) &&
								(impl->SyntaxNode->LayoutAttributes.ContainsKey(L"Pinned") || shader->Pipeline->Worlds[w]().SyntaxNode->LayoutAttributes.ContainsKey(L"Pinned"))));
							CloneContext cloneCtx;
							def->SyntaxNode = impl->SyntaxNode->Clone(cloneCtx);
							def->World = w;
							result->Definitions.Add(def);
							bool existingDefIsPinned = false;
							if (defs.ContainsKey(w))
								existingDefIsPinned = pinnedImpl.Contains(impls[w]());
							if (!existingDefIsPinned)
							{
								defs[w] = def.Ptr();
								impls[w] = impl.Ptr();
							}
						}
					}
					result->DefinitionsByComponent[comp.Key] = defs;
				}
				bool changed = true;
				while (changed)
				{
					changed = false;
					result->ResolveComponentReference();
					result->EliminateDeadCode();
					// check circular references
					for (auto & def : result->Definitions)
					{
						if (def->Dependency.Contains(def.Ptr()))
						{
							cresult.GetErrorWriter()->Error(33102, L"component definition \'" + def->OriginalName + L"\' involves circular reference.",
								def->SyntaxNode->Position);
							return nullptr;
						}
					}
					/*
					// eliminate redundant (downstream) definitions, one at a time
					auto comps = result->GetComponentDependencyOrder();
					for (int i = comps.Count() - 1; i >= 0; i--)
					{
						auto comp = comps[i];
						auto & defs = result->DefinitionsByComponent[comp->UniqueName]();
						EnumerableHashSet<ComponentDefinitionIR*> removedDefs;
						for (auto & def : defs)
							if (!def.Value->IsEntryPoint && !comp->Type->PinnedWorlds.Contains(def.Value->World))
							{
								for (auto & otherDef : defs)
								{
									if (otherDef.Value != def.Value && !removedDefs.Contains(otherDef.Value)
										&& shader->Pipeline->IsWorldReachable(otherDef.Value->World, def.Value->World))
									{
										removedDefs.Add(def.Value);
										break;
									}
								}
							}
						if (removedDefs.Count())
						{
							result->RemoveDefinitions([&](ComponentDefinitionIR* def) {return removedDefs.Contains(def); });
							changed = true;
						}
					}
					*/
				}
				return result;
			}
		public:
			virtual CompileUnit Parse(CompileResult & result, String source, String fileName) override
			{
				result.Success = false;
				Lexer lexer;
				auto tokens = lexer.Parse(fileName, source, result.ErrorList);
				Parser parser(tokens, result.ErrorList, fileName);
				CompileUnit rs;
				rs.SyntaxNode = parser.Parse();
				return rs;
			}
			virtual void Compile(CompileResult & result, CompilationContext & context, List<CompileUnit> & units, const CompileOptions & options) override
			{
				result.Success = false;
				RefPtr<ProgramSyntaxNode> programSyntaxNode = new ProgramSyntaxNode();
				for (auto & unit : units)
				{
					programSyntaxNode->Include(unit.SyntaxNode.Ptr());
				}

				SymbolTable & symTable = context.Symbols;
				auto & shaderClosures = context.ShaderClosures;
				RefPtr<SyntaxVisitor> visitor = CreateSemanticsVisitor(&symTable, result.GetErrorWriter());
				try
				{
					programSyntaxNode->Accept(visitor.Ptr());
					visitor = nullptr;
					if (result.ErrorList.Count() > 0)
						return;
					symTable.EvalFunctionReferenceClosure();
					if (result.ErrorList.Count() > 0)
						return;

					for (auto & shader : symTable.ShaderDependenceOrder)
					{
						if (shader->IsAbstract)
							continue;
						if (!shaderClosures.ContainsKey(shader->SyntaxNode->Name.Content))
						{
							auto shaderClosure = CreateShaderClosure(result.GetErrorWriter(), &symTable, shader);
							FlattenShaderClosure(result.GetErrorWriter(), &symTable, shaderClosure.Ptr());
							shaderClosures.Add(shader->SyntaxNode->Name.Content, shaderClosure);
						}
					}
					
					ResolveAttributes(&symTable);

					if (result.ErrorList.Count() > 0)
						return;
					CodeGenBackend * backend = nullptr;
					switch(options.Target)
					{
					case CodeGenTarget::SPIRV:
						backend = backends[L"spirv"]().Ptr();
						break;
					case CodeGenTarget::GLSL:
						backend = backends[L"glsl"]().Ptr();
						break;
					case CodeGenTarget::HLSL:
						backend = backends[L"hlsl"]().Ptr();
						break;
					default:
						// TODO: emit an appropriate diagnostic
						return;
					}

					Schedule schedule;
					if (options.ScheduleSource != L"")
					{
						schedule = Schedule::Parse(options.ScheduleSource, options.ScheduleFileName, result.ErrorList);
					}
					for (auto shader : shaderClosures)
					{
						// generate shader variant from schedule file, and also apply mechanic deduction rules
						if (!shader.Value->IR)
							shader.Value->IR = GenerateShaderVariantIR(result, shader.Value.Ptr(), schedule, &symTable);
					}
					if (options.Mode == CompilerMode::ProduceShader)
					{
						if (result.ErrorList.Count() > 0)
							return;
						// generate IL code
						
						RefPtr<ICodeGenerator> codeGen = CreateCodeGenerator(&symTable, result);
						if (context.Program)
						{
							result.Program->Functions = context.Program->Functions;
							result.Program->Shaders = context.Program->Shaders;
							result.Program->Structs = context.Program->Structs;
							result.Program->ConstantPool = context.Program->ConstantPool;
						}
						for (auto & s : programSyntaxNode->Structs)
							codeGen->ProcessStruct(s.Ptr());

						for (auto & func : programSyntaxNode->Functions)
							codeGen->ProcessFunction(func.Ptr());
						for (auto & shader : shaderClosures)
						{
							InsertImplicitImportOperators(shader.Value->IR.Ptr());
						}
						if (result.ErrorList.Count() > 0)
							return;
						for (auto & shader : shaderClosures)
						{
							codeGen->ProcessShader(shader.Value->IR.Ptr());
						}
						if (result.ErrorList.Count() > 0)
							return;
						// emit target code
						EnumerableHashSet<String> symbolsToGen;
						for (auto & unit : units)
						{
							for (auto & shader : unit.SyntaxNode->Shaders)
								if (!shader->IsModule)
									symbolsToGen.Add(shader->Name.Content);
							for (auto & func : unit.SyntaxNode->Functions)
								symbolsToGen.Add(func->Name);
						}
						auto IsSymbolToGen = [&](String & shaderName)
						{
							if (symbolsToGen.Contains(shaderName))
								return true;
							for (auto & symbol : symbolsToGen)
								if (shaderName.StartsWith(symbol))
									return true;
							return false;
						};
						ErrorWriter errWriter(result.ErrorList, result.WarningList);
						for (auto & shader : result.Program->Shaders)
						{
							if ((options.SymbolToCompile.Length() == 0 && IsSymbolToGen(shader->Name))
								|| options.SymbolToCompile == shader->Name)
							{
								StringBuilder glslBuilder;
								Dictionary<String, String> targetCode;
								result.CompiledSource[shader->Name] = backend->GenerateShader(result, &symTable, shader.Ptr(), &errWriter);
							}
						}
						result.Success = result.ErrorList.Count() == 0;
					}
					else if (options.Mode == CompilerMode::GenerateChoice)
					{
						for (auto shader : shaderClosures)
						{
							if (options.SymbolToCompile.Length() == 0 || shader.Value->Name == options.SymbolToCompile)
							{
								auto &worldOrder = shader.Value->Pipeline->GetWorldTopologyOrder();
								for (auto & comp : shader.Value->AllComponents)
								{
									ShaderChoice choice;
									if (comp.Value->ChoiceNames.Count() == 0)
										continue;
									if (comp.Value->IsParam())
										continue;
									choice.ChoiceName = comp.Value->ChoiceNames.First();
									for (auto & impl : comp.Value->Implementations)
									{
										for (auto w : impl->Worlds)
											if (comp.Value->Type->ConstrainedWorlds.Contains(w))
												choice.Options.Add(ShaderChoiceValue(w, impl->AlternateName));
									}
									if (auto defs = shader.Value->IR->DefinitionsByComponent.TryGetValue(comp.Key))
									{
										int latestWorldOrder = -1;
										for (auto & def : *defs)
										{
											int order = worldOrder.IndexOf(def.Key);
											if (latestWorldOrder < order)
											{
												choice.DefaultValue = def.Key;
												latestWorldOrder = order;
											}
										}
									}
									result.Choices.Add(choice);
								}
							}
						}
					}
					else
					{
						result.GetErrorWriter()->Error(2, L"unsupported compiler mode.", CodePosition());
						return;
					}
					context.Program = result.Program;
					result.Success = true;
				}
				catch (int)
				{
				}
				catch (...)
				{
					throw;
				}
				return;
			}

			ShaderCompilerImpl()
			{
				if (compilerInstances == 0)
				{
					BasicExpressionType::Init();
				}
				compilerInstances++;
				backends.Add(L"glsl", CreateGLSLCodeGen());
				backends.Add(L"hlsl", CreateHLSLCodeGen());
				backends.Add(L"spirv", CreateSpirVCodeGen());
			}

			~ShaderCompilerImpl()
			{
				compilerInstances--;
				if (compilerInstances == 0)
				{
					BasicExpressionType::Finalize();
					SpireStdLib::Finalize();
				}
			}
		};

		ShaderCompiler * CreateShaderCompiler()
		{
			return new ShaderCompilerImpl();
		}

	}
}

/***********************************************************************
SPIRECORE\SPIRVCODEGEN.CPP
***********************************************************************/
#if 0

using namespace CoreLib::Basic;

namespace Spire
{
	namespace Compiler
	{

		enum class ExecutionModel
		{
			Invalid = 777,
			Vertex = 0,
			TessellationControl = 1,
			TessellationEvaluation = 2,
			Geometry = 3,
			Fragment = 4,
			GLCompute = 5,
			Kernel = 6
		};

		String ExecutionModelToString(ExecutionModel em)
		{
			switch (em)
			{
			case ExecutionModel::Invalid:
				return L"invalid";
			case ExecutionModel::Vertex:
				return L"Vertex";
			case ExecutionModel::TessellationControl:
				return L"TessellationControl";
			case ExecutionModel::TessellationEvaluation:
				return L"TessellationEvaluation";
			case ExecutionModel::Geometry:
				return L"Geometry";
			case ExecutionModel::Fragment:
				return L"Fragment";
			case ExecutionModel::GLCompute:
				return L"GLCompute";
			case ExecutionModel::Kernel:
				return L"Kernel";
			default:
				throw NotImplementedException(L"unknown ExecutionModel");
			}
		}

		enum class ExecutionMode
		{
			Invalid = 777,
			Invocations = 0,
			PixelCenterInteger = 6,
			OriginUpperLeft = 7,
			OriginLowerLeft = 8,
			EarlyFragmentTests = 9,
			DepthReplacing = 12,
			DepthGreater = 14,
			DepthLess = 15,
			DepthUnchanged = 16,
			LocalSize = 17
		};

		String ExecutionModeToString(ExecutionMode em)
		{
			switch (em)
			{
			case ExecutionMode::Invalid:
				return L"invalid";
			case ExecutionMode::Invocations:
				return L"Invocations";
			case ExecutionMode::PixelCenterInteger:
				return L"PixelCenterInteger";
			case ExecutionMode::OriginUpperLeft:
				return L"OriginUpperLeft";
			case ExecutionMode::OriginLowerLeft:
				return L"OriginLowerLeft";
			case ExecutionMode::EarlyFragmentTests:
				return L"EarlyFragmentTests";
			case ExecutionMode::DepthReplacing:
				return L"DepthReplacing";
			case ExecutionMode::DepthGreater:
				return L"DepthGreater";
			case ExecutionMode::DepthLess:
				return L"DepthLess";
			case ExecutionMode::DepthUnchanged:
				return L"DepthUnchanged";
			case ExecutionMode::LocalSize:
				return L"LocalSize";
			default:
				throw NotImplementedException(L"unknown ExecutionMode");
			}
		}

		enum class StorageClass
		{
			Invalid = 777,
			UniformConstant = 0,
			Input = 1,
			Uniform = 2,
			Output = 3,
			Workgroup = 4,
			CrossWorkGroup = 5,
			Private = 6,
			Function = 7,
			Generic = 8,
			PushConstant = 9,
			AtomicCounter = 10,
			Image = 11
		};

		String StorageClassToString(StorageClass store)
		{
			switch (store)
			{
			case StorageClass::UniformConstant:
				return L"UniformConstant";
			case StorageClass::Input:
				return L"Input";
			case StorageClass::Uniform:
				return L"Uniform";
			case StorageClass::Output:
				return L"Output";
			case StorageClass::Workgroup:
				return L"Workgroup";
			case StorageClass::CrossWorkGroup:
				return L"CrossWorkGroup";
			case StorageClass::Private:
				return L"Private";
			case StorageClass::Function:
				return L"Function";
			case StorageClass::Generic:
				return L"Generic";
			case StorageClass::PushConstant:
				return L"PushConstant";
			case StorageClass::AtomicCounter:
				return L"AtomicCounter";
			case StorageClass::Image:
				return L"Image";
			default:
				throw NotImplementedException(L"Unknown StorageClass: ");
			}
		}

		enum class MemoryAccess
		{
			None = 0, //0x0
			Volatile = 1, //0x1
			Aligned = 2, //0x2
			Nontemporal = 4 //0x4
		};

		String MemoryAccessToString(MemoryAccess ma)
		{
			switch (ma)
			{
			case MemoryAccess::None:
				return L"None";
			case MemoryAccess::Volatile:
				return L"Volatile";
			case MemoryAccess::Aligned:
				return L"Aligned";
			case MemoryAccess::Nontemporal:
				return L"Nontemporal";
			default:
				throw NotImplementedException(L"Unknown MemoryAccess");
			}
		}

		enum class Decoration
		{
			Invalid = 777,
			Block = 2,
			BufferBlock = 3,
			RowMajor = 4,
			ColMajor = 5,
			ArrayStride = 6,
			MatrixStride = 7,
			BuiltIn = 11,
			Flat = 14,
			Constant = 22,
			Location = 30,
			Component = 31,
			Index = 32,
			Binding = 33,
			DescriptorSet = 34,
			Offset = 35
		};

		String DecorationToString(Decoration d)
		{
			switch (d)
			{
			case Decoration::Invalid:
				return L"invalid";
			case Decoration::Block:
				return L"Block";
			case Decoration::BufferBlock:
				return L"BufferBlock";
			case Decoration::RowMajor:
				return L"RowMajor";
			case Decoration::ColMajor:
				return L"ColMajor";
			case Decoration::ArrayStride:
				return L"ArrayStride";
			case Decoration::MatrixStride:
				return L"MatrixStride";
			case Decoration::BuiltIn:
				return L"BuiltIn";
			case Decoration::Flat:
				return L"Flat";
			case Decoration::Constant:
				return L"Constant";
			case Decoration::Location:
				return L"Location";
			case Decoration::Component:
				return L"Component";
			case Decoration::Index:
				return L"Index";
			case Decoration::Binding:
				return L"Binding";
			case Decoration::DescriptorSet:
				return L"DescriptorSet";
			case Decoration::Offset:
				return L"Offset";
			default:
				throw NotImplementedException(L"unknown Decoration");
			}
		}

		enum class BuiltIn
		{
			Invalid = 777,
			Position = 0,
			PointSize = 1,
			ClipDistance = 3,
			CullDistance = 4,
			FragDepth = 22,
			WorkgroupSize = 25,
			GlobalInvocationId = 28
		};

		String BuiltinToString(BuiltIn b)
		{
			switch (b)
			{
			case BuiltIn::Invalid:
				return L"invalid";
			case BuiltIn::Position:
				return L"Position";
			case BuiltIn::PointSize:
				return L"PointSize";
			case BuiltIn::ClipDistance:
				return L"ClipDistance";
			case BuiltIn::CullDistance:
				return L"CullDistance";
			case BuiltIn::FragDepth:
				return L"FragDepth";
			case BuiltIn::WorkgroupSize:
				return L"WorkgroupSize";
			case BuiltIn::GlobalInvocationId:
				return L"GlobalInvocationId";
			default:
				throw NotImplementedException(L"unknown Builtin");
			}
		}

		enum class Dim
		{
			e1D = 0,
			e2D = 1,
			e3D = 2,
			eCube = 3,
			eRect = 4,
			eBuffer = 5,
			eSubpassData = 6
		};

		String DimToString(Dim b)
		{
			switch (b)
			{
			case Dim::e1D:
				return L"1D";
			case Dim::e2D:
				return L"2D";
			case Dim::e3D:
				return L"3D";
			case Dim::eCube:
				return L"Cube";
			case Dim::eRect:
				return L"Rect";
			case Dim::eBuffer:
				return L"Buffer";
			case Dim::eSubpassData:
				return L"SubpassData";
			default:
				throw NotImplementedException(L"unknown Builtin");
			}
		}

		enum class ImageOperands
		{
			None = 0,
			Bias = 0x1,
			Lod = 0x2,
			Grad = 0x4,
			ConstOffset = 0x8,
			Offset = 0x10,
			ConstOffsets = 0x20,
			Sample = 0x40,
			MinLod = 0x80
		};

		String ImageOperandsToString(ImageOperands io)
		{
			switch (io)
			{
			case ImageOperands::None:
				return L"None";
			case ImageOperands::Bias:
				return L"Bias";
			case ImageOperands::Lod:
				return L"Lod";
			case ImageOperands::Grad:
				return L"Grad";
			case ImageOperands::ConstOffset:
				return L"ConstOffset";
			case ImageOperands::Offset:
				return L"Offset";
			case ImageOperands::ConstOffsets:
				return L"ConstOffsets";
			case ImageOperands::Sample:
				return L"Sample";
			case ImageOperands::MinLod:
				return L"MinLod";
			default:
				throw NotImplementedException(L"unknown Image Operands");
			}
		}

		Dictionary<String, int> GenGLSLstd450InstructionSet()
			//https://www.khronos.org/registry/spir-v/specs/1.0/GLSL.std.450.html
		{
			Dictionary<String, int> ret;

			ret[L"abs"] = 4;	//fabs, actually :(
			ret[L"sign"] = 6;	//fsign, actually :(
			ret[L"floor"] = 8;
			ret[L"ceil"] = 9;
			ret[L"fract"] = 10;
			ret[L"sin"] = 13;
			ret[L"cos"] = 14;
			ret[L"tan"] = 15;
			ret[L"asin"] = 16;
			ret[L"acos"] = 17;
			ret[L"atan"] = 18;
			ret[L"atan2"] = 25;
			ret[L"pow"] = 26;
			ret[L"exp"] = 27;
			ret[L"log"] = 28;
			ret[L"exp2"] = 29;
			ret[L"log2"] = 30;

			ret[L"sqrt"] = 31;

			ret[L"min"] = 37;
			ret[L"max"] = 40;
			ret[L"clamp"] = 43;

			ret[L"mix"] = 46;

			ret[L"step"] = 48;
			ret[L"smoothstep"] = 49;

			ret["length"] = 66;

			ret[L"cross"] = 68;
			ret[L"normalize"] = 69;

			ret[L"reflect"] = 71;
			ret[L"refract"] = 72;

			return ret;
		}

		String GetFuncOriginalName(const String & name)
		{
			String originalName;
			int splitPos = name.IndexOf(L'@');
			if (splitPos == 0)
				return name;
			if (splitPos != -1)
				originalName = name.SubString(0, splitPos);
			else
				originalName = name;
			return originalName;
		}

		String SpirVFloatToString(float v)
		{
			String rs(v, L"%.12e");
			if (!rs.Contains(L'.') && !rs.Contains(L'e') && !rs.Contains(L'E'))
				rs = rs + L".0";
			return rs;
		};

		String SpirVUIntToString(unsigned int i)
		{
			String s;
			if (i >> 31)
				s = s + L"1";
			s = s + int(i & 0x7fffffff);
			return s;
		}

		RefPtr<ILType> GetTypeFromString(String s)
		{
			CoreLib::Text::Parser parser(s);
			return TypeFromString(parser);
		}

		//UniformOrBuffer - 0: none; 1: uniform; 2: buffer 
		int GetBaseAlignment(ILType* Type, int UniformOrBuffer)
		{
			auto RoundUpTo = [](int x, int r)
			{
				if (x%r)
					x += r - x%r;
				return x;
			};
			if (auto basicType = dynamic_cast<ILBasicType*>(Type))
			{
				return Type->GetAlignment();
			}
			else if (auto arrayType = dynamic_cast<ILArrayType*>(Type))
			{
				int elementAlignment = GetBaseAlignment(arrayType->BaseType.Ptr(), UniformOrBuffer);
				if (UniformOrBuffer == 1)
					elementAlignment = RoundUpTo(elementAlignment, 16);
				return elementAlignment;
			}
			else if (auto structType = dynamic_cast<ILStructType*>(Type))
			{
				int maxAlignment = -1;
				for (auto &member : structType->Members)
				{
					int memberAlignment = GetBaseAlignment(member.Type.Ptr(), UniformOrBuffer);
					maxAlignment = std::max(maxAlignment, memberAlignment);
				}
				if (UniformOrBuffer == 1)
					maxAlignment = RoundUpTo(maxAlignment, 16);
				return maxAlignment;
			}
			return -1;
		}

		int GetSize(ILType* Type, int UniformOrBuffer)
		{
			auto RoundUpTo = [](int x, int r)
			{
				if (x%r)
					x += r - x%r;
				return x;
			};

			if (auto basicType = dynamic_cast<ILBasicType*>(Type))
			{
				return Type->GetSize();
			}
			else if (auto arrayType = dynamic_cast<ILArrayType*>(Type))
			{
				return GetSize(arrayType->BaseType.Ptr(), UniformOrBuffer) * arrayType->ArrayLength;
			}
			else if (auto structType = dynamic_cast<ILStructType*>(Type))
			{
				int rs = 0;
				for (auto &member : structType->Members)
				{
					int memberAlignment = GetBaseAlignment(member.Type.Ptr(), UniformOrBuffer);
					rs = RoundUpTo(rs, memberAlignment);
					rs += GetSize(member.Type.Ptr(), UniformOrBuffer);
				}
				return rs;
			}
			return 0;
		}

		enum class IDClass
		{
			None,
			TypeofValue,
			TypeofPointer,
			Pointer,
			Value,
			Function
		};

		class IDInfo
		{
		private:
			bool available;
			IDClass idClass;
			int ID;
			String variableName; // only available for Class:Pointer
			String typeName;
			int typeID;
			int baseTypeID;
			RefPtr<ILType> typeIL;
			StorageClass store;
			CompiledFunction * func = nullptr;
			ILOperand *op;
		public:
			IDInfo()
				:available(false)
			{
			}

			//
			static IDInfo CreateIDInfoForTypeofValue(int ID, RefPtr<ILType> typeIL, int UniformOrBuffer = 0)
			{
				IDInfo ret;
				ret.available = true;
				ret.idClass = IDClass::TypeofValue;
				ret.ID = ID;
				ret.typeName = L"";
				if (typeIL) 
				{
					ret.typeName = typeIL->ToString();
					if (UniformOrBuffer)
						ret.typeName = ret.typeName + L"#" + UniformOrBuffer;
				}
				ret.typeID = ID;
				ret.typeIL = typeIL;
				return ret;
			}

			static IDInfo CreateIDInfoForValue(int ID, RefPtr<ILType> typeIL, ILOperand *op, int typeID)
			{
				IDInfo ret;
				ret.available = true;
				ret.idClass = IDClass::Value;
				ret.ID = ID;
				if (op)
					ret.variableName = op->Name;
				else
					ret.variableName = L"";
				ret.op = op;
				ret.typeName = typeIL->ToString();
				ret.typeID = typeID;
				ret.typeIL = typeIL;
				return ret;
			}

			static IDInfo CreateIDInfoForPointer(int ID, ILOperand *op, int typeID, RefPtr<ILType> basetypeIL, int basetypeID, StorageClass store)
			{
				IDInfo ret;
				ret.available = true;
				ret.idClass = IDClass::Pointer;
				ret.ID = ID;
				ret.op = op;
				if (op)
					ret.variableName = op->Name;
				else
					ret.variableName = L"";
				ret.typeName = basetypeIL->ToString();
				ret.typeID = typeID;
				ret.baseTypeID = basetypeID;
				ret.typeIL = basetypeIL;
				ret.store = store;
				return ret;
			}

			static IDInfo CreateIDInfoForTypeofPointer(int ID, RefPtr<ILType> baseTypeIL, int baseTypeID, StorageClass store)
			{
				IDInfo ret;
				ret.available = true;
				ret.idClass = IDClass::TypeofPointer;
				ret.ID = ID;
				ret.typeName = baseTypeIL->ToString();
				ret.typeID = ID;
				ret.baseTypeID = baseTypeID;
				ret.typeIL = baseTypeIL;
				ret.store = store;
				return ret;
			}

			static IDInfo CreateIDInfoForFunction(int ID, CompiledFunction * func)
			{
				IDInfo ret;
				ret.available = true;
				ret.idClass = IDClass::Function;
				ret.ID = ID;
				ret.func = func;
				return ret;
			}

			bool IsAvailable()
			{
				return available;
			}
			int GetID()
			{
				if (!available) return -1;
				return ID;
			}
			IDClass GetClass()
			{
				if (!available) return IDClass::None;
				return idClass;
			}
			bool IsTypeofValue()
			{
				if (!available) return false;
				return idClass == IDClass::TypeofValue;
			}
			bool IsValue()
			{
				if (!available) return false;
				return idClass == IDClass::Value;
			}
			bool IsPointer()
			{
				if (!available) return false;
				return idClass == IDClass::Pointer;
			}
			bool IsTypeofPointer()
			{
				if (!available) return false;
				return idClass == IDClass::TypeofPointer;
			}
			bool IsFunction()
			{
				if (!available) return false;
				return idClass == IDClass::Function;
			}
			String GetVariableName()
			{
				if (!available) return L"";
				return variableName;
			}
			String GetTypeName()
			{
				if (!available) return L"";
				return typeName;
			}
			int GetTypeID()
			{
				if (!available) return -1;
				return typeID;
			}
			int GetBaseTypeID()
			{
				if (!available) return -1;
				return baseTypeID;
			}
			RefPtr<ILType> GetILType()
			{
				if (!available) return nullptr;
				return typeIL;
			}
			StorageClass GetStorageClass()
			{
				if (!available) return StorageClass::Invalid;
				return store;
			}
			CompiledFunction * GetFunc()
			{
				if (!available || idClass != IDClass::Function)
					return nullptr;
				return func;
			}
			ILOperand* GetOp()
			{
				if (!available)
					return nullptr;
				return op;
			}
		};

		class SpirVCodeBuilder
		{
			List<unsigned int> streamHeader;
			List<unsigned int> streamDebug;
			List<unsigned int> streamAnnotation;
			List<unsigned int> streamTypeDefinition;
			List<unsigned int> streamFunctionHeader;
			List<unsigned int> streamFunctionVariable;
			List<unsigned int> streamFunctionBody;
			List<unsigned int> streamProcessedFunctions;
			StringBuilder sbTextHeader;
			//OpCapability, OpExtension, OpExtInstImport, OpMemoryModel, OpEntryPoint, OpExecutionMode
			StringBuilder sbDebug;
			//OpName, OpMemberName
			StringBuilder sbTextAnnotation;
			//OpDecorate, OpMemberDecorate, OpGroupDecorate, OpGroupMemberDecorate, OpDecoration Group
			StringBuilder sbTextTypeDefinition;
			//OpTypeXXXX, OpConstant, global variable declarations(all OpVariable instructions whose storage class is not Function)
			StringBuilder sbTextFunctionDefinitions;
			StringBuilder sbTextFunctionHeader;
			StringBuilder sbTextFunctionVariable;
			StringBuilder sbTextFunctionBody;

		public:
			void Clear()
			{
				streamHeader.Clear();
				streamDebug.Clear();
				streamAnnotation.Clear();
				streamTypeDefinition.Clear();
				streamFunctionHeader.Clear();
				streamFunctionVariable.Clear();
				streamFunctionBody.Clear();
				streamProcessedFunctions.Clear();
				
				sbTextHeader.Clear();
				sbDebug.Clear();
				sbTextAnnotation.Clear();
				sbTextTypeDefinition.Clear();
				sbTextFunctionDefinitions.Clear();
				sbTextFunctionHeader.Clear();
				sbTextFunctionVariable.Clear();
				sbTextFunctionBody.Clear();
			}
			void Initiate()
			{
				Clear();

				streamHeader.Add(0x07230203); // magic number
				streamHeader.Add(0x00010000); // version 
				streamHeader.Add(0x00080001); // register number
				streamHeader.Add(0x0000ffff); // ID bound
				streamHeader.Add(0x00000000); // reserved
			}
			void ProduceFunction()
			{
				//---------------- for binary code ----------------
				streamProcessedFunctions.AddRange(streamFunctionHeader);
				streamFunctionHeader.Clear();

				streamProcessedFunctions.AddRange(streamFunctionVariable);
				streamFunctionVariable.Clear();

				streamProcessedFunctions.AddRange(streamFunctionBody);
				streamFunctionBody.Clear();

				//---------------- for text code ----------------
				sbTextFunctionDefinitions
					<< sbTextFunctionHeader.ToString()
					<< sbTextFunctionVariable.ToString()
					<< sbTextFunctionBody.ToString();
				sbTextFunctionHeader.Clear();
				sbTextFunctionVariable.Clear();
				sbTextFunctionBody.Clear();
			}
			List<unsigned int> ProduceWordStream(int IDBound)
			{
				streamHeader[3] = IDBound + 5;
				List<unsigned int> ret;
				ret.AddRange(streamHeader);
				ret.AddRange(streamDebug);
				ret.AddRange(streamAnnotation);
				ret.AddRange(streamTypeDefinition);
				ret.AddRange(streamProcessedFunctions);
				return ret;
			}
			String ProduceTextCode()
			{
				String ret;
				ret = ret + sbTextHeader.ToString();
				ret = ret + sbDebug.ToString();
				ret = ret + sbTextAnnotation.ToString();
				ret = ret + sbTextTypeDefinition.ToString();
				ret = ret + sbTextFunctionDefinitions.ToString();
				return ret;
			}
			void ProgramHeader()
			{
				sbTextHeader << LR"(OpCapability Shader)" << EndLine;
				sbTextHeader << LR"(%1 = OpExtInstImport "GLSL.std.450")" << EndLine;
				sbTextHeader << LR"(OpMemoryModel Logical GLSL450)" << EndLine;

				streamHeader.Add(17 + (2 << 16));	//wordCount and opCode
				streamHeader.Add(1);	//Shader

										//hardcoded
				streamHeader.Add(0x0006000B);
				streamHeader.Add(0x00000001);
				streamHeader.Add(0x4c534c47);
				streamHeader.Add(0x6474732E);
				streamHeader.Add(0x3035342E);
				streamHeader.Add(0);

				streamHeader.Add(14 + (3 << 16));
				streamHeader.Add(0);
				streamHeader.Add(1);
			}
			void OpFunction(const int funcID, const int returnTypeID, const int functionTypeID)
			{

				sbTextFunctionHeader << LR"(%)" << funcID << LR"( = OpFunction )";
				sbTextFunctionHeader << LR"(%)" << returnTypeID;
				sbTextFunctionHeader << LR"( None)";
				sbTextFunctionHeader << LR"( %)" << functionTypeID;
				sbTextFunctionHeader << EndLine;

				streamFunctionHeader.Add(54 + (5 << 16));
				streamFunctionHeader.Add(returnTypeID);
				streamFunctionHeader.Add(funcID);
				streamFunctionHeader.Add(0);	// function control - 0
				streamFunctionHeader.Add(functionTypeID);
			}
			void OpFunctionParameter(const int paramID, const int typeID)
			{
				sbTextFunctionHeader << LR"(%)" << paramID << LR"( = OpFunctionParameter %)" << typeID << EndLine;

				streamFunctionHeader.Add(55 + (3 << 16));
				streamFunctionHeader.Add(typeID);
				streamFunctionHeader.Add(paramID);
			}
			void OpTypeFunction(const int functionTypeID, const int returnTypeID, const List<int> &argIDList)
			{
				sbTextTypeDefinition << LR"(%)" << functionTypeID << LR"( = OpTypeFunction %)" << returnTypeID;
				for (auto & arg : argIDList)
					sbTextTypeDefinition << LR"( %)" << arg;
				sbTextTypeDefinition << EndLine;

				streamTypeDefinition.Add(33 + ((3 + argIDList.Count()) << 16));
				streamTypeDefinition.Add(functionTypeID);
				streamTypeDefinition.Add(returnTypeID);
				for (auto & arg : argIDList)
					streamTypeDefinition.Add(arg);
			}
			void OpLabel_AtFunctionHeader(const int label)
			{
				sbTextFunctionHeader << LR"(%)" << label << LR"( = OpLabel)" << EndLine;

				streamFunctionHeader.Add(248 + (2 << 16));
				streamFunctionHeader.Add(label);
			}
			void OpLabel_AtFunctionBody(const int label)
			{
				sbTextFunctionBody << LR"(%)" << label << LR"( = OpLabel)" << EndLine;

				streamFunctionBody.Add(248 + (2 << 16));
				streamFunctionBody.Add(label);
			}
			void OpBranch(const int ID)
			{
				sbTextFunctionBody << LR"(OpBranch %)" << ID << EndLine;

				streamFunctionBody.Add(249 + (2 << 16));
				streamFunctionBody.Add(ID);
			}
			void OpBranchConditional(const int cond, const int tb, const int fb)
			{
				sbTextFunctionBody << LR"(OpBranchConditional %)" << cond << LR"( %)" << tb << LR"( %)" << fb << EndLine;

				streamFunctionBody.Add(250 + (4 << 16));
				streamFunctionBody.Add(cond);
				streamFunctionBody.Add(tb);
				streamFunctionBody.Add(fb);
			}
			void OpLoopMerge(const int merge, const int cont)
			{
				sbTextFunctionBody << LR"(OpLoopMerge %)" << merge << LR"( %)" << cont << LR"( None)" << EndLine;

				streamFunctionBody.Add(246 + (4 << 16));
				streamFunctionBody.Add(merge);
				streamFunctionBody.Add(cont);
				streamFunctionBody.Add(0);	//loop control: none
			}
			void OpSelectionMerge(const int merge)
			{
				sbTextFunctionBody << LR"(OpSelectionMerge %)" << merge << LR"( None)" << EndLine;

				streamFunctionBody.Add(247 + (3 << 16));
				streamFunctionBody.Add(merge);
				streamFunctionBody.Add(0);	//selection control: none
			}
			void OpPhi(const int ID, const int typeID, const List<int> branches)
			{
				//<branches>: (variable1, parent branch1), (variable2, parent branch2), ...
				sbTextFunctionBody << LR"(%)" << ID << LR"( = OpPhi %)" << typeID;
				for (const auto & x : branches)
					sbTextFunctionBody << LR"( %)" << x;
				sbTextFunctionBody << EndLine;

				streamFunctionBody.Add(245 + ((3 + branches.Count()) << 16));
				streamFunctionBody.Add(typeID);
				streamFunctionBody.Add(ID);
				for (const auto & x : branches)
					streamFunctionBody.Add(x);
			}
			void OpFunctionCall(const int ID, const int typeID, const int funcID, const List<int> &args)
			{
				sbTextFunctionBody << LR"(%)" << ID << LR"( = OpFunctionCall %)" << typeID << LR"( %)" << funcID;
				for (auto & arg : args)
					sbTextFunctionBody << LR"( %)" << arg;
				sbTextFunctionBody << EndLine;

				streamFunctionBody.Add(57 + ((4 + args.Count()) << 16));
				streamFunctionBody.Add(typeID);
				streamFunctionBody.Add(ID);
				streamFunctionBody.Add(funcID);
				for (auto & arg : args)
					streamFunctionBody.Add(arg);
			}
			void OpKill()
			{
				sbTextFunctionBody << LR"(OpKill)" << EndLine;
				
				streamFunctionBody.Add(252 + (1<<16));
			}
			void OpReturn()
			{
				sbTextFunctionBody << LR"(OpReturn)" << EndLine;

				streamFunctionBody.Add(253 + (1 << 16));
			}
			void OpReturnValue(const int ID)
			{
				sbTextFunctionBody << LR"(OpReturnValue %)" << ID << EndLine;

				streamFunctionBody.Add(254 + (2 << 16));
				streamFunctionBody.Add(ID);
			}
			void OpFunctionEnd()
			{
				sbTextFunctionBody << LR"(OpFunctionEnd)" << EndLine;

				streamFunctionBody.Add(56 + (1 << 16));
			}
			int EncodeString(List<unsigned int> & stream, String S)
			{
				auto encoder = CoreLib::IO::Encoding::UTF8;
				List<char> bytes;
				encoder->GetBytes(bytes, S);
				int padding = (4 - (bytes.Count() & 3)) & 3;
				for (int i = 0; i < padding; i++)
					bytes.Add(0);
				int oldSize = stream.Count();
				stream.SetSize(oldSize + (bytes.Count() >> 2));
				memcpy(stream.Buffer() + oldSize, bytes.Buffer(), bytes.Count());
				if (padding==0)
					stream.Add(0);
				return stream.Count() - oldSize;
			}
			void OpEntryPoint(const ExecutionModel currentExecutionModel, const int entryID, const List<int> &interfaceIDs)
			{
				sbTextHeader << LR"(OpEntryPoint )";
				sbTextHeader << ExecutionModelToString(currentExecutionModel) << LR"( )";
				sbTextHeader << LR"(%)" << entryID << LR"( "main" )";
				for (auto & id : interfaceIDs)
					sbTextHeader << LR"( %)" << id;
				sbTextHeader << EndLine;

				int len_i = streamHeader.Count();
				streamHeader.Add(0);
				streamHeader.Add((int)currentExecutionModel);
				streamHeader.Add(entryID);
				int NameLen = EncodeString(streamHeader, L"main");
				for (auto & id : interfaceIDs)
					streamHeader.Add(id);
				streamHeader[len_i] = (15) + ((1 + 1 + NameLen + 1 + interfaceIDs.Count()) << 16);
			}
			void OpExecutionMode(const int entryID, const ExecutionMode mode, const int op1, const int op2, const int op3)
			{
				bool LocalSize = false;
				if (mode == ExecutionMode::LocalSize)
					LocalSize = true;

				sbTextHeader << LR"(OpExecutionMode %)" << entryID << LR"( )" << ExecutionModeToString(mode);
				if (LocalSize)
					sbTextHeader << op1 << op2 << op3;
				sbTextHeader << EndLine;

				int len = 3;
				if (LocalSize)
					len += 3;
				streamHeader.Add(16 + (len << 16));
				streamHeader.Add(entryID);
				streamHeader.Add((int)mode);
				if (LocalSize) {
					streamHeader.Add(op1);
					streamHeader.Add(op2);
					streamHeader.Add(op3);
				}
			}
			int Decorate(const Decoration deco, int op1 = 0)
			{
				int len = 0;
				sbTextAnnotation << L" " << DecorationToString(deco);
				streamAnnotation.Add((int)deco);
				len++;
				if (deco == Decoration::Location ||
					deco == Decoration::Offset ||
					deco == Decoration::MatrixStride ||
					deco == Decoration::ArrayStride ||
					deco == Decoration::DescriptorSet ||
					deco == Decoration::Binding)
				{
					sbTextAnnotation << LR"( )" << op1;
					streamAnnotation.Add(op1);
					len++;
				}
				if (deco == Decoration::BuiltIn)
				{
					BuiltIn builtin = static_cast<BuiltIn>(op1);
					sbTextAnnotation << LR"( )" << BuiltinToString(builtin);
					streamAnnotation.Add(op1);
					len++;
				}
				return len;
			}
			void OpDecorate(const int ID, const Decoration deco, int op1 = 0)
			{
				sbTextAnnotation << LR"(OpDecorate %)" << ID;

				int len_i = streamAnnotation.Count();
				streamAnnotation.Add(0);
				streamAnnotation.Add(ID);
				int deco_len = Decorate(deco, op1);
				streamAnnotation[len_i] = 71 + ((2 + deco_len) << 16);

				sbTextAnnotation << EndLine;
			}
			void OpMemberDecorate(const int ID, const int memberIndex, const Decoration deco, int op1 = 0)
			{
				sbTextAnnotation << LR"(OpMemberDecorate %)" << ID << LR"( )" << memberIndex;

				int len_i = streamAnnotation.Count();
				streamAnnotation.Add(0);
				streamAnnotation.Add(ID);
				streamAnnotation.Add(memberIndex);
				int deco_len = Decorate(deco, op1);
				streamAnnotation[len_i] = 72 + ((3 + deco_len) << 16);

				sbTextAnnotation << EndLine;
			}
			void OpSNegate(const int ID, const int typeID, const int valueID)
			{
				sbTextFunctionBody << LR"(%)" << ID << LR"( = OpSNegate %)" << typeID << LR"( %)" << valueID << EndLine;

				streamFunctionBody.Add(126 + (4 << 16));
				streamFunctionBody.Add(typeID);
				streamFunctionBody.Add(ID);
				streamFunctionBody.Add(valueID);
			}
			void OpFNegate(const int ID, const int typeID, const int valueID)
			{
				sbTextFunctionBody << LR"(%)" << ID << LR"( = OpFNegate %)" << typeID << LR"( %)" << valueID << EndLine;

				streamFunctionBody.Add(127 + (4 << 16));
				streamFunctionBody.Add(typeID);
				streamFunctionBody.Add(ID);
				streamFunctionBody.Add(valueID);
			}
			void OpFAdd(const int ID, const int typeID, const int op1, const int op2)
			{
				sbTextFunctionBody << LR"(%)" << ID << LR"( = OpFAdd %)" << typeID << LR"( %)" << op1 << LR"( %)" << op2 << EndLine;

				streamFunctionBody.Add(129 + (5 << 16));
				streamFunctionBody.Add(typeID);
				streamFunctionBody.Add(ID);
				streamFunctionBody.Add(op1);
				streamFunctionBody.Add(op2);
			}
			void OpFMul(const int ID, const int typeID, const int op1, const int op2)
			{
				sbTextFunctionBody << LR"(%)" << ID << LR"( = OpFMul %)" << typeID << LR"( %)" << op1 << LR"( %)" << op2 << EndLine;

				streamFunctionBody.Add(133 + (5 << 16));
				streamFunctionBody.Add(typeID);
				streamFunctionBody.Add(ID);
				streamFunctionBody.Add(op1);
				streamFunctionBody.Add(op2);
			}
			void OpINotEqual(const int ID, const int typeID, const int id0, const int id1)
			{
				sbTextFunctionBody << LR"(%)" << ID << LR"( = OpINotEqual %)" << typeID << LR"( %)" << id0 << LR"( %)" << id1 << EndLine;

				streamFunctionBody.Add(171 + (5 << 16));
				streamFunctionBody.Add(typeID);
				streamFunctionBody.Add(ID);
				streamFunctionBody.Add(id0);
				streamFunctionBody.Add(id1);
			}
			void OpNot(const int ID, const int typeID, const int valueID)
			{
				sbTextFunctionBody << LR"(%)" << ID << LR"( = OpNot %)" << typeID << LR"( %)" << valueID << EndLine;

				streamFunctionBody.Add(200 + (4 << 16));
				streamFunctionBody.Add(typeID);
				streamFunctionBody.Add(ID);
				streamFunctionBody.Add(valueID);
			}
			void OpLogicalNot(const int ID, const int typeID, const int valueID)
			{
				sbTextFunctionBody << LR"(%)" << ID << LR"( = OpLogicalNot %)" << typeID << LR"( %)" << valueID << EndLine;

				streamFunctionBody.Add(168 + (4 << 16));
				streamFunctionBody.Add(typeID);
				streamFunctionBody.Add(ID);
				streamFunctionBody.Add(valueID);
			}
			void OpBinaryInstr(const int ID, String opStr, const int typeID, const int ID0, const int ID1)
			{
				sbTextFunctionBody << LR"(%)" << ID << LR"( = )";
				sbTextFunctionBody << opStr;
				sbTextFunctionBody << LR"( %)" << typeID << LR"( %)" << ID0 << LR"( %)" << ID1 << EndLine;

				int opCode = -1;
				String opStr_prefix = opStr.SubString(0, 2);
				opStr = opStr.SubString(2, opStr.Length() - 2);
				if (opStr == L"FMul")
					opCode = 133;
				else if (opStr == L"IMul")
					opCode = 132;
				else if (opStr == L"FAdd")
					opCode = 129;
				else if (opStr == L"IAdd")
					opCode = 128;
				else if (opStr == L"UDiv")
					opCode = 134;
				else if (opStr == L"SDiv")
					opCode = 135;
				else if (opStr == L"FDiv")
					opCode = 136;
				else if (opStr == L"FSub")
					opCode = 131;
				else if (opStr == L"ISub")
					opCode = 130;
				else if (opStr == L"UMod")
					opCode = 137;
				else if (opStr == L"SMod")
					opCode = 139;
				else if (opStr == L"FMod")
					opCode = 141;
				else if (opStr == L"ShiftLeftLogical")
					opCode = 196;
				else if (opStr == L"ShiftRightArithmetic")
					opCode = 195;
				else if (opStr == L"ShiftRightLogical")
					opCode = 194;
				else if (opStr == L"BitwiseXor")
					opCode = 198;
				else if (opStr == L"BitwiseAnd")
					opCode = 199;
				else if (opStr == L"BitwiseOr")
					opCode = 197;
				else if (opStr == L"LogicalAnd")
					opCode = 167;
				else if (opStr == L"LogicalOr")
					opCode = 166;
				else if (opStr == L"INotEqual")
					opCode = 171;
				else if (opStr == L"FOrdNotEqual")
					opCode = 182;
				else if (opStr == L"IEqual")
					opCode = 170;
				else if (opStr == L"FOrdEqual")
					opCode = 180;
				else if (opStr == L"SGreaterThanEqual")
					opCode = 175;
				else if (opStr == L"FOrdGreaterThanEqual")
					opCode = 190;
				else if (opStr == L"SGreaterThan")
					opCode = 173;
				else if (opStr == L"FOrdGreaterThan")
					opCode = 186;
				else if (opStr == L"SLessThanEqual")
					opCode = 179;
				else if (opStr == L"FOrdLessThanEqual")
					opCode = 188;
				else if (opStr == L"SLessThan")
					opCode = 177;
				else if (opStr == L"FOrdLessThan")
					opCode = 184;
				else if (opStr == L"UGreaterThan")
					opCode = 172;
				else if (opStr == L"UGreaterThanEqual")
					opCode = 174;
				else if (opStr == L"ULessThan")
					opCode = 176;
				else if (opStr == L"ULessThanEqual")
					opCode = 178;
				if (opCode == -1)
					throw InvalidOperationException(L"unrecognized op string in CodeGenerator::OpBinaryInstr(): " + opStr);

				streamFunctionBody.Add(opCode + (5 << 16));
				streamFunctionBody.Add(typeID);
				streamFunctionBody.Add(ID);
				streamFunctionBody.Add(ID0);
				streamFunctionBody.Add(ID1);
			}
			void OpMatrixTimesScalar(const int ID, const int typeID, const int ID0, const int ID1)
			{
				sbTextFunctionBody << LR"(%)" << ID << LR"( = OpMatrixTimesScalar %)" << typeID << LR"( %)" << ID0 << LR"( %)" << ID1 << EndLine;

				streamFunctionBody.Add(143 + (5 << 16));
				streamFunctionBody.Add(typeID);
				streamFunctionBody.Add(ID);
				streamFunctionBody.Add(ID0);
				streamFunctionBody.Add(ID1);
			}
			void OpVectorTimesMatrix(const int ID, const int typeID, const int ID0, const int ID1)
			{
				sbTextFunctionBody << LR"(%)" << ID << LR"( = OpVectorTimesMatrix %)" << typeID << LR"( %)" << ID0 << LR"( %)" << ID1 << EndLine;

				streamFunctionBody.Add(144 + (5 << 16));
				streamFunctionBody.Add(typeID);
				streamFunctionBody.Add(ID);
				streamFunctionBody.Add(ID0);
				streamFunctionBody.Add(ID1);
			}
			void OpMatrixTimesVector(const int ID, const int typeID, const int ID0, const int ID1)
			{
				sbTextFunctionBody << LR"(%)" << ID << LR"( = OpMatrixTimesVector %)" << typeID << LR"( %)" << ID0 << LR"( %)" << ID1 << EndLine;

				streamFunctionBody.Add(145 + (5 << 16));
				streamFunctionBody.Add(typeID);
				streamFunctionBody.Add(ID);
				streamFunctionBody.Add(ID0);
				streamFunctionBody.Add(ID1);
			}
			void OpMatrixTimesMatrix(const int ID, const int typeID, const int ID0, const int ID1)
			{
				sbTextFunctionBody << LR"(%)" << ID << LR"( = OpMatrixTimesMatrix %)" << typeID << LR"( %)" << ID0 << LR"( %)" << ID1 << EndLine;

				streamFunctionBody.Add(146 + (5 << 16));
				streamFunctionBody.Add(typeID);
				streamFunctionBody.Add(ID);
				streamFunctionBody.Add(ID0);
				streamFunctionBody.Add(ID1);
			}
			void OpConstantBool(const int typeID, const int ID, const bool b)
			{
				if (b)
				{
					sbTextTypeDefinition << LR"(%)" << ID << LR"( = OpConstantTrue%)" << EndLine;

					streamTypeDefinition.Add(41 + (3 << 16));
					streamTypeDefinition.Add(typeID);
					streamTypeDefinition.Add(ID);
				}
				else
				{
					sbTextTypeDefinition << LR"(%)" << ID << LR"( = OpConstantFalse%)" << EndLine;

					streamTypeDefinition.Add(42 + (3 << 16));
					streamTypeDefinition.Add(typeID);
					streamTypeDefinition.Add(ID);
				}
			}
			void OpConstantFloat(const int ID, const int typeID, float f)
			{
				sbTextTypeDefinition << LR"(%)" << ID << LR"( = OpConstant %)" << typeID << LR"( )" << SpirVFloatToString(f) << EndLine;

				streamTypeDefinition.Add(43 + (4 << 16));
				streamTypeDefinition.Add(typeID);
				streamTypeDefinition.Add(ID);
				streamTypeDefinition.Add(*reinterpret_cast<unsigned int*>(&f));
				//printf("%.8f -> %x\n", f, streamTypeDefinition[streamTypeDefinition.Count() - 1]);
			}
			void OpConstantInt(const int ID, const int typeID, int i)
			{
				sbTextTypeDefinition << LR"(%)" << ID << LR"( = OpConstant %)" << typeID << LR"( )" << i << EndLine;

				streamTypeDefinition.Add(43 + (4 << 16));
				streamTypeDefinition.Add(typeID);
				streamTypeDefinition.Add(ID);
				streamTypeDefinition.Add(*reinterpret_cast<unsigned int*>(&i));
			}
			void OpConstantUInt(const int ID, const int typeID, const unsigned int i)
			{
				sbTextTypeDefinition << LR"(%)" << ID << LR"( = OpConstant %)" << typeID << LR"( )";
				sbTextTypeDefinition << SpirVUIntToString(i);
				sbTextTypeDefinition << EndLine;

				streamTypeDefinition.Add(43 + (4 << 16));
				streamTypeDefinition.Add(typeID);
				streamTypeDefinition.Add(ID);
				streamTypeDefinition.Add(i);
			}
			void OpConstantComposite(const int ID, const int typeID, const List<int> &args)
			{
				sbTextTypeDefinition << LR"(%)" << ID << LR"( = OpConstantComposite %)" << typeID;
				for (auto & id : args)
					sbTextTypeDefinition << LR"( %)" << id;
				sbTextTypeDefinition << EndLine;

				streamTypeDefinition.Add(44 + ((3 + args.Count()) << 16));
				streamTypeDefinition.Add(typeID);
				streamTypeDefinition.Add(ID);
				for (auto & id : args)
					streamTypeDefinition.Add(id);
			}
			void OpCompositeConstruct(const int ID, const int typeID, const List<int> &args)
			{
				sbTextFunctionBody << LR"(%)" << ID << LR"( = OpCompositeConstruct %)" << typeID;
				for (auto & id : args)
					sbTextFunctionBody << LR"( %)" << id;
				sbTextFunctionBody << EndLine;

				streamFunctionBody.Add(80 + ((3 + args.Count()) << 16));
				streamFunctionBody.Add(typeID);
				streamFunctionBody.Add(ID);
				for (auto & id : args)
					streamFunctionBody.Add(id);
			}
			void OpCompositeExtract(const int ID, const int baseTypeID, const int compositeID, const int index)
			{
				sbTextFunctionBody << LR"(%)" << ID << LR"( = OpCompositeExtract %)" << baseTypeID << LR"( %)" << compositeID
					<< LR"( )" << index << EndLine;

				streamFunctionBody.Add(81 + (5 << 16));
				streamFunctionBody.Add(baseTypeID);
				streamFunctionBody.Add(ID);
				streamFunctionBody.Add(compositeID);
				streamFunctionBody.Add(index);
			}
			void OpCompositeInsert(const int ID, const int typeID, const int objectID, const int compositeID, const int index)
			{
				sbTextFunctionBody << LR"(%)" << ID << LR"( = OpCompositeInsert %)"
					<< typeID << LR"( %)" << objectID << LR"( %)" << compositeID << LR"( )" << index << EndLine;

				streamFunctionBody.Add(82 + (6 << 16));
				streamFunctionBody.Add(typeID);
				streamFunctionBody.Add(ID);
				streamFunctionBody.Add(objectID);
				streamFunctionBody.Add(compositeID);
				streamFunctionBody.Add(index);
			}
			void OpExtInst(const int ID, const int typeID, const int instrNumber, const List<int> &Arguments)
			{
				sbTextFunctionBody << LR"(%)" << ID << LR"( = OpExtInst %)" << typeID << LR"( %1 )";
				sbTextFunctionBody << instrNumber;
				for (auto & arg : Arguments)
					sbTextFunctionBody << LR"( %)" << arg;
				sbTextFunctionBody << EndLine;

				streamFunctionBody.Add(12 + ((5 + Arguments.Count()) << 16));
				streamFunctionBody.Add(typeID);
				streamFunctionBody.Add(ID);
				streamFunctionBody.Add(1);	//instruction set **<ID>**
				streamFunctionBody.Add(instrNumber);
				for (auto & arg : Arguments)
					streamFunctionBody.Add(arg);
			}
			void OpStore(const int op0, const int op1)
			{
				sbTextFunctionBody << LR"(OpStore %)" << op0 << LR"( %)" << op1 << EndLine;

				streamFunctionBody.Add(62 + (3 << 16));
				streamFunctionBody.Add(op0);
				streamFunctionBody.Add(op1);
			}
			void OpLoad(const int ID, const int typeID, const int variableID, const MemoryAccess ma)
			{
				sbTextFunctionBody << LR"(%)" << ID << LR"( = OpLoad %)" << typeID << LR"( %)"
					<< variableID << LR"( )" << MemoryAccessToString(ma) << EndLine;

				if (ma != MemoryAccess::None)
					throw NotImplementedException(L"not support memory access in CodeGenerator::OpLoad(): " + MemoryAccessToString(ma));

				streamFunctionBody.Add(61 + (4 << 16));
				streamFunctionBody.Add(typeID);
				streamFunctionBody.Add(ID);
				streamFunctionBody.Add(variableID);
			}
			void OpVariable(const int ID, const int typeID, StorageClass store)
			{
				StringBuilder instrBuilder;
				instrBuilder << LR"(%)" << ID << LR"( = OpVariable %)" << typeID << LR"( )" << StorageClassToString(store) << EndLine;
				if (store == StorageClass::Function)
					sbTextFunctionVariable << instrBuilder.ProduceString() << EndLine;
				else
					sbTextTypeDefinition << instrBuilder.ProduceString() << EndLine;

				if (store == StorageClass::Function)
				{
					streamFunctionVariable.Add(59 + (4 << 16));
					streamFunctionVariable.Add(typeID);
					streamFunctionVariable.Add(ID);
					streamFunctionVariable.Add((int)store);
				}
				else
				{
					streamTypeDefinition.Add(59 + (4 << 16));
					streamTypeDefinition.Add(typeID);
					streamTypeDefinition.Add(ID);
					streamTypeDefinition.Add((int)store);
				}
			}
			void OpAccessChain(const int ID, const int typeID, const int structID, const int indexID)
			{
				sbTextFunctionBody << LR"(%)" << ID << LR"( = OpAccessChain %)" << typeID
					<< LR"( %)" << structID << LR"( %)" << indexID << EndLine;

				streamFunctionBody.Add(65 + (5 << 16));
				streamFunctionBody.Add(typeID);
				streamFunctionBody.Add(ID);
				streamFunctionBody.Add(structID);
				streamFunctionBody.Add(indexID);
			}
			void OpImageSampleImplicitLod(
				const int ID, 
				const int typeID, 
				const int textureID, 
				const int coordinateID,
				const int Bias = -1)
			{
				sbTextFunctionBody << LR"(%)" << ID << LR"( = OpImageSampleImplicitLod %)"
					<< typeID << LR"( %)" << textureID << LR"( %)" << coordinateID;
				if (Bias != -1)
					sbTextFunctionBody << LR"( Bias %)" << Bias;
				sbTextFunctionBody << EndLine;

				int len = 5;
				int IO = 0;
				if (Bias != -1)
				{
					len++;
					IO |= (int)ImageOperands::Bias;
				}
				if (IO)
					len++;
				streamFunctionBody.Add(87 + (len << 16));
				streamFunctionBody.Add(typeID);
				streamFunctionBody.Add(ID);
				streamFunctionBody.Add(textureID);
				streamFunctionBody.Add(coordinateID);
				if (IO)
					streamFunctionBody.Add(IO);
				if (Bias != -1)
					streamFunctionBody.Add(Bias);
			}
			void OpImageSampleExplicitLod(
				const int ID, 
				const int typeID, 
				const int textureID, 
				const int coordinateID, 
				const int LodID,
				const int Bias = -1,
				const int GradX = -1, 
				const int GradY = -1)
			{
				sbTextFunctionBody << LR"(%)" << ID << LR"( = OpImageSampleExplicitLod %)"
					<< typeID << LR"( %)" << textureID << LR"( %)" << coordinateID;
				if (Bias != -1)
					sbTextFunctionBody << LR"( Bias %)" << Bias;
				if (GradX != -1)
					sbTextFunctionBody << LR"( Grad %)" << GradX << LR"( %)" << GradY;
				else
					sbTextFunctionBody << LR"( Lod %)" << LodID;
				sbTextFunctionBody << EndLine;

				int IO = 0;
				int len = 5;
				if (Bias != -1)
				{
					IO |= (int)ImageOperands::Bias;
					len++;
				}
				if (GradX != -1) {
					IO |= (int)ImageOperands::Grad;
					len += 2;
				}
				else
				{
					IO |= (int)ImageOperands::Lod;
					len++;
				}
				if (IO)
					len++;
				streamFunctionBody.Add(88 + (len << 16));
				streamFunctionBody.Add(typeID);
				streamFunctionBody.Add(ID);
				streamFunctionBody.Add(textureID);
				streamFunctionBody.Add(coordinateID);
				if (IO)
					streamFunctionBody.Add(IO);
				if (Bias != -1)
					streamFunctionBody.Add(Bias);
				if (GradX != -1)
				{
					streamFunctionBody.Add(GradX);
					streamFunctionBody.Add(GradY);
				}
				else
					streamFunctionBody.Add(LodID);
			}
			void OpImageSampleDrefImplicitLod(
				const int ID,
				const int typeID,
				const int textureID,
				const int coordinateID,
				const int DrefID)
			{
				sbTextFunctionBody << LR"(%)" << ID << LR"( = OpImageSampleDrefImplicitLod %)"
					<< typeID << LR"( %)" << textureID << LR"( %)" << coordinateID << LR"( %)" << DrefID;
				sbTextFunctionBody << EndLine;

				int len = 6;
				streamFunctionBody.Add(89 + (len << 16));
				streamFunctionBody.Add(typeID);
				streamFunctionBody.Add(ID);
				streamFunctionBody.Add(textureID);
				streamFunctionBody.Add(coordinateID);
				streamFunctionBody.Add(DrefID);
			}
			void OpImageSampleDrefExplicitLod(
				const int ID,
				const int typeID,
				const int textureID,
				const int coordinateID, 
				const int DrefID,
				const int LodID)
			{
				sbTextFunctionBody << LR"(%)" << ID << LR"( = OpImageSampleDrefExplicitLod %)"
					<< typeID << LR"( %)" << textureID << LR"( %)" << coordinateID << LR"( %)" << DrefID;
				sbTextFunctionBody << LR"( Lod %)" << LodID;
				sbTextFunctionBody << EndLine;

				int len = 8;
				streamFunctionBody.Add(90 + (len << 16));
				streamFunctionBody.Add(typeID);
				streamFunctionBody.Add(ID);
				streamFunctionBody.Add(textureID);
				streamFunctionBody.Add(coordinateID);
				streamFunctionBody.Add(DrefID);
				streamFunctionBody.Add((int)ImageOperands::Lod);
				streamFunctionBody.Add(LodID);
			}
			void OpImageSampleProjDrefImplicitLod(
				const int ID,
				const int typeID,
				const int textureID,
				const int coordinateID,
				const int DrefID) 
			{
				sbTextFunctionBody << LR"(%)" << ID << LR"( = OpImageSampleProjDrefImplicitLod %)"
					<< typeID << LR"( %)" << textureID << LR"( %)" << coordinateID << LR"( %)" << DrefID;
				sbTextFunctionBody << EndLine;

				int len = 6;
				streamFunctionBody.Add(93 + (len << 16));
				streamFunctionBody.Add(typeID);
				streamFunctionBody.Add(ID);
				streamFunctionBody.Add(textureID);
				streamFunctionBody.Add(coordinateID);
				streamFunctionBody.Add(DrefID);
			}
			void OpImageSampleProjDrefExplicitLod(
				const int ID,
				const int typeID,
				const int textureID,
				const int coordinateID,
				const int DrefID,
				const int LodID)
			{
				sbTextFunctionBody << LR"(%)" << ID << LR"( = OpImageSampleProjDrefExplicitLod %)"
					<< typeID << LR"( %)" << textureID << LR"( %)" << coordinateID << LR"( %)" << DrefID;
				sbTextFunctionBody << LR"( Lod %)" << LodID;
				sbTextFunctionBody << EndLine;

				int len = 8;
				streamFunctionBody.Add(94 + (len << 16));
				streamFunctionBody.Add(typeID);
				streamFunctionBody.Add(ID);
				streamFunctionBody.Add(textureID);
				streamFunctionBody.Add(coordinateID);
				streamFunctionBody.Add(DrefID);
				streamFunctionBody.Add((int)ImageOperands::Lod);
				streamFunctionBody.Add(LodID);
			}
			void OpConvertSToF(const int ID, const int typeID, const int operandID)
			{
				sbTextFunctionBody << LR"(%)" << ID << LR"( = OpConvertSToF %)" << typeID << LR"( %)" << operandID << EndLine;

				streamFunctionBody.Add(111 + (4 << 16));
				streamFunctionBody.Add(typeID);
				streamFunctionBody.Add(ID);
				streamFunctionBody.Add(operandID);
			}
			void OpConvertFToS(const int ID, const int typeID, const int operandID)
			{
				sbTextFunctionBody << LR"(%)" << ID << LR"( = OpConvertFToS %)" << typeID << LR"( %)" << operandID << EndLine;

				streamFunctionBody.Add(110 + (4 << 16));
				streamFunctionBody.Add(typeID);
				streamFunctionBody.Add(ID);
				streamFunctionBody.Add(operandID);
			}
			void OpConvertFToU(const int ID, const int typeID, const int operandID)
			{
				sbTextFunctionBody << LR"(%)" << ID << LR"( = OpConvertFToU %)" << typeID << LR"( %)" << operandID << EndLine;

				streamFunctionBody.Add(109 + (4 << 16));
				streamFunctionBody.Add(typeID);
				streamFunctionBody.Add(ID);
				streamFunctionBody.Add(operandID);
			}
			void OpConvertUToF(const int ID, const int typeID, const int operandID)
			{
				sbTextFunctionBody << LR"(%)" << ID << LR"( = OpConvertUToF %)" << typeID << LR"( %)" << operandID << EndLine;

				streamFunctionBody.Add(112 + (4 << 16));
				streamFunctionBody.Add(typeID);
				streamFunctionBody.Add(ID);
				streamFunctionBody.Add(operandID);
			}
			void OpBitCast(const int ID, const int typeID, const int operandID)
			{
				sbTextFunctionBody << LR"(%)" << ID << LR"( = OpBitcast %)" << typeID << LR"( %)" << operandID << EndLine;

				streamFunctionBody.Add(124 + (4 << 16));
				streamFunctionBody.Add(typeID);
				streamFunctionBody.Add(ID);
				streamFunctionBody.Add(operandID);
			}
			void OpTypeVoid(const int ID)
			{
				sbTextTypeDefinition << LR"(%)" << ID << LR"( = OpTypeVoid)" << EndLine;

				streamTypeDefinition.Add(19 + (2 << 16));
				streamTypeDefinition.Add(ID);
			}
			void OpTypeBool(const int ID)
			{
				sbTextTypeDefinition << LR"(%)" << ID << LR"( = OpTypeBool)" << EndLine;

				streamTypeDefinition.Add(20 + (2 << 16));
				streamTypeDefinition.Add(ID);
			}
			void OpTypeInt(const int ID, const int width, const int signedness)
			{
				sbTextTypeDefinition << LR"(%)" << ID << LR"( = OpTypeInt )" << width << LR"( )" << signedness << EndLine;

				streamTypeDefinition.Add(21 + (4 << 16));
				streamTypeDefinition.Add(ID);
				streamTypeDefinition.Add(width);
				streamTypeDefinition.Add(signedness);
			}
			void OpTypeFloat(const int ID, const int width)
			{
				sbTextTypeDefinition << LR"(%)" << ID << LR"( = OpTypeFloat )" << width << EndLine;

				streamTypeDefinition.Add(22 + (3 << 16));
				streamTypeDefinition.Add(ID);
				streamTypeDefinition.Add(width);
			}
			void OpTypeVector(const int ID, const int eleTypeID, const int vecLen)
			{
				sbTextTypeDefinition << LR"(%)" << ID << LR"( = OpTypeVector %)" << eleTypeID << LR"( )" << vecLen << EndLine;

				streamTypeDefinition.Add(23 + (4 << 16));
				streamTypeDefinition.Add(ID);
				streamTypeDefinition.Add(eleTypeID);
				streamTypeDefinition.Add(vecLen);
			}
			void OpTypeMatrix(const int ID, const int colTypeID, const int Dim)
			{
				sbTextTypeDefinition << LR"(%)" << ID << LR"( = OpTypeMatrix %)" << colTypeID << LR"( )" << Dim << EndLine;

				streamTypeDefinition.Add(24 + (4 << 16));
				streamTypeDefinition.Add(ID);
				streamTypeDefinition.Add(colTypeID);
				streamTypeDefinition.Add(Dim);
			}
			void OpTypeImage(const int ID, const int sampledTypeID, const Dim d, const int depth)
			{
				sbTextTypeDefinition << LR"(%)" << ID << LR"( = OpTypeImage %)" << sampledTypeID
					<< LR"( )" << DimToString(d) << LR"( )" << depth << LR"( 0 0 1 Unknown)" << EndLine;

				streamTypeDefinition.Add(25 + (9 << 16));
				streamTypeDefinition.Add(ID);
				streamTypeDefinition.Add(sampledTypeID);
				streamTypeDefinition.Add((int)d);			//Dim
				streamTypeDefinition.Add(depth);			//depth
				streamTypeDefinition.Add(0);				//arrayed
				streamTypeDefinition.Add(0);				//MS
				streamTypeDefinition.Add(1);				//sampled: will be used with sampler
				streamTypeDefinition.Add(0);				//image format: Unknown
			}
			void OpTypeSampledImage(const int ID, const int imageTypeID)
			{
				sbTextTypeDefinition << LR"(%)" << ID << LR"( = OpTypeSampledImage %)" << imageTypeID << EndLine;

				streamTypeDefinition.Add(27 + (3 << 16));
				streamTypeDefinition.Add(ID);
				streamTypeDefinition.Add(imageTypeID);
			}
			void OpTypePointer(const int ID, const StorageClass store, const int baseTypeID)
			{
				sbTextTypeDefinition << LR"(%)" << ID << LR"( = OpTypePointer )" << StorageClassToString(store)
					<< LR"( %)" << baseTypeID << EndLine;

				streamTypeDefinition.Add(32 + (4 << 16));
				streamTypeDefinition.Add(ID);
				streamTypeDefinition.Add((int)store);
				streamTypeDefinition.Add(baseTypeID);
			}
			void OpTypeArray(const int ID, const int elementTypeID, const int lengthID)
			{
				sbTextTypeDefinition << LR"(%)" << ID << LR"( = OpTypeArray %)" << elementTypeID << LR"( %)" << lengthID << EndLine;

				streamTypeDefinition.Add(28 + (4 << 16));
				streamTypeDefinition.Add(ID);
				streamTypeDefinition.Add(elementTypeID);
				streamTypeDefinition.Add(lengthID);
			}
			void OpTypeRuntimeArray(const int ID, const int elementTypeID)
			{
				sbTextTypeDefinition << LR"(%)" << ID << LR"( = OpTypeRuntimeArray %)" << elementTypeID << EndLine;

				streamTypeDefinition.Add(29 + (3 << 16));
				streamTypeDefinition.Add(ID);
				streamTypeDefinition.Add(elementTypeID);
			}
			void OpTypeStruct(const int ID, const List<int> & memberIDList)
			{
				sbTextTypeDefinition << LR"(%)" << ID << LR"( = OpTypeStruct)";
				for (auto & member : memberIDList)
					sbTextTypeDefinition << LR"( %)" << member;
				sbTextTypeDefinition << EndLine;

				streamTypeDefinition.Add(30 + ((2 + memberIDList.Count()) << 16));
				streamTypeDefinition.Add(ID);
				for (auto & member : memberIDList)
					streamTypeDefinition.Add(member);
			}

			void OpDot(const int ID, const int typeID, const int ID0, const int ID1)
			{
				sbTextFunctionBody << LR"(%)" << ID << LR"( = OpDot %)" << typeID << LR"( %)" << ID0 << LR"( %)" << ID1 << EndLine;

				streamFunctionBody.Add(148 + (5 << 16));
				streamFunctionBody.Add(typeID);
				streamFunctionBody.Add(ID);
				streamFunctionBody.Add(ID0);
				streamFunctionBody.Add(ID1);
			}

			void OpTranspose(const int ID, const int typeID, const int Op0)
			{
				sbTextFunctionBody << LR"(%)" << ID << LR"( = OpTranspose %)" << typeID << LR"( %)" << Op0 << EndLine;

				streamFunctionBody.Add(84 + (4 << 16));
				streamFunctionBody.Add(typeID);
				streamFunctionBody.Add(ID);
				streamFunctionBody.Add(Op0);
			}

			void OpDPdx(const int ID, const int typeID, const int Op0)
			{
				sbTextFunctionBody << LR"(%)" << ID << LR"( = OpDPdx %)" << typeID << LR"( %)" << Op0 << EndLine;

				streamFunctionBody.Add(207 + (4 << 16));
				streamFunctionBody.Add(typeID);
				streamFunctionBody.Add(ID);
				streamFunctionBody.Add(Op0);
			}

			void OpDPdy(const int ID, const int typeID, const int Op0)
			{
				sbTextFunctionBody << LR"(%)" << ID << LR"( = OpDPdy %)" << typeID << LR"( %)" << Op0 << EndLine;

				streamFunctionBody.Add(208 + (4 << 16));
				streamFunctionBody.Add(typeID);
				streamFunctionBody.Add(ID);
				streamFunctionBody.Add(Op0);
			}

			void OpFwidth(const int ID, const int typeID, const int Op0)
			{
				sbTextFunctionBody << LR"(%)" << ID << LR"( = OpFwidth %)" << typeID << LR"( %)" << Op0 << EndLine;

				streamFunctionBody.Add(209 + (4 << 16));
				streamFunctionBody.Add(typeID);
				streamFunctionBody.Add(ID);
				streamFunctionBody.Add(Op0);
			}

			void OpName(int ID, String Name)
			{
				sbDebug << LR"(OpName %)" << ID << LR"( ")" << Name << LR"(")" << EndLine;

				int len_i = streamDebug.Count();
				streamDebug.Add(0);
				streamDebug.Add(ID);
				int len = EncodeString(streamDebug, Name);
				streamDebug[len_i] = 5 + ((2 + len) << 16);
			}

			void OpMemberName(int ID, int index, String Name)
			{
				sbDebug << LR"(OpMemberName %)" << ID << LR"( )" << index << LR"( ")" << Name << LR"(")" << EndLine;

				int len_i = streamDebug.Count();
				streamDebug.Add(0);
				streamDebug.Add(ID);
				streamDebug.Add(index);
				int len = EncodeString(streamDebug, Name);
				streamDebug[len_i] = 6 + ((3 + len) << 16);
			}
		};

		class SpirVCodeGenContext
		{
		public:
			CompileResult * Result = nullptr;

			int CurrentID = 0;
			int MainFunctionID = 0;
			int MainFunctionReturnTypeID = 0;
			int MainFunctionTypeID = 0;
			int ReturnID = -1;
			Dictionary<String, int> TypeNameToID;					// 'int' - 1, 'vec4' - 2
			Dictionary<String, int> TypeStorageToTypePointerID;		// 'uint Function' - 5, 'mat3 Uniform' - 6
			Dictionary<String, int> FunctionNameToFunctionTypeID;
			Dictionary<String, int> FunctionNameToFunctionID;
			Dictionary<ILOperand*, int> ParameterNameToID;

			List<Dictionary<ILOperand*, int>> StackVariableNameToStorageID;
			List<Dictionary<ILOperand*, int>> StackVariableNameToValueID;
			Dictionary<String, int> InterfaceNameToID;

			Dictionary<int, int> Dictionary_ConstantIntToID;
			Dictionary<unsigned int, int> Dictionary_ConstantUIntToID;
			Dictionary<int, int> Dictionary_ConstantBoolToID;

			Dictionary<int, IDInfo> IDInfos;

			List<int> StackMergeBlock;
			List<int> StackContinueBlock;

			SpirVCodeBuilder CodeGen;

			void Clear()
			{
				Result = nullptr;
				CurrentID = 0;
				MainFunctionID = 0;
				MainFunctionReturnTypeID = 0;
				MainFunctionTypeID = 0;
				ReturnID = -1;
				StackVariableNameToStorageID.Clear();
				StackVariableNameToValueID.Clear();
				TypeNameToID.Clear();
				TypeStorageToTypePointerID.Clear();
				FunctionNameToFunctionTypeID.Clear();
				FunctionNameToFunctionID.Clear();
				ParameterNameToID.Clear();
				Dictionary_ConstantIntToID.Clear();
				Dictionary_ConstantUIntToID.Clear();
				Dictionary_ConstantBoolToID.Clear();
				IDInfos.Clear();
				StackMergeBlock.Clear();
				StackContinueBlock.Clear();
				CodeGen.Clear();
				InterfaceNameToID.Clear();
			}

			void ClearBuffer()
			{
				StackVariableNameToStorageID.Clear();
				StackVariableNameToValueID.Clear();
				ParameterNameToID.Clear();
				ReturnID = -1;
			}

			void PushScope()
			{
				StackVariableNameToStorageID.Add(Dictionary<ILOperand*, int>());
				StackVariableNameToValueID.Add(Dictionary<ILOperand*, int>());
			}

			void PopScope()
			{
				StackVariableNameToStorageID.RemoveAt(StackVariableNameToStorageID.Count() - 1);
				StackVariableNameToValueID.RemoveAt(StackVariableNameToValueID.Count() - 1); 
			}

			void UpdateVariable(ILOperand* op, int id)
			{
				if (op == nullptr)
					return;
				StackVariableNameToStorageID.Last()[op] = id;
			}

			int FindVariableID(ILOperand* op)
			{
				auto it = StackVariableNameToStorageID.end();
				while (it != StackVariableNameToStorageID.begin())
				{
					it--;
					if (it->ContainsKey(op))
						return (*it)[op];
				}
				return -1;
			}

			// ***NOTICE***: 
			//   There is no relation between VariableNameToStorageID and ValueIDToVariableNames.

			void UpdateValue(ILOperand *op, int id)
			{
				if (op == nullptr)
					return;
				StackVariableNameToValueID.Last()[op] = id;
			}

			int FindValueID(ILOperand *op)
			{
				auto it = StackVariableNameToValueID.end();
				while (it != StackVariableNameToValueID.begin())
				{
					it--;
					if (it->ContainsKey(op))
						return (*it)[op];
				}
				return -1;
			}

			void InvalidateValue(ILOperand *op)
			{
				if (StackVariableNameToValueID.Last().ContainsKey(op))
					StackVariableNameToValueID.Last()[op] = -1;
			}

			int DefineBasicType(RefPtr<ILType> Type)
			{
				String typeName = Type->ToString();
				if (TypeNameToID.ContainsKey(typeName))
					return TypeNameToID[typeName];
				TypeNameToID[typeName] = -1; //marked as visited

				if (typeName == L"int" || typeName.StartsWith(L"ivec"))
				{
					DefineBasicType(new ILBasicType(ILBaseType::Int));

					if (typeName == L"int")
					{
						++CurrentID;
						CodeGen.OpTypeInt(CurrentID, 32, 1);
						TypeNameToID[typeName] = CurrentID;
					}

					if (typeName.StartsWith(L"ivec"))
					{
						++CurrentID;
						CodeGen.OpTypeVector(CurrentID, TypeNameToID[L"int"](), StringToInt(typeName[4]));
						TypeNameToID[typeName] = CurrentID;
					}
				}

				if (typeName == L"uint" || typeName.StartsWith(L"uvec"))
				{
					DefineBasicType(new ILBasicType(ILBaseType::UInt));

					if (typeName == L"uint") {
						++CurrentID;
						CodeGen.OpTypeInt(CurrentID, 32, 0);
						TypeNameToID[typeName] = CurrentID;
					}

					if (typeName.StartsWith(L"uvec"))
					{
						++CurrentID;
						CodeGen.OpTypeVector(CurrentID, TypeNameToID[L"uint"](), StringToInt(typeName[4]));
						TypeNameToID[typeName] = CurrentID;
					}
				}

				if (typeName == L"float" || typeName.StartsWith(L"vec") || typeName.StartsWith(L"mat"))
				{
					DefineBasicType(new ILBasicType(ILBaseType::Float));

					if (typeName == L"float")
					{
						++CurrentID;
						CodeGen.OpTypeFloat(CurrentID, 32);
						TypeNameToID[typeName] = CurrentID;
					}

					if (typeName.StartsWith(L"vec"))
					{
						++CurrentID;
						CodeGen.OpTypeVector(CurrentID, TypeNameToID[L"float"](), StringToInt(typeName[3]));
						TypeNameToID[typeName] = CurrentID;
					}

					if (typeName == L"mat3")
					{
						DefineBasicType(new ILBasicType(ILBaseType::Float3));
						++CurrentID;
						CodeGen.OpTypeMatrix(CurrentID, TypeNameToID[L"vec3"](), 3);
						TypeNameToID[typeName] = CurrentID;
					}

					if (typeName == L"mat4")
					{
						DefineBasicType(new ILBasicType(ILBaseType::Float4));
						++CurrentID;
						CodeGen.OpTypeMatrix(CurrentID, TypeNameToID[L"vec4"](), 4);
						TypeNameToID[typeName] = CurrentID;
					}
				}

				if (typeName == L"sampler2D")
				{
					//according to vulkan specification
					//	Resource Descriptors, Descriptor Types, Sampled Image
					DefineBasicType(new ILBasicType(ILBaseType::Float));

					++CurrentID;
					CodeGen.OpTypeImage(CurrentID, TypeNameToID[L"float"](), Dim::e2D, 0);
					int tmp = CurrentID;

					++CurrentID;
					CodeGen.OpTypeSampledImage(CurrentID, tmp);
					TypeNameToID[typeName] = CurrentID;
				}

				if (typeName == L"samplerCube")
				{
					DefineBasicType(new ILBasicType(ILBaseType::Float));

					++CurrentID;
					CodeGen.OpTypeImage(CurrentID, TypeNameToID[L"float"](), Dim::eCube, 0);
					int tmp = CurrentID;

					++CurrentID;
					CodeGen.OpTypeSampledImage(CurrentID, tmp);
					TypeNameToID[typeName] = CurrentID;
				}

				if (typeName == L"samplerCubeShadow")
				{
					DefineBasicType(new ILBasicType(ILBaseType::Float));

					++CurrentID;
					CodeGen.OpTypeImage(CurrentID, TypeNameToID[L"float"](), Dim::eCube, 1);
					int tmp = CurrentID;

					++CurrentID;
					CodeGen.OpTypeSampledImage(CurrentID, tmp);
					TypeNameToID[typeName] = CurrentID;
				}

				if (typeName == L"sampler2DShadow")
				{
					DefineBasicType(new ILBasicType(ILBaseType::Float));

					++CurrentID;
					CodeGen.OpTypeImage(CurrentID, TypeNameToID[L"float"](), Dim::e2D, 1);
					int tmp = CurrentID;

					++CurrentID;
					CodeGen.OpTypeSampledImage(CurrentID, tmp);
					TypeNameToID[typeName] = CurrentID;
				}

				if (typeName == L"bool")
				{
					++CurrentID;
					CodeGen.OpTypeBool(CurrentID);
					TypeNameToID[typeName] = CurrentID;
				}

				if (TypeNameToID[typeName] == -1)
				{
					throw InvalidProgramException(L"fail to generate type definition for: " + typeName);
				}

				int id = TypeNameToID[typeName];
				IDInfos[id] = IDInfo::CreateIDInfoForTypeofValue(id, Type);

				return id;
			}

			//UniformOrBuffer - 0: none; 1: uniform; 2: buffer 
			int DefineType(RefPtr<ILType> Type, int UniformOrBuffer = 0)
			{
				if (!Type)
				{
					if (TypeNameToID.ContainsKey(L"void"))
						return TypeNameToID[L"void"];
					++CurrentID;
					//TypeDefinition << LR"(%)" <<  << LR"( = OpTypeVoid)" << EndLine;
					CodeGen.OpTypeVoid(CurrentID);
					TypeNameToID[L"void"] = CurrentID;
					IDInfos[CurrentID] = IDInfo::CreateIDInfoForTypeofValue(CurrentID, nullptr);
					return CurrentID;
				}
				int RetID = -1;
				if (auto ArrayType = dynamic_cast<ILArrayType*>(Type.Ptr()))
				{
					String IndexName = Type->ToString();
					if (UniformOrBuffer != 0)
						IndexName = IndexName + L"#" + UniformOrBuffer;
					if (TypeNameToID.ContainsKey(IndexName))
						return TypeNameToID[IndexName];

					if (ArrayType->ArrayLength != 0)
					{
						//normal constant-length array
						int lengthID = AddInstrConstantInt(ArrayType->ArrayLength);

						int elementTypeID = DefineType(ArrayType->BaseType, UniformOrBuffer);
						++CurrentID;
						CodeGen.OpTypeArray(CurrentID, elementTypeID, lengthID);
						TypeNameToID[IndexName] = CurrentID;
						IDInfos[CurrentID] = IDInfo::CreateIDInfoForTypeofValue(CurrentID, Type, UniformOrBuffer);
						RetID = CurrentID;
					}
					else
					{
						//dynamic array
						int elementTypeID = DefineType(ArrayType->BaseType, UniformOrBuffer);
						++CurrentID;
						CodeGen.OpTypeRuntimeArray(CurrentID, elementTypeID);
						TypeNameToID[IndexName] = CurrentID;
						IDInfos[CurrentID] = IDInfo::CreateIDInfoForTypeofValue(CurrentID, Type, UniformOrBuffer);
						RetID = CurrentID;
					}

					if (UniformOrBuffer != 0)
					{
						int Stride = GetSize(ArrayType->BaseType.Ptr(), UniformOrBuffer);
						CodeGen.OpDecorate(RetID, Decoration::ArrayStride, Stride);
					}
				}
				if (auto StructType = dynamic_cast<ILStructType*>(Type.Ptr()))
				{
					String IndexName = Type->ToString();
					if (UniformOrBuffer != 0)
						IndexName = IndexName + L"#" + UniformOrBuffer;
					if (TypeNameToID.ContainsKey(IndexName))
						return TypeNameToID[IndexName];

					List<int> memberIDList;
					for (auto & member : StructType->Members)
						memberIDList.Add(DefineType(member.Type, UniformOrBuffer));
					++CurrentID;
					CodeGen.OpTypeStruct(CurrentID, memberIDList);
					TypeNameToID[IndexName] = CurrentID;
					IDInfos[CurrentID] = IDInfo::CreateIDInfoForTypeofValue(CurrentID, Type, UniformOrBuffer);
					RetID = CurrentID;

					//generate decoration for struct layout
					if (UniformOrBuffer != 0)
					{
						int Offset = 0;
						int Index = 0;
						for (auto & MemberTypeID : memberIDList)
						{
							RefPtr<ILType> MemberType = IDInfos[MemberTypeID]().GetILType();

							int BaseAlignment = GetBaseAlignment(MemberType.Ptr(), UniformOrBuffer);

							//round up to baseAlignment
							if (Offset % BaseAlignment)
								Offset += BaseAlignment - Offset % BaseAlignment;

							AddInstrMemberDecorate(RetID, Index, Decoration::Offset, Offset);

							if (MemberType->IsFloatMatrix())
							{
								AddInstrMemberDecorate(RetID, Index, Decoration::ColMajor);
								AddInstrMemberDecorate(RetID, Index, Decoration::MatrixStride, 16);
							}

							Offset += GetSize(MemberType.Ptr(), UniformOrBuffer);
							Index++;
						}
					}

					//generate debug information
					CodeGen.OpName(RetID, Type->ToString());
					int index = 0;
					for (auto &member : StructType->Members)
					{
						CodeGen.OpMemberName(RetID, index, member.FieldName);
						index++;
					}
				}
				if (auto BasicType = dynamic_cast<ILBasicType*>(Type.Ptr()))
				{
					if (TypeNameToID.ContainsKey(Type->ToString()))
						return TypeNameToID[Type->ToString()];
					RetID = DefineBasicType(Type);
				}
				return RetID;
			}

			int DefineTypePointer(RefPtr<ILType> Type, StorageClass store, int UniformOrBuffer = 0)
			{
				String PointerName = Type->ToString() + L"$" + StorageClassToString(store) + L"#" + UniformOrBuffer;
				if (TypeStorageToTypePointerID.ContainsKey(PointerName))
					return TypeStorageToTypePointerID[PointerName]();

				int basetypeID = DefineType(Type, UniformOrBuffer);
				++CurrentID;
				CodeGen.OpTypePointer(CurrentID, store, basetypeID);
				TypeStorageToTypePointerID[PointerName] = CurrentID;
				IDInfos[CurrentID] = IDInfo::CreateIDInfoForTypeofPointer(CurrentID, Type, basetypeID, store);
				return CurrentID;
			}

			int AddInstrTypeFunction(CompiledFunction * func, const List<RefPtr<ILType>> & argTypes, RefPtr<ILType> returnType)
			{
				int returnTypeID = DefineType(returnType);
				for (auto & arg : argTypes)
					DefineTypePointer(arg, StorageClass::Function);
				int functionTypeID = ++CurrentID;
				List<int> argIDList;
				for (auto & arg : argTypes)
					argIDList.Add(DefineTypePointer(arg, StorageClass::Function));
				CodeGen.OpTypeFunction(functionTypeID, returnTypeID, argIDList);
				IDInfos[functionTypeID] = IDInfo::CreateIDInfoForFunction(functionTypeID, func);
				if (func)
					FunctionNameToFunctionTypeID[func->Name] = functionTypeID;
				else
					FunctionNameToFunctionTypeID[L"main"] = functionTypeID;
				return functionTypeID;
			}

			int AddInstrConstantBool(int value)
			{
				if (Dictionary_ConstantBoolToID.ContainsKey(value != 0))
					return Dictionary_ConstantBoolToID[value != 0].GetValue();

				auto Type = GetTypeFromString(L"bool");
				int typeID = DefineType(Type);
				++CurrentID;
				CodeGen.OpConstantBool(typeID, CurrentID, value != 0);
				IDInfos[CurrentID] = IDInfo::CreateIDInfoForValue(CurrentID, Type, 0, typeID);
				Dictionary_ConstantBoolToID[value != 0] = CurrentID;
				return CurrentID;
			}

			int AddInstrConstantFloat(float f)
			{
				auto Type = GetTypeFromString(L"float");
				int typeID = DefineType(Type);
				++CurrentID;
				CodeGen.OpConstantFloat(CurrentID, typeID, f);
				IDInfos[CurrentID] = IDInfo::CreateIDInfoForValue(CurrentID, Type, 0, typeID);
				return CurrentID;
			}

			int AddInstrConstantInt(int i)
			{
				auto Type = GetTypeFromString(L"int");
				if (Dictionary_ConstantIntToID.ContainsKey(i))
					return Dictionary_ConstantIntToID[i].GetValue();

				int typeID = DefineType(Type);
				++CurrentID;
				CodeGen.OpConstantInt(CurrentID, typeID, i);
				IDInfos[CurrentID] = IDInfo::CreateIDInfoForValue(CurrentID, Type, 0, typeID);
				Dictionary_ConstantIntToID[i] = CurrentID;
				return CurrentID;
			}

			int AddInstrConstantUInt(unsigned int i)
			{
				auto Type = GetTypeFromString(L"uint");
				if (Dictionary_ConstantUIntToID.ContainsKey(i))
					return Dictionary_ConstantUIntToID[i].GetValue();

				int typeID = DefineType(Type);
				++CurrentID;
				CodeGen.OpConstantUInt(CurrentID, typeID, i);
				IDInfos[CurrentID] = IDInfo::CreateIDInfoForValue(CurrentID, Type, 0, typeID);
				Dictionary_ConstantUIntToID[i] = CurrentID;
				return CurrentID;
			}

			int AddInstrConstantCompositeFloat(float *f, int len)
			{
				RefPtr<ILType> Type;
				if (len == 2)
					Type = GetTypeFromString(L"vec2");
				else if (len == 3)
					Type = GetTypeFromString(L"vec3");
				else if (len == 4)
					Type = GetTypeFromString(L"vec4");
				else
					throw InvalidOperationException(L"Invalid type in AddInstrConstantCompositeFloat(): vec"+len);
				int typeID = DefineType(Type);

				List<int> elementIDs;
				for (int i = 0; i < len; i++)
					elementIDs.Add(AddInstrConstantFloat(f[i]));

				++CurrentID;
				CodeGen.OpConstantComposite(CurrentID, typeID, elementIDs);

				IDInfos[CurrentID] = IDInfo::CreateIDInfoForValue(CurrentID, Type, 0, typeID);
				return CurrentID;
			}

			int AddInstrConstantCompositeInt(int *v, int len)
			{
				RefPtr<ILType> Type;
				if (len == 2)
					Type = GetTypeFromString(L"ivec2");
				else if (len == 3)
					Type = GetTypeFromString(L"ivec3");
				else if (len == 4)
					Type = GetTypeFromString(L"ivec4");
				else
					throw InvalidOperationException(L"Invalid type in AddInstrConstantCompositeInt(): ivec" + len);
				int typeID = DefineType(Type);

				List<int> elementIDs;
				for (int i = 0; i < len; i++)
					elementIDs.Add(AddInstrConstantInt(v[i]));

				++CurrentID;
				CodeGen.OpConstantComposite(CurrentID, typeID, elementIDs);

				IDInfos[CurrentID] = IDInfo::CreateIDInfoForValue(CurrentID, Type, 0, typeID);
				return CurrentID;
			}

			int AddInstrConstantCompositeUInt(unsigned int *v, int len)
			{
				RefPtr<ILType> Type;
				if (len == 2)
					Type = GetTypeFromString(L"uvec2");
				else if (len == 3)
					Type = GetTypeFromString(L"uvec3");
				else if (len == 4)
					Type = GetTypeFromString(L"uvec4");
				else
					throw InvalidOperationException(L"Invalid type in AddInstrConstantCompositeUInt(): uvec" + len);
				int typeID = DefineType(Type);

				List<int> elementIDs;
				for (int i = 0; i < len; i++)
					elementIDs.Add(AddInstrConstantUInt(*(v + i)));

				++CurrentID;
				CodeGen.OpConstantComposite(CurrentID, typeID, elementIDs);

				IDInfos[CurrentID] = IDInfo::CreateIDInfoForValue(CurrentID, Type, 0, typeID);
				return CurrentID;
			}

			int AddInstrConstantMatrix(float *f, int n)
			{
				RefPtr<ILType> Type;
				if (n == 3)
					Type = GetTypeFromString(L"mat3");
				else if (n == 4)
					Type = GetTypeFromString(L"mat4");
				else
					throw InvalidOperationException(L"Invalid type in AddInstrConstantMatrix(): mat" + n);
				int typeID = DefineType(Type);

				List<int> vectorIDs;
				for (int i = 0; i < n; i++)
					vectorIDs.Add(AddInstrConstantCompositeFloat(f + (i * n), n));

				++CurrentID;
				CodeGen.OpConstantComposite(CurrentID, typeID, vectorIDs);

				IDInfos[CurrentID] = IDInfo::CreateIDInfoForValue(CurrentID, Type, 0, typeID);
				return CurrentID;
			}

			int AddInstrCompositeConstruct(ILOperand* op, RefPtr<ILType> Type, List<int> Arguments)
				// return ID of this instruction
			{
				int typeID = DefineType(Type);
				++CurrentID;
				CodeGen.OpCompositeConstruct(CurrentID, typeID, Arguments);
				IDInfos[CurrentID] = IDInfo::CreateIDInfoForValue(CurrentID, Type, op, typeID);
				UpdateValue(op, CurrentID);
				return CurrentID;
			}

			int AddInstrCompositeExtract(int ID, RefPtr<ILType> baseType, int index)
			{
				int baseTypeID = DefineType(baseType);
				++CurrentID;
				CodeGen.OpCompositeExtract(CurrentID, baseTypeID, ID, index);
				IDInfos[CurrentID] = IDInfo::CreateIDInfoForValue(CurrentID, baseType, 0, baseTypeID);
				return CurrentID;
			}

			int AddInstrCompositeInsert(RefPtr<ILType> Type, int ID, int index, int op)
			{
				//ID[index] = op
				int typeID = DefineType(Type);
				++CurrentID;
				CodeGen.OpCompositeInsert(CurrentID, typeID, op, ID, index);
				IDInfos[CurrentID] = IDInfo::CreateIDInfoForValue(CurrentID, Type, 0, typeID);
				return CurrentID;
			}

			int AddInstrExtInst(ILOperand* op, RefPtr<ILType> Type, int instrNumber, List<int> Arguments)
			{
				int typeID = DefineType(Type);
				++CurrentID;
				CodeGen.OpExtInst(CurrentID, typeID, instrNumber, Arguments);
				IDInfos[CurrentID] = IDInfo::CreateIDInfoForValue(CurrentID, Type, op, typeID);
				UpdateValue(op, CurrentID);
				return CurrentID;
			}

			void AddInstrStore(ILOperand *op, int op0, int op1) {
				CodeGen.OpStore(op0, op1);
				UpdateValue(op, op1);
				return;
			}

			int AddInstrVariableDeclaration(ILOperand *op, RefPtr<ILType> typeIL, StorageClass store, String DebugName = L"", int UniformOrBuffer = 0)
			{
				int typeID = DefineTypePointer(typeIL, store, UniformOrBuffer);
				++CurrentID;
				CodeGen.OpVariable(CurrentID, typeID, store);
				UpdateVariable(op, CurrentID);
				IDInfos[CurrentID] =
					IDInfo::CreateIDInfoForPointer(CurrentID, op, typeID, typeIL, IDInfos[typeID]().GetBaseTypeID(), store);
				//Debug Information
				CodeGen.OpName(CurrentID, DebugName!=L""? DebugName : (op?op->Name:L""));
				return CurrentID;
			}

			int AddInstrAccessChain_VectorMember(ILOperand *op, int ID, int indexID, int index)
			{
				String variableName = L"";
				if (index == -1 && indexID == -1)
					throw InvalidOperationException(L"indexID=-1 && index=-1 in AddInstrAccessChain_VectorMember()");

				if (indexID == -1) {
					//indexID == -1 && index != -1
					indexID = AddInstrConstantInt(index);
				}

				if (index != -1)
				{
					variableName = IDInfos[ID]().GetVariableName() + L"[" + index + L"]";
				}

				RefPtr<ILType> TypeIL = IDInfos[ID]().GetILType();
				RefPtr<ILType> memberTypeIL = nullptr;
				if (TypeIL->IsFloatMatrix())
				{
					if (TypeIL->ToString() == "mat3")
						memberTypeIL = GetTypeFromString(L"vec3");
					else if (TypeIL->ToString() == "mat4")
						memberTypeIL = GetTypeFromString(L"vec4");
				}
				else if (TypeIL->IsFloatVector())
				{
					memberTypeIL = GetTypeFromString(L"float");
				}
				else if (TypeIL->IsIntVector())
				{
					memberTypeIL = GetTypeFromString(L"int");
				}
				else if (TypeIL->IsUIntVector())
				{
					memberTypeIL = GetTypeFromString(L"uint");
				}
				else
					throw InvalidOperationException(L"invalid operand type for access chain: " + TypeIL->ToString());

				int memberTypeID = DefineTypePointer(memberTypeIL, IDInfos[ID]().GetStorageClass());

				++CurrentID;
				/*FunctionBody << LR"(%)" << CurrentID << LR"( = OpAccessChain %)" << memberTypeID
				<< LR"( %)" << ID << LR"( %)" << indexID << EndLine;*/
				CodeGen.OpAccessChain(CurrentID, memberTypeID, ID, indexID);
				IDInfos[CurrentID] =
					IDInfo::CreateIDInfoForPointer(
						CurrentID,
						op,
						memberTypeID,
						memberTypeIL,
						IDInfos[memberTypeID]().GetBaseTypeID(),
						IDInfos[ID]().GetStorageClass()
					);
				UpdateVariable(op, CurrentID);
				return CurrentID;
			}

			int AddInstrAccessChain_StructMember(ILOperand *op, int ID, int indexID, int index)
			{
				if (indexID == -1)
					indexID = AddInstrConstantInt(index);
				RefPtr<ILType> Type = IDInfos[ID]().GetILType();
				ILStructType * structType = dynamic_cast<ILStructType*>(Type.Ptr());
				RefPtr<ILType> memberBasetypeIL = structType->Members[index].Type;
				int memberTypeID = DefineTypePointer(memberBasetypeIL, IDInfos[ID]().GetStorageClass());

				++CurrentID;
				/*
				FunctionBody << LR"(%)" << CurrentID << LR"( = OpAccessChain %)"
				<< memberTypeID
				<< LR"( %)" << ID << LR"( %)" << indexID << EndLine;
				*/
				CodeGen.OpAccessChain(CurrentID, memberTypeID, ID, indexID);

				UpdateVariable(op, CurrentID);
				IDInfos[CurrentID] =
					IDInfo::CreateIDInfoForPointer(
						CurrentID,
						op,
						memberTypeID,
						memberBasetypeIL,
						IDInfos[memberTypeID]().GetBaseTypeID(),
						IDInfos[ID]().GetStorageClass()
					);
				return CurrentID;
			}

			int AddInstrAccessChain_StructMember(ILOperand *op, String memberName)
			{
				int structID = FindVariableID(op);
				ILStructType* structIL = dynamic_cast<ILStructType*>(IDInfos[structID]().GetILType().Ptr());
				if (!structIL)
					throw InvalidProgramException(L"can not convert to ILStruct in AddInstrAccessChain_StructMember()");
				int index = structIL->Members.FindFirst([&](ILStructType::ILStructField member)
				{
					return member.FieldName == memberName;
				});
				int indexID = AddInstrConstantInt(index);
				return AddInstrAccessChain_StructMember(op, structID, indexID, index);
			}

			int AddInstrAccessChain_StructMember(ILOperand *op, int structID, String memberName)
			{
				ILStructType* structIL = dynamic_cast<ILStructType*>(IDInfos[structID]().GetILType().Ptr());
				if (!structIL)
					throw InvalidProgramException(L"can not convert to ILStruct in AddInstrAccessChain_StructMember()");
				int index = structIL->Members.FindFirst([&](ILStructType::ILStructField member)
				{
					return member.FieldName == memberName;
				});
				int indexID = AddInstrConstantInt(index);
				return AddInstrAccessChain_StructMember(op, structID, indexID, index);
			}

			int AddInstrAccessChain_ArrayMember(ILOperand *op, RefPtr<ILType> Type, int ID, int indexID)
			{
				if (!Type)
					throw InvalidProgramException(L"empty type in AddInstrAccessChain_ArrayMember()");
				auto arrayType = dynamic_cast<ILArrayType*>(Type.Ptr());
				int baseTypeID = DefineTypePointer(arrayType->BaseType, IDInfos[ID]().GetStorageClass()); //it's a pointer

				++CurrentID;
				CodeGen.OpAccessChain(CurrentID, baseTypeID, ID, indexID);
				IDInfos[CurrentID] =
					IDInfo::CreateIDInfoForPointer(
						CurrentID,
						op,
						baseTypeID,
						arrayType->BaseType,
						IDInfos[baseTypeID]().GetBaseTypeID(),
						IDInfos[ID]().GetStorageClass()
					);
				UpdateVariable(op, CurrentID);

				return CurrentID;
			}

			int AddInstrLoad(int variableID, MemoryAccess ma)
			{
				++CurrentID;
				RefPtr<ILType> Type = IDInfos[variableID]().GetILType();
				int TypeID = IDInfos[variableID]().GetBaseTypeID();
				CodeGen.OpLoad(CurrentID, TypeID, variableID, ma);
				IDInfos[CurrentID]
					= IDInfo::CreateIDInfoForValue(
						CurrentID,
						Type,
						0,
						TypeID);
				return CurrentID;
			}

			int AddInstrLoad(ILOperand *op, ILOperand *targetOp, MemoryAccess ma)
			{
				int targetID = FindVariableID(targetOp);
				if (targetID == -1)
					return -1;
				int typeID = IDInfos[targetID]().GetBaseTypeID();
				++CurrentID;
				CodeGen.OpLoad(CurrentID, typeID, targetID, ma);
				IDInfos[CurrentID]
					= IDInfo::CreateIDInfoForValue(
						CurrentID,
						IDInfos[targetID]().GetILType(),
						op,
						typeID);
				UpdateValue(op, CurrentID);
				return CurrentID;
			}

			int AddInstrINotEqual(int id0, int id1)
			{
				RefPtr<ILType> typeIL = GetTypeFromString(L"bool");
				int typeID = DefineType(typeIL);
				++CurrentID;
				CodeGen.OpINotEqual(CurrentID, typeID, id0, id1);
				IDInfos[CurrentID]
					= IDInfo::CreateIDInfoForValue(
						CurrentID,
						typeIL,
						0,
						typeID
					);
				return CurrentID;
			}

			int AddInstrTexture(
				ILOperand *op, 
				int textureID, 
				int coordinateID, 
				ExecutionModel currentExecutionModel,
				int Bias = -1,
				int GradX = -1,
				int GradY = -1)
			{
				RefPtr<ILType> typeIL = GetTypeFromString(L"vec4");
				int typeID = DefineType(typeIL);

				++CurrentID;
				if (currentExecutionModel == ExecutionModel::Fragment && GradX == -1)
				{
					//implicit LOD
					CodeGen.OpImageSampleImplicitLod(CurrentID, typeID, textureID, coordinateID, Bias);
				}
				else
				{
					//explicit LOD
					int zeroID = AddInstrConstantInt(0);
					CodeGen.OpImageSampleExplicitLod(CurrentID, typeID, textureID, coordinateID, zeroID, Bias, GradX, GradY);
				}
				IDInfos[CurrentID] = IDInfo::CreateIDInfoForValue(
					CurrentID,
					typeIL,
					op,
					typeID
				);
				UpdateValue(op, CurrentID);

				return CurrentID;
			}

			int AddInstrTextureShadow(
				ILOperand *op, 
				int textureID, 
				int coordinateID, 
				ExecutionModel currentExecutionModel) 
			{
				RefPtr<ILType> typeIL = GetTypeFromString(L"vec4");
				int typeID = DefineType(typeIL);

				int veclen = IDInfos[coordinateID]().GetILType()->GetVectorSize();
				int DrefID = AddInstrCompositeExtract(coordinateID, GetTypeFromString(L"float"), veclen-1);

				++CurrentID;
				if (currentExecutionModel == ExecutionModel::Fragment)
				{
					//implicit LOD
					CodeGen.OpImageSampleDrefImplicitLod(CurrentID, typeID, textureID, coordinateID, DrefID);
				}
				else
				{
					//explicit LOD
					int zeroID = AddInstrConstantInt(0);
					CodeGen.OpImageSampleDrefExplicitLod(CurrentID, typeID, textureID, coordinateID, DrefID, zeroID);
				}
				IDInfos[CurrentID] = IDInfo::CreateIDInfoForValue(
					CurrentID,
					typeIL,
					op,
					typeID
				);
				UpdateValue(op, CurrentID);

				return CurrentID;
			}

			int AddInstrTexture2DShadowProj(
				ILOperand *op,
				int textureID,
				int coordinateID,	////coordinateID: u, v, depth, q
				ExecutionModel currentExecutionModel)
			{
				RefPtr<ILType> typeIL = GetTypeFromString(L"vec4");
				int typeID = DefineType(typeIL);

				int DrefID = AddInstrCompositeExtract(coordinateID, GetTypeFromString(L"float"), 2);
				int qID = AddInstrCompositeExtract(coordinateID, GetTypeFromString(L"float"), 3);
				int NewCoordinateID = AddInstrCompositeInsert(IDInfos[coordinateID]().GetILType(), coordinateID, 2, qID);

				++CurrentID;
				if (currentExecutionModel == ExecutionModel::Fragment)
				{
					//implicit LOD
					CodeGen.OpImageSampleProjDrefImplicitLod(CurrentID, typeID, textureID, NewCoordinateID, DrefID);
				}
				else
				{
					//explicit LOD
					int zeroID = AddInstrConstantInt(0);
					CodeGen.OpImageSampleProjDrefExplicitLod(CurrentID, typeID, textureID, NewCoordinateID, DrefID, zeroID);
				}
				IDInfos[CurrentID] = IDInfo::CreateIDInfoForValue(
					CurrentID,
					typeIL,
					op,
					typeID
				);
				UpdateValue(op, CurrentID);

				return CurrentID;
			}

			int AddInstrConvertSToF(int destTypeID, int operandID)
			{
				++CurrentID;
				CodeGen.OpConvertSToF(CurrentID, destTypeID, operandID);
				IDInfos[CurrentID] = IDInfo::CreateIDInfoForValue(
					CurrentID,
					IDInfos[destTypeID]().GetILType(),
					0,
					destTypeID
				);
				return CurrentID;
			}

			int AddInstrConvertFToS(int destTypeID, int operandID)
			{
				++CurrentID;
				CodeGen.OpConvertFToS(CurrentID, destTypeID, operandID);
				IDInfos[CurrentID] = IDInfo::CreateIDInfoForValue(
					CurrentID,
					IDInfos[destTypeID]().GetILType(),
					0,
					destTypeID
				);
				return CurrentID;
			}

			int AddInstrConvertUToF(int destTypeID, int operandID)
			{
				++CurrentID;
				CodeGen.OpConvertUToF(CurrentID, destTypeID, operandID);
				IDInfos[CurrentID] = IDInfo::CreateIDInfoForValue(
					CurrentID,
					IDInfos[destTypeID]().GetILType(),
					0,
					destTypeID
				);
				return CurrentID;
			}

			int AddInstrConvertFToU(int destTypeID, int operandID)
			{
				++CurrentID;
				CodeGen.OpConvertFToU(CurrentID, destTypeID, operandID);
				IDInfos[CurrentID] = IDInfo::CreateIDInfoForValue(
					CurrentID,
					IDInfos[destTypeID]().GetILType(),
					0,
					destTypeID
				);
				return CurrentID;
			}

			int AddInstrConvertSToU(int destTypeID, int operandID)
			{
				++CurrentID;
				CodeGen.OpBitCast(CurrentID, destTypeID, operandID);
				IDInfos[CurrentID] = IDInfo::CreateIDInfoForValue(
					CurrentID,
					IDInfos[destTypeID]().GetILType(),
					0,
					destTypeID
				);
				return CurrentID;
			}

			int AddInstrConvertUToS(int destTypeID, int operandID) 
			{
				++CurrentID;
				CodeGen.OpBitCast(CurrentID, destTypeID, operandID);
				IDInfos[CurrentID] = IDInfo::CreateIDInfoForValue(
					CurrentID,
					IDInfos[destTypeID]().GetILType(),
					0,
					destTypeID
				);
				return CurrentID;
			}

			int AddInstrBitcast(int destTypeID, int operandID)
			{
				++CurrentID;
				CodeGen.OpBitCast(CurrentID, destTypeID, operandID);
				IDInfos[CurrentID] = IDInfo::CreateIDInfoForValue(
					CurrentID,
					IDInfos[destTypeID]().GetILType(),
					0,
					destTypeID
				);
				return CurrentID;
			}

			int AddInstrFunctionCall(ILOperand *op, int typeID, int funcID, List<int> &args)
			{
				++CurrentID;
				CodeGen.OpFunctionCall(CurrentID, typeID, funcID, args);
				IDInfos[CurrentID] = IDInfo::CreateIDInfoForValue(
					CurrentID,
					IDInfos[typeID]().GetILType(),
					op,
					typeID
				);
				UpdateValue(op, CurrentID);
				return CurrentID;
			}

			int AddInstrFnegate(ILOperand *op, int typeID, int valueID)
			{
				++CurrentID;
				CodeGen.OpFNegate(CurrentID, typeID, valueID);
				IDInfos[CurrentID] = IDInfo::CreateIDInfoForValue(
					CurrentID,
					IDInfos[typeID]().GetILType(),
					op, 
					typeID
				);
				UpdateValue(op, CurrentID);
				return CurrentID;
			}

			int AddInstrSnegate(ILOperand *op, int typeID, int valueID)
			{
				++CurrentID;
				CodeGen.OpSNegate(CurrentID, typeID, valueID);
				IDInfos[CurrentID] = IDInfo::CreateIDInfoForValue(
					CurrentID,
					IDInfos[typeID]().GetILType(),
					op,
					typeID
				);
				UpdateValue(op, CurrentID);
				return CurrentID;
			}

			int AddInstrNot(ILOperand *op, int typeID, int valueID)
			{
				++CurrentID;
				CodeGen.OpNot(CurrentID, typeID, valueID);
				IDInfos[CurrentID] = IDInfo::CreateIDInfoForValue(
					CurrentID,
					IDInfos[typeID]().GetILType(),
					op,
					typeID
				);
				UpdateValue(op, CurrentID);
				return CurrentID;
			}

			int AddInstrLogicalNot(ILOperand *op, int typeID, int valueID)
			{
				++CurrentID;
				CodeGen.OpLogicalNot(CurrentID, typeID, valueID);
				IDInfos[CurrentID] = IDInfo::CreateIDInfoForValue(
					CurrentID,
					IDInfos[typeID]().GetILType(),
					op,
					typeID
				);
				UpdateValue(op, CurrentID);
				return CurrentID;
			}

			int AddInstrMatrixTimesScalar(ILOperand *op, int ID0, int ID1)
			{
				++CurrentID;
				CodeGen.OpMatrixTimesScalar(CurrentID, IDInfos[ID0]().GetTypeID(), ID0, ID1);
				IDInfos[CurrentID] = IDInfo::CreateIDInfoForValue(
					CurrentID,
					IDInfos[ID0]().GetILType(),
					op,
					IDInfos[ID0]().GetTypeID()
				);
				UpdateValue(op, CurrentID);
				return CurrentID;
			}

			int AddInstrVectorTimesMatrix(ILOperand *op, int ID0, int ID1)
			{
				++CurrentID;
				CodeGen.OpVectorTimesMatrix(CurrentID, IDInfos[ID0]().GetTypeID(), ID0, ID1);
				IDInfos[CurrentID] = IDInfo::CreateIDInfoForValue(
					CurrentID,
					IDInfos[ID0]().GetILType(),
					op,
					IDInfos[ID0]().GetTypeID()
				);
				UpdateValue(op, CurrentID);
				return CurrentID;
			}

			int AddInstrMatrixTimesVector(ILOperand *op, int ID0, int ID1)
			{
				++CurrentID;
				CodeGen.OpMatrixTimesVector(CurrentID, IDInfos[ID1]().GetTypeID(), ID0, ID1);
				IDInfos[CurrentID] = IDInfo::CreateIDInfoForValue(
					CurrentID,
					IDInfos[ID1]().GetILType(),
					op,
					IDInfos[ID1]().GetTypeID()
				);
				UpdateValue(op, CurrentID);
				return CurrentID;
			}

			int AddInstrMatrixTimesMatrix(ILOperand *op, int ID0, int ID1)
			{
				++CurrentID;
				CodeGen.OpMatrixTimesMatrix(CurrentID, IDInfos[ID0]().GetTypeID(), ID0, ID1);
				IDInfos[CurrentID] = IDInfo::CreateIDInfoForValue(
					CurrentID,
					IDInfos[ID0]().GetILType(),
					op,
					IDInfos[ID0]().GetTypeID()
				);
				UpdateValue(op, CurrentID);
				return CurrentID;
			}

			int AddInstrBinaryInstr(ILOperand *op, RefPtr<ILType> instrType, const String &opStr, int ID0, int ID1)
			{
				int instrTypeID = DefineType(instrType);
				CurrentID++;
				CodeGen.OpBinaryInstr(CurrentID, opStr, instrTypeID, ID0, ID1);
				IDInfos[CurrentID] = IDInfo::CreateIDInfoForValue(CurrentID, instrType, op, instrTypeID);
				UpdateValue(op, CurrentID);
				return CurrentID;
			}

			int AddInstrMulAdd(int operandID, float mul, float add)
			{
				//return 0.5*op+0.5
				int typeID = IDInfos[operandID]().GetTypeID();  //shoudl be float 
				RefPtr<ILType> typeIL = IDInfos[operandID]().GetILType();

				int mul_ID = AddInstrConstantFloat(mul);
				mul_ID = ConvertBasicType(mul_ID, IDInfos[mul_ID]().GetILType(), IDInfos[operandID]().GetILType());

				int add_ID = AddInstrConstantFloat(add);
				add_ID = ConvertBasicType(add_ID, IDInfos[add_ID]().GetILType(), IDInfos[operandID]().GetILType());

				++CurrentID;
				//ctx.FunctionBody << LR"(%)" << ctx.CurrentID << LR"( = OpFMul %)" << typeID << LR"( %)" << operandID << LR"( %)" << mul_ID << EndLine;
				CodeGen.OpFMul(CurrentID, typeID, operandID, mul_ID);
				IDInfos[CurrentID] = IDInfo::CreateIDInfoForValue(CurrentID, typeIL, 0, typeID);
				++CurrentID;
				//ctx.FunctionBody << LR"(%)" << ctx.CurrentID << LR"( = OpFAdd %)" << typeID << LR"( %)" << ctx.CurrentID-1 << LR"( %)" << add_ID << EndLine;
				CodeGen.OpFAdd(CurrentID, typeID, CurrentID - 1, add_ID);
				IDInfos[CurrentID] = IDInfo::CreateIDInfoForValue(CurrentID, typeIL, 0, typeID);
				return CurrentID;
			}

			int ConvertBasicType(int operandID, RefPtr<ILType> srcType, RefPtr<ILType> dstType)
			{
				String srcStr = srcType->ToString();
				String dstStr = dstType->ToString();
				if (srcStr == dstStr)
					return operandID;

				if (dstType->IsBool())
				{
					if (srcType->IsInt())
						return AddInstrINotEqual(operandID, AddInstrConstantInt(0));
					if (srcType->IsUInt())
						return AddInstrINotEqual(operandID, AddInstrConstantUInt(0));
					throw NotImplementedException(L"only convert int to bool in ConvertBasicType(): " + srcType->ToString());
				}

				//from column vector to column vector
				bool srcIsColumnVector = (srcType->IsFloat() || srcType->IsFloatVector() || srcType->IsIntegral()) && !srcType->IsFloatMatrix();
				bool dstIsColumnVector = (dstType->IsFloat() || dstType->IsFloatVector() || dstType->IsIntegral()) && !dstType->IsFloatMatrix();
				if (srcIsColumnVector && dstIsColumnVector && srcType->GetVectorSize() != dstType->GetVectorSize())
				{
					//make src ID have length equal to destType

					RefPtr<ILType> elementType;
					if (srcType->IsInt() || srcType->IsUInt())
						elementType = new ILBasicType(ILBaseType::Int);
					else if (srcType->IsUInt() || srcType->IsUIntVector())
						elementType = new ILBasicType(ILBaseType::UInt);
					else
						elementType = new ILBasicType(ILBaseType::Float);
					List<int> arguments;
					int extraID = -1;

					if (srcType->GetVectorSize() == 1)
					{
						for (int i = 0; i < dstType->GetVectorSize(); i++)
						{
							arguments.Add(operandID);
						}
					}
					else {
						for (int i = 0; i < dstType->GetVectorSize(); i++)
						{
							if (i >= srcType->GetVectorSize())
							{
								if (i == srcType->GetVectorSize())
								{
									if (srcType->IsInt() || srcType->IsIntVector())
										extraID = AddInstrConstantInt(0);
									else if (srcType->IsUInt() || srcType->IsUIntVector())
										extraID = AddInstrConstantUInt(0);
									else
										extraID = AddInstrConstantFloat(0.0);
								}
								arguments.Add(extraID);
							}
							else
							{
								if (srcType->GetVectorSize() == 1)
									arguments.Add(operandID);
								else
									arguments.Add(AddInstrCompositeExtract(operandID, elementType, i));
							}
						}
					}

					int BaseType = (dynamic_cast<ILBasicType*>(srcType.Ptr()))->Type;
					int newBaseType = BaseType & ~15; // int or float
					newBaseType += dstType->GetVectorSize() - 1;
					RefPtr<ILType> newSrcType = new ILBasicType(ILBaseType(newBaseType));

					operandID = AddInstrCompositeConstruct(0, newSrcType, arguments);
					srcType = newSrcType;
				}

				srcStr = srcType->ToString();
				dstStr = dstType->ToString();
				if (srcStr == dstStr)
					return operandID;

				//from scalar to matrix
				if ((srcStr == L"float" || srcStr == L"int" || srcStr == L"uint") && dstType->IsFloatMatrix())
				{
					throw NotImplementedException(L"scalar to matrix conversion is not supported yet.");
				}

				//from matrix to matrix
				if (srcType->IsFloatMatrix() && dstType->IsFloatMatrix())
				{
					throw NotImplementedException(L"matrix to matrix conversion is not supported yet.");
				}

				if (srcType->GetVectorSize() != dstType->GetVectorSize())
				{
					throw NotImplementedException(L"can not convert " + srcType->ToString() + L" to " + dstType->ToString());
				}

				//component-wise conversion

				bool srcFloat = srcType->IsFloat() || srcType->IsFloatVector();
				bool srcInt = srcType->IsInt() || srcType->IsIntVector();
				bool srcUint = srcType->IsUInt() || srcType->IsUIntVector();
				bool dstFloat = dstType->IsFloat() || dstType->IsFloatVector();
				bool dstInt = dstType->IsInt() || dstType->IsIntVector();
				bool dstUint = dstType->IsUInt() || dstType->IsUIntVector();

				int destTypeID = DefineType(dstType);
				if (srcInt && dstFloat)
					return AddInstrConvertSToF(destTypeID, operandID);
				else if (srcFloat && dstInt)
					return AddInstrConvertFToS(destTypeID, operandID);
				else if (srcUint && dstFloat)
					return AddInstrConvertUToF(destTypeID, operandID);
				else if (srcFloat && dstUint)
					return AddInstrConvertFToU(destTypeID, operandID);
				else if (srcInt && dstUint)
					return AddInstrConvertSToU(destTypeID, operandID);
				else if (srcUint && dstInt)
					return AddInstrConvertUToS(destTypeID, operandID);
				else
					throw NotImplementedException(L"can not convert " + srcType->ToString() + L" to " + dstType->ToString());
			}

			void AddInstrSelectionMerge(int MergeLabel) {
				CodeGen.OpSelectionMerge(MergeLabel);
			}

			void AddInstrBranchConditional(int ID, int TrueLabel, int FalseLabel)
			{
				CodeGen.OpBranchConditional(ID, TrueLabel, FalseLabel);
			}

			void AddInstrLabel_AtFunctionBody(int Label) {
				CodeGen.OpLabel_AtFunctionBody(Label);
			}

			void AddInstrLabel_AtFunctionHeader(int Label)
			{
				CodeGen.OpLabel_AtFunctionHeader(Label);
			}

			void AddInstrBranch(int Target)
			{
				CodeGen.OpBranch(Target);;
			}

			int AddInstrPhi(ILOperand *op, int ID1, int Label1, int ID2, int Label2)
			{
				List<int> branches;
				branches.Add(ID1); branches.Add(Label1);
				branches.Add(ID2); branches.Add(Label2);

				++CurrentID;
				CodeGen.OpPhi(CurrentID, IDInfos[ID1]().GetTypeID(), branches);

				IDInfos[CurrentID] =
					IDInfo::CreateIDInfoForValue(
						CurrentID,
						IDInfos[ID1]().GetILType(),
						op,
						IDInfos[ID1]().GetTypeID()
					);
				UpdateValue(op, CurrentID);
				return CurrentID;
			}

			void AddInstrLoopMerge(int MergeLabel, int ContinueLabel)
			{
				CodeGen.OpLoopMerge(MergeLabel, ContinueLabel);
			}

			void AddInstrReturnValue(int operandID) 
			{
				CodeGen.OpReturnValue(operandID);
			}

			void AddInstrKill() 
			{
				CodeGen.OpKill();
			}

			void AddInstrDecorate(int ID, Decoration deco, int ID1 = 0)
			{
				CodeGen.OpDecorate(ID, deco, ID1);
			}

			void AddInstrMemberDecorate(int ID, int index, Decoration deco, int ID1 = 0)
			{
				CodeGen.OpMemberDecorate(ID, index, deco, ID1);
			}

			void AddInstrFunction(int funcID, int returnTypeID, int funcTypeID, String funcName) 
			{
				CodeGen.OpName(funcID, funcName);
				CodeGen.OpFunction(funcID, returnTypeID, funcTypeID);
			}

			void AddInstrFunctionParameter(ILOperand *op, int typeID, String DebugName)
			{
				int paramID = ++CurrentID;
				CodeGen.OpName(paramID, DebugName);
				CodeGen.OpFunctionParameter(paramID, typeID);
				IDInfos[paramID] = IDInfo::CreateIDInfoForPointer(
					paramID,
					op,
					typeID,
					IDInfos[typeID]().GetILType(),
					IDInfos[typeID]().GetBaseTypeID(),
					StorageClass::Function
				);
				ParameterNameToID[op] = paramID;
				UpdateVariable(op, paramID);
			}

			void AddInstrReturn()
			{
				CodeGen.OpReturn();
			}

			void AddInstrFunctionEnd()
			{
				CodeGen.OpFunctionEnd();
			}

			void AddInstrEntryPoint(ExecutionModel EM, int entryID, const List<int>& interfaceIDs)
			{
				CodeGen.OpEntryPoint(EM, entryID, interfaceIDs);
			}

			void AddInstrExecutionMode(int ID, ExecutionMode mode, int op1 = -1, int op2 = -1, int op3 = -1) 
			{
				CodeGen.OpExecutionMode(ID, mode, op1, op2, op3);
			}

			int AddInstrDot(ILOperand *op, RefPtr<ILType> typeIL, int ID0, int ID1)
			{
				int typeID = DefineType(typeIL);
				++CurrentID;
				CodeGen.OpDot(CurrentID, typeID, ID0, ID1);
				IDInfos[CurrentID] = IDInfo::CreateIDInfoForValue(
					CurrentID,
					typeIL,
					op,
					typeID
				);
				UpdateValue(op, CurrentID);
				return CurrentID;
			}

			int AddInstrTranspose(ILOperand *op, RefPtr<ILType> typeIL, int ID)
			{
				int typeID = DefineType(typeIL);
				++CurrentID;
				CodeGen.OpTranspose(CurrentID, typeID, ID);
				IDInfos[CurrentID] = IDInfo::CreateIDInfoForValue(
					CurrentID,
					typeIL,
					op,
					typeID
				);
				UpdateValue(op, CurrentID);
				return CurrentID;
			}

			int AddInstrDFdx(ILOperand *op, RefPtr<ILType> typeIL, int ID)
			{
				int typeID = DefineType(typeIL);
				++CurrentID;
				CodeGen.OpDPdx(CurrentID, typeID, ID);
				IDInfos[CurrentID] = IDInfo::CreateIDInfoForValue(
					CurrentID,
					typeIL,
					op,
					typeID
				);
				UpdateValue(op, CurrentID);
				return CurrentID;
			}

			int AddInstrDFdy(ILOperand *op, RefPtr<ILType> typeIL, int ID)
			{
				int typeID = DefineType(typeIL);
				++CurrentID;
				CodeGen.OpDPdy(CurrentID, typeID, ID);
				IDInfos[CurrentID] = IDInfo::CreateIDInfoForValue(
					CurrentID,
					typeIL,
					op,
					typeID
				);
				UpdateValue(op, CurrentID);
				return CurrentID;
			}

			int AddInstrFwidth(ILOperand *op, RefPtr<ILType> typeIL, int ID)
			{
				int typeID = DefineType(typeIL);
				++CurrentID;
				CodeGen.OpFwidth(CurrentID, typeID, ID);
				IDInfos[CurrentID] = IDInfo::CreateIDInfoForValue(
					CurrentID,
					typeIL,
					op,
					typeID
				);
				UpdateValue(op, CurrentID);
				return CurrentID;
			}

			void ProduceFunction()
			{
				CodeGen.ProduceFunction();
			}

			List<unsigned int> ProduceWordStream()
			{
				return CodeGen.ProduceWordStream(CurrentID);
			}

			String ProduceTextCode() 
			{
				return CodeGen.ProduceTextCode();
			}
		};



		class SpirvModule
		{
		private:
			SpirVCodeGenContext ctx;
			ExecutionModel currentExecutionModel;
			List<int> interfaceIDs;
			bool DepthReplacing;
			bool LocalSize;
			bool BufferImportOrExport;
			CompiledWorld * currentWorld;

			int GetOperandValue(ILOperand * op)
			{
				int id = -1;
				if (auto c = dynamic_cast<ILConstOperand*>(op))
				{
					auto type = c->Type.Ptr();
					if (type->IsFloat())
					{
						id = ctx.AddInstrConstantFloat(c->FloatValues[0]);
					}
					else if (type->IsInt())
					{
						id = ctx.AddInstrConstantInt(c->IntValues[0]);
					}
					else if (type->IsUInt())
					{
						id = ctx.AddInstrConstantUInt(*((unsigned int*)(&c->IntValues[0])));
					}
					else if (auto baseType = dynamic_cast<ILBasicType*>(type))
					{
						if (baseType->Type == ILBaseType::Float2)
						{
							id = ctx.AddInstrConstantCompositeFloat(c->FloatValues, 2);
						}
						else if (baseType->Type == ILBaseType::Float3)
						{
							id = ctx.AddInstrConstantCompositeFloat(c->FloatValues, 3);
						}
						else if (baseType->Type == ILBaseType::Float4)
						{
							id = ctx.AddInstrConstantCompositeFloat(c->FloatValues, 4);
						}
						else if (baseType->Type == ILBaseType::Float3x3)
						{
							id = ctx.AddInstrConstantMatrix(c->FloatValues, 3);
						}
						else if (baseType->Type == ILBaseType::Float4x4)
						{
							id = ctx.AddInstrConstantMatrix(c->FloatValues, 4);
						}
						else if (baseType->Type == ILBaseType::Int2)
						{
							id = ctx.AddInstrConstantCompositeInt(c->IntValues, 2);
						}
						else if (baseType->Type == ILBaseType::Int3)
						{
							id = ctx.AddInstrConstantCompositeInt(c->IntValues, 3);
						}
						else if (baseType->Type == ILBaseType::Int4)
						{
							id = ctx.AddInstrConstantCompositeInt(c->IntValues, 4);
						}
						else if (baseType->Type == ILBaseType::UInt2)
						{
							id = ctx.AddInstrConstantCompositeUInt((unsigned int*)c->IntValues, 2);
						}
						else if (baseType->Type == ILBaseType::UInt3)
						{
							id = ctx.AddInstrConstantCompositeUInt((unsigned int*)c->IntValues, 3);
						}
						else if (baseType->Type == ILBaseType::UInt4)
						{
							id = ctx.AddInstrConstantCompositeUInt((unsigned int*)c->IntValues, 4);
						}
						else if (baseType->Type == ILBaseType::Bool)
						{
							id = ctx.AddInstrConstantBool(c->IntValues[0]);
						}
					}
					else
						throw InvalidOperationException(L"Illegal constant.");
				}
				else if (auto instr = dynamic_cast<ILInstruction*>(op))
				{
					id = ctx.FindValueID(op);
					if (id == -1)
					{
						//need to load it from storage
						id = ctx.AddInstrLoad(op, op, MemoryAccess::None);
					}
				}
				else
					throw InvalidOperationException(L"Unsupported operand type.");

				return id;
			}

			int GetOperandPointer(ILOperand * op)
			{
				int id = -1;
				//RefPtr<ILType> result_type;
				if (auto c = dynamic_cast<ILConstOperand*>(op))
				{
					int valueID = GetOperandValue(op);
					id = ctx.AddInstrVariableDeclaration(op, op->Type, StorageClass::Function);
					ctx.AddInstrStore(op, id, valueID);
				}
				else if (auto instr = dynamic_cast<ILInstruction*>(op))
				{
					id = ctx.FindVariableID(op);
					if (id == -1)
					{
						int valueID = ctx.FindValueID(op);
						if (valueID == -1)
							throw InvalidOperationException(L"can not find variable ID in Get OperandPointer(): " + op->ToString());
						id = ctx.AddInstrVariableDeclaration(op, instr->Type, StorageClass::Function);
						ctx.AddInstrStore(op, id, valueID);
					}
				}
				else
					throw InvalidOperationException(L"Unsupported operand type.");

				return id;
			}

			void PrintAllocVarInstr(AllocVarInstruction * instr, StorageClass store)
			{
				if (dynamic_cast<ILConstOperand*>(instr->Size.Ptr()))
				{
					ctx.AddInstrVariableDeclaration((ILOperand*)instr, instr->Type, store);
				}
				else
					throw InvalidProgramException(L"size operand of allocVar instr is not an intermediate.");
			}

			Dictionary<String, int> GLSLstd450InstructionSet = GenGLSLstd450InstructionSet();

			void PrintCallInstr(CallInstruction * instr)
				// return ID of this instruction
			{
				String callName = GetFuncOriginalName(instr->Function);

				//------------------------- texture instructions -------------------------
				if (callName == L"texture")
				{
					if (instr->Arguments[0]->Type->IsNonShadowTexture())
					{
						if (instr->Arguments[0]->Type->ToString() == L"sampler2D")
						{
							//*** no bias!!!
							//__intrinsic vec4 texture(sampler2D tex, vec2 coord);
							ctx.AddInstrTexture(
								(ILOperand*)instr,
								GetOperandValue(instr->Arguments[0].Ptr()),
								GetOperandValue(instr->Arguments[1].Ptr()),
								currentExecutionModel
							);
							return;
						}
						else if (instr->Arguments[0]->Type->ToString() == L"samplerCube")
						{
							if (instr->Arguments.Count() == 2)
							{
								//__intrinsic vec4 texture(samplerCube tex, vec3 coord);
								ctx.AddInstrTexture(
									(ILOperand*)instr,
									GetOperandValue(instr->Arguments[0].Ptr()),
									GetOperandValue(instr->Arguments[1].Ptr()),
									currentExecutionModel
								);
								return;
							}
							else
							{
								//__intrinsic vec4 texture(samplerCube tex, vec3 coord, float bias);
								ctx.AddInstrTexture(
									(ILOperand*)instr,
									GetOperandValue(instr->Arguments[0].Ptr()),
									GetOperandValue(instr->Arguments[1].Ptr()),
									currentExecutionModel,
									GetOperandValue(instr->Arguments[2].Ptr())
								);
								return;
							}
						}
					}
					else
					{
						//instr->Arguments[0]->Type->IsShadowTexture

						//__intrinsic float texture(sampler2DShadow tex, vec3 coord);
						//__intrinsic float texture(samplerCubeShadow tex, vec4 coord);
						ctx.AddInstrTextureShadow(
							(ILOperand*)instr,
							GetOperandValue(instr->Arguments[0].Ptr()),
							GetOperandValue(instr->Arguments[1].Ptr()),
							currentExecutionModel
						);
						return;
					}
				}

				if (callName == L"textureGrad")
				{
					//__intrinsic vec4 textureGrad(sampler2D tex, vec2 coord, vec2 dPdx, vec2 dPdy);
					//__intrinsic vec4 textureGrad(samplerCube tex, vec3 coord, vec3 dPdx, vec3 dPdy);
					ctx.AddInstrTexture(
						(ILOperand*)instr,
						GetOperandValue(instr->Arguments[0].Ptr()),
						GetOperandValue(instr->Arguments[1].Ptr()),
						currentExecutionModel,
						-1,	//Bias
						GetOperandValue(instr->Arguments[2].Ptr()),
						GetOperandValue(instr->Arguments[3].Ptr())
					);
					return;
				}

				if (callName == L"textureProj")
				{
					if (instr->Arguments[0]->Type->ToString() == L"sampler2DShadow")
					{
						//__intrinsic float textureProj(sampler2DShadow tex, vec4 coord);
						ctx.AddInstrTexture2DShadowProj(
							(ILOperand*)instr,
							GetOperandValue(instr->Arguments[0].Ptr()),
							GetOperandValue(instr->Arguments[1].Ptr()),
							currentExecutionModel
						);
						return;
					}
				}

				//------------------------- Dot Instruction ------------------------------
				if (callName == L"dot"
					&& instr->Arguments.Count() == 2
					&& instr->Arguments[0]->Type->ToString() == instr->Arguments[1]->Type->ToString()
					&& instr->Arguments[0]->Type->IsFloatVector()
					&& !instr->Arguments[0]->Type->IsFloatMatrix())
				{
					ctx.AddInstrDot(
						(ILOperand*)instr,
						instr->Type,
						GetOperandValue(instr->Arguments[0].Ptr()),
						GetOperandValue(instr->Arguments[1].Ptr())
					);
					return;
				}

				//------------------------- Transpose Instruction ------------------------------
				if (callName == L"transpose" && instr->Arguments.Count() == 1 && instr->Arguments[0]->Type->IsFloatMatrix())
				{
					ctx.AddInstrTranspose((ILOperand*)instr, instr->Type, GetOperandValue(instr->Arguments[0].Ptr()));
					return;
				}

				//------------------------- Derivative Instruction -----------------------------
				if (callName == L"dFdx")
				{
					ctx.AddInstrDFdx((ILOperand*)instr, instr->Type, GetOperandValue(instr->Arguments[0].Ptr()));
					return;
				}
				else if (callName == L"dFdy")
				{
					ctx.AddInstrDFdy((ILOperand*)instr, instr->Type, GetOperandValue(instr->Arguments[0].Ptr()));
					return;
				}
				else if (callName == L"fwidth")
				{
					ctx.AddInstrFwidth((ILOperand*)instr, instr->Type, GetOperandValue(instr->Arguments[0].Ptr()));
					return;
				}

				//------------------------- user-defined  instructions -------------------------
				int funcID;
				if (ctx.FunctionNameToFunctionID.TryGetValue(instr->Function, funcID))
				{
					RefPtr<ILType> returnType = ctx.IDInfos[
						ctx.FunctionNameToFunctionTypeID[instr->Function]()
					]().GetFunc()->ReturnType;
						int typeID = ctx.DefineType(returnType);
						List<int> args;
						for (auto & arg : instr->Arguments) {
							int valueID = GetOperandValue(arg.Ptr());
							int paramID = ctx.AddInstrVariableDeclaration(0, arg->Type, StorageClass::Function, L"param");
							// the name of the parameter must be empty; or may conflict with non-param variables
							ctx.AddInstrStore(0, paramID, valueID);
							args.Add(paramID);
						}
						ctx.AddInstrFunctionCall((ILOperand*)instr, typeID, funcID, args);
						return;
				}

				//------------------------- ext-import  instructions -----------------------------
				List<int> Arguments;

				for (auto & arg : instr->Arguments) {
					int valueID = GetOperandValue(arg.Ptr());
					if (callName == L"mix") {
						//the mix instruction in spirv only accept mix(vec_, vec_, vec_);
						//however, front end of SPIRE can accept mix(vec_, vec_, float);
						valueID = ctx.ConvertBasicType(valueID, arg->Type, instr->Type);
					}
					Arguments.Add(valueID);
				}

				if (GLSLstd450InstructionSet.ContainsKey(callName))
				{
					ctx.AddInstrExtInst((ILOperand*)instr, instr->Type, GLSLstd450InstructionSet[callName](), Arguments);
					return;
				}


				//------------------------- built-in constructors -----------------------------

				RefPtr<ILType> dstType = GetTypeFromString(callName);
				if (dstType == nullptr)
					throw InvalidOperationException(L"can not call: " + callName);
				RefPtr<ILBasicType> dstBasicType = dstType;

				if (instr->Arguments.Count() > 1)
				{
					//composite
					for (auto & ID : Arguments)
					{
						auto argBasicType = dynamic_cast<ILBasicType*>((ctx.IDInfos[ID]().GetILType()).Ptr());
						if (argBasicType)
							if (argBasicType->IsIntegral() != dstType->IsIntegral())
							{
								RefPtr<ILType> argDstType = new ILBasicType(ILBaseType((dstBasicType->Type & ~15) + (argBasicType->Type & 15)));
								ID = ctx.ConvertBasicType(ID, ctx.IDInfos[ID]().GetILType(), argDstType);
							}
					}

					if (instr->Type->IsFloatMatrix() &&
						(Arguments.Count() == 0 || (Arguments.Count() > 0 && ctx.IDInfos[Arguments[0]]().GetILType()->IsScalar())))
					{
						//need to arrange scalars into vectors
						int n = (int)sqrt((float)instr->Type->GetVectorSize() + 1e-6);
						int diff = n * n - Arguments.Count();
						if (diff > 0)
							for (int i = 0; i < diff; i++)
								Arguments.Add(ctx.AddInstrConstantFloat(0.0));
						List<int> newArguments;
						RefPtr<ILType> vectorType = new ILBasicType(ILBaseType(ILBaseType::Float + n - 1));
						for (int i = 0; i < n; i++)
						{
							List<int> subArguments;
							for (int j = 0; j < n; j++)
								subArguments.Add(Arguments[i*n + j]);
							newArguments.Add(ctx.AddInstrCompositeConstruct(0, vectorType, subArguments));
						}
						Arguments = newArguments;
					}

					ctx.AddInstrCompositeConstruct((ILOperand*)instr, instr->Type, Arguments);
					return;
				}
				else
				{
					//need conversion
					int ID = Arguments[0];
					ID = ctx.ConvertBasicType(ID, ctx.IDInfos[ID]().GetILType(), dstType);
					ctx.UpdateValue((ILOperand*)instr, ID);
					return;
				}

			}

			void PrintUnaryInstr(UnaryInstruction * instr)
			{
				auto op0 = instr->Operand.Ptr();
				if (instr->Is<LoadInstruction>())
				{
					ctx.AddInstrLoad((ILOperand*)instr, op0, MemoryAccess::None);
					return;
				}

				if (instr->Is<NotInstruction>())
					instr->Type = GetTypeFromString(L"bool");

				int op0ValueID = GetOperandValue(op0);
				op0ValueID = ctx.ConvertBasicType(op0ValueID, ctx.IDInfos[op0ValueID]().GetILType(), instr->Type);
				RefPtr<ILType> op0ILType = ctx.IDInfos[op0ValueID]().GetILType();

				if (instr->Is<Float2IntInstruction>() || instr->Is<Int2FloatInstruction>() || instr->Is<CopyInstruction>())
				{
					ctx.UpdateValue((ILOperand*)instr, op0ValueID);
					return;
				}

				int instrTypeID = ctx.DefineType(instr->Type);

				if (instr->Is<NegInstruction>())
				{
					if (op0ILType->IsFloat() || op0ILType->IsFloatVector())
						ctx.AddInstrFnegate((ILOperand*)instr, instrTypeID, op0ValueID);
					else if (op0ILType->IsInt() || op0ILType->IsIntVector())
						ctx.AddInstrSnegate((ILOperand*)instr, instrTypeID, op0ValueID);
					else if (op0ILType->IsUInt() || op0ILType->IsUIntVector())
						throw InvalidOperationException(L"trying to negate a uint in PrintUnaryInstruction(): " + instr->ToString());
				}
				else if (instr->Is<BitNotInstruction>())
					ctx.AddInstrNot((ILOperand*)instr, instrTypeID, op0ValueID);
				else if (instr->Is<NotInstruction>())
					ctx.AddInstrLogicalNot((ILOperand*)instr, instrTypeID, op0ValueID);
				else
					throw InvalidProgramException(L"unsupported unary instruction.");
			}

			void PrintBinaryInstr(BinaryInstruction * instr)
			{
				auto op0 = instr->Operands[0].Ptr();
				auto op1 = instr->Operands[1].Ptr();

				//-------------------------------------Store Instruction------------------------------------------
				if (instr->Is<StoreInstruction>())
				{
					if (auto structType = dynamic_cast<ILStructType*>(op0->Type.Ptr()))
					{
						int op0ID = ctx.FindVariableID(op0);
						int op1ID = ctx.FindVariableID(op1);
						int index = 0;
						for (int i = 0; i < structType->Members.Count(); i++)
						{
							int indexID = ctx.AddInstrConstantInt(index);
							int dest = ctx.AddInstrAccessChain_StructMember(0, op0ID, indexID, index);
							int pSrc = ctx.AddInstrAccessChain_StructMember(0, op1ID, indexID, index);
							int vSrc = ctx.AddInstrLoad(pSrc, MemoryAccess::None);
							ctx.AddInstrStore(0, dest, vSrc);
							index++;
						}
						return;
					}

					int op0ID = ctx.FindVariableID(op0); // should be a pointer 
					int op1ID = GetOperandValue(op1);
					op1ID = ctx.ConvertBasicType(op1ID, ctx.IDInfos[op1ID]().GetILType(), ctx.IDInfos[op0ID]().GetILType());
					ctx.AddInstrStore(instr, op0ID, op1ID); //TO FIX
					return;
				}

				//----------------------------------Member Load Instruction---------------------------------------
				if (instr->Is<MemberLoadInstruction>())
				{
					int fatherID = GetOperandPointer(op0);
					if (op0->Type->IsVector())
					{
						if (auto c = dynamic_cast<ILConstOperand*>(op1))
						{
							//if op1 is constant, take that as index of vector 
							int memberID = ctx.AddInstrAccessChain_VectorMember((ILOperand*)instr, fatherID, -1, c->IntValues[0]);
							int retID = ctx.AddInstrLoad(memberID, MemoryAccess::None);
							ctx.UpdateValue((ILOperand*)instr, retID);
							return;
						}
						else
						{
							//if op1 is not constant, compute it
							int memberID = ctx.AddInstrAccessChain_VectorMember((ILOperand*)instr, fatherID, GetOperandValue(op1), -1);
							int retID = ctx.AddInstrLoad(memberID, MemoryAccess::None);
							ctx.UpdateValue((ILOperand*)instr, retID);
							return;
						}
					}
					else if (auto structType = dynamic_cast<ILStructType*>(op0->Type.Ptr()))
					{
						if (auto c = dynamic_cast<ILConstOperand*>(op1))
						{
							//index of struct must be constant
							int indexID = GetOperandValue(c);
							int memberID = ctx.AddInstrAccessChain_StructMember((ILOperand*)instr, fatherID, indexID, c->IntValues[0]);
							int retID = ctx.AddInstrLoad(memberID, MemoryAccess::None);
							ctx.UpdateValue((ILOperand*)instr, retID);
							return;
						}
						else
							throw InvalidOperationException(L"wrong: " + instr->ToString());
					}
					else if (auto arrayType = dynamic_cast<ILArrayType*>(op0->Type.Ptr()))
					{
						int memberID = ctx.AddInstrAccessChain_ArrayMember((ILOperand*)instr, op0->Type, fatherID, GetOperandValue(op1));
						int retID = ctx.AddInstrLoad(memberID, MemoryAccess::None);
						ctx.UpdateValue((ILOperand*)instr, retID);
						return;
					}
					else
						throw InvalidOperationException(L"wrong op0 type for MemberLoadInstruction(): " + op0->Type->ToString());
				}

				int ID0 = GetOperandValue(op0);
				int ID1 = GetOperandValue(op1);
				RefPtr<ILType> ID0Type = ctx.IDInfos[ID0]().GetILType();
				RefPtr<ILType> ID1Type = ctx.IDInfos[ID1]().GetILType();

				//----------------------------------Vec/Mat Multiplication---------------------------------------
				if (instr->Is<MulInstruction>())
				{
					//scalar X matrix or matrix X scalar
					if (ID0Type->IsScalar() && ID1Type->IsFloatMatrix() ||
						ID1Type->IsScalar() && ID0Type->IsFloatMatrix())
					{
						if (ID1Type->IsFloatMatrix())
							Swap(ID0, ID1);
						//now ID0 is matrix, ID1 is scalar, 
						ID1 = ctx.ConvertBasicType(ID1, ctx.IDInfos[ID1]().GetILType(), GetTypeFromString(L"float"));
						ctx.AddInstrMatrixTimesScalar((ILOperand*)instr, ID0, ID1);
						return;
					}

					//vector X matrix
					if (ID0Type->IsFloatVector() && !ID0Type->IsFloatMatrix() && ID1Type->IsFloatMatrix())
					{
						ctx.AddInstrVectorTimesMatrix((ILOperand*)instr, ID0, ID1);
						return;
					}

					//matrix X vector
					if (ID1Type->IsFloatVector() && !ID1Type->IsFloatMatrix() && ID0Type->IsFloatMatrix())
					{
						ctx.AddInstrMatrixTimesVector((ILOperand*)instr, ID0, ID1);
						return;
					}

					//matrix X matrix
					if (ID0Type->IsFloatMatrix() && ID1Type->IsFloatMatrix())
					{
						ctx.AddInstrMatrixTimesMatrix((ILOperand*)instr, ID0, ID1);
						return;
					}
				}

				//---------------------------------Boolean-Related Instruction---------------------------------------
				bool ResultIsLogical =
					instr->Is<OrInstruction>() || instr->Is<AndInstruction>() ||
					instr->Is<CmpeqlInstruction>() || instr->Is<CmpgeInstruction>() || instr->Is<CmpgtInstruction>() ||
					instr->Is<CmpleInstruction>() || instr->Is<CmpltInstruction>() || instr->Is<CmpneqInstruction>();

				if (dynamic_cast<ILBasicType*>(instr->Type.Ptr())->Type == 0)
				{
					instr->Type = ID0Type;
				}

				if (ResultIsLogical)
				{
					RefPtr<ILType> OperandType = nullptr;
					if (instr->Is<OrInstruction>() || instr->Is<AndInstruction>())
					{
						OperandType = GetTypeFromString(L"bool");
					}
					else
					{
						if (ID0Type->IsFloat() || ID1Type->IsFloat())
							OperandType = GetTypeFromString(L"float");
						else if (ID0Type->IsUInt() || ID1Type->IsUInt())
							OperandType = GetTypeFromString(L"uint");
						else if (ID0Type->IsInt() || ID1Type->IsInt())
							OperandType = GetTypeFromString(L"int");
					}

					ID0 = ctx.ConvertBasicType(ID0, ID0Type, OperandType);
					ID1 = ctx.ConvertBasicType(ID1, ID1Type, OperandType);

					instr->Type = GetTypeFromString(L"bool");
					ID0Type = ctx.IDInfos[ID0]().GetILType();
					ID1Type = ctx.IDInfos[ID1]().GetILType();
				}
				else
				{
					ID0 = ctx.ConvertBasicType(ID0, ID0Type, instr->Type);
					ID1 = ctx.ConvertBasicType(ID1, ID1Type, instr->Type);

					ID0Type = ctx.IDInfos[ID0]().GetILType();
					ID1Type = ctx.IDInfos[ID1]().GetILType();
				}

				//--------------------------------------Get Binary Operator String---------------------------------------
				String opStr;
				bool needPrefix = false;
				bool Signed = false;
				if (instr->Is<MulInstruction>())
				{
					opStr = L"Mul";
					needPrefix = true;
				}
				else if (instr->Is<AddInstruction>())
				{
					opStr = L"Add";
					needPrefix = true;
				}
				else if (instr->Is<DivInstruction>())
				{
					opStr = L"Div";
					needPrefix = true;
					Signed = true;
				}
				else if (instr->Is<SubInstruction>())
				{
					opStr = L"Sub";
					needPrefix = true;
				}
				else if (instr->Is<ModInstruction>())
				{
					opStr = L"Mod";
					needPrefix = true;
					Signed = true;
				}
				else if (instr->Is<ShlInstruction>())
				{
					opStr = L"ShiftLeftLogical";
				}
				else if (instr->Is<ShrInstruction>())
				{
					if (ID0Type->IsUInt() || ID0Type->IsUIntVector())
						opStr = L"ShiftRightLogical";
					else
						opStr = L"ShiftRightArithmetic";
				}
				else if (instr->Is<BitXorInstruction>())
				{
					opStr = L"BitwiseXor";
				}
				else if (instr->Is<BitAndInstruction>())
				{
					opStr = L"BitwiseAnd";
				}
				else if (instr->Is<BitOrInstruction>())
				{
					opStr = L"BitwiseOr";
				}
				else if (instr->Is<AndInstruction>())
				{
					opStr = L"LogicalAnd";
				}
				else if (instr->Is<OrInstruction>())
				{
					opStr = L"LogicalOr";
				}
				else if (instr->Is<CmpneqInstruction>())
				{
					if (ID0Type->IsIntegral())
						opStr = L"INotEqual";
					else
						opStr = L"FOrdNotEqual";
				}
				else if (instr->Is<CmpeqlInstruction>())
				{
					if (ID0Type->IsIntegral())
						opStr = L"IEqual";
					else
						opStr = L"FOrdEqual";
				}
				else if (instr->Is<CmpgeInstruction>())
				{
					if (ID0Type->IsIntegral())
					{
						if (ID0Type->IsUInt() || ID0Type->IsUIntVector())
							opStr = L"UGreaterThanEqual";
						else
							opStr = L"SGreaterThanEqual";
					}
					else
						opStr = L"FOrdGreaterThanEqual";
				}
				else if (instr->Is<CmpgtInstruction>())
				{
					if (ID0Type->IsIntegral())
					{
						if (ID0Type->IsUInt() || ID0Type->IsUIntVector())
							opStr = L"UGreaterThan";
						else
							opStr = L"SGreaterThan";
					}
					else
						opStr = L"FOrdGreaterThan";
				}
				else if (instr->Is<CmpleInstruction>())
				{
					if (ID0Type->IsIntegral())
					{
						if (ID0Type->IsUInt() || ID0Type->IsUIntVector())
							opStr = L"ULessThanEqual";
						else
							opStr = L"SLessThanEqual";
					}
					else
						opStr = L"FOrdLessThanEqual";
				}
				else if (instr->Is<CmpltInstruction>())
				{
					if (ID0Type->IsIntegral())
					{
						if (ID0Type->IsUInt() || ID0Type->IsUIntVector())
							opStr = L"ULessThan";
						else
							opStr = L"SLessThan";
					}
					else
						opStr = L"FOrdLessThan";
				}
				else
					throw InvalidProgramException(L"unsupported binary instruction: " + instr->ToString());

				//---------------------------------------Generate Instrction---------------------------------------

				String finalOpStr = LR"(Op)";
				if (needPrefix)
				{
					if (ID0Type->IsFloat() || ID0Type->IsFloatVector())
						finalOpStr = finalOpStr + LR"(F)";
					else if (ID0Type->IsIntegral())
					{
						if (Signed)
							finalOpStr = finalOpStr + LR"(S)";
						else
							finalOpStr = finalOpStr + LR"(I)";
					}
				}
				finalOpStr = finalOpStr + opStr;

				ctx.AddInstrBinaryInstr((ILOperand*)instr, instr->Type, finalOpStr, ID0, ID1);
			}

			void PrintUpdateInstr(MemberUpdateInstruction * instr)
			{
				int variableID = ctx.AddInstrVariableDeclaration((ILOperand*)instr, instr->Operands[0]->Type, StorageClass::Function);
				ctx.AddInstrStore((ILOperand*)instr, variableID, GetOperandValue(instr->Operands[0].Ptr()));

				auto typeIL = ctx.IDInfos[variableID]().GetILType().Ptr();
				int memberID = -1;
				int indexID = GetOperandValue(instr->Operands[1].Ptr());

				if (indexID == -1)
					throw InvalidOperationException(L"bad index in PrintUpdateInstr(): " + instr->Operands[1]->ToString());

				if (auto structType = dynamic_cast<ILStructType*>(typeIL))
				{
					auto c = dynamic_cast<ILConstOperand*>(instr->Operands[1].Ptr());
					if (c)
						memberID = ctx.AddInstrAccessChain_StructMember(0, variableID, indexID, c->IntValues[0]);
					else
						throw InvalidOperationException(L"index of struct must be const in PrintUpdateInstr(): " + instr->Operands[1]->ToString());
				}
				else if (auto arrayType = dynamic_cast<ILArrayType*>(typeIL))
				{
					memberID = ctx.AddInstrAccessChain_ArrayMember(0, typeIL, variableID, indexID);
				}
				else if (auto vecType = dynamic_cast<ILBasicType*>(typeIL))
				{
					if (!typeIL->IsVector())
						throw InvalidOperationException(L"unable to update members of type: " + typeIL->ToString());
					memberID = ctx.AddInstrAccessChain_VectorMember(0, variableID, indexID, -1);
				}
				else
					throw InvalidOperationException(L"not supported type in PrintUpdateInstr(): " + typeIL->ToString());

				ctx.AddInstrStore(
					0,
					memberID,
					GetOperandValue(instr->Operands[2].Ptr())
				);
				ctx.InvalidateValue((ILOperand*)instr);
			}

			void PrintSelectInstr(SelectInstruction * instr)
			{
				int ID0 = GetOperandValue(instr->Operands[0].Ptr());
				ID0 = ctx.ConvertBasicType(
					ID0,
					ctx.IDInfos[ID0]().GetILType(),
					GetTypeFromString(L"bool"));

				int TrueLabel = ++ctx.CurrentID;
				int FalseLabel = ++ctx.CurrentID;
				int MergeLabel = ++ctx.CurrentID;

				ctx.AddInstrSelectionMerge(MergeLabel);
				ctx.AddInstrBranchConditional(ID0, TrueLabel, FalseLabel);

				ctx.AddInstrLabel_AtFunctionBody(TrueLabel);
				int ID1 = GetOperandValue(instr->Operands[1].Ptr());
				ID1 = ctx.ConvertBasicType(ID1, ctx.IDInfos[ID1]().GetILType(), instr->Type);
				ctx.AddInstrBranch(MergeLabel);

				ctx.AddInstrLabel_AtFunctionBody(FalseLabel);
				int ID2 = GetOperandValue(instr->Operands[2].Ptr());
				ID2 = ctx.ConvertBasicType(ID2, ctx.IDInfos[ID2]().GetILType(), instr->Type);
				ctx.AddInstrBranch(MergeLabel);

				ctx.AddInstrLabel_AtFunctionBody(MergeLabel);

				ctx.AddInstrPhi((ILOperand*)instr, ID1, TrueLabel, ID2, FalseLabel);
			}

			void PrintFetchArgInstr(FetchArgInstruction * instr)
			{
				if (instr->ArgId == 0)
				{
					ctx.ReturnID = ctx.AddInstrVariableDeclaration((ILOperand*)instr, instr->Type, StorageClass::Function);
				}
			}

			void PrintExportInstr(ExportInstruction * instr)
			{
				String exportOpName = instr->ExportOperator;

				if (exportOpName == L"fragmentExport")
				{
					CompiledComponent ccomp;
					bool isNormal = false;
					bool isDepthOutput = false;
					if (currentWorld->LocalComponents.TryGetValue(instr->ComponentName, ccomp))
					{
						if (ccomp.Attributes.ContainsKey(L"Normal"))
							isNormal = true;
						if (ccomp.Attributes.ContainsKey(L"DepthOutput"))
							isDepthOutput = true;
					}
					String exportName;
					if (isDepthOutput)
						exportName = L"gl_FragDepth";
					else
						exportName = instr->ComponentName;

					int exportID = ctx.InterfaceNameToID[exportName];
					if (exportID == -1)
						throw InvalidOperationException(L"can not find component for export instruction for fragmentExport in PrintExportInstr(): " + exportName);

					int operandID = GetOperandValue(instr->Operand.Ptr());
					if (isNormal)
						operandID = ctx.AddInstrMulAdd(operandID, 0.5, 0.5);

					ctx.AddInstrStore((ILOperand*)instr, exportID, operandID);
				}

				else if (exportOpName == L"standardExport")
				{
					int storeID = ctx.AddInstrAccessChain_StructMember(0, ctx.InterfaceNameToID[L"blk" + currentWorld->WorldOutput->Name], instr->ComponentName);
					ctx.AddInstrStore((ILOperand*)instr, storeID, GetOperandValue(instr->Operand.Ptr()));
				}

				else if (exportOpName == L"bufferExport")
				{
					auto & comp = currentWorld->WorldOutput->Entries[instr->ComponentName]();

					auto UIntType = GetTypeFromString(L"uint");
					auto FloatType = GetTypeFromString(L"float");
					int GIIDx = ctx.AddInstrLoad(
						ctx.AddInstrAccessChain_VectorMember(0, ctx.InterfaceNameToID[L"gl_GlobalInvocationID"], -1, 0),
						MemoryAccess::None
					);	//GlobalInvocationID.x
					int baseIndex = ctx.AddInstrBinaryInstr(
						0,
						UIntType,
						L"OpIMul",
						GIIDx,
						ctx.AddInstrConstantUInt(currentWorld->WorldOutput->Size / 4)
					);
					baseIndex = ctx.AddInstrBinaryInstr(
						0,
						UIntType,
						L"OpIAdd",
						baseIndex,
						ctx.AddInstrConstantUInt(comp.Offset / 4)
					);

					RefPtr<ILType> compElementType =
						(!comp.Type->IsIntegral())
						? FloatType
						: ((comp.Type->IsUInt() || comp.Type->IsUIntVector()) ? UIntType : GetTypeFromString(L"int"));

					for (int i = 0; i < comp.Type->GetVectorSize(); i++)
					{
						int index = ctx.AddInstrBinaryInstr(
							0,
							UIntType,
							L"OpIAdd",
							baseIndex,
							ctx.AddInstrConstantUInt(i)
						);

						int blockID = ctx.InterfaceNameToID[L"blk" + currentWorld->WorldOutput->Name];
						int arrayID = ctx.AddInstrAccessChain_StructMember(0, blockID, -1, 0);
						int storeID = ctx.AddInstrAccessChain_ArrayMember(
							0,
							ctx.IDInfos[arrayID]().GetILType(),
							arrayID,
							index
						);

						int valueID = -1;
						if (instr->Operand->Type->GetVectorSize() > 1)
							valueID = ctx.AddInstrLoad(
								ctx.AddInstrAccessChain_VectorMember(0, GetOperandPointer(instr->Operand.Ptr()), -1, i),
								MemoryAccess::None
							);
						else
							valueID = ctx.AddInstrLoad(
								GetOperandPointer(instr->Operand.Ptr()),
								MemoryAccess::None
							);

						valueID = ctx.ConvertBasicType(valueID, ctx.IDInfos[valueID]().GetILType(), compElementType);

						if (ctx.IDInfos[valueID]().GetILType()->IsIntegral())
							valueID = ctx.AddInstrBitcast(ctx.DefineType(FloatType), valueID);

						ctx.AddInstrStore(0, storeID, valueID);
					}
				}

				else
					throw InvalidOperationException(L"not valid export operator in PrintExportInstr(): " + exportOpName);
			}

			void PrintImportInstr(ImportInstruction * instr)
			{
				auto block = instr->SourceWorld->WorldOutput;

				if (instr->ImportOperator->Name.Content == L"standardImport")
				{
					ctx.AddInstrAccessChain_StructMember(instr, ctx.InterfaceNameToID[L"blk" + block->Name], instr->ComponentName);
				}

				else if (instr->ImportOperator->Name.Content == L"vertexImport")
				{
					int componentID = ctx.InterfaceNameToID[instr->ComponentName];
					if (componentID == -1)
						throw InvalidOperationException(L"can not find import component for vertexImport in PrintImportInstr(): " + instr->ComponentName);
					ctx.UpdateVariable(instr, componentID);
				}

				else if (instr->ImportOperator->Name.Content == L"uniformImport")
				{
					if (instr->Type->IsTexture())
					{
						int pointerID = ctx.InterfaceNameToID[instr->ComponentName];
						if (pointerID == -1)
							throw InvalidOperationException(L"can not find import component for uniformImport in PrintImportInstr(): " + instr->ComponentName);
						ctx.UpdateVariable(instr, pointerID);
					}
					else
					{
						ctx.AddInstrAccessChain_StructMember(instr, ctx.InterfaceNameToID[L"blk" + block->Name], instr->ComponentName);
					}
				}

				else if (instr->ImportOperator->Name.Content == L"textureImport")
				{
					int textureStorageID = ctx.InterfaceNameToID[instr->ComponentName];
					int textureValueID = ctx.AddInstrLoad(textureStorageID, MemoryAccess::None);

					int operandID = -1;
					operandID = ctx.AddInstrTexture(
						0,
						textureValueID,
						GetOperandValue(instr->Arguments[0].Ptr()),
						currentExecutionModel
					);

					operandID = ctx.ConvertBasicType(
						operandID,
						ctx.IDInfos[operandID]().GetILType(),
						instr->Type);
					CompiledComponent ccomp;
					if (instr->SourceWorld->LocalComponents.TryGetValue(instr->ComponentName, ccomp))
					{
						if (ccomp.Attributes.ContainsKey(L"Normal"))
							operandID = ctx.AddInstrMulAdd(operandID, 2.0, -1.0);
					}

					int storeID = ctx.AddInstrVariableDeclaration((ILOperand*)instr, instr->Type, StorageClass::Function);
					ctx.AddInstrStore((ILOperand*)instr, storeID, operandID);
				}

				else if (instr->ImportOperator->Name.Content == L"bufferImport")
				{
					//instr->Name[][] = 
					//	*(int*/float*) 
					//	( block->Name + block->Entries[instr->ComponentName].GetValue().Offset / 4 + i + gl_GlobalInvocationID.x * block->Size / 4 )

					auto UIntType = GetTypeFromString(L"uint");
					auto FloatType = GetTypeFromString(L"float");
					int GIIDx = ctx.AddInstrLoad(
						ctx.AddInstrAccessChain_VectorMember(0, ctx.InterfaceNameToID[L"gl_GlobalInvocationID"], -1, 0),
						MemoryAccess::None
					);	//GlobalInvocationID.x
					int baseIndex = ctx.AddInstrBinaryInstr(
						0,
						UIntType,
						L"OpIMul",
						GIIDx,
						ctx.AddInstrConstantUInt(block->Size / 4)
					);
					baseIndex = ctx.AddInstrBinaryInstr(
						0,
						UIntType,
						L"OpIAdd",
						baseIndex,
						ctx.AddInstrConstantUInt(block->Entries[instr->ComponentName]().Offset / 4)
					);

					RefPtr<ILType> instrElementType =
						(!instr->Type->IsIntegral())
						? FloatType
						: ((instr->Type->IsUInt() || instr->Type->IsUIntVector()) ? UIntType : GetTypeFromString(L"int"));

					int vecSize = instr->Type->GetVectorSize();
					int srcIDs[16];
					for (int i = 0; i < vecSize; i++)
					{
						int index = ctx.AddInstrBinaryInstr(
							0,
							UIntType,
							L"OpIAdd",
							baseIndex,
							ctx.AddInstrConstantUInt(i)
						);
						int blockID = ctx.InterfaceNameToID[L"blk" + block->Name];
						int arrayID = ctx.AddInstrAccessChain_StructMember(0, blockID, -1, 0);
						int srcID = ctx.AddInstrLoad(
							ctx.AddInstrAccessChain_ArrayMember(0, ctx.IDInfos[arrayID]().GetILType(), arrayID, index),
							MemoryAccess::None
						);
						srcIDs[i] = ctx.AddInstrBitcast(ctx.DefineType(instrElementType), srcID);
					}

					int valueID = -1;

					if (instr->Type->IsFloatMatrix())
					{
						int n = 3;
						auto colType = GetTypeFromString(L"vec3");
						if (instr->Type->GetVectorSize() == 16)
						{
							n = 4;
							colType = GetTypeFromString(L"vec4");
						}
						int colIDs[4];
						for (int i = 0; i < n; i++)
						{
							List<int> args;
							for (int j = 0; j < n; j++)
								args.Add(srcIDs[i*n + j]);
							colIDs[i] = ctx.AddInstrCompositeConstruct(0, colType, args);
						}
						List<int> args;
						for (int i = 0; i < n; i++)
							args.Add(colIDs[i]);
						valueID = ctx.AddInstrCompositeConstruct(0, instr->Type, args);
					}
					else if (instr->Type->IsVector())
					{
						int n = 3;
						if (instr->Type->GetVectorSize() == 16)
							n = 4;
						List<int> args;
						for (int i = 0; i < n; i++)
							args.Add(srcIDs[i]);
						valueID = ctx.AddInstrCompositeConstruct(0, instr->Type, args);
					}
					else //scalar
					{
						valueID = srcIDs[0];
					}

					int storeID = ctx.AddInstrVariableDeclaration(instr, instr->Type, StorageClass::Function);
					ctx.AddInstrStore(instr, storeID, valueID);
				}

				else
					throw NotImplementedException(L"import in PrintImportInstr(): " + instr->ImportOperator->Name.Content);
			}

			void PrintInstr(ILInstruction & instr)
			{
				if (auto binInstr = instr.As<BinaryInstruction>())
					PrintBinaryInstr(binInstr);
				else if (auto allocVar = instr.As<AllocVarInstruction>())
					PrintAllocVarInstr(allocVar, StorageClass::Function);
				else if (auto call = instr.As<CallInstruction>())
					PrintCallInstr(call);
				else if (auto exportInstr = instr.As<ExportInstruction>())
				{
					PrintExportInstr(exportInstr);
					//throw InvalidOperationException(L"export instruction not supported");

				}
				else if (auto import = instr.As<ImportInstruction>())
				{
					PrintImportInstr(import);
					//throw InvalidOperationException(L"import instruction not supported");
				}
				else if (auto update = instr.As<MemberUpdateInstruction>())
					PrintUpdateInstr(update);
				else if (auto unaryInstr = instr.As<UnaryInstruction>())
					PrintUnaryInstr(unaryInstr);
				else if (auto select = instr.As<SelectInstruction>())
					PrintSelectInstr(select);
				else if (auto fetchArg = instr.As<FetchArgInstruction>()) //for function: return instruction
					PrintFetchArgInstr(fetchArg);
				else
					throw NotImplementedException(L"unsupported instruction in PrintInstr()" + instr.ToString());
			}

			void PrintIf(IfInstruction * instr)
			{
				int operandID = GetOperandValue(instr->Operand.Ptr());
				operandID = ctx.ConvertBasicType(
					operandID,
					ctx.IDInfos[operandID]().GetILType(),
					GetTypeFromString(L"bool"));

				int TrueLabel = ++ctx.CurrentID;
				int FalseLabel = ++ctx.CurrentID;
				int MergeLabel = ++ctx.CurrentID;

				ctx.AddInstrSelectionMerge(MergeLabel);
				ctx.AddInstrBranchConditional(operandID, TrueLabel, FalseLabel);

				ctx.PushScope();
				ctx.AddInstrLabel_AtFunctionBody(TrueLabel);
				GenerateCode(instr->TrueCode.Ptr(), TrueLabel);
				ctx.AddInstrBranch(MergeLabel);
				ctx.PopScope();

				ctx.PushScope();
				ctx.AddInstrLabel_AtFunctionBody(FalseLabel);
				if (instr->FalseCode)
					GenerateCode(instr->FalseCode.Ptr(), FalseLabel);
				ctx.AddInstrBranch(MergeLabel);
				ctx.PopScope();

				ctx.AddInstrLabel_AtFunctionBody(MergeLabel);
			}

			void PrintFor(ForInstruction * instr)
			{
				int HeaderBlockLabel = ++ctx.CurrentID;
				int ConditionBlockLabel = ++ctx.CurrentID;
				int BodyBlockLabel = ++ctx.CurrentID;
				int UpdateBlockLabel = ++ctx.CurrentID;
				int MergeBlockLabel = ++ctx.CurrentID;

				ctx.AddInstrBranch(HeaderBlockLabel);

				ctx.AddInstrLabel_AtFunctionBody(HeaderBlockLabel);
				ctx.AddInstrLoopMerge(MergeBlockLabel, UpdateBlockLabel);
				ctx.AddInstrBranch(ConditionBlockLabel);

				// condition block
				ctx.PushScope();
				ctx.AddInstrLabel_AtFunctionBody(ConditionBlockLabel);
				GenerateCode(instr->ConditionCode.Ptr(), ConditionBlockLabel);
				int conditionID = GetOperandValue(instr->ConditionCode->GetLastInstruction());
				conditionID = ctx.ConvertBasicType(
					conditionID,
					ctx.IDInfos[conditionID]().GetILType(),
					GetTypeFromString(L"bool"));
				ctx.AddInstrBranchConditional(conditionID, BodyBlockLabel, MergeBlockLabel);
				ctx.PopScope();

				// body block
				ctx.PushScope();
				ctx.AddInstrLabel_AtFunctionBody(BodyBlockLabel);
				ctx.StackMergeBlock.Add(MergeBlockLabel);
				ctx.StackContinueBlock.Add(UpdateBlockLabel);
				GenerateCode(instr->BodyCode.Ptr(), BodyBlockLabel);
				ctx.StackMergeBlock.RemoveAt(ctx.StackMergeBlock.Count() - 1);
				ctx.StackContinueBlock.RemoveAt(ctx.StackContinueBlock.Count() - 1);
				ctx.AddInstrBranch(UpdateBlockLabel);
				ctx.PopScope();

				// update block
				ctx.PushScope();
				ctx.AddInstrLabel_AtFunctionBody(UpdateBlockLabel);
				GenerateCode(instr->SideEffectCode.Ptr(), UpdateBlockLabel);
				ctx.AddInstrBranch(HeaderBlockLabel);
				ctx.PopScope();

				// merge block
				ctx.AddInstrLabel_AtFunctionBody(MergeBlockLabel);
			}

			void PrintWhileDo(WhileInstruction * instr)
			{
				int HeaderBlockLabel = ++ctx.CurrentID;
				int ConditionBlockLabel = ++ctx.CurrentID;
				int BodyBlockLabel = ++ctx.CurrentID;
				int UpdateBlockLabel = ++ctx.CurrentID;
				int MergeBlockLabel = ++ctx.CurrentID;

				ctx.AddInstrBranch(HeaderBlockLabel);

				// header block
				ctx.AddInstrLabel_AtFunctionBody(HeaderBlockLabel);
				ctx.AddInstrLoopMerge(MergeBlockLabel, UpdateBlockLabel);
				ctx.AddInstrBranch(ConditionBlockLabel);

				// condition block
				ctx.PushScope();
				ctx.AddInstrLabel_AtFunctionBody(ConditionBlockLabel);
				GenerateCode(instr->ConditionCode.Ptr(), ConditionBlockLabel, true);
				int conditionID = GetOperandValue(instr->ConditionCode->GetLastInstruction()->As<ReturnInstruction>()->Operand.Ptr());
				conditionID = ctx.ConvertBasicType(
					conditionID,
					ctx.IDInfos[conditionID]().GetILType(),
					GetTypeFromString(L"bool")
				);
				ctx.AddInstrBranchConditional(conditionID, BodyBlockLabel, MergeBlockLabel);
				ctx.PopScope();

				// body block
				ctx.PushScope();
				ctx.AddInstrLabel_AtFunctionBody(BodyBlockLabel);
				ctx.StackMergeBlock.Add(MergeBlockLabel);
				ctx.StackContinueBlock.Add(UpdateBlockLabel);
				GenerateCode(instr->BodyCode.Ptr(), BodyBlockLabel);
				ctx.StackMergeBlock.RemoveAt(ctx.StackMergeBlock.Count() - 1);
				ctx.StackContinueBlock.RemoveAt(ctx.StackContinueBlock.Count() - 1);
				ctx.AddInstrBranch(UpdateBlockLabel);
				ctx.PopScope();

				// update block (empty)
				ctx.AddInstrLabel_AtFunctionBody(UpdateBlockLabel);
				ctx.AddInstrBranch(HeaderBlockLabel);

				// merge block
				ctx.AddInstrLabel_AtFunctionBody(MergeBlockLabel);
			}

			void PrintDoWhile(DoInstruction * instr)
			{
				int HeaderBlockLabel = ++ctx.CurrentID;
				int BodyBlockLabel = ++ctx.CurrentID;
				int ConditionBlockLabel = ++ctx.CurrentID;
				int MergeBlockLabel = ++ctx.CurrentID;

				//ctx.FunctionBody << LR"(OpBranch %)" << HeaderBlockLabel << EndLine;
				ctx.AddInstrBranch(HeaderBlockLabel);

				// header block
				ctx.AddInstrLabel_AtFunctionBody(HeaderBlockLabel);
				ctx.AddInstrLoopMerge(MergeBlockLabel, ConditionBlockLabel);
				ctx.AddInstrBranch(BodyBlockLabel);

				// body block
				ctx.PushScope();
				ctx.AddInstrLabel_AtFunctionBody(BodyBlockLabel);
				ctx.StackMergeBlock.Add(MergeBlockLabel);
				ctx.StackContinueBlock.Add(ConditionBlockLabel);
				GenerateCode(instr->BodyCode.Ptr(), BodyBlockLabel);
				ctx.StackMergeBlock.RemoveAt(ctx.StackMergeBlock.Count() - 1);
				ctx.StackContinueBlock.RemoveAt(ctx.StackContinueBlock.Count() - 1);
				ctx.AddInstrBranch(ConditionBlockLabel);
				ctx.PopScope();

				// condition block
				ctx.PushScope();
				ctx.AddInstrLabel_AtFunctionBody(ConditionBlockLabel);
				GenerateCode(instr->ConditionCode.Ptr(), ConditionBlockLabel, true);
				int conditionID = GetOperandValue(instr->ConditionCode->GetLastInstruction()->As<ReturnInstruction>()->Operand.Ptr());
				conditionID = ctx.ConvertBasicType(
					conditionID,
					ctx.IDInfos[conditionID]().GetILType(),
					GetTypeFromString(L"bool")
				);
				ctx.AddInstrBranchConditional(conditionID, HeaderBlockLabel, MergeBlockLabel);
				ctx.PopScope();

				// merge block
				ctx.AddInstrLabel_AtFunctionBody(MergeBlockLabel);
			}

			void GenerateCode(CFGNode * code, int givenLabel = -1, bool LoopReturn = false)
			{
				if (givenLabel == -1)
				{
					++ctx.CurrentID; //label ID
					ctx.AddInstrLabel_AtFunctionBody(ctx.CurrentID);
				}

				List<int> usedID;
				for (auto & instr : *code)
				{

					if (auto ifInstr = instr.As<IfInstruction>())
					{
						PrintIf(ifInstr);
					}
					else if (auto forInstr = instr.As<ForInstruction>())
					{
						PrintFor(forInstr);
					}
					else if (auto doInstr = instr.As<DoInstruction>())
					{
						PrintDoWhile(doInstr);
					}
					else if (auto whileInstr = instr.As<WhileInstruction>())
					{
						PrintWhileDo(whileInstr);
					}
					else if (auto ret = instr.As<ReturnInstruction>())
					{
						if (!LoopReturn)
						{
							if (ret->Operand)
								ctx.AddInstrReturnValue(GetOperandValue(ret->Operand.Ptr()));
							else
								ctx.AddInstrReturn();
							ctx.AddInstrLabel_AtFunctionBody(++ctx.CurrentID);
						}
					}
					else if (instr.Is<BreakInstruction>())
					{
						ctx.AddInstrBranch(ctx.StackMergeBlock.Last());
						ctx.AddInstrLabel_AtFunctionBody(++ctx.CurrentID);
					}
					else if (instr.Is<ContinueInstruction>())
					{
						ctx.AddInstrBranch(ctx.StackContinueBlock.Last());
						ctx.AddInstrLabel_AtFunctionBody(++ctx.CurrentID);
					}
					else if (instr.Is<DiscardInstruction>())
					{
						ctx.AddInstrKill();
						ctx.AddInstrLabel_AtFunctionBody(++ctx.CurrentID);
					}
					else
					{
						PrintInstr(instr);
					}
				}
			}

		public:

			bool BufferPreProcessed;

			void Initiate(ExecutionModel model, CompiledWorld * shaderWorld)
			{
				ctx.Clear();
				ctx.CodeGen.Initiate();
				ctx.CurrentID = 1; // reserved for extinst
				ctx.CodeGen.ProgramHeader();
				ctx.PushScope();
				interfaceIDs.Clear();
				DepthReplacing = false;
				LocalSize = false;
				BufferImportOrExport = false;
				BufferPreProcessed = false;
				currentWorld = shaderWorld;
				currentExecutionModel = model;
			}

			int GenerateFunctionDeclaration(CompiledFunction *func)
				//return the ID of the Function Type
			{
				List<RefPtr<ILType>> args;
				for (auto & instr : *func->Code)
					if (auto arg = instr.As<FetchArgInstruction>())
						if (arg->ArgId != 0)
						{
							args.Add(arg->Type);
						}
				int funcTypeID = ctx.AddInstrTypeFunction(func, args, func->ReturnType);
				ctx.FunctionNameToFunctionID[func->Name] = ++ctx.CurrentID;
				return funcTypeID;
			}

			int GenerateFunctionDefinition(CompiledFunction *func, ILOperand *vertexOutput = nullptr)
				//return the ID of the Function
			{
				ctx.ClearBuffer();

				ctx.PushScope();

				int funcID = ctx.FunctionNameToFunctionID[func->Name]();
				int funcTypeID = ctx.FunctionNameToFunctionTypeID[func->Name]();

				ctx.AddInstrFunction(funcID, ctx.DefineType(func->ReturnType), funcTypeID, GetFuncOriginalName(func->Name));

				for (auto & instr : *func->Code)
					if (auto arg = instr.As<FetchArgInstruction>())
						if (arg->ArgId != 0)
						{
							if (!ctx.ParameterNameToID.ContainsKey((ILOperand*)&instr))
							{
								ctx.DefineType(arg->Type);
								int typeID = ctx.DefineTypePointer(arg->Type, StorageClass::Function);
								ctx.AddInstrFunctionParameter((ILOperand*)&instr, typeID, arg->Name);
							}
						}

				++ctx.CurrentID;
				ctx.AddInstrLabel_AtFunctionHeader(ctx.CurrentID);

				func->Code->NameAllInstructions();
				GenerateCode(func->Code.Ptr(), ctx.CurrentID);

				if (vertexOutput)
				{
					int valueID = ctx.AddInstrLoad(nullptr, vertexOutput, MemoryAccess::None);
					int gl_PositionID = ctx.AddInstrAccessChain_StructMember(
						0,
						ctx.InterfaceNameToID[L"variable_gl_PerVertex"],
						L"gl_Position"
					);
					ctx.AddInstrStore(0, gl_PositionID, valueID);
				}

				ctx.AddInstrReturn();
				ctx.AddInstrFunctionEnd();

				ctx.ProduceFunction();

				ctx.PopScope();

				return funcID;
			}

			void Decorate(int ID, Decoration deco, int op1 = -1)
			{
				ctx.AddInstrDecorate(ID, deco, op1);
			}

			void MemberDecorate(int ID, int index, Decoration deco, int op1 = -1)
			{
				ctx.AddInstrMemberDecorate(ID, index, deco, op1);
			}

			void SetDepthReplacing()
			{
				DepthReplacing = true;
			}

			void SetLocalSize(unsigned int x)
			{
				//layout(local_size_x = <x> ) in;
				LocalSize = true;
				unsigned int workgroup[3] = { x, 1, 1 };
				ctx.AddInstrDecorate(
					ctx.AddInstrConstantCompositeUInt(workgroup, 3),
					Decoration::BuiltIn,
					(int)BuiltIn::WorkgroupSize
				);
			}

			void GenerateEntryPoint(int mainFunctionID)
			{
				ctx.AddInstrEntryPoint(currentExecutionModel, mainFunctionID, interfaceIDs);
				if (currentExecutionModel == ExecutionModel::Fragment)
				{
					ctx.AddInstrExecutionMode(mainFunctionID, ExecutionMode::OriginUpperLeft);
				}
				if (DepthReplacing)
				{
					ctx.AddInstrExecutionMode(mainFunctionID, ExecutionMode::DepthReplacing);
				}
				if (LocalSize)
				{
					ctx.AddInstrExecutionMode(mainFunctionID, ExecutionMode::LocalSize, 256, 1, 1);
				}
			}

			int GenerateGlGlobalInvocationID()
				//return the ID of the gl_GlobalInvocationID variable
			{
				int GlobalInvocationID = ctx.AddInstrVariableDeclaration(0, GetTypeFromString(L"uvec3"), StorageClass::Input, L"gl_GlobalInvocationID", 0);
				ctx.AddInstrDecorate(GlobalInvocationID, Decoration::BuiltIn, (int)BuiltIn::GlobalInvocationId);
				ctx.InterfaceNameToID[L"gl_GlobalInvocationID"] = GlobalInvocationID;
				return GlobalInvocationID;
			}

			int GenerateInterfaceForSingleVariable(
				String varName,
				RefPtr<ILType> varType,
				StorageClass storageClass,
				int location = -1,
				int bindIndex = -1)
				//return the ID of the variable
			{
				int entID = ctx.AddInstrVariableDeclaration(0, varType, storageClass, varName, 0);
				ctx.InterfaceNameToID[varName] = entID;
				if (location != -1)
					ctx.AddInstrDecorate(entID, Decoration::Location, location);
				if (bindIndex != -1)
				{
					ctx.AddInstrDecorate(entID, Decoration::DescriptorSet, 0);
					ctx.AddInstrDecorate(entID, Decoration::Binding, bindIndex);
				}
				if (storageClass == StorageClass::Input || storageClass == StorageClass::Output)
					interfaceIDs.Add(entID);
				return entID;
			}

			std::pair<int,int> GenerateInterfaceForStructVariable(
				String structTypeName,
				String structVariableName,
				List<RefPtr<ILType>> memberTypes,
				List<String> memberNames,
				int UniformOrBuffer,
				StorageClass storageClass,
				int location = -1,
				int bindindex = -1)
				//first  - the ID of the struct type
				//second - the ID of the variable 
			{
				RefPtr<ILStructType> structIL = new ILStructType();
				structIL->TypeName = structTypeName;
				int n = memberTypes.Count();
				for (int i = 0; i < n; i++)
				{
					ILStructType::ILStructField field;
					field.Type = memberTypes[i];
					field.FieldName = memberNames[i];
					structIL->Members.Add(field);
				}

				int structTypeID = ctx.DefineType(structIL, UniformOrBuffer);
				int structVariableID = ctx.AddInstrVariableDeclaration(0, structIL, storageClass, structVariableName, UniformOrBuffer);
				ctx.InterfaceNameToID[structVariableName] = structVariableID;

				if (UniformOrBuffer == 1)
				{
					ctx.AddInstrDecorate(structVariableID, Decoration::DescriptorSet, 0);
					ctx.AddInstrDecorate(structTypeID, Decoration::Block);
				}
				else if (UniformOrBuffer == 2)
				{
					ctx.AddInstrDecorate(structVariableID, Decoration::DescriptorSet, 0);
					ctx.AddInstrDecorate(structTypeID, Decoration::BufferBlock);
				}

				if (location != -1)
				{
					ctx.AddInstrDecorate(structVariableID, Decoration::Location, location);
				}

				if (bindindex != -1)
				{
					ctx.AddInstrDecorate(structVariableID, Decoration::Binding, bindindex);
				}

				if (storageClass == StorageClass::Input || storageClass == StorageClass::Output)
				{
					for (int i = 0; i < n; i++)
						if (memberTypes[i]->IsIntegral())
							ctx.AddInstrMemberDecorate(structTypeID, i, Decoration::Flat);
					interfaceIDs.Add(structVariableID);
				}

				return std::make_pair(structTypeID, structVariableID);
			}

			CompiledShaderSource GenerateShaderWorld()
			{
				CompiledShaderSource rs;

				auto binaryForm = ctx.ProduceWordStream();
				rs.BinaryCode.SetSize(binaryForm.Count() * sizeof(unsigned int));
				memcpy(rs.BinaryCode.Buffer(), binaryForm.Buffer(), rs.BinaryCode.Count());

				rs.MainCode = ctx.ProduceTextCode();

				return rs;
			}
		};

		class SpirVCodeGen : public CodeGenBackend
		{
			String vertexOutputName;
			EnumerableDictionary<String, String> backendArguments;

		public:

			ExecutionModel currentExecutionModel = ExecutionModel::Invalid;

			void ProcessBufferImportOrExportInterfaces(SpirvModule & spvModule, String blkName, int index)
			{
				if (!spvModule.BufferPreProcessed)
				{
					spvModule.BufferPreProcessed = true;
					spvModule.SetLocalSize(256);
					spvModule.GenerateGlGlobalInvocationID();

					List<RefPtr<ILType>> memberTypes;
					List<String> memberNames;
					memberTypes.Add(GetTypeFromString(L"uint"));
					memberNames.Add(L"sys_thread_count");
					spvModule.GenerateInterfaceForStructVariable(
						L"SystemBlock",
						L"blkSystemBlock",
						memberTypes,
						memberNames,
						1,
						StorageClass::Uniform,
						-1,
						0
					);
				}

				List<RefPtr<ILType>> memberTypes;
				List<String> memberNames;
				memberTypes.Add(GetTypeFromString(L"float[0]"));
				memberNames.Add(L"a");
				spvModule.GenerateInterfaceForStructVariable(
					blkName,
					L"blk" + blkName,
					memberTypes,
					memberNames,
					2,
					StorageClass::Uniform,
					-1,
					index
				);
			}

			virtual CompiledShaderSource GenerateShaderWorld(CompileResult & result, SymbolTable * /*symbols*/, CompiledWorld * shaderWorld, Dictionary<String, ImportOperatorHandler*>& opHandlers, Dictionary<String, ExportOperatorHandler*>& exportHandlers) override
			{
				
				currentExecutionModel = ExecutionModel::Invalid;
				if (shaderWorld->ExportOperator.Content == L"fragmentExport")
					currentExecutionModel = ExecutionModel::Fragment;
				else if (shaderWorld->BackendParameters.ContainsKey(L"vertex"))
					currentExecutionModel = ExecutionModel::Vertex;
				else if (shaderWorld->ExportOperator.Content == L"bufferExport")
					currentExecutionModel = ExecutionModel::GLCompute;

				CompiledFunction mainFunction;
				mainFunction.Name = L"main";
				mainFunction.ReturnType = nullptr;
				mainFunction.Code = shaderWorld->Code;

				SpirvModule spvModule;
				spvModule.Initiate(currentExecutionModel, shaderWorld);
				spvModule.GenerateFunctionDeclaration(&mainFunction);

				for (auto funcName : shaderWorld->ReferencedFunctions)
					for(auto & func : result.Program->Functions)
						if (funcName == func->Name)
							spvModule.GenerateFunctionDeclaration(func.Ptr());

				for (auto funcName : shaderWorld->ReferencedFunctions)
					for (auto & func : result.Program->Functions)
						if (funcName == func->Name)
							spvModule.GenerateFunctionDefinition(func.Ptr());

				for (auto & inputBlock : shaderWorld->WorldInputs)
				{
					auto block = inputBlock.Value.Block;
					if (!block->UserWorlds.Contains(shaderWorld->WorldName))
						continue;
					String impOpName = inputBlock.Value.ImportOperator.Name.Content;

					if (impOpName == L"standardImport")
					{
						List<RefPtr<ILType>> memberTypes;
						List<String> memberNames;
						for (auto & ent : block->Entries)
						{
							memberTypes.Add(ent.Value.Type);
							memberNames.Add(ent.Value.Name);
						}
						spvModule.GenerateInterfaceForStructVariable(
							block->Name,
							L"blk"+block->Name,
							memberTypes,
							memberNames,
							0,
							StorageClass::Input,
							0
						);
					}

					else if (impOpName == L"vertexImport")
					{
						int location = 0;
						for (auto & ent : block->Entries)
						{
							spvModule.GenerateInterfaceForSingleVariable(
								ent.Key,
								ent.Value.Type,
								StorageClass::Input,
								location
							);
							location++;
						}
					}

					else if (impOpName == L"uniformImport")
					{
						int nonTextureCount = 0;
						for (auto & ent : block->Entries)
							if (!ent.Value.Type->IsTexture())
								nonTextureCount++;

						int TypeOfStruct = 1; //1: uniform buffer; 2: shader storage buffer; 0: not a buffer
						if (block->Attributes.ContainsKey(L"ShaderStorageBlock"))
							TypeOfStruct = 2;

						if (nonTextureCount)
						{
							List<RefPtr<ILType>> memberTypes;
							List<String> memberNames;
							for (auto & ent : block->Entries)
								if (!ent.Value.Type->IsTexture())
								{
									memberTypes.Add(ent.Value.Type);
									memberNames.Add(ent.Value.Name);
								}
							String strIndex;
							int index = -1;
							if (block->Attributes.TryGetValue(L"Index", strIndex))
								index = StringToInt(strIndex);
							spvModule.GenerateInterfaceForStructVariable(
								block->Name,
								L"blk" + block->Name,
								memberTypes,
								memberNames,
								TypeOfStruct,
								StorageClass::Uniform,
								-1,
								index
							);
						}
						
						int bindPoint = 0;
						String bindingStart;
						if (backendArguments.TryGetValue(L"TextureBindingStart", bindingStart))
							bindPoint = StringToInt(bindingStart);

						for(auto & ent : block->Entries)
							if (ent.Value.Type->IsTexture())
							{
								spvModule.GenerateInterfaceForSingleVariable(
									ent.Key,
									ent.Value.Type,
									StorageClass::UniformConstant,
									-1,
									bindPoint
								);
								bindPoint++;
							}
					}

					else if (impOpName == L"textureImport")
					{
						int bindPoint = 0;
						String strIndex;
						if (block->Attributes.TryGetValue(L"Index", strIndex))
							bindPoint = StringToInt(strIndex);
						for (auto & ent : block->Entries)
						{
							spvModule.GenerateInterfaceForSingleVariable(
								ent.Key,
								ent.Value.Type,
								StorageClass::UniformConstant,
								-1,
								bindPoint
							);
							bindPoint++;
						}
					}

					else if (impOpName == L"bufferImport")
					{
						String strIdx;
						int index = 0;
						if (block->Attributes.TryGetValue(L"Index", strIdx))
							index = StringToInt(strIdx);
						ProcessBufferImportOrExportInterfaces(spvModule, block->Name, index);
					}

					else 
						throw NotImplementedException(L"not implemented input interface: " + impOpName);
				}

				if (shaderWorld->ExportOperator.Content == L"fragmentExport")
				{
					int location = 0;
					for (auto & ent : shaderWorld->WorldOutput->Entries)
						if (!ent.Value.LayoutAttribs.ContainsKey(L"DepthOutput"))
						{
							spvModule.GenerateInterfaceForSingleVariable(
								ent.Key,
								ent.Value.Type,
								StorageClass::Output,
								location
							);
							location++;
						}
						else
						{
							int entID = spvModule.GenerateInterfaceForSingleVariable(
								L"gl_FragDepth",
								ent.Value.Type,
								StorageClass::Output,
								location
							);
							spvModule.SetDepthReplacing();
							spvModule.Decorate(entID, Decoration::BuiltIn, (int)BuiltIn::FragDepth);
						}
				}

				else if (shaderWorld->ExportOperator.Content == L"standardExport")
				{
					List<RefPtr<ILType>> memberTypes;
					List<String> memberNames;
					for (auto & ent : shaderWorld->WorldOutput->Entries)
					{
						memberTypes.Add(ent.Value.Type);
						memberNames.Add(ent.Value.Name);
					}
					spvModule.GenerateInterfaceForStructVariable(
						shaderWorld->WorldOutput->Name,
						L"blk" + shaderWorld->WorldOutput->Name,
						memberTypes,
						memberNames,
						0,
						StorageClass::Output,
						0
					);
				}

				else if (shaderWorld->ExportOperator.Content == L"bufferExport")
				{
					String strIdx;
					int index = 0;
					if (shaderWorld->WorldOutput->Attributes.TryGetValue(L"Index", strIdx))
						index = StringToInt(strIdx);
					ProcessBufferImportOrExportInterfaces(spvModule, shaderWorld->WorldOutput->Name, index);
				}

				else
					throw NotImplementedException(L"not implemented output interface: " + shaderWorld->ExportOperator.Content);

				if (vertexOutputName.Length())
				{
					CompiledComponent ccomp;
					if (shaderWorld->LocalComponents.TryGetValue(vertexOutputName, ccomp))
					{
						List<RefPtr<ILType>> memberTypes;
						List<String> memberNames;
						memberTypes.Add(GetTypeFromString(L"vec4"));
						memberNames.Add(L"gl_Position");
						memberTypes.Add(GetTypeFromString(L"float"));
						memberNames.Add(L"gl_PointSize");
						memberTypes.Add(GetTypeFromString(L"float[1]"));
						memberNames.Add(L"gl_ClipDistance");
						memberTypes.Add(GetTypeFromString(L"float[1]"));
						memberNames.Add(L"gl_CullDistance");

						int typeID = spvModule.GenerateInterfaceForStructVariable(
							L"gl_PerVertex",
							L"variable_gl_PerVertex",
							memberTypes,
							memberNames,
							0,
							StorageClass::Output,
							-1,
							-1
						).first;

						spvModule.Decorate(typeID, Decoration::Block);
						spvModule.MemberDecorate(typeID, 0, Decoration::BuiltIn, (int)BuiltIn::Position);
						spvModule.MemberDecorate(typeID, 1, Decoration::BuiltIn, (int)BuiltIn::PointSize);
						spvModule.MemberDecorate(typeID, 2, Decoration::BuiltIn, (int)BuiltIn::ClipDistance);
						spvModule.MemberDecorate(typeID, 3, Decoration::BuiltIn, (int)BuiltIn::CullDistance);
					}
				}

				ILOperand *vertexOutput = nullptr;
				if (vertexOutputName.Length())
				{
					CompiledComponent ccomp;
					if (shaderWorld->LocalComponents.TryGetValue(vertexOutputName, ccomp))
					{
						vertexOutput = ccomp.CodeOperand;
					}
					else
						throw InvalidOperationException(L"can not find vertexOutputName");
				}

				int mainFunctionID = spvModule.GenerateFunctionDefinition(&mainFunction, vertexOutput);

				spvModule.GenerateEntryPoint(mainFunctionID);

				return spvModule.GenerateShaderWorld();
				
				/*
				ctx.Clear();

				currentWorld = shaderWorld;
				CompiledShaderSource rs;
				ctx.Result = &result;

				currentExecutionModel = ExecutionModel::Invalid;
				if (currentWorld->ExportOperator.Content == L"fragmentExport")
					currentExecutionModel = ExecutionModel::Fragment;
				else if (currentWorld->BackendParameters.ContainsKey(L"vertex"))
					currentExecutionModel = ExecutionModel::Vertex;
				else if (currentWorld->ExportOperator.Content == L"bufferExport")
					currentExecutionModel = ExecutionModel::GLCompute;

				if (ExecutionModel::Invalid == currentExecutionModel)
					throw InvalidOperationException(L"invalid execution model for shader world: " + currentWorld->WorldName);

				ctx.CurrentID = 1;

				ctx.CodeGen.Initiate();
				ctx.CodeGen.ProgramHeader();

				//add all functions type definition
				for (auto funcName : shaderWorld->ReferencedFunctions)
				{
					for (auto &func : result.Program->Functions)
					{
						if (func->Name == funcName)
						{
							List<RefPtr<ILType>> args;
							for (auto & instr : *func->Code)
								if (auto arg = instr.As<FetchArgInstruction>())
									if (arg->ArgId != 0)
									{
										args.Add(arg->Type);
									}
							ctx.AddInstrTypeFunction(func.Ptr(), args, func->ReturnType);
							ctx.FunctionNameToFunctionID[func->Name] = ++ctx.CurrentID; 
							//this is reserverd for the result ID of the OpFunction instruction! 
						}
					}
				}

				//add all functions definition
				for (auto funcName : shaderWorld->ReferencedFunctions)
				{
					for (auto &func : result.Program->Functions)
					{
						if (func->Name == funcName)
						{

							ctx.ClearBuffer();

							ctx.PushScope();

							int funcID = ctx.FunctionNameToFunctionID[func->Name]();
							int funcTypeID = ctx.FunctionNameToFunctionTypeID[func->Name]();

							ctx.AddInstrFunction(funcID, ctx.DefineType(func->ReturnType), funcTypeID, GetFuncOriginalName(funcName));

							for (auto & instr : *func->Code)
								if (auto arg = instr.As<FetchArgInstruction>())
									if (arg->ArgId != 0)
									{
										if (!ctx.ParameterNameToID.ContainsKey((ILOperand*)&instr))
										{
											ctx.DefineType(arg->Type);
											int typeID = ctx.DefineTypePointer(arg->Type, StorageClass::Function);
											ctx.AddInstrFunctionParameter((ILOperand*)&instr, typeID, arg->Name);
										}
									}

							++ctx.CurrentID;
							ctx.AddInstrLabel_AtFunctionHeader(ctx.CurrentID);

							func->Code->NameAllInstructions();
							GenerateCode(func->Code.Ptr(), ctx.CurrentID);

							ctx.AddInstrReturn();
							ctx.AddInstrFunctionEnd();

							ctx.ProduceFunction();

							ctx.PopScope();
						}
					}
				}

				ctx.ClearBuffer();

				ctx.PushScope();

				List<int> interfaceIDs;
				bool DepthReplacing = false;
				bool LocalSize = false;
				bool BufferImportOrExport = false;
				ProcessInterfaces(interfaceIDs, shaderWorld, opHandlers, DepthReplacing, LocalSize, BufferImportOrExport);

				//for gl_Position
				if (vertexOutputName.Length())
				{
					CompiledComponent ccomp;
					if (currentWorld->LocalComponents.TryGetValue(vertexOutputName, ccomp))
					{
						RefPtr<ILStructType> structIL = new ILStructType();
						structIL->TypeName = L"gl_PerVertex";

						ILStructType::ILStructField f1;
						f1.Type = GetTypeFromString(L"vec4");
						f1.FieldName = L"gl_Position";
						structIL->Members.Add(f1);
						ILStructType::ILStructField f2;
						f2.Type = GetTypeFromString(L"float");
						f2.FieldName = L"gl_PointSize";
						structIL->Members.Add(f2);
						ILStructType::ILStructField f3;
						f3.Type = GetTypeFromString(L"float[1]");
						f3.FieldName = L"gl_ClipDistance";
						structIL->Members.Add(f3);
						ILStructType::ILStructField f4;
						f4.Type = GetTypeFromString(L"float[1]");
						f4.FieldName = L"gl_CullDistance";
						structIL->Members.Add(f4);

						int structTypeID = ctx.DefineType(structIL);
						int structVariableID = ctx.AddInstrVariableDeclaration(0, structIL, StorageClass::Output, L"gl_PerVertex");
						ctx.InterfaceNameToID[L"gl_PerVertex"] = structVariableID;

						ctx.AddInstrDecorate(structTypeID, Decoration::Block);
						ctx.AddInstrMemberDecorate(structTypeID, 0, Decoration::BuiltIn, (int)BuiltIn::Position);
						ctx.AddInstrMemberDecorate(structTypeID, 1, Decoration::BuiltIn, (int)BuiltIn::PointSize);
						ctx.AddInstrMemberDecorate(structTypeID, 2, Decoration::BuiltIn, (int)BuiltIn::ClipDistance);
						ctx.AddInstrMemberDecorate(structTypeID, 3, Decoration::BuiltIn, (int)BuiltIn::CullDistance);

						interfaceIDs.Add(structVariableID);
					}
					else
						throw InvalidOperationException(L"can not find vertexOutputName");
				}

				//add Main function type definition
				ctx.MainFunctionTypeID = ctx.AddInstrTypeFunction(nullptr, List<RefPtr<ILType>>(), nullptr);
				ctx.MainFunctionID = ++ctx.CurrentID;

				//Entry Point
				ctx.AddInstrEntryPoint(currentExecutionModel, ctx.MainFunctionID, interfaceIDs);

				//execution mode
				if (currentExecutionModel == ExecutionModel::Fragment)
				{
					//CodeGen.OpExecutionMode(ctx.MainFunctionID, ExecutionMode::OriginUpperLeft);
					ctx.AddInstrExecutionMode(ctx.MainFunctionID, ExecutionMode::OriginUpperLeft);
				}
				if (DepthReplacing)
				{
					//CodeGen.OpExecutionMode(ctx.MainFunctionID, ExecutionMode::DepthReplacing);
					ctx.AddInstrExecutionMode(ctx.MainFunctionID, ExecutionMode::DepthReplacing);
				}
				if (LocalSize)
				{
					ctx.AddInstrExecutionMode(ctx.MainFunctionID, ExecutionMode::LocalSize, 256, 1, 1);
				}

				//MainFunction
				ctx.AddInstrFunction(ctx.MainFunctionID, ctx.TypeNameToID[L"void"](), ctx.MainFunctionTypeID, L"main");

				++ctx.CurrentID;
				ctx.AddInstrLabel_AtFunctionHeader(ctx.CurrentID);

				if (BufferImportOrExport)
				{
					int GIIDx = ctx.AddInstrLoad(
						ctx.AddInstrAccessChain_VectorMember(0, ctx.InterfaceNameToID[L"gl_GlobalInvocationID"], -1, 0),
						MemoryAccess::None
					);	//GlobalInvocationID.x
					int SysThreadCountID = ctx.AddInstrLoad(
						ctx.AddInstrAccessChain_StructMember(0, ctx.InterfaceNameToID[L"SystemBlock"], L"sys_thread_count"),
						MemoryAccess::None
					);
					int conditionID = ctx.AddInstrBinaryInstr(
						0, GetTypeFromString(L"bool"), L"OpUGreaterThanEqual", GIIDx, SysThreadCountID
					);
					int MergeLabel = ++ctx.CurrentID;
					int TrueLabel = ++ctx.CurrentID;
					ctx.AddInstrSelectionMerge(MergeLabel);
					ctx.AddInstrBranchConditional(conditionID, TrueLabel, MergeLabel);
					ctx.AddInstrLabel_AtFunctionBody(TrueLabel);
					ctx.AddInstrReturn();
					ctx.AddInstrLabel_AtFunctionBody(MergeLabel);
				}

				shaderWorld->Code->NameAllInstructions();
				GenerateCode(shaderWorld->Code.Ptr(), ctx.CurrentID);

				if (vertexOutputName.Length())
				{
					CompiledComponent ccomp;
					if (currentWorld->LocalComponents.TryGetValue(vertexOutputName, ccomp))
					{
						int valueID = ctx.AddInstrLoad(nullptr, ccomp.CodeOperand, MemoryAccess::None);
						int gl_PositionID = ctx.AddInstrAccessChain_StructMember(
							0,
							ctx.InterfaceNameToID[L"gl_PerVertex"],
							L"gl_Position"
						);
						ctx.AddInstrStore(0, gl_PositionID, valueID);
					}
					else
						throw InvalidOperationException(L"can not find vertexOutputName");
				}

				//MainFunction End
				ctx.AddInstrReturn();
				ctx.AddInstrFunctionEnd();

				ctx.ProduceFunction();

				ctx.PopScope();

				auto binaryForm = ctx.ProduceWordStream();
				rs.BinaryCode.SetSize(binaryForm.Count() * sizeof(unsigned int));
				memcpy(rs.BinaryCode.Buffer(), binaryForm.Buffer(), rs.BinaryCode.Count());

				rs.MainCode = ctx.ProduceTextCode();

				rs.OutputDeclarations = L"spirv";

				//print IL 
				{
					auto compiledProgram = result.Program.Ptr();
					StringBuilder sb;

					//function part
					sb << L"function" << EndLine;
					sb << L"{" << EndLine;
					for (auto &pfunc : compiledProgram->Functions) {
						sb << pfunc->ReturnType->ToString() << L" " << pfunc->Name << L"(";
						bool first = true;
						for (auto &name2param : pfunc->Parameters) {
							if (!first)
								sb << L", ";
							sb << name2param.Value->ToString() << L" " << name2param.Key;
							first = false;
						}
						sb << L")" << EndLine;
						sb << L"{" << EndLine;
						pfunc->Code->NameAllInstructions();
						sb << pfunc->Code->ToString() << EndLine;
						sb << L"}" << EndLine;
					}
					sb << L"}" << EndLine;

					//shader part
					for (auto &pshader : compiledProgram->Shaders) {
						sb << L"Shader " << pshader->MetaData.ShaderName << EndLine;
						sb << L"{" << EndLine;
						for (auto &pworld : pshader->Worlds) {
							sb << L"World " << pworld.Key << EndLine;
							sb << L"{" << EndLine;
							pworld.Value.Ptr()->Code->NameAllInstructions();
							sb << pworld.Value.Ptr()->Code->ToString() << EndLine;
							sb << L"}" << EndLine;
						}
						sb << L"}" << EndLine;
					}

					StringBuilder sb_indent;
					IndentString(sb_indent, sb.ToSt\`ring());
					CoreLib::IO::StreamWriter sw(L"IL-" + currentWorld->ShaderName + L"-" + currentWorld->WorldOutput->Name + String(L".out"));
					sw.Write(sb_indent.ToString());
				}

				currentWorld = nullptr;

				return rs;
				*/
			}

			virtual void SetParameters(const EnumerableDictionary<String, String>& arguments) override
			{
				backendArguments = arguments;
				if (!arguments.TryGetValue(L"vertex", vertexOutputName))
					vertexOutputName = L"";
			}
		};

		CodeGenBackend * CreateSpirVCodeGen()
		{
			return new SpirVCodeGen();
		}
	}
}
#endif

/***********************************************************************
SPIRECORE\STDINCLUDE.CPP
***********************************************************************/

const char * LibIncludeString = R"(
__intrinsic float dFdx(float v);
__intrinsic float dFdy(float v);
__intrinsic float fwidth(float v);
__intrinsic vec2 dFdx(vec2 v);
__intrinsic vec2 dFdy(vec2 v);
__intrinsic vec2 fwidth(vec2 v);
__intrinsic vec3 dFdx(vec3 v);
__intrinsic vec3 dFdy(vec3 v);
__intrinsic vec3 fwidth(vec3 v);
__intrinsic vec4 dFdx(vec4 v);
__intrinsic vec4 dFdy(vec4 v);
__intrinsic vec4 fwidth(vec4 v);

__intrinsic vec3 normalize(vec3 v);
__intrinsic float dot(vec2 v0, vec2 v1);
__intrinsic float dot(vec3 v0, vec3 v1);
__intrinsic float dot(vec4 v0, vec4 v1);
__intrinsic float sin(float v);
__intrinsic float cos(float v);
__intrinsic float tan(float v);
__intrinsic float sqrt(float v);
__intrinsic vec2 sin(vec2 v);
__intrinsic vec2 cos(vec2 v);
__intrinsic vec2 tan(vec2 v);
__intrinsic vec2 sqrt(vec2 v);
__intrinsic vec3 sin(vec3 v);
__intrinsic vec3 cos(vec3 v);
__intrinsic vec3 tan(vec3 v);
__intrinsic vec3 sqrt(vec3 v);
__intrinsic vec4 sin(vec4 v);
__intrinsic vec4 cos(vec4 v);
__intrinsic vec4 tan(vec4 v);
__intrinsic vec4 sqrt(vec4 v);
__intrinsic float abs(float v);
__intrinsic vec2 abs(vec2 v);
__intrinsic vec3 abs(vec3 v);
__intrinsic vec4 abs(vec4 v);

__intrinsic float exp(float v);
__intrinsic vec2 exp(vec2 v);
__intrinsic vec3 exp(vec3 v);
__intrinsic vec4 exp(vec4 v);

__intrinsic float log(float v);
__intrinsic vec2 log(vec2 v);
__intrinsic vec3 log(vec3 v);
__intrinsic vec4 log(vec4 v);

__intrinsic float exp2(float v);
__intrinsic vec2 exp2(vec2 v);
__intrinsic vec3 exp2(vec3 v);
__intrinsic vec4 exp2(vec4 v);

__intrinsic float log2(float v);
__intrinsic vec2 log2(vec2 v);
__intrinsic vec3 log2(vec3 v);
__intrinsic vec4 log2(vec4 v);

__intrinsic float asin(float v);
__intrinsic vec2 asin(vec2 v);
__intrinsic vec3 asin(vec3 v);
__intrinsic vec4 asin(vec4 v);

__intrinsic float acos(float v);
__intrinsic vec2 acos(vec2 v);
__intrinsic vec3 acos(vec3 v);
__intrinsic vec4 acos(vec4 v);

__intrinsic float atan(float v);
__intrinsic vec2 atan(vec2 v);
__intrinsic vec3 atan(vec3 v);
__intrinsic vec4 atan(vec4 v);

__intrinsic float sign(float x);
__intrinsic vec2 sign(vec2 x);
__intrinsic vec3 sign(vec3 x);
__intrinsic vec4 sign(vec4 x);

__intrinsic float pow(float base, float e);
__intrinsic vec2 pow(vec2 base, vec2 e);
__intrinsic vec3 pow(vec3 base, vec3 e);
__intrinsic vec4 pow(vec4 base, vec4 e);
__intrinsic float atan2(float x, float y);
__intrinsic float floor(float v);
__intrinsic vec2 floor(vec2 v);
__intrinsic vec3 floor(vec3 v);
__intrinsic vec4 floor(vec4 v);
__intrinsic float fract(float v);
__intrinsic vec2 fract(vec2 v);
__intrinsic vec3 fract(vec3 v);
__intrinsic vec4 fract(vec4 v);
__intrinsic float ceil(float v);
__intrinsic vec2 ceil(vec2 v);
__intrinsic vec3 ceil(vec3 v);
__intrinsic vec4 ceil(vec4 v);
__intrinsic float step(float v, float y);
__intrinsic vec2 step(vec2 v, vec2 v1);
__intrinsic vec3 step(vec3 v, vec3 v1);
__intrinsic vec4 step(vec4 v, vec4 v1);
__intrinsic float smoothstep(float e0, float e1, float v);
__intrinsic vec2 smoothstep(vec2 e0, vec2 e1, vec2 v);
__intrinsic vec3 smoothstep(vec3 e0, vec3 e1, vec3 v);
__intrinsic vec4 smoothstep(vec4 e0, vec4 e1, vec4 v);
__intrinsic vec4 texture(sampler2D tex, vec2 coord);
__intrinsic vec4 texture(samplerCube tex, vec3 coord);
__intrinsic vec4 textureGrad(sampler2D tex, vec2 coord, vec2 dPdx, vec2 dPdy);
__intrinsic vec4 textureGrad(samplerCube tex, vec3 coord, vec3 dPdx, vec3 dPdy);
__intrinsic vec4 texture(samplerCube tex, vec3 coord, float bias);
__intrinsic float texture(sampler2DShadow tex, vec3 coord);
__intrinsic float texture(samplerCubeShadow tex, vec4 coord);
__intrinsic vec4 textureProj(sampler2D tex, vec3 coord);
__intrinsic vec4 textureProj(samplerCube tex, vec4 coord);
__intrinsic float textureProj(sampler2DShadow tex, vec4 coord);
__intrinsic float textureProj(samplerCubeShadow tex, vec4 coord);
__intrinsic vec4 texelFetch(sampler2D sampler, ivec2 P, int lod);
__intrinsic float diff(float v);
__intrinsic float mod(float x, float y);
__intrinsic float max(float v);
__intrinsic float min(float v);
__intrinsic float max(float v, float v1);
__intrinsic float min(float v, float v1);
__intrinsic vec2 max(vec2 v, vec2 v1);
__intrinsic vec2 min(vec2 v, vec2 v1);
__intrinsic vec3 max(vec3 v, vec3 v1);
__intrinsic vec3 min(vec3 v, vec3 v1);
__intrinsic vec4 max(vec4 v, vec4 v1);
__intrinsic vec4 min(vec4 v, vec4 v1);
__intrinsic float clamp(float v, float v1, float v2);
__intrinsic vec2 clamp(vec2 v, vec2 v1, vec2 v2);
__intrinsic vec3 clamp(vec3 v, vec3 v1, vec3 v2);
__intrinsic vec4 clamp(vec4 v, vec4 v1, vec4 v2);

__intrinsic vec3 reflect(vec3 I, vec3 N);
__intrinsic vec3 refract(vec3 I, vec3 N, float eta);

__intrinsic float length(vec2 v);
__intrinsic float length(vec3 v);
__intrinsic float length(vec4 v);

__intrinsic void alphaTest(float alpha, float threshold);
__intrinsic vec3 mix(vec3 v0, vec3 v1, float t);
__intrinsic vec4 mix(vec4 v0, vec4 v1, float t);
__intrinsic vec2 mix(vec2 v0, vec2 v1, float t);
__intrinsic float mix(float v0, float v1, float t);
__intrinsic vec3 mix(vec3 v0, vec3 v1, vec3 t);
__intrinsic vec4 mix(vec4 v0, vec4 v1, vec4 t);
__intrinsic vec2 mix(vec2 v0, vec2 v1, vec2 t);
__intrinsic mat3 mat3(vec3 a, vec3 b, vec3 c);
__intrinsic mat3 mat3(float a0, float a1, float a2, float a3, float a4, float a5, float a6, float a7, float a8);
__intrinsic mat4 mat4(vec4 a, vec4 b, vec4 c, vec4 d);
__intrinsic mat4 mat4(float a0, float a1, float a2, float a3, float a4, float a5, float a6, float a7, float a8, float a9, float a10, float a11, float a12, float a13, float a14, float a15);
__intrinsic vec3 cross(vec3 v1, vec3 v2);
__intrinsic vec2 vec2(float v);
__intrinsic vec3 vec3(float v);
__intrinsic vec4 vec4(float v);
__intrinsic vec2 vec2(float x, float y);
__intrinsic vec3 vec3(float x, float y, float z);
__intrinsic vec3 vec3(vec2 v, float z);
__intrinsic vec4 vec4(float x, float y, float z, float w);
__intrinsic vec4 vec4(vec3 v, float w);
__intrinsic vec4 vec4(vec2 v, float z, float w);
__intrinsic vec4 vec4(vec2 v, vec2 w);
__intrinsic ivec2 ivec2(int x, int y);
__intrinsic ivec3 ivec3(int x, int y, int z);
__intrinsic ivec3 ivec3(ivec2 v, int z);
__intrinsic ivec4 ivec4(int x, int y, int z, int w);
__intrinsic ivec4 ivec4(ivec3 v, int w);
__intrinsic ivec4 ivec4(ivec2 v, int z, int w);
__intrinsic ivec4 ivec4(ivec2 v, ivec2 w);

__intrinsic uvec2 uvec2(uint x, uint y);
__intrinsic uvec3 uvec3(uint x, uint y, uint z);
__intrinsic uvec3 uvec3(uvec2 v, uint z);
__intrinsic uvec4 uvec4(uint x, uint y, uint z, uint w);
__intrinsic uvec4 uvec4(uvec3 v, uint w);
__intrinsic uvec4 uvec4(uvec2 v, uint z, uint w);
__intrinsic uvec4 uvec4(uvec2 v, uvec2 w);

__intrinsic int int(uint val);
__intrinsic int int(float val);
__intrinsic ivec2 ivec2(uvec2 val);
__intrinsic ivec2 ivec2(vec2 val);
__intrinsic ivec3 ivec3(uvec3 val);
__intrinsic ivec3 ivec3(vec3 val);
__intrinsic ivec4 ivec4(uvec4 val);
__intrinsic ivec4 ivec4(vec4 val);

__intrinsic uint uint(int val);
__intrinsic uint uint(float val);
__intrinsic uvec2 uvec2(ivec2 val);
__intrinsic uvec2 uvec2(vec2 val);
__intrinsic uvec3 uvec3(ivec3 val);
__intrinsic uvec3 uvec3(vec3 val);
__intrinsic uvec4 uvec4(ivec4 val);
__intrinsic uvec4 uvec4(vec4 val);

__intrinsic float float(int val);
__intrinsic float float(uint val);
__intrinsic vec2 vec2(ivec2 val);
__intrinsic vec2 vec2(uvec2 val);
__intrinsic vec3 vec3(ivec3 val);
__intrinsic vec3 vec3(uvec3 val);
__intrinsic vec4 vec4(ivec4 val);
__intrinsic vec4 vec4(uvec4 val);

__intrinsic mat3 transpose(mat3 in);
__intrinsic mat4 transpose(mat4 in);

struct trait __intrinsic {};
__intrinsic trait IsTriviallyPassable(float);
__intrinsic trait IsTriviallyPassable(vec2);
__intrinsic trait IsTriviallyPassable(vec3);
__intrinsic trait IsTriviallyPassable(vec4);
__intrinsic trait IsTriviallyPassable(mat3);
__intrinsic trait IsTriviallyPassable(mat4);
__intrinsic trait IsTriviallyPassable(int);
__intrinsic trait IsTriviallyPassable(ivec2);
__intrinsic trait IsTriviallyPassable(ivec3);
__intrinsic trait IsTriviallyPassable(ivec4);
__intrinsic trait IsTriviallyPassable(uint);
__intrinsic trait IsTriviallyPassable(uvec2);
__intrinsic trait IsTriviallyPassable(uvec3);
__intrinsic trait IsTriviallyPassable(uvec4);
__intrinsic trait IsTriviallyPassable(bool);
#line_reset#
)";

using namespace CoreLib::Basic;

namespace Spire
{
	namespace Compiler
	{
		String SpireStdLib::code;

		String SpireStdLib::GetCode()
		{
			if (code.Length() > 0)
				return code;
			StringBuilder sb;
			// generate operator overloads
			Operator floatUnaryOps[] = { Operator::Neg, Operator::Not, Operator::PreInc, Operator::PreDec };
			Operator intUnaryOps[] = { Operator::Neg, Operator::Not, Operator::BitNot, Operator::PreInc, Operator::PreDec};
			Operator floatOps[] = { Operator::Mul, Operator::Div,
				Operator::Add, Operator::Sub, Operator::And, Operator::Or,
				Operator::Eql, Operator::Neq, Operator::Greater, Operator::Less, Operator::Geq, Operator::Leq };
			Operator intOps[] = {  Operator::Mul, Operator::Div, Operator::Mod,
				Operator::Add, Operator::Sub,
				Operator::Lsh, Operator::Rsh,
				Operator::Eql, Operator::Neq, Operator::Greater, Operator::Less, Operator::Geq, Operator::Leq,
				Operator::BitAnd, Operator::BitXor, Operator::BitOr,
				Operator::And,
				Operator::Or };
			String floatTypes[] = { L"float", L"vec2", L"vec3", L"vec4" };
			String intTypes[] = { L"int", L"ivec2", L"ivec3", L"ivec4" };
			String uintTypes[] = { L"uint", L"uvec2", L"uvec3", L"uvec4" };

			sb << L"__intrinsic vec3 operator * (vec3, mat3);\n";
			sb << L"__intrinsic vec3 operator * (mat3, vec3);\n";

			sb << L"__intrinsic vec4 operator * (vec4, mat4);\n";
			sb << L"__intrinsic vec4 operator * (mat4, vec4);\n";

			sb << L"__intrinsic mat3 operator * (mat3, mat3);\n";
			sb << L"__intrinsic mat4 operator * (mat4, mat4);\n";

			sb << L"__intrinsic bool operator && (bool, bool);\n";
			sb << L"__intrinsic bool operator || (bool, bool);\n";

			for (auto type : intTypes)
			{
				sb << L"__intrinsic bool operator && (bool, " << type << L");\n";
				sb << L"__intrinsic bool operator || (bool, " << type << L");\n";
				sb << L"__intrinsic bool operator && (" << type << ", bool);\n";
				sb << L"__intrinsic bool operator || (" << type << ", bool);\n";
			}

			for (auto op : intUnaryOps)
			{
				String opName = GetOperatorFunctionName(op);
				for (int i = 0; i < 4; i++)
				{
					auto itype = intTypes[i];
					auto utype = uintTypes[i];
					for (int j = 0; j < 2; j++)
					{
						auto retType = (op == Operator::Not) ? L"bool" : j == 0 ? itype : utype;
						sb << L"__intrinsic " << retType << L" operator " << opName << L"(" << (j == 0 ? itype : utype) << L");\n";
					}
				}
			}

			for (auto op : floatUnaryOps)
			{
				String opName = GetOperatorFunctionName(op);
				for (int i = 0; i < 4; i++)
				{
					auto type = floatTypes[i];
					auto retType = (op == Operator::Not) ? L"bool" : type;
					sb << L"__intrinsic " << retType << L" operator " << opName << L"(" << type << L");\n";
				}
			}

			for (auto op : floatOps)
			{
				String opName = GetOperatorFunctionName(op);
				for (int i = 0; i < 4; i++)
				{
					auto type = floatTypes[i];
					auto itype = intTypes[i];
					auto utype = uintTypes[i];
					auto retType = ((op >= Operator::Eql && op <= Operator::Leq) || op == Operator::And || op == Operator::Or) ? L"bool" : type;
					sb << L"__intrinsic " << retType << L" operator " << opName << L"(" << type << L", " << type << L");\n";
					sb << L"__intrinsic " << retType << L" operator " << opName << L"(" << itype << L", " << type << L");\n";
					sb << L"__intrinsic " << retType << L" operator " << opName << L"(" << utype << L", " << type << L");\n";
					sb << L"__intrinsic " << retType << L" operator " << opName << L"(" << type << L", " << itype << L");\n";
					sb << L"__intrinsic " << retType << L" operator " << opName << L"(" << type << L", " << utype << L");\n";
					if (i > 0)
					{
						sb << L"__intrinsic " << retType << L" operator " << opName << L"(" << type << L", " << floatTypes[0] << L");\n";
						sb << L"__intrinsic " << retType << L" operator " << opName << L"(" << floatTypes[0] << L", " << type << L");\n";

						sb << L"__intrinsic " << retType << L" operator " << opName << L"(" << type << L", " << intTypes[0] << L");\n";
						sb << L"__intrinsic " << retType << L" operator " << opName << L"(" << intTypes[0] << L", " << type << L");\n";

						sb << L"__intrinsic " << retType << L" operator " << opName << L"(" << type << L", " << uintTypes[0] << L");\n";
						sb << L"__intrinsic " << retType << L" operator " << opName << L"(" << uintTypes[0] << L", " << type << L");\n";
					}
				}
			}

			for (auto op : intOps)
			{
				String opName = GetOperatorFunctionName(op);
				for (int i = 0; i < 4; i++)
				{
					auto type = intTypes[i];
					auto utype = uintTypes[i];
					auto retType = ((op >= Operator::Eql && op <= Operator::Leq) || op == Operator::And || op == Operator::Or) ? L"bool" : type;
					sb << L"__intrinsic " << retType << L" operator " << opName << L"(" << type << L", " << type << L");\n";
					sb << L"__intrinsic " << retType << L" operator " << opName << L"(" << utype << L", " << type << L");\n";
					sb << L"__intrinsic " << retType << L" operator " << opName << L"(" << type << L", " << utype << L");\n";
					sb << L"__intrinsic " << retType << L" operator " << opName << L"(" << utype << L", " << utype << L");\n";
					if (i > 0)
					{
						sb << L"__intrinsic " << retType << L" operator " << opName << L"(" << type << L", " << intTypes[0] << L");\n";
						sb << L"__intrinsic " << retType << L" operator " << opName << L"(" << intTypes[0] << L", " << type << L");\n";

						sb << L"__intrinsic " << retType << L" operator " << opName << L"(" << type << L", " << uintTypes[0] << L");\n";
						sb << L"__intrinsic " << retType << L" operator " << opName << L"(" << uintTypes[0] << L", " << type << L");\n";
					}
				}
			}
			sb << LibIncludeString;
			code = sb.ProduceString();
			return code;
		}

		void SpireStdLib::Finalize()
		{
			code = nullptr;
		}

	}
}


/***********************************************************************
SPIRECORE\SYMBOLTABLE.CPP
***********************************************************************/

namespace Spire
{
	namespace Compiler
	{

		bool SymbolTable::SortShaders()
		{
			HashSet<ShaderSymbol*> shaderSet;
			ShaderDependenceOrder.Clear();
			List<ShaderSymbol *> nextShaders, currentShaders;
			// sort shaders in dependency order
			for (auto & shader : Shaders)
			{
				if (shader.Value->DependentShaders.Count() == 0)
				{
					ShaderDependenceOrder.Add(shader.Value.Ptr());
					shaderSet.Add(shader.Value.Ptr());
				}
				else
					currentShaders.Add(shader.Value.Ptr());
			}
			while (currentShaders.Count())
			{
				nextShaders.Clear();
				for (auto & shader : currentShaders)
				{
					bool pass = true;
					for (auto & dshader : shader->DependentShaders)
						if (!shaderSet.Contains(dshader))
						{
							pass = false;
							break;
						}
					if (pass)
					{
						ShaderDependenceOrder.Add(shader);
						shaderSet.Add(shader);
					}
					else
						nextShaders.Add(shader);
				}
				currentShaders.SwapWith(nextShaders);
			}
			return (ShaderDependenceOrder.Count() == Shaders.Count());
		}
		void SymbolTable::EvalFunctionReferenceClosure()
		{
			for (auto & func : Functions)
			{
				if (!func.Value->IsReferencedFunctionsTransitiveClosureEvaluated)
				{
					List<String> funcList;
					EnumerableHashSet<String> funcSet;
					for (auto & ref : func.Value->ReferencedFunctions)
					{
						funcList.Add(ref);
						funcSet.Add(ref);
					}
					for (int i = 0; i < funcList.Count(); i++)
					{
						RefPtr<FunctionSymbol> funcSym;
						if (Functions.TryGetValue(funcList[i], funcSym))
						{
							if (funcSym->IsReferencedFunctionsTransitiveClosureEvaluated)
							{
								for (auto rfunc : funcSym->ReferencedFunctions)
									funcSet.Add(rfunc);
							}
							else
							{
								for (auto rfunc : funcSym->ReferencedFunctions)
								{
									if (funcSet.Add(rfunc))
										funcList.Add(rfunc);
								}
							}
						}
					}
					func.Value->ReferencedFunctions = _Move(funcSet);
					func.Value->IsReferencedFunctionsTransitiveClosureEvaluated = true;
				}
			}
		}

		List<ImportPath>& PipelineSymbol::GetPaths(String srcWorld, String destWorld)
		{
			if (auto first = pathCache.TryGetValue(srcWorld))
			{
				if (auto second = first->TryGetValue(destWorld))
					return *second;
			}
			else
			{
				pathCache[srcWorld] = EnumerableDictionary<String, List<ImportPath>>();
			}
			auto path = FindPaths(srcWorld, destWorld);
			auto & dict = pathCache[srcWorld]();
			dict[destWorld] = _Move(path);
			return dict[destWorld]();
		}

		List<ImportPath> PipelineSymbol::FindPaths(String worldSrc, String worldDest)
		{
			List<ImportPath> resultPaths;
			if (worldSrc == worldDest)
				return resultPaths;
			List<ImportPath> paths, paths2;
			paths.Add(ImportPath());
			paths[0].Nodes.Add(ImportPath::Node(worldSrc, nullptr));
			while (paths.Count())
			{
				paths2.Clear();
				for (auto & p : paths)
				{
					String world0 = p.Nodes.Last().TargetWorld;
					for (auto op : SyntaxNode->ImportOperators)
					{
						if (op->SourceWorld.Content == world0)
						{
							ImportPath np = p;
							if (op->Parameters.Count() != 0)
								np.IsImplicitPath = false;
							for (auto &req : op->Requirements)
								np.TypeRequirements.Add(req.Ptr());
							np.Nodes.Add(ImportPath::Node(op->DestWorld.Content, op.Ptr()));
							if (op->DestWorld.Content == worldDest)
								resultPaths.Add(np);
							else
								paths2.Add(np);
						}
					}
				}
				paths.SwapWith(paths2);
			}
			return resultPaths;
		}

		bool PipelineSymbol::IsAbstractWorld(String world)
		{
			WorldSymbol ws;
			if (Worlds.TryGetValue(world, ws))
				return ws.IsAbstract;
			return false;
		}

		bool PipelineSymbol::IsChildOf(PipelineSymbol * parentPipeline)
		{
			if (this == parentPipeline)
				return true;
			else if (ParentPipeline)
				return ParentPipeline->IsChildOf(parentPipeline);
			else
				return false;
		}

		List<String>& PipelineSymbol::GetWorldTopologyOrder()
		{
			if (WorldTopologyOrder.Count() != 0)
				return WorldTopologyOrder;
			List<String> rs;
			HashSet<String> rsSet;
			bool changed = true;
			while (changed)
			{
				changed = false;
				for (auto & w : WorldDependency)
				{
					if (!rsSet.Contains(w.Key))
					{
						bool canAdd = true;
						for (auto & dw : w.Value)
							if (!rsSet.Contains(dw))
							{
								canAdd = false;
								break;
							}
						if (canAdd)
						{
							rsSet.Add(w.Key);
							rs.Add(w.Key);
							changed = true;
						}
					}
				}
			}
			WorldTopologyOrder = _Move(rs);
			return WorldTopologyOrder;
		}
		
		List<ImportOperatorDefSyntaxNode*> PipelineSymbol::GetImportOperatorsFromSourceWorld(String worldSrc)
		{
			List<ImportOperatorDefSyntaxNode*> rs;
			auto dict = ImportOperatorsByPath.TryGetValue(worldSrc);
			if (dict)
			{
				for (auto & op : *dict)
				{
					for (auto & x : op.Value)
						rs.Add(x.Ptr());
				}
			}
			return rs;
		}
		void PipelineSymbol::AddImportOperator(RefPtr<ImportOperatorDefSyntaxNode> op)
		{
			auto list = ImportOperators.TryGetValue(op->Name.Content);
			if (!list)
			{
				ImportOperators[op->Name.Content] = List<RefPtr<ImportOperatorDefSyntaxNode>>();
				list = ImportOperators.TryGetValue(op->Name.Content);
			}
			list->Add(op);

			auto first = ImportOperatorsByPath.TryGetValue(op->SourceWorld.Content);
			if (!first)
			{
				ImportOperatorsByPath[op->SourceWorld.Content] = EnumerableDictionary<String, List<RefPtr<ImportOperatorDefSyntaxNode>>>();
				first = ImportOperatorsByPath.TryGetValue(op->SourceWorld.Content);
			}

			auto second = first->TryGetValue(op->DestWorld.Content);
			if (!second)
			{
				(*first)[op->DestWorld.Content] = List<RefPtr<ImportOperatorDefSyntaxNode>>();
				second = first->TryGetValue(op->DestWorld.Content);
			}
			second->Add(op);
		}

		List<ShaderComponentSymbol*> ShaderSymbol::GetComponentDependencyOrder()
		{
			List<ShaderComponentSymbol*> components;

			for (auto & comp : Components)
			{
				components.Add(comp.Value.Ptr());
			}
			SortComponents(components);
			return components;
		}
		void ShaderSymbol::SortComponents(List<ShaderComponentSymbol*>& comps)
		{
			comps.Sort([&](ShaderComponentSymbol*c0, ShaderComponentSymbol*c1)
			{
				return c0->Implementations.First()->SyntaxNode->Position < c1->Implementations.First()->SyntaxNode->Position;
			});
			HashSet<ShaderComponentSymbol*> allSymbols, addedSymbols;
			for (auto & comp : comps)
				allSymbols.Add(comp);
			List<ShaderComponentSymbol*> sorted;
			bool changed = true;
			while (changed)
			{
				changed = false;
				for (auto & comp : comps)
				{
					if (!addedSymbols.Contains(comp))
					{
						bool isFirst = true;
						for (auto & impl : comp->Implementations)
							for (auto & dep : impl->DependentComponents)
								if (allSymbols.Contains(dep.Key) && !addedSymbols.Contains(dep.Key))
								{
									isFirst = false;
									goto loopEnd;
								}
					loopEnd:;
						if (isFirst)
						{
							addedSymbols.Add(comp);
							sorted.Add(comp);
							changed = true;
						}
					}
				}
			}
			comps = _Move(sorted);
		}

		ShaderSymbol::ComponentReference ShaderSymbol::ResolveComponentReference(String compName, bool topLevel)
		{
			ComponentReference result;
			result.IsAccessible = true;
			RefPtr<ShaderComponentSymbol> refComp, privateRefComp;
			if (Components.TryGetValue(compName, refComp))
			{
				result.Component = refComp.Ptr();
				return result;
			}
			for (auto & shaderUsing : ShaderUsings)
			{
				if (shaderUsing.Shader->Components.TryGetValue(compName, refComp))
				{
					if (refComp->Implementations.First()->SyntaxNode->IsPublic)
					{
						result.Component = refComp.Ptr();
						result.IsAccessible = true;
						return result;
					}
					else
					{
						result.Component = refComp.Ptr();
						result.IsAccessible = false;
					}
				}
				else if (shaderUsing.IsPublic || topLevel)
				{
					auto rresult = shaderUsing.Shader->ResolveComponentReference(compName, false);
					if (rresult.IsAccessible)
						return rresult;
					else
						result = rresult;
				}
			}
			if (Pipeline && Pipeline->Components.TryGetValue(compName, refComp))
			{
				if (!refComp->IsParam())
				{
					result.Component = refComp.Ptr();
					return result;
				}
			}
			result.IsAccessible = false;
			return result;
		}

		bool SymbolTable::CheckComponentImplementationConsistency(ErrorWriter * err, ShaderComponentSymbol * comp, ShaderComponentImplSymbol * impl)
		{
			bool rs = true;
			if (impl->SyntaxNode->Rate)
			{
				for (auto & cimpl : comp->Implementations)
				{
					for (auto & w : cimpl->Worlds)
						if (impl->Worlds.Contains(w) && impl->AlternateName == cimpl->AlternateName)
						{
							err->Error(33020, L"\'" + comp->Name + L"\' is already defined at '" + w + L"\'.", impl->SyntaxNode->Position);
							rs = false;
						}
				}
			}
			else
			{
				for (auto & cimpl : comp->Implementations)
				{
					if (cimpl->Worlds.Count() == 0 && impl->Worlds.Count() == 0 && impl->AlternateName == cimpl->AlternateName)
					{
						err->Error(33020, L"\'" + comp->Name + L"\' is already defined.", impl->SyntaxNode->Position);
						rs = false;
					}
				}
			}
			for (auto & cimpl : comp->Implementations)
			{
				if (impl->SyntaxNode->IsOutput != cimpl->SyntaxNode->IsOutput)
				{
					err->Error(33021, L"\'" + comp->Name + L"\': inconsistent signature.\nsee previous definition at " + cimpl->SyntaxNode->Position.ToString(), impl->SyntaxNode->Position);
					rs = false;
					break;
				}
				if (impl->SyntaxNode->IsParam != cimpl->SyntaxNode->IsParam)
				{
					err->Error(33021, L"\'" + comp->Name + L"\': inconsistent signature.\nsee previous definition at " + cimpl->SyntaxNode->Position.ToString(), impl->SyntaxNode->Position);
					rs = false;
					break;
				}
				if (impl->SyntaxNode->IsPublic != cimpl->SyntaxNode->IsPublic)
				{
					err->Error(33021, L"\'" + comp->Name + L"\': inconsistent signature.\nsee previous definition at " + cimpl->SyntaxNode->Position.ToString(), impl->SyntaxNode->Position);
					rs = false;
					break;
				}
				if (!impl->SyntaxNode->Type->Equals(cimpl->SyntaxNode->Type.Ptr()))
				{
					err->Error(33021, L"\'" + comp->Name + L"\': inconsistent signature.\nsee previous definition at " + cimpl->SyntaxNode->Position.ToString(), impl->SyntaxNode->Position);
					rs = false;
					break;
				}
			}
			if (impl->SyntaxNode->IsParam && comp->Implementations.Count() != 0)
			{
				err->Error(33022, L"\'" + comp->Name + L"\': parameter name conflicts with existing definition.", impl->SyntaxNode->Position);
				rs = false;
			}
			return rs;
		}

		String PrintType(RefPtr<ExpressionType> type, String recordReplaceStr)
		{
			if (auto basic = type->AsBasicType())
			{
				if (basic->BaseType == BaseType::Record)
					return recordReplaceStr;
				else
					return basic->ToString();
			}
			else if (auto arr = type.As<ArrayExpressionType>())
			{
				if (arr->ArrayLength > 0)
					return PrintType(arr->BaseType, recordReplaceStr) + L"[" + arr->ArrayLength + L"]";
				else
					return PrintType(arr->BaseType, recordReplaceStr) + L"[]";
			}
			else if (auto gen = type.As<GenericExpressionType>())
			{
				return gen->GenericTypeName + L"<" + PrintType(gen->BaseType, recordReplaceStr) + L">";
			}
			return L"";
		}

		bool SymbolTable::CheckTypeRequirement(const ImportPath & p, RefPtr<ExpressionType> type)
		{
			for (auto & req : p.TypeRequirements)
			{
				auto typeStr = type->ToString();
				auto retType = PrintType(req->ReturnType, typeStr);
				StringBuilder sbInternalName;
				sbInternalName << req->Name;
				for (auto & op : req->Parameters)
				{
					sbInternalName << L"@" << PrintType(op->Type, typeStr);
				}
				auto funcName = sbInternalName.ProduceString();
				auto func = Functions.TryGetValue(funcName);
				if (!func)
					return false;
				if ((*func)->SyntaxNode->ReturnType->ToString() != retType)
					return false;
			}
			return true;
		}

		bool SymbolTable::IsWorldReachable(PipelineSymbol * pipe, String src, String targetWorld, RefPtr<ExpressionType> type)
		{
			if (src == targetWorld)
				return true;
			return From(pipe->GetPaths(src, targetWorld)).Any([&](const ImportPath & p)
			{
				return CheckTypeRequirement(p, type);
			});
		}

		bool SymbolTable::IsWorldImplicitlyReachable(PipelineSymbol * pipe, String src, String targetWorld, RefPtr<ExpressionType> type)
		{
			if (src == targetWorld)
				return true;
			return From(pipe->GetPaths(src, targetWorld)).Any([&](const ImportPath & p)
			{
				return p.IsImplicitPath && CheckTypeRequirement(p, type);
			});
		}

		bool SymbolTable::IsWorldImplicitlyReachable(PipelineSymbol * pipe, EnumerableHashSet<String>& src, String targetWorld, RefPtr<ExpressionType> type)
		{
			for (auto srcW : src)
			{
				if (IsWorldImplicitlyReachable(pipe, srcW, targetWorld, type))
					return true;
			}
			return false;
		}

		bool SymbolTable::IsWorldReachable(PipelineSymbol * pipe, EnumerableHashSet<String>& src, String targetWorld, RefPtr<ExpressionType> type)
		{
			for (auto srcW : src)
			{
				if (IsWorldReachable(pipe, srcW, targetWorld, type))
					return true;
			}
			return false;
		}

		List<ImportPath> SymbolTable::FindImplicitImportOperatorChain(PipelineSymbol * pipe, String worldSrc, String worldDest, RefPtr<ExpressionType> type)
		{
			return From(pipe->GetPaths(worldSrc, worldDest)).Where([&](const ImportPath & p)
			{
				if (p.IsImplicitPath)
					return CheckTypeRequirement(p, type);
				return false;
			}).ToList();
		}

		int UniqueIdGenerator::currentGUID = 0;
		void UniqueIdGenerator::Clear()
		{
			currentGUID = 0;
		}
		int UniqueIdGenerator::Next()
		{
			return currentGUID++;
		}
		RefPtr<ShaderComponentSymbol> ShaderClosure::FindComponent(String name, bool findInPrivate, bool includeParams)
		{
			RefPtr<ShaderComponentSymbol> rs;
			if (RefMap.TryGetValue(name, rs))
			{
				if (includeParams || !rs->IsParam())
					return rs;
				else
					return nullptr;
			}
			if (Components.TryGetValue(name, rs))
			{
				if (includeParams || !rs->IsParam())
					return rs;
				else
					return nullptr;
			}
			for (auto & subClosure : SubClosures)
			{
				if (subClosure.Value->IsInPlace)
				{
					rs = subClosure.Value->FindComponent(name, findInPrivate, includeParams);
					if (rs && (findInPrivate || rs->Implementations.First()->SyntaxNode->IsPublic))
						return rs;
					else
						rs = nullptr;
				}
			}
			ShaderClosure * root = this;
			while (root->Parent != nullptr)
				root = root->Parent;
			if (root != this)
			{
				// find global components in root (pipeline-defined components)
				if (root->Components.TryGetValue(name, rs))
					return rs;
			}
			return rs;
		}
		RefPtr<ShaderClosure> ShaderClosure::FindClosure(String name)
		{
			RefPtr<ShaderClosure> rs;
			if (SubClosures.TryGetValue(name, rs))
				return rs;
			for (auto & subClosure : SubClosures)
			{
				if (subClosure.Value->IsInPlace)
				{
					rs = subClosure.Value->FindClosure(name);
					if (rs && rs->IsPublic)
						return rs;
					else
						rs = nullptr;
				}
			}
			return rs;
		}
		List<ShaderComponentSymbol*> ShaderClosure::GetDependencyOrder()
		{
			List<ShaderComponentSymbol*> comps;
			for (auto & comp : AllComponents)
				comps.Add(comp.Value);
			comps.Sort([&](ShaderComponentSymbol*c0, ShaderComponentSymbol*c1)
			{
				return c0->Implementations.First()->SyntaxNode->Position < c1->Implementations.First()->SyntaxNode->Position;
			});
			HashSet<ShaderComponentSymbol*> allSymbols, addedSymbols;
			for (auto & comp : comps)
				allSymbols.Add(comp);
			List<ShaderComponentSymbol*> sorted;
			bool changed = true;
			while (changed)
			{
				changed = false;
				for (auto & comp : comps)
				{
					if (!addedSymbols.Contains(comp))
					{
						bool isFirst = true;
						for (auto & impl : comp->Implementations)
							for (auto & dep : impl->DependentComponents)
								if (allSymbols.Contains(dep.Key) && !addedSymbols.Contains(dep.Key))
								{
									isFirst = false;
									goto loopEnd;
								}
					loopEnd:;
						if (isFirst)
						{
							addedSymbols.Add(comp);
							sorted.Add(comp);
							changed = true;
						}
					}
				}
			}
			return sorted;
		}
	}
}

/***********************************************************************
SPIRECORE\SYNTAX.CPP
***********************************************************************/

namespace Spire
{
	namespace Compiler
	{
		bool Scope::FindVariable(const String & name, VariableEntry & variable)
		{
			if (Variables.TryGetValue(name, variable))
				return true;
			if (Parent)
				return Parent->FindVariable(name, variable);
			return false;
		}

		bool BasicExpressionType::Equals(const ExpressionType * type) const
		{
			auto basicType = dynamic_cast<const BasicExpressionType*>(type);
			if (basicType == nullptr)
				return false;
			return (basicType->BaseType == BaseType &&
				basicType->Func == Func &&
				basicType->Shader == Shader &&
				basicType->Struct == Struct);
		}

		bool BasicExpressionType::IsVectorType() const
		{
			return IsVector(BaseType);
		}

		bool BasicExpressionType::IsArray() const
		{
			return false;
		}

		CoreLib::Basic::String BasicExpressionType::ToString() const
		{
			CoreLib::Basic::StringBuilder res;

			switch (BaseType)
			{
			case Compiler::BaseType::Int:
				res.Append(L"int");
				break;
			case Compiler::BaseType::UInt:
				res.Append(L"uint");
				break;
			case Compiler::BaseType::Bool:
				res.Append(L"bool");
				break;
			case Compiler::BaseType::Float:
				res.Append(L"float");
				break;
			case Compiler::BaseType::Int2:
				res.Append(L"ivec2");
				break;
			case Compiler::BaseType::UInt2:
				res.Append(L"uvec2");
				break;
			case Compiler::BaseType::Float2:
				res.Append(L"vec2");
				break;
			case Compiler::BaseType::Int3:
				res.Append(L"ivec3");
				break;
			case Compiler::BaseType::UInt3:
				res.Append(L"uvec3");
				break;
			case Compiler::BaseType::Float3:
				res.Append(L"vec3");
				break;
			case Compiler::BaseType::Int4:
				res.Append(L"ivec4");
				break;
			case Compiler::BaseType::UInt4:
				res.Append(L"uvec4");
				break;
			case Compiler::BaseType::Float4:
				res.Append(L"vec4");
				break;
			case Compiler::BaseType::Float3x3:
				res.Append(L"mat3");
				break;
			case Compiler::BaseType::Float4x4:
				res.Append(L"mat4");
				break;
			case Compiler::BaseType::Texture2D:
				res.Append(L"sampler2D");
				break;
			case Compiler::BaseType::TextureCube:
				res.Append(L"samplerCube");
				break;
			case Compiler::BaseType::TextureShadow:
				res.Append(L"samplerShadow");
				break;
			case Compiler::BaseType::TextureCubeShadow:
				res.Append(L"samplerCubeShadow");
				break;
			case Compiler::BaseType::Function:
				res.Append(Func->SyntaxNode->InternalName);
				break;
			case Compiler::BaseType::Shader:
				res.Append(Shader->SyntaxNode->Name.Content);
				break;
			case Compiler::BaseType::Void:
				res.Append("void");
				break;
			case Compiler::BaseType::Record:
				res.Append(RecordTypeName);
				break;
			case Compiler::BaseType::Error:
				res.Append(L"<errtype>");
				break;
			default:
				break;
			}
			return res.ToString();
		}

		ExpressionType * BasicExpressionType::Clone()
		{
			BasicExpressionType * rs = new BasicExpressionType(*this);
			return rs;
		}


		RefPtr<SyntaxNode> ProgramSyntaxNode::Accept(SyntaxVisitor * visitor)
		{
			return visitor->VisitProgram(this);
		}
		ProgramSyntaxNode * ProgramSyntaxNode::Clone(CloneContext & ctx)
		{
			auto rs = CloneSyntaxNodeFields(new ProgramSyntaxNode(*this), ctx);
			rs->Structs.Clear();
			for (auto & x : Structs)
				rs->Structs.Add(x->Clone(ctx));
			rs->Functions.Clear();
			for (auto & x : Functions)
				rs->Functions.Add(x->Clone(ctx));
			rs->Pipelines.Clear();
			for (auto & x : Pipelines)
				rs->Pipelines.Add(x->Clone(ctx));
			rs->Shaders.Clear();
			for (auto & x : Shaders)
				rs->Shaders.Add(x->Clone(ctx));
			return rs;
		}
		RefPtr<SyntaxNode> FunctionSyntaxNode::Accept(SyntaxVisitor * visitor)
		{
			return visitor->VisitFunction(this);
		}
		FunctionSyntaxNode * FunctionSyntaxNode::Clone(CloneContext & ctx)
		{
			auto rs = CloneSyntaxNodeFields(new FunctionSyntaxNode(*this), ctx);
			rs->Parameters.Clear();
			for (auto & param : Parameters)
			{
				rs->Parameters.Add(param->Clone(ctx));
			}
			rs->ReturnTypeNode = ReturnTypeNode->Clone(ctx);
			rs->Body = Body->Clone(ctx);
			return rs;
		}
		RefPtr<SyntaxNode> BlockStatementSyntaxNode::Accept(SyntaxVisitor * visitor)
		{
			return visitor->VisitBlockStatement(this);
		}
		BlockStatementSyntaxNode * BlockStatementSyntaxNode::Clone(CloneContext & ctx)
		{
			auto rs = CloneSyntaxNodeFields(new BlockStatementSyntaxNode(*this), ctx);
			rs->Statements.Clear();
			for (auto & stmt : Statements)
			{
				rs->Statements.Add(stmt->Clone(ctx));
			}
			return rs;
		}
		RefPtr<SyntaxNode> BreakStatementSyntaxNode::Accept(SyntaxVisitor * visitor)
		{
			return visitor->VisitBreakStatement(this);
		}
		BreakStatementSyntaxNode * BreakStatementSyntaxNode::Clone(CloneContext & ctx)
		{
			return CloneSyntaxNodeFields(new BreakStatementSyntaxNode(*this), ctx);
		}
		RefPtr<SyntaxNode> ContinueStatementSyntaxNode::Accept(SyntaxVisitor * visitor)
		{
			return visitor->VisitContinueStatement(this);
		}
		ContinueStatementSyntaxNode * ContinueStatementSyntaxNode::Clone(CloneContext & ctx)
		{
			return CloneSyntaxNodeFields(new ContinueStatementSyntaxNode(*this), ctx);
		}
		RefPtr<SyntaxNode> DoWhileStatementSyntaxNode::Accept(SyntaxVisitor * visitor)
		{
			return visitor->VisitDoWhileStatement(this);
		}
		DoWhileStatementSyntaxNode * DoWhileStatementSyntaxNode::Clone(CloneContext & ctx)
		{
			auto rs = CloneSyntaxNodeFields(new DoWhileStatementSyntaxNode(*this), ctx);
			if (Predicate)
				rs->Predicate = Predicate->Clone(ctx);
			if (Statement)
				rs->Statement = Statement->Clone(ctx);
			return rs;
		}
		RefPtr<SyntaxNode> EmptyStatementSyntaxNode::Accept(SyntaxVisitor * visitor)
		{
			return visitor->VisitEmptyStatement(this);
		}
		EmptyStatementSyntaxNode * EmptyStatementSyntaxNode::Clone(CloneContext & ctx)
		{
			return CloneSyntaxNodeFields(new EmptyStatementSyntaxNode(*this), ctx);
		}
		RefPtr<SyntaxNode> ForStatementSyntaxNode::Accept(SyntaxVisitor * visitor)
		{
			return visitor->VisitForStatement(this);
		}
		ForStatementSyntaxNode * ForStatementSyntaxNode::Clone(CloneContext & ctx)
		{
			auto rs = CloneSyntaxNodeFields(new ForStatementSyntaxNode(*this), ctx);
			if (InitialExpression)
				rs->InitialExpression = InitialExpression->Clone(ctx);
			if (SideEffectExpression)
				rs->SideEffectExpression = SideEffectExpression->Clone(ctx);
			if (PredicateExpression)
				rs->PredicateExpression = PredicateExpression->Clone(ctx);
			if (Statement)
				rs->Statement = Statement->Clone(ctx);
			if (rs->TypeDef)
				rs->TypeDef = TypeDef->Clone(ctx);
			return rs;
		}
		RefPtr<SyntaxNode> IfStatementSyntaxNode::Accept(SyntaxVisitor * visitor)
		{
			return visitor->VisitIfStatement(this);
		}
		IfStatementSyntaxNode * IfStatementSyntaxNode::Clone(CloneContext & ctx)
		{
			auto rs = CloneSyntaxNodeFields(new IfStatementSyntaxNode(*this), ctx);
			if (Predicate)
				rs->Predicate = Predicate->Clone(ctx);
			if (PositiveStatement)
				rs->PositiveStatement = PositiveStatement->Clone(ctx);
			if (NegativeStatement)
				rs->NegativeStatement = NegativeStatement->Clone(ctx);
			return rs;
		}
		RefPtr<SyntaxNode> ReturnStatementSyntaxNode::Accept(SyntaxVisitor * visitor)
		{
			return visitor->VisitReturnStatement(this);
		}
		ReturnStatementSyntaxNode * ReturnStatementSyntaxNode::Clone(CloneContext & ctx)
		{
			auto rs = CloneSyntaxNodeFields(new ReturnStatementSyntaxNode(*this), ctx);
			if (Expression)
				rs->Expression = Expression->Clone(ctx);
			return rs;
		}
		RefPtr<SyntaxNode> VarDeclrStatementSyntaxNode::Accept(SyntaxVisitor * visitor)
		{
			return visitor->VisitVarDeclrStatement(this);
		}
		VarDeclrStatementSyntaxNode * VarDeclrStatementSyntaxNode::Clone(CloneContext & ctx)
		{
			auto rs = CloneSyntaxNodeFields(new VarDeclrStatementSyntaxNode(*this), ctx);
			rs->TypeNode = TypeNode->Clone(ctx);
			rs->Variables.Clear();
			for (auto & var : Variables)
				rs->Variables.Add(var->Clone(ctx));
			return rs;
		}
		RefPtr<SyntaxNode> Variable::Accept(SyntaxVisitor * visitor)
		{
			return visitor->VisitDeclrVariable(this);
		}
		Variable * Variable::Clone(CloneContext & ctx)
		{
			auto rs = CloneSyntaxNodeFields(new Variable(*this), ctx);
			if (Expression)
				rs->Expression = Expression->Clone(ctx);
			return rs;
		}
		RefPtr<SyntaxNode> WhileStatementSyntaxNode::Accept(SyntaxVisitor * visitor)
		{
			return visitor->VisitWhileStatement(this);
		}
		WhileStatementSyntaxNode * WhileStatementSyntaxNode::Clone(CloneContext & ctx)
		{
			auto rs = CloneSyntaxNodeFields(new WhileStatementSyntaxNode(*this), ctx);
			if (Predicate)
				rs->Predicate = Predicate->Clone(ctx);
			if (Statement)
				rs->Statement = Statement->Clone(ctx);
			return rs;
		}
		RefPtr<SyntaxNode> ExpressionStatementSyntaxNode::Accept(SyntaxVisitor * visitor)
		{
			return visitor->VisitExpressionStatement(this);
		}
		ExpressionStatementSyntaxNode * ExpressionStatementSyntaxNode::Clone(CloneContext & ctx)
		{
			auto rs = CloneSyntaxNodeFields(new ExpressionStatementSyntaxNode(*this), ctx);
			if (Expression)
				rs->Expression = Expression->Clone(ctx);
			return rs;
		}
		RefPtr<SyntaxNode> BinaryExpressionSyntaxNode::Accept(SyntaxVisitor * visitor)
		{
			return visitor->VisitBinaryExpression(this);
		}
		BinaryExpressionSyntaxNode * BinaryExpressionSyntaxNode::Clone(CloneContext & ctx)
		{
			auto rs = CloneSyntaxNodeFields(new BinaryExpressionSyntaxNode(*this), ctx);
			rs->LeftExpression = LeftExpression->Clone(ctx);
			rs->RightExpression = RightExpression->Clone(ctx);
			return rs;
		}
		RefPtr<SyntaxNode> ConstantExpressionSyntaxNode::Accept(SyntaxVisitor * visitor)
		{
			return visitor->VisitConstantExpression(this);
		}
		ConstantExpressionSyntaxNode * ConstantExpressionSyntaxNode::Clone(CloneContext & ctx)
		{
			return CloneSyntaxNodeFields(new ConstantExpressionSyntaxNode(*this), ctx);
		}
		IndexExpressionSyntaxNode * IndexExpressionSyntaxNode::Clone(CloneContext & ctx)
		{
			auto rs = CloneSyntaxNodeFields(new IndexExpressionSyntaxNode(*this), ctx);
			rs->BaseExpression = BaseExpression->Clone(ctx);
			rs->IndexExpression = IndexExpression->Clone(ctx);
			return rs;
		}
		RefPtr<SyntaxNode> IndexExpressionSyntaxNode::Accept(SyntaxVisitor * visitor)
		{
			return visitor->VisitIndexExpression(this);
		}
		RefPtr<SyntaxNode> MemberExpressionSyntaxNode::Accept(SyntaxVisitor * visitor)
		{
			return visitor->VisitMemberExpression(this);
		}
		MemberExpressionSyntaxNode * MemberExpressionSyntaxNode::Clone(CloneContext & ctx)
		{
			auto rs = CloneSyntaxNodeFields(new MemberExpressionSyntaxNode(*this), ctx);
			rs->BaseExpression = BaseExpression->Clone(ctx);
			return rs;
		}
		RefPtr<SyntaxNode> InvokeExpressionSyntaxNode::Accept(SyntaxVisitor * visitor)
		{
			return visitor->VisitInvokeExpression(this);
		}
		InvokeExpressionSyntaxNode * InvokeExpressionSyntaxNode::Clone(CloneContext & ctx)
		{
			auto rs = CloneSyntaxNodeFields(new InvokeExpressionSyntaxNode(*this), ctx);
			rs->FunctionExpr = FunctionExpr->Clone(ctx);
			rs->Arguments.Clear();
			for (auto & arg : Arguments)
			{
				rs->Arguments.Add(arg->Clone(ctx));
			}
			return rs;
		}
		RefPtr<SyntaxNode> TypeCastExpressionSyntaxNode::Accept(SyntaxVisitor * visitor)
		{
			return visitor->VisitTypeCastExpression(this);
		}
		TypeCastExpressionSyntaxNode * TypeCastExpressionSyntaxNode::Clone(CloneContext & ctx)
		{
			auto rs = CloneSyntaxNodeFields(new TypeCastExpressionSyntaxNode(*this), ctx);
			rs->TargetType = TargetType->Clone(ctx);
			rs->Expression = Expression->Clone(ctx);
			return rs;
		}
		RefPtr<SyntaxNode> SelectExpressionSyntaxNode::Accept(SyntaxVisitor * visitor)
		{
			return visitor->VisitSelectExpression(this);
		}
		SelectExpressionSyntaxNode * SelectExpressionSyntaxNode::Clone(CloneContext & ctx)
		{
			auto rs = CloneSyntaxNodeFields(new SelectExpressionSyntaxNode(*this), ctx);
			rs->SelectorExpr = SelectorExpr->Clone(ctx);
			rs->Expr0 = Expr0->Clone(ctx);
			rs->Expr1 = Expr1->Clone(ctx);
			return rs;
		}
		RefPtr<SyntaxNode> UnaryExpressionSyntaxNode::Accept(SyntaxVisitor * visitor)
		{
			return visitor->VisitUnaryExpression(this);
		}
		UnaryExpressionSyntaxNode * UnaryExpressionSyntaxNode::Clone(CloneContext & ctx)
		{
			auto rs = CloneSyntaxNodeFields(new UnaryExpressionSyntaxNode(*this), ctx);
			rs->Expression = Expression->Clone(ctx);
			return rs;
		}
		RefPtr<SyntaxNode> VarExpressionSyntaxNode::Accept(SyntaxVisitor * visitor)
		{
			return visitor->VisitVarExpression(this);
		}
		VarExpressionSyntaxNode * VarExpressionSyntaxNode::Clone(CloneContext & ctx)
		{
			return CloneSyntaxNodeFields(new VarExpressionSyntaxNode(*this), ctx);
		}
		RefPtr<SyntaxNode> ParameterSyntaxNode::Accept(SyntaxVisitor * visitor)
		{
			return visitor->VisitParameter(this);
		}
		ParameterSyntaxNode * ParameterSyntaxNode::Clone(CloneContext & ctx)
		{
			auto rs = CloneSyntaxNodeFields(new ParameterSyntaxNode(*this), ctx);
			rs->TypeNode = TypeNode->Clone(ctx);
			rs->Expr = Expr->Clone(ctx);
			return rs;
		}
		RefPtr<SyntaxNode> BasicTypeSyntaxNode::Accept(SyntaxVisitor * visitor)
		{
			return visitor->VisitBasicType(this);
		}
		RefPtr<TypeSyntaxNode> TypeSyntaxNode::FromExpressionType(ExpressionType * type)
		{
			if (auto basicType = dynamic_cast<BasicExpressionType*>(type))
			{
				RefPtr<BasicTypeSyntaxNode> rs = new BasicTypeSyntaxNode();
				auto & t = *basicType;
				if (basicType->BaseType == BaseType::Int)
					rs->TypeName = L"int";
				else if (t.BaseType == BaseType::Float)
					rs->TypeName = L"float";
				else if (t.BaseType == BaseType::Bool)
					rs->TypeName = L"bool";
				else if (t.BaseType == BaseType::Int2)
					rs->TypeName = L"ivec2";
				else if (t.BaseType == BaseType::Int3)
					rs->TypeName = L"ivec3";
				else if (t.BaseType == BaseType::Int4)
					rs->TypeName = L"ivec4";
				else if (t.BaseType == BaseType::UInt)
					rs->TypeName = L"uint";
				else if (t.BaseType == BaseType::UInt2)
					rs->TypeName = L"uint2";
				else if (t.BaseType == BaseType::UInt3)
					rs->TypeName = L"uint3";
				else if (t.BaseType == BaseType::UInt4)
					rs->TypeName = L"uint4";
				else if (t.BaseType == BaseType::Float2)
					rs->TypeName = L"vec2";
				else if (t.BaseType == BaseType::Float3)
					rs->TypeName = L"vec3";
				else if (t.BaseType == BaseType::Float4)
					rs->TypeName = L"vec4";
				else if (t.BaseType == BaseType::Float3x3)
					rs->TypeName = L"mat3";
				else if (t.BaseType == BaseType::Float4x4)
					rs->TypeName = L"mat4";
				else if (t.BaseType == BaseType::Texture2D)
					rs->TypeName = L"sampler2D";
				else if (t.BaseType == BaseType::TextureCube)
					rs->TypeName = L"samplerCube";
				else if (t.BaseType == BaseType::TextureShadow)
					rs->TypeName = L"samplerShadow";
				else if (t.BaseType == BaseType::TextureCubeShadow)
					rs->TypeName = L"samplerCubeShadow";
				return rs;
			}
			else if (auto arrayType = dynamic_cast<ArrayExpressionType*>(type))
			{
				RefPtr<ArrayTypeSyntaxNode> rs = new ArrayTypeSyntaxNode();
				rs->ArrayLength = arrayType->ArrayLength;
				rs->BaseType = FromExpressionType(arrayType->BaseType.Ptr());
				return rs;
			}
			throw NotImplementedException();
		}
		RefPtr<SyntaxNode> ComponentSyntaxNode::Accept(SyntaxVisitor * visitor)
		{
			return visitor->VisitComponent(this);
		}
		ComponentSyntaxNode * ComponentSyntaxNode::Clone(CloneContext & ctx)
		{
			auto rs = CloneSyntaxNodeFields(new ComponentSyntaxNode(*this), ctx);
			rs->TypeNode = TypeNode->Clone(ctx);
			if (Rate)
				rs->Rate = Rate->Clone(ctx);
			if (BlockStatement)
				rs->BlockStatement = BlockStatement->Clone(ctx);
			if (Expression)
				rs->Expression = Expression->Clone(ctx);
			return rs;
		}
		RefPtr<SyntaxNode> ShaderSyntaxNode::Accept(SyntaxVisitor * visitor)
		{
			return visitor->VisitShader(this);
		}
		ShaderSyntaxNode * ShaderSyntaxNode::Clone(CloneContext & ctx)
		{
			auto rs = CloneSyntaxNodeFields(new ShaderSyntaxNode(*this), ctx);
			rs->Members.Clear();
			for (auto & comp : Members)
				rs->Members.Add(comp->Clone(ctx));
			return rs;
		}
		RateSyntaxNode * RateSyntaxNode::Clone(CloneContext & ctx)
		{
			return CloneSyntaxNodeFields(new RateSyntaxNode(*this), ctx);
		}
		WorldSyntaxNode * WorldSyntaxNode::Clone(CloneContext & ctx)
		{
			return CloneSyntaxNodeFields(new WorldSyntaxNode(*this), ctx);
		}
		RefPtr<SyntaxNode> ImportOperatorDefSyntaxNode::Accept(SyntaxVisitor * visitor)
		{
			return visitor->VisitImportOperatorDef(this); 
		}
		ImportOperatorDefSyntaxNode * ImportOperatorDefSyntaxNode::Clone(CloneContext & ctx)
		{
			return CloneSyntaxNodeFields(new ImportOperatorDefSyntaxNode(*this), ctx);
		}
		PipelineSyntaxNode * PipelineSyntaxNode::Clone(CloneContext & ctx)
		{
			auto rs = CloneSyntaxNodeFields(new PipelineSyntaxNode(*this), ctx);
			rs->Worlds.Clear();
			for (auto & w : Worlds)
				rs->Worlds.Add(w->Clone(ctx));
			rs->ImportOperators.Clear();
			for (auto & imp : ImportOperators)
				rs->ImportOperators.Add(imp->Clone(ctx));
			rs->AbstractComponents.Clear();
			for (auto & comp : AbstractComponents)
				rs->AbstractComponents.Add(comp->Clone(ctx));
			return rs;
		}
		ChoiceValueSyntaxNode * ChoiceValueSyntaxNode::Clone(CloneContext & ctx)
		{
			return CloneSyntaxNodeFields(new ChoiceValueSyntaxNode(*this), ctx);
		}
		RefPtr<SyntaxNode> ImportSyntaxNode::Accept(SyntaxVisitor * v)
		{
			return v->VisitImport(this);
		}
		ImportSyntaxNode * ImportSyntaxNode::Clone(CloneContext & ctx)
		{
			auto rs = CloneSyntaxNodeFields(new ImportSyntaxNode(*this), ctx);
			rs->Arguments.Clear();
			for (auto & arg : Arguments)
				rs->Arguments.Add(arg->Clone(ctx));
			return rs;
		}
		RefPtr<SyntaxNode> ImportArgumentSyntaxNode::Accept(SyntaxVisitor * visitor)
		{
			return visitor->VisitImportArgument(this);
		}
		ImportArgumentSyntaxNode * ImportArgumentSyntaxNode::Clone(CloneContext & ctx)
		{
			auto rs = CloneSyntaxNodeFields(new ImportArgumentSyntaxNode(*this), ctx);
			rs->Expression = Expression->Clone(ctx);
			return rs;
		}
		RefPtr<SyntaxNode> ImportStatementSyntaxNode::Accept(SyntaxVisitor * visitor)
		{
			return visitor->VisitImportStatement(this);
		}
		ImportStatementSyntaxNode * ImportStatementSyntaxNode::Clone(CloneContext & ctx)
		{
			auto rs = CloneSyntaxNodeFields(new ImportStatementSyntaxNode(*this), ctx);
			rs->Import = Import->Clone(ctx);
			return rs;
		}
		RefPtr<SyntaxNode> StructField::Accept(SyntaxVisitor * visitor)
		{
			return visitor->VisitStructField(this);
		}
		RefPtr<SyntaxNode> StructSyntaxNode::Accept(SyntaxVisitor * visitor)
		{
			return visitor->VisitStruct(this);
		}
		RefPtr<SyntaxNode> DiscardStatementSyntaxNode::Accept(SyntaxVisitor * visitor)
		{
			return visitor->VisitDiscardStatement(this);
		}
		DiscardStatementSyntaxNode * DiscardStatementSyntaxNode::Clone(CloneContext & ctx)
		{
			auto rs = CloneSyntaxNodeFields(new DiscardStatementSyntaxNode(*this), ctx);
			return rs;
		}
		bool BasicExpressionType::IsIntegral() const
		{
			return (BaseType == Compiler::BaseType::Int || BaseType == Compiler::BaseType::UInt || BaseType == Compiler::BaseType::Bool);
		}
		bool ExpressionType::IsTexture() const
		{
			auto basicType = AsBasicType();
			if (basicType)
				return basicType->BaseType == BaseType::Texture2D ||
					basicType->BaseType == BaseType::TextureCube ||
					basicType->BaseType == BaseType::TextureCubeShadow ||
					basicType->BaseType == BaseType::TextureShadow;
			return false;
		}
		bool ExpressionType::IsStruct() const
		{
			auto basicType = AsBasicType();
			if (basicType)
				return basicType->Struct != nullptr;
			return false;
		}
		bool ExpressionType::IsShader() const
		{
			auto basicType = AsBasicType();
			if (basicType)
				return basicType->Shader != nullptr;
			return false;
		}

		RefPtr<ExpressionType> ExpressionType::Bool;
		RefPtr<ExpressionType> ExpressionType::UInt;
		RefPtr<ExpressionType> ExpressionType::UInt2;
		RefPtr<ExpressionType> ExpressionType::UInt3;
		RefPtr<ExpressionType> ExpressionType::UInt4;
		RefPtr<ExpressionType> ExpressionType::Int;
		RefPtr<ExpressionType> ExpressionType::Int2;
		RefPtr<ExpressionType> ExpressionType::Int3;
		RefPtr<ExpressionType> ExpressionType::Int4;
		RefPtr<ExpressionType> ExpressionType::Float;
		RefPtr<ExpressionType> ExpressionType::Float2;
		RefPtr<ExpressionType> ExpressionType::Float3;
		RefPtr<ExpressionType> ExpressionType::Float4;
		RefPtr<ExpressionType> ExpressionType::Void;
		RefPtr<ExpressionType> ExpressionType::Error;

		void ExpressionType::Init()
		{
			Bool = new BasicExpressionType(BaseType::Bool);
			UInt = new BasicExpressionType(BaseType::UInt);
			UInt2 = new BasicExpressionType(BaseType::UInt2);
			UInt3 = new BasicExpressionType(BaseType::UInt3);
			UInt4 = new BasicExpressionType(BaseType::UInt4);
			Int = new BasicExpressionType(BaseType::Int);
			Int2 = new BasicExpressionType(BaseType::Int2);
			Int3 = new BasicExpressionType(BaseType::Int3);
			Int4 = new BasicExpressionType(BaseType::Int4);
			Float = new BasicExpressionType(BaseType::Float);
			Float2 = new BasicExpressionType(BaseType::Float2);
			Float3 = new BasicExpressionType(BaseType::Float3);
			Float4 = new BasicExpressionType(BaseType::Float4);
			Void = new BasicExpressionType(BaseType::Void);
			Error = new BasicExpressionType(BaseType::Error);
		}
		void ExpressionType::Finalize()
		{
			Bool = nullptr;
			UInt = nullptr;
			UInt2 = nullptr;
			UInt3 = nullptr;
			UInt4 = nullptr;
			Int = nullptr;
			Int2 = nullptr;
			Int3 = nullptr;
			Int4 = nullptr;
			Float = nullptr;
			Float2 = nullptr;
			Float3 = nullptr;
			Float4 = nullptr;
			Void = nullptr;
			Error = nullptr;
		}
		bool ArrayExpressionType::IsIntegral() const
		{
			return false;
		}
		bool ArrayExpressionType::IsArray() const
		{
			return true;
		}
		bool ArrayExpressionType::Equals(const ExpressionType * type) const
		{
			auto arrType = dynamic_cast<const ArrayExpressionType*>(type);
			if (!arrType)
				return false;
			return (ArrayLength == arrType->ArrayLength && BaseType->Equals(arrType->BaseType.Ptr()));
		}
		bool ArrayExpressionType::IsVectorType() const
		{
			return false;
		}
		CoreLib::Basic::String ArrayExpressionType::ToString() const
		{
			if (ArrayLength > 0)
				return BaseType->ToString() + L"[" + String(ArrayLength) + L"]";
			else
				return BaseType->ToString() + L"[]";
		}
		ExpressionType * ArrayExpressionType::Clone()
		{
			auto rs = new ArrayExpressionType(*this);
			rs->BaseType = BaseType->Clone();
			return rs;
		}
		RefPtr<SyntaxNode> ArrayTypeSyntaxNode::Accept(SyntaxVisitor * visitor)
		{
			return visitor->VisitArrayType(this);
		}
		RefPtr<SyntaxNode> GenericTypeSyntaxNode::Accept(SyntaxVisitor * visitor)
		{
			return visitor->VisitGenericType(this);
		}
		bool GenericExpressionType::IsIntegral() const
		{
			return false;
		}
		bool GenericExpressionType::IsArray() const
		{
			return false;
		}
		bool GenericExpressionType::Equals(const ExpressionType * type) const
		{
			if (auto gtype = dynamic_cast<const GenericExpressionType*>(type))
				return GenericTypeName == gtype->GenericTypeName && gtype->BaseType->Equals(BaseType.Ptr());
			
			return false;
		}
		bool GenericExpressionType::IsVectorType() const
		{
			return false;
		}
		CoreLib::Basic::String GenericExpressionType::ToString() const
		{
			return GenericTypeName + L"<" + BaseType->ToString() + L">";
		}
		ExpressionType * GenericExpressionType::Clone()
		{
			auto rs = new GenericExpressionType(*this);
			rs->BaseType = BaseType->Clone();
			return rs;
		}
		RefPtr<SyntaxNode> ImportExpressionSyntaxNode::Accept(SyntaxVisitor * visitor)
		{
			return visitor->VisitImportExpression(this);
		}
		ImportExpressionSyntaxNode * ImportExpressionSyntaxNode::Clone(CloneContext & ctx)
		{
			ImportExpressionSyntaxNode * result = new ImportExpressionSyntaxNode(*this);
			CloneSyntaxNodeFields(result, ctx);
			result->Component = Component->Clone(ctx);
			result->Arguments.Clear();
			for (auto & arg : Arguments)
				result->Arguments.Add(arg->Clone(ctx));
			return result;
		}
		StageSyntaxNode * StageSyntaxNode::Clone(CloneContext &)
		{
			return new StageSyntaxNode(*this);
		}
		RefPtr<ComponentSyntaxNode> SyntaxVisitor::VisitComponent(ComponentSyntaxNode * comp)
		{
			if (comp->TypeNode)
				comp->TypeNode = comp->TypeNode->Accept(this).As<TypeSyntaxNode>();
			if (comp->Expression)
				comp->Expression = comp->Expression->Accept(this).As<ExpressionSyntaxNode>();
			if (comp->BlockStatement)
				comp->BlockStatement = comp->BlockStatement->Accept(this).As<BlockStatementSyntaxNode>();
			return comp;
		}
		String GetOperatorFunctionName(Operator op)
		{
			switch (op)
			{
			case Operator::Add:
			case Operator::AddAssign:
				return L"+";
			case Operator::Sub:
			case Operator::SubAssign:
				return L"-";
			case Operator::Neg:
				return L"-";
			case Operator::Not:
				return L"!";
			case Operator::BitNot:
				return L"~";
			case Operator::PreInc:
			case Operator::PostInc:
				return L"++";
			case Operator::PreDec:
			case Operator::PostDec:
				return L"--";
			case Operator::Mul:
			case Operator::MulAssign:
				return L"*";
			case Operator::Div:
			case Operator::DivAssign:
				return L"/";
			case Operator::Mod:
			case Operator::ModAssign:
				return L"%";
			case Operator::Lsh:
			case Operator::LshAssign:
				return L"<<";
			case Operator::Rsh:
			case Operator::RshAssign:
				return L">>";
			case Operator::Eql:
				return L"==";
			case Operator::Neq:
				return L"!=";
			case Operator::Greater:
				return L">";
			case Operator::Less:
				return L"<";
			case Operator::Geq:
				return L">=";
			case Operator::Leq:
				return L"<=";
			case Operator::BitAnd:
			case Operator::AndAssign:
				return L"&";
			case Operator::BitXor:
			case Operator::XorAssign:
				return L"^";
			case Operator::BitOr:
			case Operator::OrAssign:
				return L"|";
			case Operator::And:
				return L"&&";
			case Operator::Or:
				return L"||";
			default:
				return L"";
			}
		}
	}
}

/***********************************************************************
SPIRECORE\TYPETRANSLATION.CPP
***********************************************************************/

namespace Spire
{
	namespace Compiler
	{
		RefPtr<ILType> TranslateExpressionType(ExpressionType * type, Dictionary<String, RefPtr<ILRecordType>> * recordTypes)
		{
			RefPtr<ILType> resultType = 0;
			if (auto basicType = type->AsBasicType())
			{
				if (basicType->BaseType == BaseType::Struct)
				{
					resultType = basicType->Struct->Type;
				}
				else if (basicType->BaseType == BaseType::Record)
				{
					if (recordTypes)
						return (*recordTypes)[basicType->RecordTypeName]();
					else
						throw InvalidProgramException(L"unexpected record type.");
				}
				else
				{
					auto base = new ILBasicType();
					base->Type = (ILBaseType)basicType->BaseType;
					resultType = base;
				}
			}
			else if (auto arrType = type->AsArrayType())
			{
				auto nArrType = new ILArrayType();
				nArrType->BaseType = TranslateExpressionType(arrType->BaseType.Ptr(), recordTypes);
				nArrType->ArrayLength = arrType->ArrayLength;
				resultType = nArrType;
			}
			else if (auto genType = type->AsGenericType())
			{
				auto gType = new ILGenericType();
				gType->GenericTypeName = genType->GenericTypeName;
				gType->BaseType = TranslateExpressionType(genType->BaseType.Ptr(), recordTypes);
				resultType = gType;
			}
			return resultType;
		}

		RefPtr<ILType> TranslateExpressionType(const RefPtr<ExpressionType> & type, Dictionary<String, RefPtr<ILRecordType>> * recordTypes)
		{
			return TranslateExpressionType(type.Ptr(), recordTypes);
		}
	}
}

/***********************************************************************
SPIRECORE\VARIANTIR.CPP
***********************************************************************/

namespace Spire
{
	namespace Compiler
	{
		class ComponentDependency
		{
		public:
			String ReferencedComponent;
			ImportOperatorDefSyntaxNode * ImportOperator = nullptr;
			ComponentDependency() = default;
			ComponentDependency(String compName, ImportOperatorDefSyntaxNode * impOp)
				: ReferencedComponent(compName), ImportOperator(impOp)
			{}
			int GetHashCode()
			{
				return ReferencedComponent.GetHashCode() ^ (int)(CoreLib::PtrInt)(void*)(ImportOperator);
			}
			bool operator == (const ComponentDependency & other)
			{
				return ReferencedComponent == other.ReferencedComponent && ImportOperator == other.ImportOperator;
			}
		};
		class GetDependencyVisitor : public SyntaxVisitor
		{
		public:
			EnumerableHashSet<ComponentDependency> Result;
			GetDependencyVisitor()
				: SyntaxVisitor(nullptr)
			{}

			RefPtr<ExpressionSyntaxNode> VisitVarExpression(VarExpressionSyntaxNode * var) override
			{
				RefPtr<Object> refCompObj;
				if (var->Tags.TryGetValue(L"ComponentReference", refCompObj))
				{
					auto refComp = refCompObj.As<StringObject>().Ptr();
					Result.Add(ComponentDependency(refComp->Content, nullptr));
				}
				return var;
			}

			RefPtr<ExpressionSyntaxNode> VisitMemberExpression(MemberExpressionSyntaxNode * member) override
			{
				RefPtr<Object> refCompObj;
				if (member->Tags.TryGetValue(L"ComponentReference", refCompObj))
				{
					auto refComp = refCompObj.As<StringObject>().Ptr();
					Result.Add(ComponentDependency(refComp->Content, nullptr));
				}
				else
					member->BaseExpression->Accept(this);
				return member;
			}

			RefPtr<ExpressionSyntaxNode> VisitImportExpression(ImportExpressionSyntaxNode * syntax) override
			{
				for (auto & comp : syntax->ImportOperatorDef->Usings)
					Result.Add(ComponentDependency(comp, nullptr));
				Result.Add(ComponentDependency(syntax->ComponentUniqueName, syntax->ImportOperatorDef.Ptr()));
				return SyntaxVisitor::VisitImportExpression(syntax);
			}
		};

		EnumerableHashSet<ComponentDependency> GetDependentComponents(SyntaxNode * tree)
		{
			GetDependencyVisitor visitor;
			tree->Accept(&visitor);
			return visitor.Result;
		}

		void ShaderIR::EliminateDeadCode()
		{
			// mark entry points
			auto MarkUsing = [&](String compName, String userWorld)
			{
				if (auto defs = DefinitionsByComponent.TryGetValue(compName))
				{
					if (auto def = defs->TryGetValue(userWorld))
						(*def)->IsEntryPoint = true;
					else
					{
						for (auto & world : Shader->Pipeline->WorldDependency[userWorld]())
						{
							if (auto def2 = defs->TryGetValue(world))
							{
								(*def2)->IsEntryPoint = true;
								break;
							}
						}
					}
				}
			};
			for (auto & impOp : Shader->Pipeline->SyntaxNode->ImportOperators)
				for (auto & ref : impOp->Usings)
					MarkUsing(ref, impOp->DestWorld.Content);
			for (auto & req : Shader->Pipeline->Components)
				if (req.Value->IsParam())
				{
					for (auto & impl : req.Value->Implementations)
					{
						if (impl->Worlds.Count())
						{
							for (auto & world : impl->Worlds)
								MarkUsing(req.Key, world);
						}
						else
						{
							for (auto & world : Shader->Pipeline->Worlds)
								MarkUsing(req.Key, world.Key);
						}
					}
				}
			List<ComponentDefinitionIR*> workList;
			HashSet<ComponentDefinitionIR*> referencedDefs;
			for (auto & def : Definitions)
			{
				if (def->IsEntryPoint)
				{
					if (referencedDefs.Add(def.Ptr()))
						workList.Add(def.Ptr());
				}
			}
			for (int i = 0; i < workList.Count(); i++)
			{
				auto def = workList[i];
				for (auto & dep : def->Dependency)
				{
					if (referencedDefs.Add(dep))
						workList.Add(dep);
				}
			}
			List<RefPtr<ComponentDefinitionIR>> newDefinitions;
			for (auto & def : Definitions)
			{
				if (referencedDefs.Contains(def.Ptr()))
				{
					newDefinitions.Add(def);
					EnumerableHashSet<ComponentDefinitionIR*> newSet;
					for (auto & comp : def->Users)
						if (referencedDefs.Contains(comp))
						{
							newSet.Add(comp);
						}
					def->Users = newSet;
					newSet.Clear();
					for (auto & comp : def->Dependency)
						if (referencedDefs.Contains(comp))
						{
							newSet.Add(comp);
						}
					def->Dependency = newSet;
				}
			}
			Definitions = _Move(newDefinitions);
			for (auto & kv : DefinitionsByComponent)
			{
				for (auto & def : kv.Value)
					if (!referencedDefs.Contains(def.Value))
						kv.Value.Remove(def.Key);
			}
		}

		class ReferenceWorkItem
		{
		public:
			ComponentDependency Dependency;
			String SourceWorld;
			int GetHashCode()
			{
				return Dependency.GetHashCode();
			}
			bool operator == (const ReferenceWorkItem & other)
			{
				return Dependency == other.Dependency && SourceWorld == other.SourceWorld;
			}
		};

		void ShaderIR::ResolveComponentReference()
		{
			// build bidirectional dependency map of component definitions
			for (auto & comp : Definitions)
			{
				comp->Dependency.Clear();
				comp->Users.Clear();
			}
			for (auto & comp : Definitions)
			{
				List<ReferenceWorkItem> workList;
				for (auto & dep : GetDependentComponents(comp->SyntaxNode.Ptr()))
				{
					ReferenceWorkItem item;
					item.Dependency = dep;
					item.SourceWorld = dep.ImportOperator ? dep.ImportOperator->SourceWorld.Content : comp->World;
					workList.Add(item);
				}
				HashSet<ReferenceWorkItem> proceseedDefCompss;
				for (int i = 0; i < workList.Count(); i++)
				{
					auto dep = workList[i];
					if (!proceseedDefCompss.Add(dep))
						continue;
					auto & depDefs = DefinitionsByComponent[dep.Dependency.ReferencedComponent]();
					// select the best overload according to import operator ordering,
					// prefer user-pinned definitions (as provided in the choice file)
					List<String> depWorlds;
					depWorlds.Add(dep.SourceWorld);
					for (auto & w : Shader->Pipeline->WorldDependency[dep.SourceWorld]())
						depWorlds.Add(w);
					for (int pass = 0; pass < 2; pass++)
					{
						// in the first pass, examine the pinned definitions only
						// in the second pass, examine all the rest definitions
						for (auto & depWorld : depWorlds)
						{
							auto refComp = Shader->AllComponents[dep.Dependency.ReferencedComponent]();
							bool isPinned = refComp->Type->PinnedWorlds.Contains(depWorld);
							if ((pass == 0 && !isPinned) || (pass == 1 && isPinned)) continue;
							ComponentDefinitionIR * depDef;
							if (depDefs.TryGetValue(depWorld, depDef))
							{
								comp->Dependency.Add(depDef);
								depDef->Users.Add(comp.Ptr());
								// add additional dependencies due to import operators
								auto processImportOperatorUsings = [&](ImportOperatorDefSyntaxNode * importOp)
								{
									for (auto & importUsing : importOp->Usings)
									{
										ShaderComponentSymbol* refComp;
										if (!Shader->AllComponents.TryGetValue(importUsing, refComp))
											throw InvalidProgramException(L"import operator dependency not exists.");
										ReferenceWorkItem workItem;
										workItem.Dependency = ComponentDependency(refComp->UniqueName, nullptr);
										workItem.SourceWorld = importOp->SourceWorld.Content;
										workList.Add(workItem);
									}
								};
								if (dep.Dependency.ImportOperator)
								{
									processImportOperatorUsings(dep.Dependency.ImportOperator);
								}
								if (depWorld != dep.SourceWorld)
								{
									auto importPath = SymbolTable->FindImplicitImportOperatorChain(Shader->Pipeline, depWorld, dep.SourceWorld, refComp->Type->DataType);
									if (importPath.Count() == 0)
										continue;
									processImportOperatorUsings(importPath.First().Nodes.Last().ImportOperator);
								}
								goto selectionEnd; // first preferred overload is found, terminate searching
							}
						}
					}
				selectionEnd:;
				}
			}
		}
		List<String> ShaderIR::GetComponentDependencyOrder()
		{
			List<String> result, workList;
			HashSet<String> set;
			for (auto & comp : DefinitionsByComponent)
			{
				bool emptyDependency = true;
				for (auto & def : comp.Value)
					if (def.Value->Dependency.Count())
					{
						emptyDependency = false;
						break;
					}
				if (emptyDependency)
				{
					workList.Add(comp.Key);
				}
			}
			for (int i = 0; i < workList.Count(); i++)
			{
				auto comp = workList[i];
				if (!set.Contains(comp))
				{
					bool insertable = true;
					for (auto & def : DefinitionsByComponent[comp]())
					{
						for (auto & dep : def.Value->Dependency)
							if (!set.Contains(dep->UniqueName))
							{
								insertable = false;
								goto breakLoc;
							}
					}
				breakLoc:;
					if (insertable)
					{
						if (set.Add(comp))
						{
							result.Add(comp);
							for (auto & def : DefinitionsByComponent[comp]())
								for (auto & user : def.Value->Users)
									workList.Add(user->UniqueName);
						}
					}
				}
			}
			return result;
		}
		EnumerableHashSet<ComponentDefinitionIR*>& ComponentDefinitionIR::GetComponentFunctionDependencyClosure()
		{
			if (dependencyClosure.Count() || Dependency.Count() == 0)
				return dependencyClosure;
			for (auto & dep : Dependency)
			{
				dependencyClosure.Add(dep);
				if (dep->SyntaxNode->Parameters.Count())
				{
					for (auto & x : dep->GetComponentFunctionDependencyClosure())
						dependencyClosure.Add(x);
				}
			}
			return dependencyClosure;
		}
}
}

/***********************************************************************
SPIRELIB\SPIRELIB.CPP
***********************************************************************/

using namespace CoreLib::Basic;
using namespace CoreLib::IO;
using namespace CoreLib::Text;
using namespace Spire::Compiler;

namespace SpireLib
{
	void ReadSource(EnumerableDictionary<String, StageSource> & sources, CoreLib::Text::Parser & parser, String src)
	{
		auto getShaderSource = [&]()
		{
			auto token = parser.ReadToken();
			int endPos = token.Position + 1;
			int brace = 0;
			while (endPos < src.Length() && !(src[endPos] == L'}' && brace == 0))
			{
				if (src[endPos] == L'{')
					brace++;
				else if (src[endPos] == L'}')
					brace--;
				endPos++;
			}
			while (!parser.IsEnd() && parser.NextToken().Position != endPos)
				parser.ReadToken();
			parser.ReadToken();
			return src.SubString(token.Position + 1, endPos - token.Position - 1);
		};
		while (!parser.IsEnd() && !parser.LookAhead(L"}"))
		{
			auto worldName = parser.ReadWord();
			StageSource compiledSrc;
			if (parser.LookAhead(L"binary"))
			{
				parser.ReadToken();
				parser.Read(L"{");
				while (!parser.LookAhead(L"}") && !parser.IsEnd())
				{
					auto val = parser.ReadUInt();
					compiledSrc.BinaryCode.AddRange((unsigned char*)&val, sizeof(unsigned int));
					if (parser.LookAhead(L","))
						parser.ReadToken();
				}
				parser.Read(L"}");
			}
			if (parser.LookAhead(L"text"))
			{
				parser.ReadToken();
				compiledSrc.MainCode = getShaderSource();
			}
			sources[worldName] = compiledSrc;
		}
	}
	StageSource ShaderLib::GetStageSource(String stage)
	{
		StageSource rs;
		Sources.TryGetValue(stage, rs);
		return rs;
	}
	ShaderLib::ShaderLib(CoreLib::Basic::String fileName)
	{
		Reload(fileName);
	}
	void ShaderLib::Reload(CoreLib::Basic::String fileName)
	{
		Load(fileName);
	}
	bool ShaderLib::CompileFrom(String symbolName, String sourceFileName, String schedule)
	{
		Spire::Compiler::CompileResult result;
		CompileOptions options;
		options.ScheduleSource = schedule;
		options.SymbolToCompile = symbolName;
		options.Mode = CompilerMode::ProduceShader;
		auto shaderLibs = CompileShaderSourceFromFile(result, sourceFileName, options);
		if (result.Success)
		{
			for (auto & lib : shaderLibs)
			{
				if (lib.MetaData.ShaderName == symbolName)
				{
					FromString(shaderLibs[0].ToString());
					return true;
				}
			}
		}
		result.PrintError(true);
		return false;
	}

	List<ShaderLibFile> CompileUnits(Spire::Compiler::CompileResult & compileResult,
		ShaderCompiler * compiler, List<CompileUnit> & units,
		Spire::Compiler::CompileOptions & options)
	{
		List<ShaderLibFile> resultFiles;
		compiler->Compile(compileResult, units, options);
		if (compileResult.Success)
		{
			if (options.Mode == CompilerMode::ProduceShader)
			{
				EnumerableDictionary<String, ShaderLibFile> shaderLibs;
				for (auto file : compileResult.CompiledSource)
				{
					ShaderLibFile libFile;
					libFile.MetaData = file.Value.MetaData;
					libFile.Sources = file.Value.Stages;
					resultFiles.Add(libFile);
				}
			}
		}
		return resultFiles;
	}

	List<ShaderLibFile> CompileShaderSource(Spire::Compiler::CompileResult & compileResult,
		const CoreLib::String & src, const CoreLib::String & fileName, Spire::Compiler::CompileOptions & options)
	{
		Spire::Compiler::NamingCounter = 0;
		RefPtr<ShaderCompiler> compiler = CreateShaderCompiler();
		List<CompileUnit> units;
		HashSet<String> processedUnits;
		List<String> unitsToInclude;
		unitsToInclude.Add(fileName);
		processedUnits.Add(fileName);
		auto searchDirs = options.SearchDirectories;
		searchDirs.Add(Path::GetDirectoryName(fileName));
		searchDirs.Reverse();
		auto predefUnit = compiler->Parse(compileResult, SpireStdLib::GetCode(), L"stdlib");
		for (int i = 0; i < unitsToInclude.Count(); i++)
		{
			auto inputFileName = unitsToInclude[i];
			try
			{
				String source = src;
				if (i > 0)
					source = File::ReadAllText(inputFileName);
				auto unit = compiler->Parse(compileResult, source, inputFileName);
				units.Add(unit);
				if (unit.SyntaxNode)
				{
					for (auto inc : unit.SyntaxNode->Usings)
					{
						bool found = false;
						for (auto & dir : searchDirs)
						{
							String includeFile = Path::Combine(dir, inc.Content);
							if (File::Exists(includeFile))
							{
								if (processedUnits.Add(includeFile))
								{
									unitsToInclude.Add(includeFile);
								}
								found = true;
								break;
							}
						}
						if (!found)
						{
							compileResult.GetErrorWriter()->Error(2, L"cannot find file '" + inputFileName + L"'.", inc.Position);
						}
					}
				}
			}
			catch (IOException)
			{
				compileResult.GetErrorWriter()->Error(1, L"cannot open file '" + inputFileName + L"'.", CodePosition(0, 0, L""));
			}
		}
		units.Add(predefUnit);
		if (compileResult.ErrorList.Count() == 0)
			return CompileUnits(compileResult, compiler.Ptr(), units, options);
		else
			return List<ShaderLibFile>();
	}                                                                                             

	List<ShaderLibFile> CompileShaderSourceFromFile(Spire::Compiler::CompileResult & compileResult,
		const CoreLib::Basic::String & sourceFileName,
		Spire::Compiler::CompileOptions & options)
	{
		try
		{
			return CompileShaderSource(compileResult, File::ReadAllText(sourceFileName), sourceFileName, options);
		}
		catch (IOException)
		{
			compileResult.GetErrorWriter()->Error(1, L"cannot open file '" + Path::GetFileName(sourceFileName) + L"'.", CodePosition(0, 0, L""));
		}
		return List<ShaderLibFile>();
	}
	void ShaderLibFile::AddSource(CoreLib::Basic::String source, CoreLib::Text::Parser & parser)
	{
		ReadSource(Sources, parser, source);
	}

	CoreLib::String ShaderLibFile::ToString()
	{
		StringBuilder writer;
		writer << L"name " << MetaData.ShaderName << EndLine;
		for (auto & stage : MetaData.Stages)
		{
			writer << L"stage " << stage.Key << EndLine << L"{" << EndLine;
			writer << L"target " << stage.Value.TargetName << EndLine;
			for (auto & blk : stage.Value.InputBlocks)
			{
				writer << L"in " << blk << L";\n";
			}
			writer << L"out " << stage.Value.OutputBlock << L";\n";
			for (auto & comp : stage.Value.Components)
				writer << L"comp " << comp << L";\n";
			writer << L"}" << EndLine;
		}
		for (auto & ublock : MetaData.InterfaceBlocks)
		{
			writer << L"interface " << ublock.Key << L" size " << ublock.Value.Size << L"\n{\n";
			for (auto & entry : ublock.Value.Entries)
			{
				writer << entry.Type->ToString() << L" " << entry.Name << L" : " << entry.Offset << L"," << entry.Size;
				if (entry.Attributes.Count())
				{
					writer << L"\n{\n";
					for (auto & attrib : entry.Attributes)
					{
						writer << attrib.Key << L" : " << CoreLib::Text::Parser::EscapeStringLiteral(attrib.Value) << L";\n";
					}
					writer << L"}";
				}
				writer << L";\n";
			}
			writer << L"}\n";
		}
		writer << L"source" << EndLine << L"{" << EndLine;
		for (auto & src : Sources)
		{
			writer << src.Key << EndLine;
			if (src.Value.BinaryCode.Count())
			{
				writer << L"binary" << EndLine << L"{" << EndLine;
				auto binaryBuffer = (unsigned int*)src.Value.BinaryCode.Buffer();
				for (int i = 0; i < src.Value.BinaryCode.Count() / 4; i++)
				{
					writer << String((long long)binaryBuffer[i]) << L",";
					if ((i + 1) % 10)
						writer << EndLine;
				}
				writer << EndLine << L"}" << EndLine;
			}
			writer << L"text" << EndLine << L"{" << EndLine;
			writer << src.Value.MainCode << EndLine;

			writer << L"}" << EndLine;
		}
		writer << L"}" << EndLine;
		StringBuilder formatSB;
		IndentString(formatSB, writer.ProduceString());
		return formatSB.ProduceString();
	}

	void ShaderLibFile::Clear()
	{
		Sources.Clear();
		MetaData.Stages.Clear();
		Sources.Clear();
	}

	void ShaderLibFile::SaveToFile(CoreLib::Basic::String fileName)
	{
		StreamWriter fwriter(fileName);
		fwriter.Write(ToString());
	}

	void ShaderLibFile::FromString(const String & src)
	{
		Clear();
		CoreLib::Text::Parser parser(src);
		while (!parser.IsEnd())
		{
			auto fieldName = parser.ReadWord();
			if (fieldName == L"name")
			{
				MetaData.ShaderName = parser.ReadWord();
			}
			else if (fieldName == L"source")
			{
				parser.Read(L"{");
				ReadSource(Sources, parser, src);
				parser.Read(L"}");
			}

			else if (fieldName == L"stage")
			{
				StageMetaData stage;
				stage.Name = parser.ReadWord();
				parser.Read(L"{");
				while (!parser.LookAhead(L"}"))
				{
					auto subFieldName = parser.ReadWord();
					if (subFieldName == L"target")
						stage.TargetName = parser.ReadWord();
					else if (subFieldName == L"in")
					{
						stage.InputBlocks.Add(parser.ReadWord());
						parser.Read(L";");
					}
					else if (subFieldName == L"out")
					{
						stage.OutputBlock = parser.ReadWord();
						parser.Read(L";");
					}
					else if (subFieldName == L"comp")
					{
						auto compName = parser.ReadWord();
						parser.Read(L";");
						stage.Components.Add(compName);
					}
				}
				parser.Read(L"}");
				MetaData.Stages[stage.Name] = stage;
			}
			else if (fieldName == L"interface")
			{
				InterfaceBlockMetaData block;
				if (!parser.LookAhead(L"{") && !parser.LookAhead(L"size"))
					block.Name = parser.ReadWord();
				if (parser.LookAhead(L"size"))
				{
					parser.ReadWord();
					block.Size = parser.ReadInt();
				}
				parser.Read(L"{");
				while (!parser.LookAhead(L"}") && !parser.IsEnd())
				{
					InterfaceBlockEntry entry;
					entry.Type = TypeFromString(parser);
					entry.Name = parser.ReadWord();
					parser.Read(L":");
					entry.Offset = parser.ReadInt();
					parser.Read(L",");
					entry.Size = parser.ReadInt();
					if (parser.LookAhead(L"{"))
					{
						parser.Read(L"{");
						while (!parser.LookAhead(L"}") && !parser.IsEnd())
						{
							auto attribName = parser.ReadWord();
							parser.Read(L":");
							auto attribValue = parser.ReadStringLiteral();
							parser.Read(L";");
							entry.Attributes[attribName] = attribValue;
						}
						parser.Read(L"}");
					}
					parser.Read(L";");
					block.Entries.Add(entry);
				}
				parser.Read(L"}");
				MetaData.InterfaceBlocks[block.Name] = block;
			}
		}
	}

	void ShaderLibFile::Load(String fileName)
	{
		String src = File::ReadAllText(fileName);
		FromString(src);
	}


	class Shader
	{
		friend class CompilationContext;
	private:
		bool isShader = false;
		String targetPipeline, shaderName;
		List<String> usings;
	public:
		Shader(String name, bool pIsShader)
		{
			shaderName = name;
			isShader = pIsShader;
		}
		void TargetPipeline(CoreLib::String pipelineName)
		{
			targetPipeline = pipelineName;
		}
		void UseModule(CoreLib::String moduleName)
		{
			usings.Add(moduleName);
		}
		String GetName() const
		{
			return shaderName;
		}
		String GetSource() const
		{
			StringBuilder codeBuilder;
			codeBuilder << L"shader " << shaderName;
			if (targetPipeline.Length())
				codeBuilder << L":" << targetPipeline;
			codeBuilder << L"\n{\n";
			for (auto & m : usings)
				codeBuilder << L"using " << m << L";\n";
			codeBuilder << L"\n}\n";
			return codeBuilder.ToString();
		}
	};

	class CompileResult
	{
	public:
		bool Success = false;
		CoreLib::List<CompileError> Errors, Warnings;
		CoreLib::EnumerableDictionary<String, CompiledShaderSource> Sources;
	};

	class ComponentMetaData
	{
	public:
		RefPtr<ILType> Type;
		String TypeName;
		String Register;
		String Name;
		int Offset = 0;
		int Alignment = 0;
		int GetHashCode()
		{
			return Name.GetHashCode();
		}
		bool operator == (const ComponentMetaData & other)
		{
			return Name == other.Name;
		}
	};

	class ModuleMetaData
	{
	public:
		String Name;
		EnumerableDictionary<String, List<ComponentMetaData>> ComponentsByWorld;
		EnumerableHashSet<ComponentMetaData> Requirements;
	};
	
	class CompilationContext
	{
	private:
		bool useCache = false;
		CoreLib::String cacheDir;
		List<CompileUnit> moduleUnits;
		RefPtr<Spire::Compiler::CompilationContext> compileContext;
		HashSet<String> processedModuleUnits;
		RefPtr<ShaderCompiler> compiler;
		RefPtr<ProgramSyntaxNode> programToCompile;
		CompileResult compileResult;
		EnumerableDictionary<String, ModuleMetaData> modules;
	public:
		CompileOptions Options;

		CompilationContext(bool /*pUseCache*/, CoreLib::String /*pCacheDir*/)
		{
			compiler = CreateShaderCompiler();
			compileContext = new Spire::Compiler::CompilationContext();
			LoadModuleSource(SpireStdLib::GetCode(), L"stdlib");
		}

		~CompilationContext()
		{
			SpireStdLib::Finalize();
		}

		ModuleMetaData * FindModule(CoreLib::String moduleName)
		{
			return modules.TryGetValue(moduleName);
		}

		void UpdateModuleLibrary(List<CompileUnit> & units)
		{
			Spire::Compiler::CompileResult result;
			compiler->Compile(result, *compileContext, units, Options);
			compileResult.Errors = _Move(result.ErrorList);
			compileResult.Warnings = _Move(result.WarningList);
			compileResult.Success = result.ErrorList.Count() == 0;
			for (auto & shader : compileContext->Symbols.Shaders)
			{
				if (!modules.ContainsKey(shader.Key))
				{
					ModuleMetaData meta;
					meta.Name = shader.Key;
					for (auto & comp : shader.Value->Components)
					{
						ComponentMetaData compMeta;
						compMeta.Name = comp.Key;
						compMeta.Type = TranslateExpressionType(comp.Value->Type->DataType);
						compMeta.TypeName = compMeta.Type->ToString();
						for (auto & impl : comp.Value->Implementations)
						{
							impl->SyntaxNode->LayoutAttributes.TryGetValue(L"Binding", compMeta.Register);
							if (impl->SyntaxNode->IsParam)
							{
								meta.Requirements.Add(compMeta);
							}
							else
							{
								for (auto & world : impl->Worlds)
								{
									auto list = meta.ComponentsByWorld.TryGetValue(world);
									if (!list)
									{
										meta.ComponentsByWorld[world] = List<ComponentMetaData>();
										list = meta.ComponentsByWorld.TryGetValue(world);
									}
									list->Add(compMeta);
								}
							}
						}
					}
					modules.Add(shader.Key, _Move(meta));
				}
			}
		}

		void LoadModuleSource(CoreLib::String src, CoreLib::String fileName)
		{
			List<CompileUnit> units;
			LoadModuleSource(units, processedModuleUnits, compileResult, src, fileName);
			moduleUnits.AddRange(units);
			UpdateModuleLibrary(units);
		}

		void LoadModuleSource(List<CompileUnit> & units, HashSet<String> & processedUnits, CompileResult & cresult, CoreLib::String src, CoreLib::String fileName)
		{
			Spire::Compiler::CompileResult result;
			List<String> unitsToInclude;
			unitsToInclude.Add(fileName);
			processedUnits.Add(fileName);
			auto searchDirs = Options.SearchDirectories;
			searchDirs.Add(Path::GetDirectoryName(fileName));
			searchDirs.Reverse();
			for (int i = 0; i < unitsToInclude.Count(); i++)
			{
				auto inputFileName = unitsToInclude[i];
				try
				{
					String source = src;
					if (i > 0)
						source = File::ReadAllText(inputFileName);
					auto unit = compiler->Parse(result, source, inputFileName);
					units.Add(unit);
					if (unit.SyntaxNode)
					{
						for (auto inc : unit.SyntaxNode->Usings)
						{
							bool found = false;
							for (auto & dir : searchDirs)
							{
								String includeFile = Path::Combine(dir, inc.Content);
								if (File::Exists(includeFile))
								{
									if (processedUnits.Add(includeFile))
									{
										unitsToInclude.Add(includeFile);
									}
									found = true;
									break;
								}
							}
							if (!found)
							{
								result.GetErrorWriter()->Error(2, L"cannot find file '" + inputFileName + L"'.", inc.Position);
							}
						}
					}
				}
				catch (IOException)
				{
					result.GetErrorWriter()->Error(1, L"cannot open file '" + inputFileName + L"'.", CodePosition(0, 0, L""));
				}
			}
			cresult.Errors.AddRange(result.ErrorList);
			cresult.Warnings.AddRange(result.WarningList);
		}
		Shader * NewShader(CoreLib::String name)
		{
			return new Shader(name, true);
		}
		bool Compile(CompileResult & result, const Shader & shader)
		{
			return Compile(result, shader.GetSource(), shader.GetName());
		}
		bool Compile(CompileResult & result, CoreLib::String source, CoreLib::String fileName)
		{
			List<CompileUnit> userUnits;
			HashSet<String> processedUserUnits = processedModuleUnits;
			result = compileResult;
			result.Errors = compileResult.Errors;
			result.Warnings = compileResult.Warnings;
			if (result.Errors.Count() == 0)
			{
				LoadModuleSource(userUnits, processedUserUnits, result, source, fileName);
				if (result.Errors.Count() == 0)
				{
					Spire::Compiler::CompilationContext tmpCtx(*compileContext);
					Spire::Compiler::CompileResult cresult;
					compiler->Compile(cresult, tmpCtx, userUnits, Options);
					result.Sources = cresult.CompiledSource;
					result.Errors = _Move(cresult.ErrorList);
					result.Warnings = _Move(cresult.WarningList);
				}
			}
			result.Success = (result.Errors.Count() == 0);
			return result.Success;
		}
	};
}

using namespace SpireLib;

// implementation of C interface

#define CTX(x) reinterpret_cast<SpireLib::CompilationContext *>(x)
#define SHADER(x) reinterpret_cast<SpireLib::Shader*>(x)
#define RS(x) reinterpret_cast<SpireLib::CompileResult*>(x)
#define MODULE(x) reinterpret_cast<SpireLib::ModuleMetaData*>(x)

SpireCompilationContext * spCreateCompilationContext(const char * cacheDir)
{
	return reinterpret_cast<SpireCompilationContext *>(new SpireLib::CompilationContext((cacheDir?true:false), cacheDir));
}

void spSetCodeGenTarget(SpireCompilationContext * ctx, int target)
{
	CTX(ctx)->Options.Target = (CodeGenTarget)target;
}

void spAddSearchPath(SpireCompilationContext * ctx, const char * searchDir)
{
	CTX(ctx)->Options.SearchDirectories.Add(searchDir);
}

void spSetBackendParameter(SpireCompilationContext * ctx, const char * paramName, const char * value)
{
	CTX(ctx)->Options.BackendArguments[paramName] = value;
}

void spSetShaderToCompile(SpireCompilationContext * ctx, const char * shaderName)
{
	CTX(ctx)->Options.SymbolToCompile = shaderName;
}

void spDestroyCompilationContext(SpireCompilationContext * ctx)
{
	delete CTX(ctx);
}

void spLoadModuleLibrary(SpireCompilationContext * ctx, const char * fileName)
{
	CTX(ctx)->LoadModuleSource(File::ReadAllText(fileName), fileName);
}

void spLoadModuleLibraryFromSource(SpireCompilationContext * ctx, const char * source, const char * fileName)
{
	CTX(ctx)->LoadModuleSource(source, fileName);
}

SpireShader * spCreateShader(SpireCompilationContext * ctx, const char * name)
{
	return reinterpret_cast<SpireShader*>(CTX(ctx)->NewShader(name));
}

void spShaderAddModule(SpireShader * shader, SpireModule * module)
{
	SHADER(shader)->UseModule(MODULE(module)->Name);
}

void spShaderAddModuleByName(SpireShader * shader, const char * moduleName)
{
	SHADER(shader)->UseModule(moduleName);
}

void spShaderSetPipeline(SpireShader * shader, const char * pipelineName)
{
	SHADER(shader)->TargetPipeline(pipelineName);
}

SpireModule * spFindModule(SpireCompilationContext * ctx, const char * moduleName)
{
	return reinterpret_cast<SpireModule*>(CTX(ctx)->FindModule(moduleName));
}

const char * spGetModuleName(SpireModule * module)
{
	if (!module) return nullptr;
	auto moduleNode = MODULE(module);
	return moduleNode->Name.ToMultiByteString();
}

int spComponentInfoCollectionGetComponent(SpireComponentInfoCollection * collection, int index, SpireComponentInfo * result)
{
	auto list = reinterpret_cast<List<ComponentMetaData>*>(collection);
	if (!list)
		return SPIRE_ERROR_INVALID_PARAMETER;
	if (index < 0 || index >= list->Count())
		return SPIRE_ERROR_INVALID_PARAMETER;
	result->Name = (*list)[index].Name.ToMultiByteString();
	result->Alignment = (*list)[index].Alignment;
	result->Offset = (*list)[index].Offset;
	result->Size = (*list)[index].Type->GetSize();
	result->Register = (*list)[index].Register.ToMultiByteString();
	result->TypeName = (*list)[index].TypeName.ToMultiByteString();
	return 0;
}

int spComponentInfoCollectionGetCount(SpireComponentInfoCollection * collection)
{
	auto list = reinterpret_cast<List<ComponentMetaData>*>(collection);
	if (!list)
		return SPIRE_ERROR_INVALID_PARAMETER;
	return list->Count();
}

SpireComponentInfoCollection * spModuleGetComponentsByWorld(SpireModule * module, const char * worldName, int layout)
{
	auto moduleNode = MODULE(module);
	String worldNameStr = worldName;
	Spire::Compiler::LayoutRule layoutRule;
	if (layout == SPIRE_LAYOUT_PACKED)
		layoutRule = LayoutRule::Packed;
	else if (layout == SPIRE_LAYOUT_UNIFORM)
		layoutRule = LayoutRule::Std140;
	else
		layoutRule = LayoutRule::Std430;
	if (auto components = moduleNode->ComponentsByWorld.TryGetValue(worldNameStr))
	{
		// compute layout
		int offset = 0;
		for (auto & comp : *components)
		{
			int alignment = comp.Type->GetAlignment(layoutRule);
			if (layout == SPIRE_LAYOUT_PACKED)
				alignment = 0;
			else if (layout == SPIRE_LAYOUT_UNIFORM)
			{
				if (comp.Type->IsScalar() || comp.Type->IsVector() && comp.Type->GetVectorSize() < 4)
					alignment = 16;
			}
			offset = RoundToAlignment(offset, alignment);
			comp.Offset = offset;
			comp.Alignment = alignment;
			offset += comp.Type->GetSize(layoutRule);
		}
		return reinterpret_cast<SpireComponentInfoCollection*>(components);
	}
	return 0;
}

int spModuleGetRequiredComponents(SpireModule * module, SpireComponentInfo * buffer, int bufferSize)
{
	auto moduleNode = MODULE(module);
	auto & components = moduleNode->Requirements;
	if (!buffer)
		return components.Count();
	if (bufferSize < components.Count())
		return SPIRE_ERROR_INSUFFICIENT_BUFFER;
	int ptr = 0;
	for (auto & comp : components)
	{
		buffer[ptr].Name = comp.Name.ToMultiByteString();
		buffer[ptr].TypeName = comp.TypeName.ToMultiByteString();
		buffer[ptr].Alignment = comp.Type->GetAlignment();
		buffer[ptr].Size = comp.Type->GetSize();
		buffer[ptr].Offset = comp.Offset;
		ptr++;
	}
	return ptr;
}

void spDestroyShader(SpireShader * shader)
{
	delete SHADER(shader);
}

SpireCompilationResult * spCompileShader(SpireCompilationContext * ctx, SpireShader * shader)
{
	SpireLib::CompileResult * rs = new SpireLib::CompileResult();
	CTX(ctx)->Compile(*rs, *SHADER(shader));
	return reinterpret_cast<SpireCompilationResult*>(rs);
}

SpireCompilationResult * spCompileShaderFromSource(SpireCompilationContext * ctx, const char * source, const char * fileName)
{
	SpireLib::CompileResult * rs = new SpireLib::CompileResult();
	CTX(ctx)->Compile(*rs, source, fileName);
	return reinterpret_cast<SpireCompilationResult*>(rs);
}

int spIsCompilationSucessful(SpireCompilationResult * result)
{
	return RS(result)->Success ? 1 : 0;
}

int spGetMessageCount(SpireCompilationResult * result, int messageType)
{
	return messageType == SPIRE_ERROR ? RS(result)->Errors.Count() : RS(result)->Warnings.Count();
}

int spGetMessageContent(SpireCompilationResult * result, int messageType, int index, SpireErrorMessage * pMsg)
{
	auto * list = (messageType == SPIRE_ERROR) ? &(RS(result)->Errors) : (messageType == SPIRE_WARNING) ? &(RS(result)->Warnings) : nullptr;
	if (list)
	{
		if (index >= 0 && index < list->Count())
		{
			auto & msg = (*list)[index];
			pMsg->Message = msg.Message.ToMultiByteString();
			pMsg->ErrorId = msg.ErrorID;
			pMsg->FileName = msg.Position.FileName.ToMultiByteString();
			pMsg->Line = msg.Position.Line;
			pMsg->Col = msg.Position.Col;
			return 1;
		}
	}
	return SPIRE_ERROR_INVALID_PARAMETER;
}

int ReturnStr(const char * content, char * buffer, int bufferSize)
{
	int len = (int)strlen(content);
	if (buffer)
	{
		if (bufferSize >= len + 1)
		{
			memcpy(buffer, content, len + 1);
			return len + 1;
		}
		else
			return SPIRE_ERROR_INSUFFICIENT_BUFFER;
	}
	else
		return len + 1;
}

int spGetCompilerOutput(SpireCompilationResult * result, char * buffer, int bufferSize)
{
	StringBuilder sb;
	auto rs = RS(result);
	for (auto & x : rs->Errors)
		sb << L"error " << x.Message << L":" << x.Position.ToString() << L": " << x.Message << L"\n";
	for (auto & x : rs->Warnings)
		sb << L"error " << x.Message << L":" << x.Position.ToString() << L": " << x.Message << L"\n";
	auto str = sb.ProduceString();
	return ReturnStr(str.ToMultiByteString(), buffer, bufferSize);
}

int spGetCompiledShaderNames(SpireCompilationResult * result, char * buffer, int bufferSize)
{
	StringBuilder sb;
	auto rs = RS(result);
	bool first = true;
	for (auto x : rs->Sources)
	{
		if (!first)
			sb << L"\n";
		sb << x.Key;
		first = false;
	}
	auto str = sb.ProduceString();
	return ReturnStr(str.ToMultiByteString(), buffer, bufferSize);
}

int spGetCompiledShaderStageNames(SpireCompilationResult * result, const char * shaderName, char * buffer, int bufferSize)
{
	auto rs = RS(result);
	if (auto src = rs->Sources.TryGetValue(shaderName))
	{
		StringBuilder sb;
		bool first = true;
		for (auto x : src->Stages)
		{
			if (!first)
				sb << L"\n";
			sb << x.Key;
			first = false;
		}
		auto str = sb.ProduceString();
		return ReturnStr(str.ToMultiByteString(), buffer, bufferSize);
	}
	else
	{
		return SPIRE_ERROR_INVALID_PARAMETER;
	}
}

char * spGetShaderStageSource(SpireCompilationResult * result, const char * shaderName, const char * stage, int * length)
{
	auto rs = RS(result);
	CompiledShaderSource * src = nullptr;
	if (shaderName == nullptr)
	{
		if (rs->Sources.Count())
			src = &rs->Sources.First().Value;
	}
	else
	{
		src = rs->Sources.TryGetValue(shaderName);
	}
	if (src)
	{
		if (auto state = src->Stages.TryGetValue(stage))
		{
			if (state->MainCode.Length())
			{
				if (length)
					*length = (int)strlen(state->MainCode.ToMultiByteString()) + 1;
				return state->MainCode.ToMultiByteString();
			}
			else
			{
				if (length)
					*length = state->BinaryCode.Count();
				return (char*)state->BinaryCode.Buffer();
			}
		}
	}
	return nullptr;
}

void spDestroyCompilationResult(SpireCompilationResult * result)
{
	delete RS(result);
}



/***********************************************************************
CORELIB\LIBIO.CPP
***********************************************************************/
#ifndef SPIRE_NO_CORE_LIB
#ifndef __STDC__
#define __STDC__ 1
#endif
#include <sys/stat.h>
#ifdef _WIN32
#include <direct.h>
#endif
namespace CoreLib
{
	namespace IO
	{
		using namespace CoreLib::Basic;

		CommandLineWriter * currentCommandWriter = nullptr;

		void SetCommandLineWriter(CommandLineWriter * writer)
		{
			currentCommandWriter = writer;
		}

		bool File::Exists(const String & fileName)
		{
			struct _stat32 statVar;
			return ::_stat32(((String)fileName).ToMultiByteString(), &statVar) != -1;
		}

		String Path::TruncateExt(const String & path)
		{
			int dotPos = path.LastIndexOf(L'.');
			if (dotPos != -1)
				return path.SubString(0, dotPos);
			else
				return path;
		}
		String Path::ReplaceExt(const String & path, const wchar_t * newExt)
		{
			StringBuilder sb(path.Length()+10);
			int dotPos = path.LastIndexOf(L'.');
			if (dotPos == -1)
				dotPos = path.Length();
			sb.Append(path.Buffer(), dotPos);
			sb.Append(L'.');
			sb.Append(newExt);
			return sb.ProduceString();
		}
		String Path::GetFileName(const String & path)
		{
			int pos = path.LastIndexOf(L'/');
			pos = Math::Max(path.LastIndexOf(L'\\'), pos) + 1;
			return path.SubString(pos, path.Length()-pos);
		}
		String Path::GetFileNameWithoutEXT(const String & path)
		{
			int pos = path.LastIndexOf(L'/');
			pos = Math::Max(path.LastIndexOf(L'\\'), pos) + 1;
			int dotPos = path.LastIndexOf(L'.');
			if (dotPos <= pos)
				dotPos = path.Length();
			return path.SubString(pos, dotPos - pos);
		}
		String Path::GetFileExt(const String & path)
		{
			int dotPos = path.LastIndexOf(L'.');
			if (dotPos != -1)
				return path.SubString(dotPos+1, path.Length()-dotPos-1);
			else
				return L"";
		}
		String Path::GetDirectoryName(const String & path)
		{
			int pos = path.LastIndexOf(L'/');
			pos = Math::Max(path.LastIndexOf(L'\\'), pos);
			if (pos != -1)
				return path.SubString(0, pos);
			else
				return L"";
		}
		String Path::Combine(const String & path1, const String & path2)
		{
			if (path1.Length() == 0) return path2;
			StringBuilder sb(path1.Length()+path2.Length()+2);
			sb.Append(path1);
			if (!path1.EndsWith(L'\\') && !path1.EndsWith(L'/'))
				sb.Append(PathDelimiter);
			sb.Append(path2);
			return sb.ProduceString();
		}
		String Path::Combine(const String & path1, const String & path2, const String & path3)
		{
			StringBuilder sb(path1.Length()+path2.Length()+path3.Length()+3);
			sb.Append(path1);
			if (!path1.EndsWith(L'\\') && !path1.EndsWith(L'/'))
				sb.Append(PathDelimiter);
			sb.Append(path2);
			if (!path2.EndsWith(L'\\') && !path2.EndsWith(L'/'))
				sb.Append(PathDelimiter);
			sb.Append(path3);
			return sb.ProduceString();
		}
#ifdef CreateDirectory
#undef CreateDirectory
#endif
		bool Path::CreateDirectory(const String & path)
		{
#if defined(_WIN32)
			return _mkdir(path.ToMultiByteString()) == 0;
#else 
			return mkdir(path.ToMultiByteString(), 0777) == 0;
#endif
		}

		CoreLib::Basic::String File::ReadAllText(const CoreLib::Basic::String & fileName)
		{
			StreamReader reader(new FileStream(fileName, FileMode::Open, FileAccess::Read, FileShare::ReadWrite));
			return reader.ReadToEnd();
		}

		void File::WriteAllText(const CoreLib::Basic::String & fileName, const CoreLib::Basic::String & text)
		{
			StreamWriter writer(new FileStream(fileName, FileMode::Create));
			writer.Write(text);
		}
	}
}
#endif

/***********************************************************************
CORELIB\LIBMATH.CPP
***********************************************************************/
#ifndef SPIRE_NO_CORE_LIB

namespace CoreLib
{
	namespace Basic
	{
		const float Math::Pi = 3.141592654f;
	}
}
#endif

/***********************************************************************
CORELIB\LIBSTRING.CPP
***********************************************************************/
#ifndef SPIRE_NO_CORE_LIB

namespace CoreLib
{
	namespace Basic
	{
		_EndLine EndLine;
		String StringConcat(const wchar_t * lhs, int leftLen, const wchar_t * rhs, int rightLen)
		{
			String res;
			res.length = leftLen + rightLen;
			res.buffer = new wchar_t[res.length + 1];
			wcscpy_s(res.buffer.Ptr(), res.length + 1, lhs);
			wcscpy_s(res.buffer + leftLen, res.length + 1 - leftLen, rhs);
			return res;
		}
		String operator+(const wchar_t * op1, const String & op2)
		{
			if(!op2.buffer)
				return String(op1);

			return StringConcat(op1, (int)wcslen(op1), op2.buffer.Ptr(), op2.length);
		}

		String operator+(const String & op1, const wchar_t*op2)
		{
			if(!op1.buffer)
				return String(op2);

			return StringConcat(op1.buffer.Ptr(), op1.length, op2, (int)wcslen(op2));
		}

		String operator+(const String & op1, const String & op2)
		{
			if(!op1.buffer && !op2.buffer)
				return String();
			else if(!op1.buffer)
				return String(op2);
			else if(!op2.buffer)
				return String(op1);

			return StringConcat(op1.buffer.Ptr(), op1.length, op2.buffer.Ptr(), op2.length);
		}

		int StringToInt(const String & str, int radix)
		{
			return (int)wcstol(str.Buffer(), NULL, radix);
			//return (int)_wcstoi64(str.Buffer(), NULL, 10);
		}
		unsigned int StringToUInt(const String & str, int radix)
		{
			return (unsigned int)wcstoul(str.Buffer(), NULL, radix);
		}
		double StringToDouble(const String & str)
		{
			return (double)wcstod(str.Buffer(), NULL);
		}

		String String::ReplaceAll(String src, String dst) const
		{
			String rs = *this;
			int index = 0;
			int srcLen = src.length;
			int len = rs.length;
			while ((index = rs.IndexOf(src, index)) != -1)
			{
				rs = rs.SubString(0, index) + dst + rs.SubString(index + srcLen, len - index - srcLen);
				len = rs.length;
			}
			return rs;
		}

		String String::MD5() const
		{
			unsigned char result[16];
			MD5_CTX ctx;
			MD5_Init(&ctx);
			MD5_Update(&ctx, buffer.Ptr(), length * sizeof(wchar_t));
			MD5_Final(result, &ctx);
			StringBuilder strResult;
			for (int i = 0; i < 16; i++)
			{
				auto ch = String((int)result[i], 16);
				if (ch.length == 1)
					strResult << L'0';
				else
					strResult << ch;
			}
			return strResult.ProduceString();
		}

		String String::PadLeft(wchar_t ch, int pLen)
		{
			StringBuilder sb;
			for (int i = 0; i < pLen - this->length; i++)
				sb << ch;
			for (int i = 0; i < this->length; i++)
				sb << buffer[i];
			return sb.ProduceString();
		}

		String String::PadRight(wchar_t ch, int pLen)
		{
			StringBuilder sb;
			for (int i = 0; i < this->length; i++)
				sb << buffer[i];
			for (int i = 0; i < pLen - this->length; i++)
				sb << ch;
			return sb.ProduceString();
		}
	}
}
#endif

/***********************************************************************
CORELIB\MD5.CPP
***********************************************************************/
#ifndef SPIRE_NO_CORE_LIB
/*
* This is an OpenSSL-compatible implementation of the RSA Data Security, Inc.
* MD5 Message-Digest Algorithm (RFC 1321).
*
* Homepage:
* http://openwall.info/wiki/people/solar/software/public-domain-source-code/md5
*
* Author:
* Alexander Peslyak, better known as Solar Designer <solar at openwall.com>
*
* This software was written by Alexander Peslyak in 2001.  No copyright is
* claimed, and the software is hereby placed in the public domain.
* In case this attempt to disclaim copyright and place the software in the
* public domain is deemed null and void, then the software is
* Copyright (c) 2001 Alexander Peslyak and it is hereby released to the
* general public under the following terms:
*
* Redistribution and use in source and binary forms, with or without
* modification, are permitted.
*
* There's ABSOLUTELY NO WARRANTY, express or implied.
*
* (This is a heavily cut-down "BSD license".)
*
* This differs from Colin Plumb's older public domain implementation in that
* no exactly 32-bit integer data type is required (any 32-bit or wider
* unsigned integer data type will do), there's no compile-time endianness
* configuration, and the function prototypes match OpenSSL's.  No code from
* Colin Plumb's implementation has been reused; this comment merely compares
* the properties of the two independent implementations.
*
* The primary goals of this implementation are portability and ease of use.
* It is meant to be fast, but not as fast as possible.  Some known
* optimizations are not included to reduce source code size and avoid
* compile-time configuration.
*/

#ifndef HAVE_OPENSSL



/*
* The basic MD5 functions.
*
* F and G are optimized compared to their RFC 1321 definitions for
* architectures that lack an AND-NOT instruction, just like in Colin Plumb's
* implementation.
*/
#define F(x, y, z)			((z) ^ ((x) & ((y) ^ (z))))
#define G(x, y, z)			((y) ^ ((z) & ((x) ^ (y))))
#define H(x, y, z)			(((x) ^ (y)) ^ (z))
#define H2(x, y, z)			((x) ^ ((y) ^ (z)))
#define I(x, y, z)			((y) ^ ((x) | ~(z)))

/*
* The MD5 transformation for all four rounds.
*/
#define STEP(f, a, b, c, d, x, t, s) \
	(a) += f((b), (c), (d)) + (x)+(t); \
	(a) = (((a) << (s)) | (((a)& 0xffffffff) >> (32 - (s)))); \
	(a) += (b);

/*
* SET reads 4 input bytes in little-endian byte order and stores them
* in a properly aligned word in host byte order.
*
* The check for little-endian architectures that tolerate unaligned
* memory accesses is just an optimization.  Nothing will break if it
* doesn't work.
*/
#if defined(__i386__) || defined(__x86_64__) || defined(__vax__)
#define SET(n) \
	(*(MD5_u32plus *)&ptr[(n)* 4])
#define GET(n) \
	SET(n)
#else
#define SET(n) \
	(ctx->block[(n)] = \
	(MD5_u32plus)ptr[(n)* 4] | \
	((MD5_u32plus)ptr[(n)* 4 + 1] << 8) | \
	((MD5_u32plus)ptr[(n)* 4 + 2] << 16) | \
	((MD5_u32plus)ptr[(n)* 4 + 3] << 24))
#define GET(n) \
	(ctx->block[(n)])
#endif

/*
* This processes one or more 64-byte data blocks, but does NOT update
* the bit counters.  There are no alignment requirements.
*/
static const void *body(MD5_CTX *ctx, const void *data, unsigned long size)
{
	const unsigned char *ptr;
	MD5_u32plus a, b, c, d;
	MD5_u32plus saved_a, saved_b, saved_c, saved_d;

	ptr = (const unsigned char *)data;

	a = ctx->a;
	b = ctx->b;
	c = ctx->c;
	d = ctx->d;

	do {
		saved_a = a;
		saved_b = b;
		saved_c = c;
		saved_d = d;

		/* Round 1 */
		STEP(F, a, b, c, d, SET(0), 0xd76aa478, 7)
			STEP(F, d, a, b, c, SET(1), 0xe8c7b756, 12)
			STEP(F, c, d, a, b, SET(2), 0x242070db, 17)
			STEP(F, b, c, d, a, SET(3), 0xc1bdceee, 22)
			STEP(F, a, b, c, d, SET(4), 0xf57c0faf, 7)
			STEP(F, d, a, b, c, SET(5), 0x4787c62a, 12)
			STEP(F, c, d, a, b, SET(6), 0xa8304613, 17)
			STEP(F, b, c, d, a, SET(7), 0xfd469501, 22)
			STEP(F, a, b, c, d, SET(8), 0x698098d8, 7)
			STEP(F, d, a, b, c, SET(9), 0x8b44f7af, 12)
			STEP(F, c, d, a, b, SET(10), 0xffff5bb1, 17)
			STEP(F, b, c, d, a, SET(11), 0x895cd7be, 22)
			STEP(F, a, b, c, d, SET(12), 0x6b901122, 7)
			STEP(F, d, a, b, c, SET(13), 0xfd987193, 12)
			STEP(F, c, d, a, b, SET(14), 0xa679438e, 17)
			STEP(F, b, c, d, a, SET(15), 0x49b40821, 22)

			/* Round 2 */
			STEP(G, a, b, c, d, GET(1), 0xf61e2562, 5)
			STEP(G, d, a, b, c, GET(6), 0xc040b340, 9)
			STEP(G, c, d, a, b, GET(11), 0x265e5a51, 14)
			STEP(G, b, c, d, a, GET(0), 0xe9b6c7aa, 20)
			STEP(G, a, b, c, d, GET(5), 0xd62f105d, 5)
			STEP(G, d, a, b, c, GET(10), 0x02441453, 9)
			STEP(G, c, d, a, b, GET(15), 0xd8a1e681, 14)
			STEP(G, b, c, d, a, GET(4), 0xe7d3fbc8, 20)
			STEP(G, a, b, c, d, GET(9), 0x21e1cde6, 5)
			STEP(G, d, a, b, c, GET(14), 0xc33707d6, 9)
			STEP(G, c, d, a, b, GET(3), 0xf4d50d87, 14)
			STEP(G, b, c, d, a, GET(8), 0x455a14ed, 20)
			STEP(G, a, b, c, d, GET(13), 0xa9e3e905, 5)
			STEP(G, d, a, b, c, GET(2), 0xfcefa3f8, 9)
			STEP(G, c, d, a, b, GET(7), 0x676f02d9, 14)
			STEP(G, b, c, d, a, GET(12), 0x8d2a4c8a, 20)

			/* Round 3 */
			STEP(H, a, b, c, d, GET(5), 0xfffa3942, 4)
			STEP(H2, d, a, b, c, GET(8), 0x8771f681, 11)
			STEP(H, c, d, a, b, GET(11), 0x6d9d6122, 16)
			STEP(H2, b, c, d, a, GET(14), 0xfde5380c, 23)
			STEP(H, a, b, c, d, GET(1), 0xa4beea44, 4)
			STEP(H2, d, a, b, c, GET(4), 0x4bdecfa9, 11)
			STEP(H, c, d, a, b, GET(7), 0xf6bb4b60, 16)
			STEP(H2, b, c, d, a, GET(10), 0xbebfbc70, 23)
			STEP(H, a, b, c, d, GET(13), 0x289b7ec6, 4)
			STEP(H2, d, a, b, c, GET(0), 0xeaa127fa, 11)
			STEP(H, c, d, a, b, GET(3), 0xd4ef3085, 16)
			STEP(H2, b, c, d, a, GET(6), 0x04881d05, 23)
			STEP(H, a, b, c, d, GET(9), 0xd9d4d039, 4)
			STEP(H2, d, a, b, c, GET(12), 0xe6db99e5, 11)
			STEP(H, c, d, a, b, GET(15), 0x1fa27cf8, 16)
			STEP(H2, b, c, d, a, GET(2), 0xc4ac5665, 23)

			/* Round 4 */
			STEP(I, a, b, c, d, GET(0), 0xf4292244, 6)
			STEP(I, d, a, b, c, GET(7), 0x432aff97, 10)
			STEP(I, c, d, a, b, GET(14), 0xab9423a7, 15)
			STEP(I, b, c, d, a, GET(5), 0xfc93a039, 21)
			STEP(I, a, b, c, d, GET(12), 0x655b59c3, 6)
			STEP(I, d, a, b, c, GET(3), 0x8f0ccc92, 10)
			STEP(I, c, d, a, b, GET(10), 0xffeff47d, 15)
			STEP(I, b, c, d, a, GET(1), 0x85845dd1, 21)
			STEP(I, a, b, c, d, GET(8), 0x6fa87e4f, 6)
			STEP(I, d, a, b, c, GET(15), 0xfe2ce6e0, 10)
			STEP(I, c, d, a, b, GET(6), 0xa3014314, 15)
			STEP(I, b, c, d, a, GET(13), 0x4e0811a1, 21)
			STEP(I, a, b, c, d, GET(4), 0xf7537e82, 6)
			STEP(I, d, a, b, c, GET(11), 0xbd3af235, 10)
			STEP(I, c, d, a, b, GET(2), 0x2ad7d2bb, 15)
			STEP(I, b, c, d, a, GET(9), 0xeb86d391, 21)

			a += saved_a;
		b += saved_b;
		c += saved_c;
		d += saved_d;

		ptr += 64;
	} while (size -= 64);

	ctx->a = a;
	ctx->b = b;
	ctx->c = c;
	ctx->d = d;

	return ptr;
}

void MD5_Init(MD5_CTX *ctx)
{
	ctx->a = 0x67452301;
	ctx->b = 0xefcdab89;
	ctx->c = 0x98badcfe;
	ctx->d = 0x10325476;

	ctx->lo = 0;
	ctx->hi = 0;
}

void MD5_Update(MD5_CTX *ctx, const void *data, unsigned long size)
{
	MD5_u32plus saved_lo;
	unsigned long used, available;

	saved_lo = ctx->lo;
	if ((ctx->lo = (saved_lo + size) & 0x1fffffff) < saved_lo)
		ctx->hi++;
	ctx->hi += size >> 29;

	used = saved_lo & 0x3f;

	if (used) {
		available = 64 - used;

		if (size < available) {
			memcpy(&ctx->buffer[used], data, size);
			return;
		}

		memcpy(&ctx->buffer[used], data, available);
		data = (const unsigned char *)data + available;
		size -= available;
		body(ctx, ctx->buffer, 64);
	}

	if (size >= 64) {
		data = body(ctx, data, size & ~(unsigned long)0x3f);
		size &= 0x3f;
	}

	memcpy(ctx->buffer, data, size);
}

void MD5_Final(unsigned char *result, MD5_CTX *ctx)
{
	unsigned long used, available;

	used = ctx->lo & 0x3f;

	ctx->buffer[used++] = 0x80;

	available = 64 - used;

	if (available < 8) {
		memset(&ctx->buffer[used], 0, available);
		body(ctx, ctx->buffer, 64);
		used = 0;
		available = 64;
	}

	memset(&ctx->buffer[used], 0, available - 8);

	ctx->lo <<= 3;
	ctx->buffer[56] = (unsigned char)(ctx->lo);
	ctx->buffer[57] = (unsigned char)(ctx->lo >> 8);
	ctx->buffer[58] = (unsigned char)(ctx->lo >> 16);
	ctx->buffer[59] = (unsigned char)(ctx->lo >> 24);
	ctx->buffer[60] = (unsigned char)(ctx->hi);
	ctx->buffer[61] = (unsigned char)(ctx->hi >> 8);
	ctx->buffer[62] = (unsigned char)(ctx->hi >> 16);
	ctx->buffer[63] = (unsigned char)(ctx->hi >> 24);

	body(ctx, ctx->buffer, 64);

	result[0] = (unsigned char)(ctx->a);
	result[1] = (unsigned char)(ctx->a >> 8);
	result[2] = (unsigned char)(ctx->a >> 16);
	result[3] = (unsigned char)(ctx->a >> 24);
	result[4] = (unsigned char)(ctx->b);
	result[5] = (unsigned char)(ctx->b >> 8);
	result[6] = (unsigned char)(ctx->b >> 16);
	result[7] = (unsigned char)(ctx->b >> 24);
	result[8] = (unsigned char)(ctx->c);
	result[9] = (unsigned char)(ctx->c >> 8);
	result[10] = (unsigned char)(ctx->c >> 16);
	result[11] = (unsigned char)(ctx->c >> 24);
	result[12] = (unsigned char)(ctx->d);
	result[13] = (unsigned char)(ctx->d >> 8);
	result[14] = (unsigned char)(ctx->d >> 16);
	result[15] = (unsigned char)(ctx->d >> 24);

	memset(ctx, 0, sizeof(*ctx));
}

#endif
#endif

/***********************************************************************
CORELIB\MEMORYPOOL.CPP
***********************************************************************/
#ifndef SPIRE_NO_CORE_LIB

namespace CoreLib
{
	namespace Basic
	{
		MemoryPool::MemoryPool(unsigned char * pBuffer, int pLog2BlockSize, int numBlocks)
		{
			Init(pBuffer, pLog2BlockSize, numBlocks);
		}
		void MemoryPool::Init(unsigned char * pBuffer, int pLog2BlockSize, int numBlocks)
		{
			assert(pLog2BlockSize >= 1 && pLog2BlockSize <= 30);
			assert(numBlocks >= 4);
			buffer = pBuffer;
			blockSize = 1 << pLog2BlockSize;
			log2BlockSize = pLog2BlockSize;
			numLevels = Math::Log2Floor(numBlocks);
			freeList[0] = (FreeListNode*)buffer;
			freeList[0]->NextPtr = nullptr;
			freeList[0]->PrevPtr = nullptr;
			used.SetMax(1 << (numLevels));
			for (int i = 1; i < MaxLevels; i++)
			{
				freeList[i] = nullptr;
			}
		}
		int MemoryPool::AllocBlock(int level)
		{
			if (level < 0)
				return -1;
			if (freeList[level] == nullptr)
			{
				auto largeBlockAddr = AllocBlock(level - 1);
				if (largeBlockAddr != -1)
				{
					auto block1 = (FreeListNode*)(buffer + ((largeBlockAddr ^ (1 << (numLevels - level))) << log2BlockSize));
					block1->NextPtr = nullptr;
					block1->PrevPtr = nullptr;
					freeList[level] = block1;

					int blockIndex = (1 << level) + (largeBlockAddr >> (numLevels-level)) - 1;
					used.Add(blockIndex);
					return largeBlockAddr;
				}
				else
					return -1;
			}
			else
			{
				auto node = freeList[level];
				if (node->NextPtr)
				{
					node->NextPtr->PrevPtr = node->PrevPtr;
				}
				freeList[level] = freeList[level]->NextPtr;
				int rs = (int)((unsigned char *)node - buffer) >> log2BlockSize;
				int blockIndex = (1 << level) + (rs >> (numLevels - level)) - 1;
				used.Add(blockIndex);
				return rs;
			}
		}
		unsigned char * MemoryPool::Alloc(int size)
		{
			if (size == 0)
				return nullptr;
			int originalSize = size;
			if (size < blockSize)
				size = blockSize;
			int order = numLevels - (Math::Log2Ceil(size) - log2BlockSize);
			assert(order >= 0 && order < MaxLevels);

			bytesAllocated += (1 << ((numLevels-order) + log2BlockSize));
			bytesWasted += (1 << ((numLevels - order) + log2BlockSize)) - originalSize;

			int blockId = AllocBlock(order);
			if (blockId != -1)
				return buffer + (blockId << log2BlockSize);
			else
				return nullptr;
		}
		void MemoryPool::FreeBlock(unsigned char * ptr, int level)
		{
			int indexInLevel = (int)(ptr - buffer) >> (numLevels - level + log2BlockSize);
			int blockIndex = (1 << level) + indexInLevel - 1;
			assert(used.Contains(blockIndex));
			int buddyIndex = (blockIndex & 1) ? blockIndex + 1 : blockIndex - 1;
			used.Remove(blockIndex);
			if (level > 0 && !used.Contains(buddyIndex))
			{
				auto buddyPtr = (FreeListNode *)(buffer + ((((int)(ptr - buffer) >> log2BlockSize) ^ (1 << (numLevels - level))) << log2BlockSize));
				if (buddyPtr->PrevPtr)
				{
					buddyPtr->PrevPtr->NextPtr = buddyPtr->NextPtr;
				}
				if (buddyPtr->NextPtr)
				{
					buddyPtr->NextPtr->PrevPtr = buddyPtr->PrevPtr;
				}
				if (freeList[level] == buddyPtr)
				{
					freeList[level] = buddyPtr->NextPtr;
				}
				// recursively free parent blocks
				auto parentPtr = Math::Min(buddyPtr, (FreeListNode*)ptr);
				if (level > 0)
					FreeBlock((unsigned char*)parentPtr, level - 1);
			}
			else
			{
				// insert to freelist
				auto freeNode = (FreeListNode *)ptr;
				freeNode->NextPtr = freeList[level];
				freeNode->PrevPtr = nullptr;
				if (freeList[level])
					freeList[level]->PrevPtr = freeNode;
				freeList[level] = freeNode;
			}
		}
		void MemoryPool::Free(unsigned char * ptr, int size)
		{
			if (size == 0)
				return;
			int originalSize = size;
			if (size < blockSize)
				size = blockSize;
			int level = numLevels - (Math::Log2Ceil(size) - log2BlockSize);
			bytesAllocated -= (1 << ((numLevels-level) + log2BlockSize));
			bytesWasted -= (1 << ((numLevels - level) + log2BlockSize)) - originalSize;
			FreeBlock(ptr, level);
		}
	}
}

#endif

/***********************************************************************
CORELIB\PARSER.CPP
***********************************************************************/
#ifndef SPIRE_NO_CORE_LIB

using namespace CoreLib::Basic;

namespace CoreLib
{
	namespace Text
	{
		RefPtr<MetaLexer> Parser::metaLexer;
		MetaLexer * Parser::GetTextLexer()
		{
			if (!metaLexer)
			{
				metaLexer = new MetaLexer();
				metaLexer->SetLexProfile(
					L"#WhiteSpace = {\\s+}\n"\
					L"#SingleLineComment = {//[^\\n]*\\n}\n"\
					L"#MultiLineComment = {/\\*([^*]|\\*[^/])*\\*/}\n"\
					L"Identifier = {[a-zA-Z_]\\w*}\n"\
					L"IntConstant = {\\d+}\n"\
					L"FloatConstant = {\\d*.\\d+|\\d+(.\\d+)?(e(-)?\\d+)?}\n"\
					L"StringConstant = {\"([^\\\\\"]|\\\\\\.)*\"}\n"\
					L"CharConstant = {'[^\\n\\r]*'}\n"\
					L"LParent = {\\(}\n"\
					L"RParent = {\\)}\n"\
					L"LBrace = {{}\n"\
					L"RBrace = {}}\n"\
					L"LBracket = {\\[}\n"\
					L"RBracket = {\\]}\n"\
					L"Dot = {.}\n"\
					L"Semicolon = {;}\n"\
					L"Comma = {,}\n"\
					L"Colon = {:}\n"\
					L"OpAdd = {\\+}\n"\
					L"OpSub = {-}\n"\
					L"OpDiv = {/}\n"\
					L"OpMul = {\\*}\n"\
					L"OpMod = {%}\n"\
					L"OpExp = {^}\n"\
					L"OpGreater = {>}\n"\
					L"OpLess = {<}\n"\
					L"OpEqual = {==}\n"\
					L"OpGEqual = {>=}\n"\
					L"OpLEqual = {<=}\n"\
					L"OpNEqual = {!=}\n"\
					L"OpAnd = {&}\n"\
					L"OpOr = {\\|}\n"\
					L"OpNot = {!}\n"\
					L"OpAssign = {=}\n"\
					L"OpDollar = {$}\n"
					);
			}
			return metaLexer.Ptr();
		}
		void Parser::DisposeTextLexer()
		{
			metaLexer = nullptr;
		}
		Basic::List<Basic::String> Parser::SplitString(Basic::String str, wchar_t ch)
		{
			List<String> result;
			StringBuilder currentBuilder;
			for (int i = 0; i < str.Length(); i++)
			{
				if (str[i] == ch)
				{
					result.Add(currentBuilder.ToString());
					currentBuilder.Clear();
				}
				else
					currentBuilder.Append(str[i]);
			}
			result.Add(currentBuilder.ToString());
			return result;
		}
		Parser::Parser(String text)
		{
			this->text = text;
			
			stream = GetTextLexer()->Parse(text);
			for (auto token : stream)
			{
				if (token.TypeID != -1)
					tokens.Add(token);
			}
			tokenPtr = 0;
		}


		List<String> Split(String text, wchar_t c)
		{
			List<String> result;
			StringBuilder sb;
			for (int i = 0; i < text.Length(); i++)
			{
				if (text[i] == c)
				{
					auto str = sb.ToString();
					if (str.Length() != 0)
						result.Add(str);
					sb.Clear();
				}
				else
					sb << text[i];
			}
			auto lastStr = sb.ToString();
			if (lastStr.Length())
				result.Add(lastStr);
			return result;
		}

	}
}
#endif

/***********************************************************************
CORELIB\PERFORMANCECOUNTER.CPP
***********************************************************************/
#ifndef SPIRE_NO_CORE_LIB

using namespace std::chrono;

namespace CoreLib
{
	namespace Diagnostics
	{
		TimePoint PerformanceCounter::Start()
		{
			return high_resolution_clock::now();
		}

		Duration PerformanceCounter::End(TimePoint counter)
		{
			return high_resolution_clock::now()-counter;
		}

		float PerformanceCounter::EndSeconds(TimePoint counter)
		{
			return (float)ToSeconds(high_resolution_clock::now() - counter);
		}

		double PerformanceCounter::ToSeconds(Duration counter)
		{
			auto rs = duration_cast<duration<double>>(counter);
			return *(double*)&rs;
		}
	}
}
#endif

/***********************************************************************
CORELIB\STREAM.CPP
***********************************************************************/
#ifndef SPIRE_NO_CORE_LIB
#ifdef _WIN32
#include <share.h>
#endif

namespace CoreLib
{
	namespace IO
	{
		using namespace CoreLib::Basic;
		FileStream::FileStream(const CoreLib::Basic::String & fileName, FileMode fileMode)
		{
			Init(fileName, fileMode, fileMode==FileMode::Open?FileAccess::Read:FileAccess::Write, FileShare::None);
		}
		FileStream::FileStream(const CoreLib::Basic::String & fileName, FileMode fileMode, FileAccess access, FileShare share)
		{
			Init(fileName, fileMode, access, share);
		}
		void FileStream::Init(const CoreLib::Basic::String & fileName, FileMode fileMode, FileAccess access, FileShare share)
		{
			const wchar_t * mode = L"rt";
			const char* modeMBCS = "rt";
			switch (fileMode)
			{
			case CoreLib::IO::FileMode::Create:
				if (access == FileAccess::Read)
					throw ArgumentException(L"Read-only access is incompatible with Create mode.");
				else if (access == FileAccess::ReadWrite)
				{
					mode = L"w+b";
					modeMBCS = "w+b";
					this->fileAccess = FileAccess::ReadWrite;
				}
				else
				{
					mode = L"wb";
					modeMBCS = "wb";
					this->fileAccess = FileAccess::Write;
				}
				break;
			case CoreLib::IO::FileMode::Open:
				if (access == FileAccess::Read)
				{
					mode = L"rb";
					modeMBCS = "rb";
					this->fileAccess = FileAccess::Read;
				}
				else if (access == FileAccess::ReadWrite)
				{
					mode = L"r+b";
					modeMBCS = "r+b";
					this->fileAccess = FileAccess::ReadWrite;
				}
				else
				{
					mode = L"wb";
					modeMBCS = "wb";
					this->fileAccess = FileAccess::Write;
				}
				break;
			case CoreLib::IO::FileMode::CreateNew:
				if (File::Exists(fileName))
				{
					throw IOException(L"Failed opening '" + fileName + L"', file already exists.");
				}
				if (access == FileAccess::Read)
					throw ArgumentException(L"Read-only access is incompatible with Create mode.");
				else if (access == FileAccess::ReadWrite)
				{
					mode = L"w+b";
					this->fileAccess = FileAccess::ReadWrite;
				}
				else
				{
					mode = L"wb";
					this->fileAccess = FileAccess::Write;
				}
				break;
			case CoreLib::IO::FileMode::Append:
				if (access == FileAccess::Read)
					throw ArgumentException(L"Read-only access is incompatible with Append mode.");
				else if (access == FileAccess::ReadWrite)
				{
					mode = L"a+b";
					this->fileAccess = FileAccess::ReadWrite;
				}
				else
				{
					mode = L"ab";
					this->fileAccess = FileAccess::Write;
				}
				break;
			default:
				break;
			}
			int shFlag;
#ifdef _WIN32
			switch (share)
			{
			case CoreLib::IO::FileShare::None:
				shFlag = _SH_DENYRW;
				break;
			case CoreLib::IO::FileShare::ReadOnly:
				shFlag = _SH_DENYWR;
				break;
			case CoreLib::IO::FileShare::WriteOnly:
				shFlag = _SH_DENYRD;
				break;
			case CoreLib::IO::FileShare::ReadWrite:
				shFlag = _SH_DENYNO;
				break;
			default:
				throw ArgumentException(L"Invalid file share mode.");
				break;
			}
			handle = _wfsopen(fileName.Buffer(), mode, shFlag);
#else
			handle = fopen(fileName.ToMultiByteString(), modeMBCS);
#endif
			if (!handle)
			{
				throw IOException(L"Cannot open file '" + fileName + L"'");
			}
		}
		FileStream::~FileStream()
		{
			Close();
		}
		Int64 FileStream::GetPosition()
		{
#ifdef _WIN32
			fpos_t pos;
			fgetpos(handle, &pos);
			return pos;
#else
			fpos64_t pos;
			fgetpos64(handle, &pos);
			return *(Int64*)(&pos);
#endif
		}
		void FileStream::Seek(SeekOrigin origin, Int64 offset)
		{
			int _origin;
			switch (origin)
			{
			case CoreLib::IO::SeekOrigin::Start:
				_origin = SEEK_SET;
				endReached = false;
				break;
			case CoreLib::IO::SeekOrigin::End:
				_origin = SEEK_END;
				endReached = true;
				break;
			case CoreLib::IO::SeekOrigin::Current:
				_origin = SEEK_CUR;
				endReached = false;
				break;
			default:
				throw NotSupportedException(L"Unsupported seek origin.");
				break;
			}
#ifdef _WIN32
			int rs = _fseeki64(handle, offset, _origin);
#else
			int rs = fseek(handle, (int)offset, _origin);
#endif
			if (rs != 0)
			{
				throw IOException(L"FileStream seek failed.");
			}
		}
		Int64 FileStream::Read(void * buffer, Int64 length)
		{
			auto bytes = fread_s(buffer, (size_t)length, 1, (size_t)length, handle);
			if (bytes == 0 && length > 0)
			{
				if (!feof(handle))
					throw IOException(L"FileStream read failed.");
				else if (endReached)
					throw EndOfStreamException(L"End of file is reached.");
				endReached = true;
			}
			return (int)bytes;
		}
		Int64 FileStream::Write(const void * buffer, Int64 length)
		{
			auto bytes = (Int64)fwrite(buffer, 1, (size_t)length, handle);
			if (bytes < length)
			{
				throw IOException(L"FileStream write failed.");
			}
			return bytes;
		}
		bool FileStream::CanRead()
		{
			return ((int)fileAccess & (int)FileAccess::Read) != 0;
		}
		bool FileStream::CanWrite()
		{
			return ((int)fileAccess & (int)FileAccess::Write) != 0;
		}
		void FileStream::Close()
		{
			if (handle)
			{
				fclose(handle);
				handle = 0;
			}
		}
		bool FileStream::IsEnd()
		{
			return endReached;
		}
	}
}
#endif

/***********************************************************************
CORELIB\TEXTIO.CPP
***********************************************************************/
#ifndef SPIRE_NO_CORE_LIB
#ifdef _WIN32
#include <Windows.h>
#define CONVERT_END_OF_LINE
#endif

namespace CoreLib
{
	namespace IO
	{
		using namespace CoreLib::Basic;

		class UnicodeEncoding : public Encoding //UTF8
		{
		public:
			virtual void GetBytes(List<char> & result, const String & str) override
			{
				for (int i = 0; i < str.Length(); i++)
				{
					unsigned int codePoint = str[i];
					if (codePoint >= 0xD800 && codePoint <= 0xDBFF && i < str.Length() - 1) // surrogate
					{
						codePoint -= 0xD800;
						codePoint <<= 10;
						i++;
						codePoint += str[i] - 0xDC00;
						codePoint += 0x10000;
					}
					// encode codePoint as UTF8
					if (codePoint <= 0x7F)
						result.Add((char)codePoint);
					else if (codePoint <= 0x7FF)
					{
						unsigned char byte = (unsigned char)(0xC0 + (codePoint >> 6));
						result.Add((char)byte);
						byte = 0x80 + (codePoint & 0x3F);
						result.Add((char)byte);
					}
					else if (codePoint <= 0xFFFF)
					{
						unsigned char byte = (unsigned char)(0xE0 + (codePoint >> 12));
						result.Add((char)byte);
						byte = (unsigned char)(0x80 + ((codePoint >> 6) & (0x3F)));
						result.Add((char)byte);
						byte = (unsigned char)(0x80 + (codePoint & 0x3F));
						result.Add((char)byte);
					}
					else
					{
						unsigned char byte = (unsigned char)(0xF0 + (codePoint >> 18));
						result.Add((char)byte);
						byte = (unsigned char)(0x80 + ((codePoint >> 12) & 0x3F));
						result.Add((char)byte);
						byte = (unsigned char)(0x80 + ((codePoint >> 6) & 0x3F));
						result.Add((char)byte);
						byte = (unsigned char)(0x80 + (codePoint & 0x3F));
						result.Add((char)byte);
					}
				}
			}
		};

		class Utf16Encoding : public Encoding //UTF16
		{
		private:
			bool reverseOrder = false;
		public:
			Utf16Encoding(bool pReverseOrder)
				: reverseOrder(pReverseOrder)
			{}
			virtual void GetBytes(List<char> & result, const String & str) override
			{
				auto addChar = [&](unsigned short ch)
				{
					if (reverseOrder)
					{
						unsigned char firstByte = ch >> 8;
						unsigned char lastByte = ch & 0xFF;
						result.Add((char)firstByte);
						result.Add((char)lastByte);
					}
					else
						result.AddRange((char*)&ch, 2);
				};
#ifdef _WIN32
				if (reverseOrder)
				{
					for (int i = 0; i < str.Length(); i++)
					{
						unsigned short ch = (unsigned short)str[i];
						addChar(ch);
					}
				}
				else
					result.AddRange((char*)str.Buffer(), str.Length() * sizeof(wchar_t));
#else
				for (int i = 0; i < str.Length(); i++)
				{
					unsigned int codePoint = str[i];
					if (codePoint <= 0xD7FF || codePoint >= 0xE000 && codePoint <= 0xFFFF)
					{
						unsigned short toWrite = (unsigned short)codePoint;
						addChar(toWrite);
					}
					else
					{
						int sub = codePoint - 0x10000;
						unsigned short high = (unsigned short)((sub >> 10) + 0xD800);
						unsigned short low = (unsigned short)((sub & 0x3FF) + 0xDC00);
						addChar(high);
						addChar(low);
					}
				}
#endif
			}
		};


		class AnsiEncoding : public Encoding
		{
		private:
			static char * WideCharToAnsi(wchar_t * buffer, int length)
			{
				return WideCharToMByte(buffer, length);
			}
		public:
			virtual void GetBytes(List<char> & result, const String & str) override
			{
				String cpy = str;
				int len;
				char * buffer = cpy.ToMultiByteString(&len);
				result.AddRange(buffer, len);
			}
		};

		UnicodeEncoding __unicodeEncoding;
		Utf16Encoding __utf16Encoding(false);
		Utf16Encoding __utf16EncodingReversed(true);
		AnsiEncoding __ansiEncoding;

		Encoding * Encoding::UTF8 = &__unicodeEncoding;
		Encoding * Encoding::UTF16 = &__utf16Encoding;
		Encoding * Encoding::UTF16Reversed = &__utf16EncodingReversed;
		Encoding * Encoding::Ansi = &__ansiEncoding;

		const unsigned short Utf16Header = 0xFEFF;
		const unsigned short Utf16ReversedHeader = 0xFFFE;

		StreamWriter::StreamWriter(const String & path, Encoding * encoding)
		{
			this->stream = new FileStream(path, FileMode::Create);
			this->encoding = encoding;
			if (encoding == Encoding::UTF16)
			{
				this->stream->Write(&Utf16Header, 2);
			}
			else if (encoding == Encoding::UTF16Reversed)
			{
				this->stream->Write(&Utf16ReversedHeader, 2);
			}
		}
		StreamWriter::StreamWriter(RefPtr<Stream> stream, Encoding * encoding)
		{
			this->stream = stream;
			this->encoding = encoding;
			if (encoding == Encoding::UTF16)
			{
				this->stream->Write(&Utf16Header, 2);
			}
			else if (encoding == Encoding::UTF16Reversed)
			{
				this->stream->Write(&Utf16ReversedHeader, 2);
			}
		}
		void StreamWriter::Write(const String & str)
		{
			encodingBuffer.Clear();
			StringBuilder sb;
			String newLine;
#ifdef _WIN32
			newLine = L"\r\n";
#else
			newLine = L"\n";
#endif
			for (int i = 0; i < str.Length(); i++)
			{
				if (str[i] == L'\r')
					sb << newLine;
				else if (str[i] == L'\n')
				{
					if (i > 0 && str[i - 1] != L'\r')
						sb << newLine;
				}
				else
					sb << str[i];
			}
			encoding->GetBytes(encodingBuffer, sb.ProduceString());
			stream->Write(encodingBuffer.Buffer(), encodingBuffer.Count());
		}
		void StreamWriter::Write(const wchar_t * str)
		{
			Write(String(str));
		}
		void StreamWriter::Write(const char * str)
		{
			Write(String(str));
		}

		StreamReader::StreamReader(const String & path)
		{
			stream = new FileStream(path, FileMode::Open);
			ReadBuffer();
			encoding = DetermineEncoding();
			if (encoding == 0)
				encoding = Encoding::Ansi;
		}
		StreamReader::StreamReader(RefPtr<Stream> stream, Encoding * encoding)
		{
			this->stream = stream;
			this->encoding = encoding;
			ReadBuffer();
			auto determinedEncoding = DetermineEncoding();
			if (this->encoding == nullptr)
				this->encoding = determinedEncoding;
		}

		Encoding * StreamReader::DetermineEncoding()
		{
			if (buffer.Count() >= 3 && (unsigned char)(buffer[0]) == 0xEF && (unsigned char)(buffer[1]) == 0xBB && (unsigned char)(buffer[2]) == 0xBF)
			{
				ptr += 3;
				return Encoding::UTF8;
			}
			else if (*((unsigned short*)(buffer.Buffer())) == 0xFEFF)
			{
				ptr += 2;
				return Encoding::UTF16;
			}
			else if (*((unsigned short*)(buffer.Buffer())) == 0xFFFE)
			{
				ptr += 2;
				return Encoding::UTF16Reversed;
			}
			else
			{
#ifdef _WIN32
				int flag = IS_TEXT_UNICODE_SIGNATURE | IS_TEXT_UNICODE_REVERSE_SIGNATURE | IS_TEXT_UNICODE_STATISTICS | IS_TEXT_UNICODE_ASCII16;
				int rs = IsTextUnicode(buffer.Buffer(), buffer.Count(), &flag);
				if (rs)
				{
					if (flag & (IS_TEXT_UNICODE_SIGNATURE | IS_TEXT_UNICODE_STATISTICS))
						return Encoding::UTF16;
					else if (flag & (IS_TEXT_UNICODE_SIGNATURE | IS_TEXT_UNICODE_STATISTICS))
						return Encoding::UTF16Reversed;
					else if (flag & IS_TEXT_UNICODE_ASCII16)
						return Encoding::Ansi;
				}
#endif 
				return Encoding::UTF8;
			}
		}
		
		void StreamReader::ReadBuffer()
		{
			buffer.SetSize(4096);
			auto len = stream->Read(buffer.Buffer(), buffer.Count());
			buffer.SetSize((int)len);
			ptr = 0;
		}

		char StreamReader::ReadBufferChar()
		{
			if (ptr<buffer.Count())
			{
				return buffer[ptr++];
			}
			if (!stream->IsEnd())
				ReadBuffer();
			if (ptr<buffer.Count())
			{
				return buffer[ptr++];
			}
			return 0;
		}
		int TextReader::Read(wchar_t * destBuffer, int length)
		{
			int i = 0;
			for (i = 0; i<length; i++)
			{
				try
				{
					auto ch = Read();
					if (IsEnd())
						break;
					if (ch == L'\r')
					{
						if (Peak() == L'\n')
							Read();
						break;
					}
					else if (ch == L'\n')
					{
						break;
					}
					destBuffer[i] = ch;
				}
				catch (EndOfStreamException)
				{
					break;
				}
			}
			return i;
		}
		String StreamReader::ReadLine()
		{
			StringBuilder sb(256);
			while (!IsEnd())
			{
				try
				{
					auto ch = Read();
					if (IsEnd())
						break;
					if (ch == L'\r')
					{
						if (Peak() == L'\n')
							Read();
						break;
					}
					else if (ch == L'\n')
					{
						break;
					}
					sb.Append(ch);
				}
				catch (EndOfStreamException)
				{
					break;
				}
			}
			return sb.ProduceString();
		}
		String StreamReader::ReadToEnd()
		{
			StringBuilder sb(16384);
			while (!IsEnd())
			{
				try
				{
					auto ch = Read();
					if (IsEnd())
						break;
					if (ch == L'\r')
					{
						sb.Append(L'\n');
						if (Peak() == L'\n')
							Read();
					}
					else
						sb.Append(ch);
				}
				catch (EndOfStreamException)
				{
					break;
				}
			}
			return sb.ProduceString();
		}
	}
}
#endif

/***********************************************************************
CORELIB\THREADING.CPP
***********************************************************************/
#ifndef SPIRE_NO_CORE_LIB

#ifdef _WIN32
#elif MACOS
#include <sys/param.h>
#include <sys/sysctl.h>
#else
#include <unistd.h>
#endif

namespace CoreLib
{
	namespace Threading
	{
		unsigned int __stdcall ThreadProcedure(const ThreadParam& param)
		{
			if (param.thread->paramedThreadProc)
				param.thread->paramedThreadProc->Invoke(param.threadParam);
			else
				param.thread->threadProc->Invoke();
			return 0;
		}

		int ParallelSystemInfo::GetProcessorCount()
		{
		#ifdef _WIN32
			SYSTEM_INFO sysinfo;
			GetSystemInfo(&sysinfo);
			return sysinfo.dwNumberOfProcessors;
		#elif MACOS
			int nm[2];
			size_t len = 4;
			uint32_t count;

			nm[0] = CTL_HW; nm[1] = HW_AVAILCPU;
			sysctl(nm, 2, &count, &len, NULL, 0);

			if(count < 1) {
				nm[1] = HW_NCPU;
				sysctl(nm, 2, &count, &len, NULL, 0);
				if(count < 1) { count = 1; }
			}
			return count;
		#else
			return sysconf(_SC_NPROCESSORS_ONLN);
		#endif
		}
	}
}
#endif

/***********************************************************************
CORELIB\VECTORMATH.CPP
***********************************************************************/
#ifndef SPIRE_NO_CORE_LIB

namespace VectorMath
{
	const __m128 Matrix4_M128::VecOne = _mm_set_ps1(1.0f);
	void Matrix4::Rotation(Matrix4 & rs, const Vec3 & axis, float angle)
	{
		float c = cosf(angle);
		float s = sinf(angle);
		float t = 1.0f - c;

		Vec3 nAxis;
		Vec3::Normalize(nAxis, axis);
		float x = nAxis.x;
		float y = nAxis.y;
		float z = nAxis.z;

		rs.m[0][0] = 1 + t*(x*x-1);
		rs.m[1][0] = z*s+t*x*y;
		rs.m[2][0] = -y*s+t*x*z;
		rs.m[3][0] = 0.0f;

		rs.m[0][1] = -z*s+t*x*y;
		rs.m[1][1] = 1+t*(y*y-1);
		rs.m[2][1] = x*s+t*y*z;
		rs.m[3][1] = 0.0f;

		rs.m[0][2] = y*s+t*x*z;
		rs.m[1][2] = -x*s+t*y*z;
		rs.m[2][2] = 1+t*(z*z-1);
		rs.m[3][2] = 0.0f;

		rs.m[0][3] = 0.0f;
		rs.m[1][3] = 0.0f;
		rs.m[2][3] = 0.0f;
		rs.m[3][3] = 1.0f;
	}
	void Matrix4::Rotation(Matrix4 & rs, float yaw, float pitch, float roll)
	{
		Matrix4 mat;
		Matrix4::RotationY(rs, yaw);
		Matrix4::RotationX(mat, pitch);
		Matrix4::Multiply(rs, rs, mat);
		Matrix4::RotationZ(mat, roll);
		Matrix4::Multiply(rs, rs, mat);
	}

	void Matrix4::GetNormalMatrix(Matrix4 & mOut) const
	{
		float fDet = (mi._11 * (mi._22 * mi._33 - mi._23 * mi._32) -
			mi._12 * (mi._21 * mi._33 - mi._23 * mi._31) +
			mi._13 * (mi._21 * mi._32 - mi._22 * mi._31));
		float fDetInv = 1.0f / fDet;

		mOut.mi._11 = fDetInv * (mi._22 * mi._33 - mi._23 * mi._32);
		mOut.mi._21 = -fDetInv * (mi._12 * mi._33 - mi._13 * mi._32);
		mOut.mi._31 = fDetInv * (mi._12 * mi._23 - mi._13 * mi._22);

		mOut.mi._12 = -fDetInv * (mi._21 * mi._33 - mi._23 * mi._31);
		mOut.mi._22 = fDetInv * (mi._11 * mi._33 - mi._13 * mi._31);
		mOut.mi._32 = -fDetInv * (mi._11 * mi._23 - mi._13 * mi._21);

		mOut.mi._13 = fDetInv * (mi._21 * mi._32 - mi._22 * mi._31);
		mOut.mi._23 = -fDetInv * (mi._11 * mi._32 - mi._12 * mi._31);
		mOut.mi._33 = fDetInv * (mi._11 * mi._22 - mi._12 * mi._21);

		mOut.mi._14 = 0.0f;
		mOut.mi._24 = 0.0f;
		mOut.mi._34 = 0.0f;
		mOut.mi._41 = 0.0f;
		mOut.mi._42 = 0.0f;
		mOut.mi._43 = 0.0f;
		mOut.mi._44 = 1.0f;
	}
	
	float Matrix4::Inverse3D(Matrix4 & mOut_d) const
	{
		if(fabs(mi._44 - 1.0f) > 0.001f)
			return 0.0f;
		if(fabs(mi._14)>0.001f || fabs(mi._24)>0.001f || fabs(mi._34)>0.001f)
			return 0.0f;

		float fDet = (mi._11 * (mi._22 * mi._33 - mi._23 * mi._32) - 
		mi._12 * (mi._21 * mi._33 - mi._23 * mi._31) +
		mi._13 * (mi._21 * mi._32 - mi._22 * mi._31));
		float fDetInv = 1.0f / fDet;

		mOut_d.mi._11 = fDetInv * (mi._22 * mi._33 - mi._23 * mi._32);
		mOut_d.mi._12 = -fDetInv * (mi._12 * mi._33 - mi._13 * mi._32);
		mOut_d.mi._13 = fDetInv * (mi._12 * mi._23 - mi._13 * mi._22);
		mOut_d.mi._14 = 0.0f;

		mOut_d.mi._21 = -fDetInv * (mi._21 * mi._33 - mi._23 * mi._31);
		mOut_d.mi._22 = fDetInv * (mi._11 * mi._33 - mi._13 * mi._31);
		mOut_d.mi._23 = -fDetInv * (mi._11 * mi._23 - mi._13 * mi._21);
		mOut_d.mi._24 = 0.0f;

		mOut_d.mi._31 = fDetInv * (mi._21 * mi._32 - mi._22 * mi._31);
		mOut_d.mi._32 = -fDetInv * (mi._11 * mi._32 - mi._12 * mi._31);
		mOut_d.mi._33 = fDetInv * (mi._11 * mi._22 - mi._12 * mi._21);
		mOut_d.mi._34 = 0.0f;

		mOut_d.mi._41 = -(mi._41 * mOut_d.mi._11 + mi._42 * mOut_d.mi._21 + mi._43 * mOut_d.mi._31);
		mOut_d.mi._42 = -(mi._41 * mOut_d.mi._12 + mi._42 * mOut_d.mi._22 + mi._43 * mOut_d.mi._32);
		mOut_d.mi._43 = -(mi._41 * mOut_d.mi._13 + mi._42 * mOut_d.mi._23 + mi._43 * mOut_d.mi._33);
		mOut_d.mi._44 = 1.0f;

		return fDet;
	}
		
	float Matrix4::InverseFPU(Matrix4 &mOut_d) const
	{
		float succ = Inverse3D(mOut_d);
		if (succ != 0.0f)
			return succ;
		double Result[4][4];
		double tmp[12];
		double src[16];
		double det;
		for (int i = 0; i < 4; i++)
		{
			src[i+0] = m[i][0];
			src[i+4] = m[i][1];
			src[i+8] = m[i][2];
			src[i+12] = m[i][3];
		}
		tmp[0] = src[10] * src[15];
		tmp[1] = src[11] * src[14];
		tmp[2] = src[9] * src[15];
		tmp[3] = src[11] * src[13];
		tmp[4] = src[9] * src[14];
		tmp[5] = src[10] * src[13];
		tmp[6] = src[8] * src[15];
		tmp[7] = src[11] * src[12];
		tmp[8] = src[8] * src[14];
		tmp[9] = src[10] * src[12];
		tmp[10] = src[8] * src[13];
		tmp[11] = src[9] * src[12];
		Result[0][0] = tmp[0]*src[5] + tmp[3]*src[6] + tmp[4]*src[7];
		Result[0][0] -= tmp[1]*src[5] + tmp[2]*src[6] + tmp[5]*src[7];
		Result[0][1] = tmp[1]*src[4] + tmp[6]*src[6] + tmp[9]*src[7];
		Result[0][1] -= tmp[0]*src[4] + tmp[7]*src[6] + tmp[8]*src[7];
		Result[0][2] = tmp[2]*src[4] + tmp[7]*src[5] + tmp[10]*src[7];
		Result[0][2] -= tmp[3]*src[4] + tmp[6]*src[5] + tmp[11]*src[7];
		Result[0][3] = tmp[5]*src[4] + tmp[8]*src[5] + tmp[11]*src[6];
		Result[0][3] -= tmp[4]*src[4] + tmp[9]*src[5] + tmp[10]*src[6];
		Result[1][0] = tmp[1]*src[1] + tmp[2]*src[2] + tmp[5]*src[3];
		Result[1][0] -= tmp[0]*src[1] + tmp[3]*src[2] + tmp[4]*src[3];
		Result[1][1] = tmp[0]*src[0] + tmp[7]*src[2] + tmp[8]*src[3];
		Result[1][1] -= tmp[1]*src[0] + tmp[6]*src[2] + tmp[9]*src[3];
		Result[1][2] = tmp[3]*src[0] + tmp[6]*src[1] + tmp[11]*src[3];
		Result[1][2] -= tmp[2]*src[0] + tmp[7]*src[1] + tmp[10]*src[3];
		Result[1][3] = tmp[4]*src[0] + tmp[9]*src[1] + tmp[10]*src[2];
		Result[1][3] -= tmp[5]*src[0] + tmp[8]*src[1] + tmp[11]*src[2];
		tmp[0] = src[2]*src[7];
		tmp[1] = src[3]*src[6];
		tmp[2] = src[1]*src[7];
		tmp[3] = src[3]*src[5];
		tmp[4] = src[1]*src[6];
		tmp[5] = src[2]*src[5];
		tmp[6] = src[0]*src[7];
		tmp[7] = src[3]*src[4];
		tmp[8] = src[0]*src[6];
		tmp[9] = src[2]*src[4];
		tmp[10] = src[0]*src[5];
		tmp[11] = src[1]*src[4];
		Result[2][0] = tmp[0]*src[13] + tmp[3]*src[14] + tmp[4]*src[15];
		Result[2][0] -= tmp[1]*src[13] + tmp[2]*src[14] + tmp[5]*src[15];
		Result[2][1] = tmp[1]*src[12] + tmp[6]*src[14] + tmp[9]*src[15];
		Result[2][1] -= tmp[0]*src[12] + tmp[7]*src[14] + tmp[8]*src[15];
		Result[2][2] = tmp[2]*src[12] + tmp[7]*src[13] + tmp[10]*src[15];
		Result[2][2] -= tmp[3]*src[12] + tmp[6]*src[13] + tmp[11]*src[15];
		Result[2][3] = tmp[5]*src[12] + tmp[8]*src[13] + tmp[11]*src[14];
		Result[2][3] -= tmp[4]*src[12] + tmp[9]*src[13] + tmp[10]*src[14];
		Result[3][0] = tmp[2]*src[10] + tmp[5]*src[11] + tmp[1]*src[9];
		Result[3][0] -= tmp[4]*src[11] + tmp[0]*src[9] + tmp[3]*src[10];
		Result[3][1] = tmp[8]*src[11] + tmp[0]*src[8] + tmp[7]*src[10];
		Result[3][1] -= tmp[6]*src[10] + tmp[9]*src[11] + tmp[1]*src[8];
		Result[3][2] = tmp[6]*src[9] + tmp[11]*src[11] + tmp[3]*src[8];
		Result[3][2] -= tmp[10]*src[11] + tmp[2]*src[8] + tmp[7]*src[9];
		Result[3][3] = tmp[10]*src[10] + tmp[4]*src[8] + tmp[9]*src[9];
		Result[3][3] -= tmp[8]*src[9] + tmp[11]*src[10] + tmp[5]*src[8];
		det=src[0]*Result[0][0]+src[1]*Result[0][1]+src[2]*Result[0][2]+src[3]*Result[0][3];
		det = 1.0f / det;
		for (int i = 0; i < 4; i++)
		{
			for (int j = 0; j < 4; j++)
			{
				mOut_d.m[i][j] = (float)(Result[i][j] * det);
			}
		}
		return (float)det;
	}
	
	void Matrix4::LookAt(Matrix4 & rs, const Vec3 & pos, const Vec3 & center, const Vec3 & up)
	{
		Vec3 xAxis, yAxis, zAxis;
		Vec3::Subtract(zAxis, pos, center);
		Vec3::Normalize(zAxis, zAxis);
		Vec3::Cross(xAxis, up, zAxis);
		Vec3::Normalize(xAxis, xAxis);
		Vec3::Cross(yAxis, zAxis, xAxis);
		Vec3::Normalize(yAxis, yAxis);

		rs.m[0][0] = xAxis.x;
		rs.m[0][1] = yAxis.x;
		rs.m[0][2] = zAxis.x;
		rs.m[0][3] = 0.0f;

		rs.m[1][0] = xAxis.y;
		rs.m[1][1] = yAxis.y;
		rs.m[1][2] = zAxis.y;
		rs.m[1][3] = 0.0f;

		rs.m[2][0] = xAxis.z;
		rs.m[2][1] = yAxis.z;
		rs.m[2][2] = zAxis.z;
		rs.m[2][3] = 0.0f;

		rs.m[3][0] = -Vec3::Dot(xAxis, pos);
		rs.m[3][1] = -Vec3::Dot(yAxis, pos);
		rs.m[3][2] = -Vec3::Dot(zAxis, pos);
		rs.m[3][3] = 1.0f;
	}
	
	float Matrix4_M128::Inverse(Matrix4_M128 &mOut) const
	{
		__m128 Fac0;
		{
			__m128 Swp0a = _mm_shuffle_ps(C4, C3, _MM_SHUFFLE(3, 3, 3, 3));
			__m128 Swp0b = _mm_shuffle_ps(C4, C3, _MM_SHUFFLE(2, 2, 2, 2));

			__m128 Swp00 = _mm_shuffle_ps(C3, C2, _MM_SHUFFLE(2, 2, 2, 2));
			__m128 Swp01 = _mm_shuffle_ps(Swp0a, Swp0a, _MM_SHUFFLE(2, 0, 0, 0));
			__m128 Swp02 = _mm_shuffle_ps(Swp0b, Swp0b, _MM_SHUFFLE(2, 0, 0, 0));
			__m128 Swp03 = _mm_shuffle_ps(C3, C2, _MM_SHUFFLE(3, 3, 3, 3));

			__m128 Mul00 = _mm_mul_ps(Swp00, Swp01);
			__m128 Mul01 = _mm_mul_ps(Swp02, Swp03);
			Fac0 = _mm_sub_ps(Mul00, Mul01);
		}

		__m128 Fac1;
		{
			__m128 Swp0a = _mm_shuffle_ps(C4, C3, _MM_SHUFFLE(3, 3, 3, 3));
			__m128 Swp0b = _mm_shuffle_ps(C4, C3, _MM_SHUFFLE(1, 1, 1, 1));

			__m128 Swp00 = _mm_shuffle_ps(C3, C2, _MM_SHUFFLE(1, 1, 1, 1));
			__m128 Swp01 = _mm_shuffle_ps(Swp0a, Swp0a, _MM_SHUFFLE(2, 0, 0, 0));
			__m128 Swp02 = _mm_shuffle_ps(Swp0b, Swp0b, _MM_SHUFFLE(2, 0, 0, 0));
			__m128 Swp03 = _mm_shuffle_ps(C3, C2, _MM_SHUFFLE(3, 3, 3, 3));

			__m128 Mul00 = _mm_mul_ps(Swp00, Swp01);
			__m128 Mul01 = _mm_mul_ps(Swp02, Swp03);
			Fac1 = _mm_sub_ps(Mul00, Mul01);
		}

		__m128 Fac2;
		{
			__m128 Swp0a = _mm_shuffle_ps(C4, C3, _MM_SHUFFLE(2, 2, 2, 2));
			__m128 Swp0b = _mm_shuffle_ps(C4, C3, _MM_SHUFFLE(1, 1, 1, 1));

			__m128 Swp00 = _mm_shuffle_ps(C3, C2, _MM_SHUFFLE(1, 1, 1, 1));
			__m128 Swp01 = _mm_shuffle_ps(Swp0a, Swp0a, _MM_SHUFFLE(2, 0, 0, 0));
			__m128 Swp02 = _mm_shuffle_ps(Swp0b, Swp0b, _MM_SHUFFLE(2, 0, 0, 0));
			__m128 Swp03 = _mm_shuffle_ps(C3, C2, _MM_SHUFFLE(2, 2, 2, 2));

			__m128 Mul00 = _mm_mul_ps(Swp00, Swp01);
			__m128 Mul01 = _mm_mul_ps(Swp02, Swp03);
			Fac2 = _mm_sub_ps(Mul00, Mul01);
		}

		__m128 Fac3;
		{
			__m128 Swp0a = _mm_shuffle_ps(C4, C3, _MM_SHUFFLE(3, 3, 3, 3));
			__m128 Swp0b = _mm_shuffle_ps(C4, C3, _MM_SHUFFLE(0, 0, 0, 0));

			__m128 Swp00 = _mm_shuffle_ps(C3, C2, _MM_SHUFFLE(0, 0, 0, 0));
			__m128 Swp01 = _mm_shuffle_ps(Swp0a, Swp0a, _MM_SHUFFLE(2, 0, 0, 0));
			__m128 Swp02 = _mm_shuffle_ps(Swp0b, Swp0b, _MM_SHUFFLE(2, 0, 0, 0));
			__m128 Swp03 = _mm_shuffle_ps(C3, C2, _MM_SHUFFLE(3, 3, 3, 3));

			__m128 Mul00 = _mm_mul_ps(Swp00, Swp01);
			__m128 Mul01 = _mm_mul_ps(Swp02, Swp03);
			Fac3 = _mm_sub_ps(Mul00, Mul01);
		}

		__m128 Fac4;
		{
			__m128 Swp0a = _mm_shuffle_ps(C4, C3, _MM_SHUFFLE(2, 2, 2, 2));
			__m128 Swp0b = _mm_shuffle_ps(C4, C3, _MM_SHUFFLE(0, 0, 0, 0));

			__m128 Swp00 = _mm_shuffle_ps(C3, C2, _MM_SHUFFLE(0, 0, 0, 0));
			__m128 Swp01 = _mm_shuffle_ps(Swp0a, Swp0a, _MM_SHUFFLE(2, 0, 0, 0));
			__m128 Swp02 = _mm_shuffle_ps(Swp0b, Swp0b, _MM_SHUFFLE(2, 0, 0, 0));
			__m128 Swp03 = _mm_shuffle_ps(C3, C2, _MM_SHUFFLE(2, 2, 2, 2));

			__m128 Mul00 = _mm_mul_ps(Swp00, Swp01);
			__m128 Mul01 = _mm_mul_ps(Swp02, Swp03);
			Fac4 = _mm_sub_ps(Mul00, Mul01);
		}

		__m128 Fac5;
		{
			__m128 Swp0a = _mm_shuffle_ps(C4, C3, _MM_SHUFFLE(1, 1, 1, 1));
			__m128 Swp0b = _mm_shuffle_ps(C4, C3, _MM_SHUFFLE(0, 0, 0, 0));

			__m128 Swp00 = _mm_shuffle_ps(C3, C2, _MM_SHUFFLE(0, 0, 0, 0));
			__m128 Swp01 = _mm_shuffle_ps(Swp0a, Swp0a, _MM_SHUFFLE(2, 0, 0, 0));
			__m128 Swp02 = _mm_shuffle_ps(Swp0b, Swp0b, _MM_SHUFFLE(2, 0, 0, 0));
			__m128 Swp03 = _mm_shuffle_ps(C3, C2, _MM_SHUFFLE(1, 1, 1, 1));

			__m128 Mul00 = _mm_mul_ps(Swp00, Swp01);
			__m128 Mul01 = _mm_mul_ps(Swp02, Swp03);
			Fac5 = _mm_sub_ps(Mul00, Mul01);
		}

		__m128 SignA = _mm_set_ps( 1.0f,-1.0f, 1.0f,-1.0f);
		__m128 SignB = _mm_set_ps(-1.0f, 1.0f,-1.0f, 1.0f);

		__m128 Temp0 = _mm_shuffle_ps(C2, C1, _MM_SHUFFLE(0, 0, 0, 0));
		__m128 Vec0 = _mm_shuffle_ps(Temp0, Temp0, _MM_SHUFFLE(2, 2, 2, 0));

		__m128 Temp1 = _mm_shuffle_ps(C2, C1, _MM_SHUFFLE(1, 1, 1, 1));
		__m128 Vec1 = _mm_shuffle_ps(Temp1, Temp1, _MM_SHUFFLE(2, 2, 2, 0));

		__m128 Temp2 = _mm_shuffle_ps(C2, C1, _MM_SHUFFLE(2, 2, 2, 2));
		__m128 Vec2 = _mm_shuffle_ps(Temp2, Temp2, _MM_SHUFFLE(2, 2, 2, 0));

		__m128 Temp3 = _mm_shuffle_ps(C2, C1, _MM_SHUFFLE(3, 3, 3, 3));
		__m128 Vec3 = _mm_shuffle_ps(Temp3, Temp3, _MM_SHUFFLE(2, 2, 2, 0));

		__m128 Mul00 = _mm_mul_ps(Vec1, Fac0);
		__m128 Mul01 = _mm_mul_ps(Vec2, Fac1);
		__m128 Mul02 = _mm_mul_ps(Vec3, Fac2);
		__m128 Sub00 = _mm_sub_ps(Mul00, Mul01);
		__m128 Add00 = _mm_add_ps(Sub00, Mul02);
		__m128 Inv0 = _mm_mul_ps(SignB, Add00);

		__m128 Mul03 = _mm_mul_ps(Vec0, Fac0);
		__m128 Mul04 = _mm_mul_ps(Vec2, Fac3);
		__m128 Mul05 = _mm_mul_ps(Vec3, Fac4);
		__m128 Sub01 = _mm_sub_ps(Mul03, Mul04);
		__m128 Add01 = _mm_add_ps(Sub01, Mul05);
		__m128 Inv1 = _mm_mul_ps(SignA, Add01);

		__m128 Mul06 = _mm_mul_ps(Vec0, Fac1);
		__m128 Mul07 = _mm_mul_ps(Vec1, Fac3);
		__m128 Mul08 = _mm_mul_ps(Vec3, Fac5);
		__m128 Sub02 = _mm_sub_ps(Mul06, Mul07);
		__m128 Add02 = _mm_add_ps(Sub02, Mul08);
		__m128 Inv2 = _mm_mul_ps(SignB, Add02);

		__m128 Mul09 = _mm_mul_ps(Vec0, Fac2);
		__m128 Mul10 = _mm_mul_ps(Vec1, Fac4);
		__m128 Mul11 = _mm_mul_ps(Vec2, Fac5);
		__m128 Sub03 = _mm_sub_ps(Mul09, Mul10);
		__m128 Add03 = _mm_add_ps(Sub03, Mul11);
		__m128 Inv3 = _mm_mul_ps(SignA, Add03);

		__m128 Row0 = _mm_shuffle_ps(Inv0, Inv1, _MM_SHUFFLE(0, 0, 0, 0));
		__m128 Row1 = _mm_shuffle_ps(Inv2, Inv3, _MM_SHUFFLE(0, 0, 0, 0));
		__m128 Row2 = _mm_shuffle_ps(Row0, Row1, _MM_SHUFFLE(2, 0, 2, 0));

		// Det0 = dot(C1, Row2)
		__m128 mul0 = _mm_mul_ps(C1, Row2);
		__m128 swp0 = _mm_shuffle_ps(mul0, mul0, _MM_SHUFFLE(2, 3, 0, 1));
		__m128 add0 = _mm_add_ps(mul0, swp0);
		__m128 swp1 = _mm_shuffle_ps(add0, add0, _MM_SHUFFLE(0, 1, 2, 3));
		__m128 Det0 = _mm_add_ps(add0, swp1);

		__m128 Rcp0 = _mm_div_ps(VecOne, Det0);

		mOut.C1 = _mm_mul_ps(Inv0, Rcp0);
		mOut.C2 = _mm_mul_ps(Inv1, Rcp0);
		mOut.C3 = _mm_mul_ps(Inv2, Rcp0);
		mOut.C4 = _mm_mul_ps(Inv3, Rcp0);

		float retVal;
		_mm_store_ss(&retVal, Det0);
		return retVal;
	}

}
#endif

/***********************************************************************
CORELIB\WIDECHAR.CPP
***********************************************************************/
#ifndef SPIRE_NO_CORE_LIB
#include <locale.h>

#define _CRT_SECUIRE_NO_WARNINGS

class DefaultLocaleSetter
{
public:
	DefaultLocaleSetter()
	{
		setlocale(LC_ALL, ""); 
	};
};


char * WideCharToMByte(const wchar_t * buffer, int length)
{
	size_t requiredBufferSize;
#ifdef _MSC_VER
	wcstombs_s(&requiredBufferSize, nullptr, 0, buffer, length);
#else
	requiredBufferSize = std::wcstombs(nullptr, buffer, 0);
#endif
	if (requiredBufferSize > 0)
	{
		char * multiByteBuffer = new char[requiredBufferSize + 1];
#ifdef _MSC_VER
		wcstombs_s(&requiredBufferSize, multiByteBuffer, requiredBufferSize, buffer, length);
		auto pos = requiredBufferSize;
#else
		auto pos = std::wcstombs(multiByteBuffer, buffer, requiredBufferSize + 1);
#endif
		if (pos <= requiredBufferSize)
			multiByteBuffer[pos] = 0;
		return multiByteBuffer;
	}
	else
		return 0;
}

wchar_t * MByteToWideChar(const char * buffer, int length)
{
	// regard as ansi
#ifdef _MSC_VER
	size_t bufferSize;
	mbstowcs_s((size_t*)&bufferSize, nullptr, 0, buffer, length);
#else
	size_t bufferSize = std::mbstowcs(nullptr, buffer, 0);
#endif
	if (bufferSize > 0)
	{
		wchar_t * rbuffer = new wchar_t[bufferSize +1];
		size_t pos;
#ifdef _MSC_VER
		mbstowcs_s(&pos, rbuffer, bufferSize, buffer, length);
#else
		pos = std::mbstowcs(rbuffer, buffer, bufferSize + 1);
#endif
		if (pos <= bufferSize)
			rbuffer[pos] = 0;
		return rbuffer;
	}
	else
		return 0;
}

void MByteToWideChar(wchar_t * buffer, int bufferSize, const char * str, int length)
{
#ifdef _MSC_VER
	size_t pos;
	mbstowcs_s(&pos, buffer, bufferSize, str, length);
#else
	std::mbstowcs(buffer, str, bufferSize);
#endif
}
#endif

/***********************************************************************
CORELIB\REGEX\METALEXER.CPP
***********************************************************************/
#ifndef SPIRE_NO_CORE_LIB


namespace CoreLib
{
namespace Text
{
	MetaLexer::MetaLexer()
	{
	}

	MetaLexer::MetaLexer(String profile)
	{
		SetLexProfile(profile);
	}

	String MetaLexer::GetTokenName(int id)
	{
		return TokenNames[id];
	}

	int MetaLexer::GetRuleCount()
	{
		return TokenNames.Count();
	}

	void MetaLexer::SetLexProfile(String lex)
	{
		Errors.Clear();
		ParseLexProfile(lex);
		if (!Errors.Count())
			ConstructDFA();
		else
			dfa = 0;
	}

	bool IsWhiteSpace(wchar_t ch)
	{
		return (ch == L' ' || ch == L'\t' || ch == L'\n' || ch == L'\r' || ch == L'\v');
	}

	bool IsIdent(wchar_t ch)
	{
		return ((ch >=L'A' && ch <= L'Z') || (ch >= L'a' && ch<=L'z') || (ch>=L'0' && ch<=L'9')
			|| ch == L'_' || ch==L'#');
	}

	bool IsLetter(wchar_t ch)
	{
		return ((ch >=L'A' && ch <= L'Z') || (ch >= L'a' && ch<=L'z') || ch == L'_' || ch==L'#');
	}

	bool MetaLexer::ParseLexProfile(const CoreLib::String & lex)
	{
		LinkedList<LexProfileToken> tokens;
		int ptr = 0;
		int state = 0;
		StringBuilder curToken;
		while (ptr < lex.Length())
		{
			wchar_t curChar = lex[ptr];
			wchar_t nextChar = 0;
			if (ptr+1<lex.Length())
				nextChar = lex[ptr+1];
			switch (state)
			{
			case 0:
				{
					if (IsLetter(curChar))
						state = 1;
					else if (IsWhiteSpace(curChar))
						ptr ++;
					else if (curChar == L'{')
					{
						state = 2;
						ptr ++;
					}
					else if (curChar == L'=')
						state = 3;
					else if (curChar == L'/' && nextChar == L'/')
						state = 4;
					else
					{
						LexerError err;
						err.Position = ptr;
						err.Text = String(L"[Profile Error] Illegal character \'") + curChar + L"\'";
						Errors.Add(err);
						ptr ++;
					}
					curToken.Clear();
				}
				break;
			case 1:
				{
					if (IsIdent(curChar))
					{
						curToken.Append(curChar);
						ptr ++;
					}
					else
					{
						LexProfileToken tk;
						tk.str = curToken.ToString();
						tk.type = LexProfileToken::Identifier;
						tokens.AddLast(tk);
						state = 0;
					}
				}
				break;
			case 2:
				{
					if (curChar == L'}' && (nextChar == L'\r' || nextChar == L'\n' || nextChar == 0) )
					{
						LexProfileToken tk;
						tk.str = curToken.ToString();
						tk.type = LexProfileToken::Regex;
						tokens.AddLast(tk);
						ptr ++;
						state = 0;
					}
					else
					{
						curToken.Append(curChar);
						ptr ++;
					}
				}
				break;
			case 3:
				{
					LexProfileToken tk;
					tk.str = curChar;
					tk.type = LexProfileToken::Equal;
					tokens.AddLast(tk);
					ptr ++;
					state = 0;
				}
				break;
			case 4:
				{
					if (curChar == L'\n')
						state = 0;
					else
						ptr ++;
				}
			}
		}

		// Parse tokens
		LinkedNode<LexProfileToken> * l = tokens.FirstNode();
		state = 0;
		String curName, curRegex;
		try
		{
			TokenNames.Clear();
			Regex.Clear();
			while (l)
			{
				curName = ReadProfileToken(l, LexProfileToken::Identifier);
				l = l->GetNext();
				ReadProfileToken(l, LexProfileToken::Equal);
				l = l->GetNext();
				curRegex = ReadProfileToken(l, LexProfileToken::Regex);
				l = l->GetNext();
				TokenNames.Add(curName);
				Regex.Add(curRegex);
				if (curName[0] == L'#')
					Ignore.Add(true);
				else
					Ignore.Add(false);
			}
		}
		catch(int)
		{
			return false;
		}
		return true;
	}

	String MetaLexer::ReadProfileToken(LexProfileTokenNode*n, LexProfileToken::LexProfileTokenType type)
	{
		if (n && n->Value.type == type)
		{
			return n->Value.str;
		}
		else
		{
			String name = L"[Profile Error] ";
			switch (type)
			{
			case LexProfileToken::Equal:
				name = L"\'=\'";
				break;
			case LexProfileToken::Identifier:
				name = L"Token identifier";
				break;
			case LexProfileToken::Regex:
				name = L"Regular expression";
				break;
			}
			name = name + L" expected.";
			LexerError err;
			err.Text = name;
			err.Position = 0;
			Errors.Add(err);
			throw 0;
		}
	}

	DFA_Table * MetaLexer::GetDFA()
	{
		return dfa.operator->();
	}

	void MetaLexer::ConstructDFA()
	{
		RegexParser parser;
		NFA_Graph nfa;
		NFA_Node * node = nfa.CreateNode();
		nfa.SetStartNode(node);
		for (int i=0; i<Regex.Count(); i++)
		{
			RefPtr<RegexNode> tree = parser.Parse(Regex[i]);
			if (tree)
			{
				NFA_Graph cNfa;
				cNfa.GenerateFromRegexTree(tree.operator->(), true);
				cNfa.SetTerminalIdentifier(i);
				nfa.CombineNFA(&cNfa);
				NFA_Translation * trans = nfa.CreateTranslation();
				trans->NodeDest = cNfa.GetStartNode();
				trans->NodeSrc = node;
				trans->NodeDest->PrevTranslations.Add(trans);
				trans->NodeSrc->Translations.Add(trans);
			}
			else
			{
				LexerError err;
				err.Position = 0;
				err.Text = L"Illegal regex for \"" + String(TokenNames[i]) + L"\"";
				Errors.Add(err);
				return;
			}
		}
		nfa.PostGenerationProcess();
		DFA_Graph dfaGraph;
		dfaGraph.Generate(&nfa);
		dfa = new DFA_Table();
		dfaGraph.ToDfaTable(dfa.operator ->());
	}

	LazyLexStream::Iterator & LazyLexStream::Iterator::operator ++()
	{
		auto &str = stream->InputText;
		auto sDfa = stream->GetDFA();
		auto & ignore = stream->GetIgnoreSet();
		if (lastTokenPtr == str.Length())
		{
			lastTokenPtr = -1;
			return *this;
		}

		int lastAcceptState = -1;
		int lastAcceptPtr = -1;
		while (ptr < str.Length())
		{
			if (sDfa->Tags[state]->IsFinal)
			{
				lastAcceptState = state;
				lastAcceptPtr = ptr;
			}
			Word charClass = (*sDfa->CharTable)[str[ptr]];
			if (charClass == 0xFFFF)
			{
				ptr++;
				continue;
			}
			int nextState = sDfa->DFA[state][charClass];
			if (nextState >= 0)
			{
				state = nextState;
				ptr++;
			}
			else
			{
				if (lastAcceptState != -1)
				{
					state = lastAcceptState;
					ptr = lastAcceptPtr;
					
					
					if (!ignore[sDfa->Tags[state]->TerminalIdentifiers[0]])
					{
						currentToken.Length = ptr - lastTokenPtr;
						currentToken.TypeID = sDfa->Tags[state]->TerminalIdentifiers[0];
						currentToken.Position = lastTokenPtr;
						state = sDfa->StartState;
						lastTokenPtr = ptr;
						lastAcceptState = -1;
						lastAcceptPtr = -1;
						break;
					}
					state = sDfa->StartState;
					lastTokenPtr = ptr;
					lastAcceptState = -1;
					lastAcceptPtr = -1;
				}
				else
				{
					ptr++;
					lastAcceptState = lastAcceptPtr = -1;
					lastTokenPtr = ptr;
					state = sDfa->StartState;
					continue;
				}
			}
		}
		if (ptr == str.Length())
		{
			if (sDfa->Tags[state]->IsFinal &&
				!ignore[sDfa->Tags[state]->TerminalIdentifiers[0]])
			{
				currentToken.Length = ptr - lastTokenPtr;
				currentToken.TypeID = sDfa->Tags[state]->TerminalIdentifiers[0];
				currentToken.Position = lastTokenPtr;
			}
			else
			{
				currentToken.Length = 0;
				currentToken.TypeID = -1;
				currentToken.Position = lastTokenPtr;
			}
			lastTokenPtr = ptr;
		}
		
		return *this;
	}

	bool MetaLexer::Parse(String str, LexStream & stream)
	{
		TokensParsed = 0;
		if (!dfa)
			return false;
		int ptr = 0;
		int lastAcceptState = -1;
		int lastAcceptPtr = -1;
		int lastTokenPtr = 0;
		int state = dfa->StartState;
		while (ptr<str.Length())
		{
			if (dfa->Tags[state]->IsFinal)
			{
				lastAcceptState = state;
				lastAcceptPtr = ptr;
			}
			Word charClass = (*dfa->CharTable)[str[ptr]];
			if (charClass == 0xFFFF)
			{
				LexerError err;
				err.Text = String(L"Illegal character \'") + str[ptr] + L"\'";
				err.Position = ptr;
				Errors.Add(err);
				ptr++;
				continue;
			}
			int nextState = dfa->DFA[state][charClass];
			if (nextState >= 0)
			{
				state = nextState;
				ptr++;
			}
			else
			{
				if (lastAcceptState != -1)
				{
					state = lastAcceptState;
					ptr = lastAcceptPtr;
					if (!Ignore[dfa->Tags[state]->TerminalIdentifiers[0]])
					{
						LexToken tk;
						tk.Str = str.SubString(lastTokenPtr, ptr-lastTokenPtr);
						tk.TypeID = dfa->Tags[state]->TerminalIdentifiers[0];
						tk.Position = lastTokenPtr;
						stream.AddLast(tk);
					}
					TokensParsed ++;
					lastTokenPtr = ptr;
					state = dfa->StartState;
					lastAcceptState = -1;
					lastAcceptPtr = -1;
				}
				else
				{
					LexerError err;
					err.Text = L"Illegal token \'" +
						str.SubString(lastTokenPtr, ptr-lastTokenPtr) + L"\'";
					err.Position = ptr;
					Errors.Add(err);
					ptr++;
					lastAcceptState = lastAcceptPtr = -1;
					lastTokenPtr = ptr;
					state = dfa->StartState;
					continue;
				}
			}
		}

		if (dfa->Tags[state]->IsFinal &&
			!Ignore[dfa->Tags[state]->TerminalIdentifiers[0]])
		{
			LexToken tk;
			tk.Str = str.SubString(lastTokenPtr, ptr-lastTokenPtr);
			tk.TypeID = dfa->Tags[state]->TerminalIdentifiers[0];
			stream.AddLast(tk);
			TokensParsed ++;
		}
		return (Errors.Count() == 0);
	}
}
}
#endif

/***********************************************************************
CORELIB\REGEX\REGEX.CPP
***********************************************************************/
#ifndef SPIRE_NO_CORE_LIB

namespace CoreLib
{
namespace Text
{
	RegexMatcher::RegexMatcher(DFA_Table * table)
		:dfa(table)
	{
	}

	int RegexMatcher::Match(const String & str, int startPos)
	{
		int state = dfa->StartState;
		if (state == -1)
			return -1;
		for (int i=startPos; i<str.Length(); i++)
		{
			Word charClass = (*dfa->CharTable)[str[i]];
			if (charClass == 0xFFFF)
				return -1;
			int nextState = dfa->DFA[state][charClass];
			if (nextState == -1)
			{
				if (dfa->Tags[state]->IsFinal)
					return i-startPos;
				else
					return -1;
			}
			else
				state = nextState;
		}
		if (dfa->Tags[state]->IsFinal)
			return str.Length()-startPos;
		else
			return -1;
	}

	DFA_Table * PureRegex::GetDFA()
	{
		return dfaTable.operator->();
	}

	PureRegex::PureRegex(const String & regex)
	{
		RegexParser p;
		RefPtr<RegexNode> tree = p.Parse(regex);
		if (tree)
		{
			NFA_Graph nfa;
			nfa.GenerateFromRegexTree(tree.operator ->());
			DFA_Graph dfa;
			dfa.Generate(&nfa);
			dfaTable = new DFA_Table();
			dfa.ToDfaTable(dfaTable.operator->());
		}
		else
		{
			IllegalRegexException ex;
			if (p.Errors.Count())
				ex.Message = p.Errors[0].Text;
			throw ex;
		}
	}

	bool PureRegex::IsMatch(const String & str)
	{
		RegexMatcher matcher(dfaTable.operator->());
		return (matcher.Match(str, 0)==str.Length());
	}

	PureRegex::RegexMatchResult PureRegex::Search(const String & str, int startPos)
	{
		RegexMatcher matcher(dfaTable.operator ->());
		for (int i=startPos; i<str.Length(); i++)
		{
			int len = matcher.Match(str, i);
			if (len >= 0)
			{
				RegexMatchResult rs;
				rs.Start = i;
				rs.Length = len;
				return rs;
			}
		}
		RegexMatchResult rs;
		rs.Start = 0;
		rs.Length = -1;
		return rs;
	}
}
}
#endif

/***********************************************************************
CORELIB\REGEX\REGEXDFA.CPP
***********************************************************************/
#ifndef SPIRE_NO_CORE_LIB

namespace CoreLib
{
namespace Text
{
	CharTableGenerator::CharTableGenerator(RegexCharTable * _table)
		: table(_table)
	{
		table->SetSize(65536);
		memset(table->Buffer(),0,sizeof(Word)*table->Count());
	}

	DFA_Table_Tag::DFA_Table_Tag()
	{
		IsFinal = false;
	}

	int CharTableGenerator::AddSet(String set)
	{
		int fid = sets.IndexOf(set);
		if (fid != -1)
			return fid;
		else
		{
			sets.Add(set);
			return sets.Count()-1;
		}
	}

	int CharTableGenerator::Generate(List<RegexCharSet *> & charSets)
	{
		/*List<RegexCharSet *> cs;
		cs.SetCapacity(charSets.Count());
		String str;
		str.Alloc(1024);
		for (int i=1; i<65536; i++)
		{
			str = L"";
			cs.Clear();
			for (int j=0; j<charSets.Count(); j++)
			{
				if (charSets[j]->Contains(i))
				{
					str += (wchar_t)(j+1);
					cs.Add(charSets[j]);
				}
			}
			int lastCount = sets.Count();
			if (str.Length())
			{
				int id = AddSet(str);
				if (id == lastCount)
				{
					for (int j=0; j<cs.Count(); j++)
						cs[j]->Elements.Add(id);
				}
				(*table)[i] = id;
			}
			else
				(*table)[i] = 0xFFFF;
		}
		return sets.Count();*/
		
		RegexCharSet::CalcCharElements(charSets, elements);
		for (int i=0; i<table->Count(); i++)
			(*table)[i] = 0xFFFF;
		Word* buf = table->Buffer();
		for (int i=0; i<elements.Count(); i++)
		{
			for (int k=elements[i].Begin; k<=elements[i].End; k++)	
			{
#ifdef _DEBUG
				if ((*table)[k] != 0xFFFF)
				{
					throw L"Illegal subset generation."; // This indicates a bug.
				}
#endif
				buf[k] = (Word)i;
			}
		}
		return elements.Count();
	}

	DFA_Node::DFA_Node(int elements)
	{
		Translations.SetSize(elements);
		for (int i=0; i<elements; i++)
			Translations[i] = 0;
	}

	void DFA_Graph::CombineCharElements(NFA_Node * node, List<Word> & elem)
	{
		for (int i=0; i<node->Translations.Count(); i++)
		{
			for (int j=0; j<node->Translations[i]->CharSet->Elements.Count(); j++)
			{
				if (elem.IndexOf(node->Translations[i]->CharSet->Elements[j]) == -1)
					elem.Add(node->Translations[i]->CharSet->Elements[j]);
			}
		}
	}

	void DFA_Graph::Generate(NFA_Graph * nfa)
	{
		table = new RegexCharTable();
		List<RegexCharSet * > charSets;
		for (int i=0; i<nfa->translations.Count(); i++)
		{
			if (nfa->translations[i]->CharSet && nfa->translations[i]->CharSet->Ranges.Count())
				charSets.Add(nfa->translations[i]->CharSet.operator->());
		}
		CharTableGenerator gen(table.operator ->());
		int elements = gen.Generate(charSets);
		CharElements = gen.elements;
		List<DFA_Node *> L,D;
		startNode = new DFA_Node(elements);
		startNode->ID = 0;
		startNode->Nodes.Add(nfa->start);
		L.Add(startNode);
		nodes.Add(startNode);
		List<Word> charElem;
		do
		{
			DFA_Node * node = L.Last();
			L.RemoveAt(L.Count()-1);
			charElem.Clear();
			node->IsFinal = false;
			for (int i=0; i<node->Nodes.Count(); i++)
			{
				CombineCharElements(node->Nodes[i], charElem);
				if (node->Nodes[i]->IsFinal)
					node->IsFinal = true;
			}
			for (int i=0; i<charElem.Count(); i++)
			{
				DFA_Node * n = new DFA_Node(0);
				for (int j=0; j<node->Nodes.Count(); j++)
				{
					for (int k=0; k<node->Nodes[j]->Translations.Count(); k++)
					{
						NFA_Translation * trans = node->Nodes[j]->Translations[k];
						if (trans->CharSet->Elements.Contains(charElem[i]))
						{
							if (!n->Nodes.Contains(node->Nodes[j]->Translations[k]->NodeDest))
								n->Nodes.Add(node->Nodes[j]->Translations[k]->NodeDest);
						}
					}
				}
				int fid = -1;
				for (int j=0; j<nodes.Count(); j++)
				{
					if ((*nodes[j]) == *n)
					{
						fid = j;
						break;
					}
				}
				if (fid == -1)
				{
					n->Translations.SetSize(elements);
					for (int m=0; m<elements; m++)
						n->Translations[m] = 0;
					n->ID = nodes.Count();
					L.Add(n);
					nodes.Add(n);
					fid = nodes.Count()-1;
				}
				else
					delete n;
				n = nodes[fid].operator ->();
				node->Translations[charElem[i]] = n;
			}
		}
		while (L.Count());

		// Set Terminal Identifiers
		HashSet<int> terminalIdentifiers;
		for (int i=0; i<nodes.Count(); i++)
		{
			terminalIdentifiers.Clear();
			for (int j=0; j<nodes[i]->Nodes.Count(); j++)
			{
				if (nodes[i]->Nodes[j]->IsFinal && 
					!terminalIdentifiers.Contains(nodes[i]->Nodes[j]->TerminalIdentifier))
				{
					nodes[i]->IsFinal = true;
					terminalIdentifiers.Add(nodes[i]->Nodes[j]->TerminalIdentifier);
					nodes[i]->TerminalIdentifiers.Add(nodes[i]->Nodes[j]->TerminalIdentifier);
				}
			}
			nodes[i]->TerminalIdentifiers.Sort();
		}
	}

	bool DFA_Node::operator == (const DFA_Node & node)
	{
		if (Nodes.Count() != node.Nodes.Count())
			return false;
		for (int i=0; i<node.Nodes.Count(); i++)
		{
			if (node.Nodes[i] != Nodes[i])
				return false;
		}
		return true;
	}

	String DFA_Graph::Interpret()
	{
		StringBuilder sb(4096000);
		for (int i=0; i<nodes.Count(); i++)
		{
			if (nodes[i]->IsFinal)
				sb.Append(L'#');
			else if (nodes[i] == startNode)
				sb.Append(L'*');
			sb.Append(String(nodes[i]->ID));
			sb.Append(L'(');
			for (int j=0; j<nodes[i]->Nodes.Count(); j++)
			{
				sb.Append(String(nodes[i]->Nodes[j]->ID));
				sb.Append(L" ");
			}
			sb.Append(L")\n");
			for (int j=0; j<nodes[i]->Translations.Count(); j++)
			{
				if (nodes[i]->Translations[j])
				{
					sb.Append(L"\tOn ");
					sb.Append(String(j));
					sb.Append(L": ");
					sb.Append(String(nodes[i]->Translations[j]->ID));
					sb.Append(L'\n');
				}
			}
		}

		sb.Append(L"\n\n==================\n");
		sb.Append(L"Char Set Table:\n");
		for (int i=0; i<CharElements.Count(); i++)
		{
			sb.Append(L"Class ");
			sb.Append(String(i));
			sb.Append(L": ");
			RegexCharSet s;
			s.Ranges.Add(CharElements[i]);
			sb.Append(s.Reinterpret());
			sb.Append(L"\n");
		}
		return sb.ProduceString();
	}

	void DFA_Graph::ToDfaTable(DFA_Table * dfa)
	{
		dfa->CharTable = table;
		dfa->DFA = new int*[nodes.Count()];
		dfa->Tags.SetSize(nodes.Count());
		for (int i=0; i<nodes.Count(); i++)
			dfa->Tags[i] = new DFA_Table_Tag();
		dfa->StateCount = nodes.Count();
		dfa->AlphabetSize = CharElements.Count();
		for (int i=0; i<nodes.Count(); i++)
		{
			dfa->DFA[i] = new int[table->Count()];
			for (int j=0; j<nodes[i]->Translations.Count(); j++)
			{
				if (nodes[i]->Translations[j])
					dfa->DFA[i][j] = nodes[i]->Translations[j]->ID;
				else
					dfa->DFA[i][j] = -1;
			}
			if (nodes[i] == startNode)
				dfa->StartState = i;
			if (nodes[i]->IsFinal)
			{
				dfa->Tags[i]->IsFinal = true;
				dfa->Tags[i]->TerminalIdentifiers = nodes[i]->TerminalIdentifiers;
			}
		}
	}

	DFA_Table::DFA_Table()
	{
		DFA = 0;
		StateCount = 0;
		AlphabetSize = 0;
		StartState = -1;
	}
	
	DFA_Table::~DFA_Table()
	{
		if (DFA)
		{
			for (int i=0; i<StateCount; i++)
				delete [] DFA[i];
			delete [] DFA;
		}
	}
}
}
#endif

/***********************************************************************
CORELIB\REGEX\REGEXNFA.CPP
***********************************************************************/
#ifndef SPIRE_NO_CORE_LIB

namespace CoreLib
{
namespace Text
{
	int NFA_Node::HandleCount = 0;

	NFA_Translation::NFA_Translation(NFA_Node * src, NFA_Node * dest, RefPtr<RegexCharSet> charSet)
		: CharSet(charSet), NodeSrc(src), NodeDest(dest)
	{}

	NFA_Translation::NFA_Translation()
	{
		NodeSrc = NodeDest = 0;
	}

	NFA_Translation::NFA_Translation(NFA_Node * src, NFA_Node * dest)
		: NodeSrc(src), NodeDest(dest)
	{
	}

	NFA_Node::NFA_Node()
		: Flag(false), IsFinal(false), TerminalIdentifier(0)
	{
		HandleCount ++;
		ID = HandleCount;
	}

	void NFA_Node::RemoveTranslation(NFA_Translation * trans)
	{
		int fid = Translations.IndexOf(trans);
		if (fid != -1)
			Translations.RemoveAt(fid);
	}

	void NFA_Node::RemovePrevTranslation(NFA_Translation * trans)
	{
		int fid = PrevTranslations.IndexOf(trans);
		if (fid != -1)
			PrevTranslations.RemoveAt(fid);
	}

	NFA_Node * NFA_Graph::CreateNode()
	{
		NFA_Node * nNode = new NFA_Node();
		nodes.Add(nNode);
		return nNode;
	}

	NFA_Translation * NFA_Graph::CreateTranslation()
	{
		NFA_Translation * trans = new NFA_Translation();
		translations.Add(trans);
		return trans;
	}

	void NFA_Graph::ClearNodes()
	{
		for (int i=0; i<nodes.Count(); i++)
			nodes[i] = 0;
		for (int i=0; i<translations.Count(); i++)
			translations[i] = 0;
		nodes.Clear();
		translations.Clear();
	}

	void NFA_Graph::GenerateFromRegexTree(RegexNode * tree, bool elimEpsilon)
	{
		NFA_StatePair s;
		tree->Accept(this);
		s = PopState();
		start = s.start;
		end = s.end;
		end->IsFinal = true;

		if (elimEpsilon)
		{
			PostGenerationProcess();
		}

	}

	void NFA_Graph::PostGenerationProcess()
	{
		EliminateEpsilon();
		for (int i=0; i<translations.Count(); i++)
		{
			if (translations[i]->CharSet)
				translations[i]->CharSet->Normalize();
			else
			{
				translations[i] = 0;
				translations.RemoveAt(i);
				i--;
			}
		}
	}

	NFA_Node * NFA_Graph::GetStartNode()
	{
		return start;
	}

	void NFA_Graph::PushState(NFA_StatePair s)
	{
		stateStack.Add(s);
	}

	NFA_Graph::NFA_StatePair NFA_Graph::PopState()
	{
		NFA_StatePair s = stateStack.Last();
		stateStack.RemoveAt(stateStack.Count()-1);
		return s;
	}

	void NFA_Graph::VisitCharSetNode(RegexCharSetNode * node)
	{
		NFA_StatePair s;
		s.start = CreateNode();
		s.end = CreateNode();
		NFA_Translation * trans = CreateTranslation();
		trans->CharSet = node->CharSet;
		trans->NodeSrc = s.start;
		trans->NodeDest = s.end;
		s.start->Translations.Add(trans);
		s.end->PrevTranslations.Add(trans);
		PushState(s);
	}

	void NFA_Graph::VisitRepeatNode(RegexRepeatNode * node)
	{
		NFA_StatePair sr;
		sr.start = sr.end = nullptr;
		node->Child->Accept(this);
		NFA_StatePair s = PopState();
		if (node->RepeatType == RegexRepeatNode::rtArbitary)
		{
			sr.start = CreateNode();
			sr.end = CreateNode();

			NFA_Translation * trans = CreateTranslation();
			trans->NodeSrc = sr.start;
			trans->NodeDest = sr.end;
			sr.start->Translations.Add(trans);
			sr.end->PrevTranslations.Add(trans);
			
			NFA_Translation * trans1 = CreateTranslation();
			trans1->NodeSrc = sr.end;
			trans1->NodeDest = s.start;
			sr.end->Translations.Add(trans1);
			s.start->PrevTranslations.Add(trans1);

			NFA_Translation * trans2 = CreateTranslation();
			trans2->NodeSrc = s.end;
			trans2->NodeDest = sr.end;
			s.end->Translations.Add(trans2);
			sr.end->PrevTranslations.Add(trans2);
		}
		else if (node->RepeatType == RegexRepeatNode::rtOptional)
		{
			sr = s;

			NFA_Translation * trans = CreateTranslation();
			trans->NodeSrc = sr.start;
			trans->NodeDest = sr.end;
			sr.start->Translations.Add(trans);
			sr.end->PrevTranslations.Add(trans);
		}
		else if (node->RepeatType == RegexRepeatNode::rtMoreThanOnce)
		{
			sr = s;

			NFA_Translation * trans = CreateTranslation();
			trans->NodeSrc = sr.end;
			trans->NodeDest = sr.start;
			sr.start->PrevTranslations.Add(trans);
			sr.end->Translations.Add(trans);
		}
		else if (node->RepeatType == RegexRepeatNode::rtSpecified)
		{
			if (node->MinRepeat == 0)
			{
				if (node->MaxRepeat > 0)
				{
					for (int i=1; i<node->MaxRepeat; i++)
					{
						node->Child->Accept(this);
						NFA_StatePair s1 = PopState();
						NFA_Translation * trans = CreateTranslation();
						trans->NodeDest = s1.start;
						trans->NodeSrc = s.end;
						trans->NodeDest->PrevTranslations.Add(trans);
						trans->NodeSrc->Translations.Add(trans);

						trans = CreateTranslation();
						trans->NodeDest = s1.start;
						trans->NodeSrc = s.start;
						trans->NodeDest->PrevTranslations.Add(trans);
						trans->NodeSrc->Translations.Add(trans);

						s.end = s1.end;
					}
					NFA_Translation * trans = CreateTranslation();
					trans->NodeDest = s.end;
					trans->NodeSrc = s.start;
					trans->NodeDest->PrevTranslations.Add(trans);
					trans->NodeSrc->Translations.Add(trans);
					sr = s;
				}
				else if (node->MaxRepeat == 0)
				{
					sr.start = CreateNode();
					sr.end = CreateNode();
					NFA_Translation * trans = CreateTranslation();
					trans->NodeDest = sr.end;
					trans->NodeSrc = sr.start;
					trans->NodeDest->PrevTranslations.Add(trans);
					trans->NodeSrc->Translations.Add(trans);
				}
				else
				{
					// Arbitary repeat
					sr.start = CreateNode();
					sr.end = CreateNode();

					NFA_Translation * trans = CreateTranslation();
					trans->NodeSrc = sr.start;
					trans->NodeDest = sr.end;
					sr.start->Translations.Add(trans);
					sr.end->PrevTranslations.Add(trans);
					
					NFA_Translation * trans1 = CreateTranslation();
					trans1->NodeSrc = sr.end;
					trans1->NodeDest = s.start;
					sr.end->Translations.Add(trans1);
					s.start->PrevTranslations.Add(trans1);

					NFA_Translation * trans2 = CreateTranslation();
					trans2->NodeSrc = s.end;
					trans2->NodeDest = sr.end;
					s.end->Translations.Add(trans2);
					sr.end->PrevTranslations.Add(trans2);
				}
			}
			else
			{
				NFA_Node * lastBegin = s.start;
				for (int i=1; i<node->MinRepeat; i++)
				{
					node->Child->Accept(this);
					NFA_StatePair s1 = PopState();
					NFA_Translation * trans = CreateTranslation();
					trans->NodeDest = s1.start;
					trans->NodeSrc = s.end;
					trans->NodeDest->PrevTranslations.Add(trans);
					trans->NodeSrc->Translations.Add(trans);
					s.end = s1.end;
					lastBegin = s1.start;
				}
				if (node->MaxRepeat == -1)
				{
					NFA_Translation * trans = CreateTranslation();
					trans->NodeDest = lastBegin;
					trans->NodeSrc = s.end;
					trans->NodeDest->PrevTranslations.Add(trans);
					trans->NodeSrc->Translations.Add(trans);
				}
				else if (node->MaxRepeat > node->MinRepeat)
				{
					lastBegin = s.end;
					for (int i=node->MinRepeat; i<node->MaxRepeat; i++)
					{
						node->Child->Accept(this);
						NFA_StatePair s1 = PopState();
						NFA_Translation * trans = CreateTranslation();
						trans->NodeDest = s1.start;
						trans->NodeSrc = s.end;
						trans->NodeDest->PrevTranslations.Add(trans);
						trans->NodeSrc->Translations.Add(trans);

						trans = CreateTranslation();
						trans->NodeDest = s1.start;
						trans->NodeSrc = lastBegin;
						trans->NodeDest->PrevTranslations.Add(trans);
						trans->NodeSrc->Translations.Add(trans);

						s.end = s1.end;
					}

					NFA_Translation * trans = CreateTranslation();
					trans->NodeDest = s.end;
					trans->NodeSrc = lastBegin;
					trans->NodeDest->PrevTranslations.Add(trans);
					trans->NodeSrc->Translations.Add(trans);
				}

				sr = s;
			}
			
		}
		PushState(sr);
	}

	void NFA_Graph::VisitSelectionNode(RegexSelectionNode * node)
	{
		NFA_StatePair s, s1, sr;
		sr.start = CreateNode();
		sr.end = CreateNode();
		s.start = sr.start;
		s.end = sr.end;
		s1.start = sr.start;
		s1.end = sr.end;
		if (node->LeftChild)
		{
			node->LeftChild->Accept(this);
			s = PopState();
		}
		if (node->RightChild)
		{
			node->RightChild->Accept(this);
			s1 = PopState();
		}
		
		NFA_Translation * trans;
		trans = CreateTranslation();
		trans->NodeSrc = sr.start;
		trans->NodeDest = s.start;
		sr.start->Translations.Add(trans);
		s.start->PrevTranslations.Add(trans);

		trans = CreateTranslation();
		trans->NodeSrc = sr.start;
		trans->NodeDest = s1.start;
		sr.start->Translations.Add(trans);
		s1.start->PrevTranslations.Add(trans);

		trans = CreateTranslation();
		trans->NodeSrc = s.end;
		trans->NodeDest = sr.end;
		s.end->Translations.Add(trans);
		sr.end->PrevTranslations.Add(trans);

		trans = CreateTranslation();
		trans->NodeSrc = s1.end;
		trans->NodeDest = sr.end;
		s1.end->Translations.Add(trans);
		sr.end->PrevTranslations.Add(trans);

		PushState(sr);
	}

	void NFA_Graph::VisitConnectionNode(RegexConnectionNode * node)
	{
		NFA_StatePair s, s1;
		node->LeftChild->Accept(this);
		s = PopState();
		node->RightChild->Accept(this);
		s1 = PopState();
		NFA_Translation * trans = CreateTranslation();
		trans->NodeDest = s1.start;
		trans->NodeSrc = s.end;
		s.end->Translations.Add(trans);
		s1.start->PrevTranslations.Add(trans);
		s.end = s1.end;
		PushState(s);
		
	}

	void NFA_Graph::ClearNodeFlags()
	{
		for (int i=0; i<nodes.Count(); i++)
			nodes[i]->Flag = false;
	}

	void NFA_Graph::GetValidStates(List<NFA_Node *> & states)
	{
		RefPtr<List<NFA_Node *>> list1 = new List<NFA_Node *>();
		RefPtr<List<NFA_Node *>> list2 = new List<NFA_Node *>();
		list1->Add(start);
		states.Add(start);
		ClearNodeFlags();
		while (list1->Count())
		{
			list2->Clear();
			for (int i=0; i<list1->Count(); i++)
			{
				bool isValid = false;
				NFA_Node * curNode = (*list1)[i];
				curNode->Flag = true;
				for (int j=0; j<curNode->PrevTranslations.Count(); j++)
				{
					if (curNode->PrevTranslations[j]->CharSet)
					{
						isValid = true;
						break;
					}
					
				}
				if (isValid)
					states.Add(curNode);
				for (int j=0; j<curNode->Translations.Count(); j++)
				{
					if (!curNode->Translations[j]->NodeDest->Flag)
					{
						list2->Add(curNode->Translations[j]->NodeDest);
					}
				}
			}
			RefPtr<List<NFA_Node *>> tmp = list1;
			list1 = list2;
			list2 = tmp;
		}
	}

	void NFA_Graph::GetEpsilonClosure(NFA_Node * node, List<NFA_Node *> & states)
	{
		RefPtr<List<NFA_Node *>> list1 = new List<NFA_Node *>();
		RefPtr<List<NFA_Node *>> list2 = new List<NFA_Node *>();
		list1->Add(node);
		ClearNodeFlags();
		while (list1->Count())
		{
			list2->Clear();
			for (int m=0; m<list1->Count(); m++)
			{
				NFA_Node * curNode = (*list1)[m];
				for (int i=0; i<curNode->Translations.Count(); i++)
				{
					
					if (!curNode->Translations[i]->CharSet)
					{
						if (!curNode->Translations[i]->NodeDest->Flag)
						{
							states.Add(curNode->Translations[i]->NodeDest);
							list2->Add(curNode->Translations[i]->NodeDest);
							curNode->Translations[i]->NodeDest->Flag = true;
						}
					}
				}
			}
			RefPtr<List<NFA_Node *>> tmp = list1;
			list1 = list2;
			list2 = tmp;
		}
	}

	void NFA_Graph::EliminateEpsilon()
	{
		List<NFA_Node *> validStates;
		GetValidStates(validStates);
		for (int i=0; i<validStates.Count(); i++)
		{
			NFA_Node * curState = validStates[i];
			List<NFA_Node *> closure;
			GetEpsilonClosure(curState, closure);
			// Add translations from epsilon closures
			for (int j=0; j<closure.Count(); j++)
			{
				NFA_Node * curNode = closure[j];
				for (int k=0; k<curNode->Translations.Count(); k++)
				{
					if (curNode->Translations[k]->CharSet)
					{
						// Generate a translation from curState to curNode->Dest[k]
						NFA_Translation * trans = CreateTranslation();
						trans->CharSet = curNode->Translations[k]->CharSet;
						trans->NodeSrc = curState;
						trans->NodeDest = curNode->Translations[k]->NodeDest;
						curState->Translations.Add(trans);
						trans->NodeDest->PrevTranslations.Add(trans);
					}
				}
				if (curNode == end)
				{
					curState->IsFinal = true;
					curState->TerminalIdentifier = end->TerminalIdentifier;
				}
			}
		}
		// Remove epsilon-translations and invalid states
		ClearNodeFlags();
		for (int i=0; i<validStates.Count(); i++)
		{
			validStates[i]->Flag = true;
		}
		for (int i=0; i<nodes.Count(); i++)
		{
			if (!nodes[i]->Flag)
			{
				// Remove invalid state
				for (int j=0; j<nodes[i]->PrevTranslations.Count(); j++)
				{
					NFA_Translation * trans = nodes[i]->PrevTranslations[j];
					trans->NodeSrc->RemoveTranslation(trans);
					int fid = translations.IndexOf(trans);
					if (fid != -1)
					{
						translations[fid] = 0;
						translations.RemoveAt(fid);
					}
				}
				for (int j=0; j<nodes[i]->Translations.Count(); j++)
				{
					NFA_Translation * trans = nodes[i]->Translations[j];
					trans->NodeDest->RemovePrevTranslation(trans);
					int fid = translations.IndexOf(trans);
					if (fid != -1)
					{
						translations[fid] = 0;
						translations.RemoveAt(fid);
					}
				}
			}
		}

		for (int i=0; i<validStates.Count(); i++)
		{
			for (int j=0; j<validStates[i]->Translations.Count(); j++)
			{
				NFA_Translation * trans = validStates[i]->Translations[j];
				if (!trans->CharSet)
				{
					validStates[i]->RemoveTranslation(trans);
					trans->NodeDest->RemovePrevTranslation(trans);
					int fid = translations.IndexOf(trans);
					if (fid != -1)
					{
						translations[fid] = 0;
						translations.RemoveAt(fid);
					}
				}
			}
		}

		int ptr = 0;
		while (ptr < nodes.Count())
		{
			if (!nodes[ptr]->Flag)
			{
				nodes[ptr] = 0;
				nodes.RemoveAt(ptr);
			}
			else
				ptr ++;
		}
	}

	String NFA_Graph::Interpret()
	{
		StringBuilder sb(4096);
		for (int i=0; i<nodes.Count(); i++)
		{
			sb.Append(L"State: ");
			if (nodes[i]->IsFinal)
				sb.Append(L"[");
			if (nodes[i] == start)
				sb.Append(L"*");
			sb.Append(String(nodes[i]->ID));
			if (nodes[i]->IsFinal)
				sb.Append(L"]");
			sb.Append(L'\n');
			for (int j=0; j<nodes[i]->Translations.Count(); j++)
			{
				sb.Append(L"\t");
				if (nodes[i]->Translations[j]->CharSet)
					sb.Append(nodes[i]->Translations[j]->CharSet->Reinterpret());
				else
					sb.Append(L"<epsilon>");
				sb.Append(L":");
				sb.Append(String(nodes[i]->Translations[j]->NodeDest->ID));
				sb.Append(L"\n");
			}
		}
		return sb.ProduceString();
		
	}

	void NFA_Graph::SetStartNode(NFA_Node *node)
	{
		start = node;
	}

	void NFA_Graph::CombineNFA(NFA_Graph * graph)
	{
		for (int i=0; i<graph->nodes.Count(); i++)
		{
			nodes.Add(graph->nodes[i]);
		}
		for (int i=0; i<graph->translations.Count(); i++)
		{
			translations.Add(graph->translations[i]);
		}

	}

	void NFA_Graph::SetTerminalIdentifier(int id)
	{
		for (int i=0; i<nodes.Count(); i++)
		{
			if (nodes[i]->IsFinal)
			{
				nodes[i]->TerminalIdentifier = id;
			}
		}
	}
}
}
#endif

/***********************************************************************
CORELIB\REGEX\REGEXPARSER.CPP
***********************************************************************/
#ifndef SPIRE_NO_CORE_LIB

namespace CoreLib
{
namespace Text
{
	RegexCharSetNode::RegexCharSetNode()
	{
		CharSet = new RegexCharSet();
	}

	RefPtr<RegexNode> RegexParser::Parse(const String &regex)
	{
		src = regex;
		ptr = 0;
		try
		{
			return ParseSelectionNode();
		}
		catch (...)
		{
			return 0;
		}
	}

	RegexNode * RegexParser::ParseSelectionNode()
	{
		if (ptr >= src.Length())
			return 0;
		RefPtr<RegexNode> left = ParseConnectionNode();
		while (ptr < src.Length() && src[ptr] == L'|')
		{
			ptr ++;
			RefPtr<RegexNode> right = ParseConnectionNode();
			RegexSelectionNode * rs = new RegexSelectionNode();
			rs->LeftChild = left;
			rs->RightChild = right;
			left = rs;
		}
		return left.Release();
	}

	RegexNode * RegexParser::ParseConnectionNode()
	{
		if (ptr >= src.Length())
		{
			return 0;
		}
		RefPtr<RegexNode> left = ParseRepeatNode();
		while (ptr < src.Length() && src[ptr] != L'|' && src[ptr] != L')')
		{
			RefPtr<RegexNode> right = ParseRepeatNode();
			if (right)
			{
				RegexConnectionNode * reg = new RegexConnectionNode();
				reg->LeftChild = left;
				reg->RightChild = right;
				left = reg;
			}
			else
				break;
		}
		return left.Release();
	}

	RegexNode * RegexParser::ParseRepeatNode()
	{
		if (ptr >= src.Length() || src[ptr] == L')' || src[ptr] == L'|')
			return 0;
		
		RefPtr<RegexNode> content;
		if (src[ptr] == L'(')
		{
			RefPtr<RegexNode> reg;
			ptr ++;
			reg = ParseSelectionNode();
			if (src[ptr] != L')')
			{
				SyntaxError err;
				err.Position = ptr;
				err.Text = L"\')\' expected.";
				Errors.Add(err);
				throw 0;
			}
			ptr ++;
			content = reg.Release();
		}
		else
		{
			RefPtr<RegexCharSetNode> reg;
			if (src[ptr] == L'[')
			{
				reg = new RegexCharSetNode();
				ptr ++;
				reg->CharSet = ParseCharSet();
				
				if (src[ptr] != L']')
				{
					SyntaxError err;
					err.Position = ptr;
					err.Text = L"\']\' expected.";
					Errors.Add(err);
					throw 0;
				}
				ptr ++;
			}
			else if (src[ptr] == L'\\')
			{
				ptr ++;
				reg = new RegexCharSetNode();
				reg->CharSet = new RegexCharSet();
				switch (src[ptr])
				{
				case L'.':
					{
						reg->CharSet->Neg = true;
						break;
					}
				case L'w':
				case L'W':
					{
						RegexCharSet::RegexCharRange range;
						reg->CharSet->Neg = false;
						range.Begin = L'a';
						range.End = L'z';
						reg->CharSet->Ranges.Add(range);
						range.Begin = L'A';
						range.End = L'Z';
						reg->CharSet->Ranges.Add(range);
						range.Begin = L'_';
						range.End = L'_';
						reg->CharSet->Ranges.Add(range);
						range.Begin = L'0';
						range.End = L'9';
						reg->CharSet->Ranges.Add(range);
						if (src[ptr] == L'W')
							reg->CharSet->Neg = true;
						break;
					}
				case L's':
				case 'S':
					{
						RegexCharSet::RegexCharRange range;
						reg->CharSet->Neg = false;
						range.Begin = L' ';
						range.End = L' ';
						reg->CharSet->Ranges.Add(range);
						range.Begin = L'\t';
						range.End = L'\t';
						reg->CharSet->Ranges.Add(range);
						range.Begin = L'\r';
						range.End = L'\r';
						reg->CharSet->Ranges.Add(range);
						range.Begin = L'\n';
						range.End = L'\n';
						reg->CharSet->Ranges.Add(range);
						if (src[ptr] == L'S')
							reg->CharSet->Neg = true;
						break;
					}
				case L'd':
				case L'D':
					{
						RegexCharSet::RegexCharRange range;
						reg->CharSet->Neg = false;
						range.Begin = L'0';
						range.End = L'9';
						reg->CharSet->Ranges.Add(range);
						if (src[ptr] == L'D')
							reg->CharSet->Neg = true;
						break;
					}
				case L'n':
					{
						RegexCharSet::RegexCharRange range;
						reg->CharSet->Neg = false;
						range.Begin = L'\n';
						range.End = L'\n';
						reg->CharSet->Ranges.Add(range);
						break;
					}
				case L't':
					{
						RegexCharSet::RegexCharRange range;
						reg->CharSet->Neg = false;
						range.Begin = L'\t';
						range.End = L'\t';
						reg->CharSet->Ranges.Add(range);
						break;
					}
				case L'r':
					{
						RegexCharSet::RegexCharRange range;
						reg->CharSet->Neg = false;
						range.Begin = L'\r';
						range.End = L'\r';
						reg->CharSet->Ranges.Add(range);
						break;
					}
				case L'v':
					{
						RegexCharSet::RegexCharRange range;
						reg->CharSet->Neg = false;
						range.Begin = L'\v';
						range.End = L'\v';
						reg->CharSet->Ranges.Add(range);
						break;
					}
				case L'f':
					{
						RegexCharSet::RegexCharRange range;
						reg->CharSet->Neg = false;
						range.Begin = L'\f';
						range.End = L'\f';
						reg->CharSet->Ranges.Add(range);
						break;
					}
				case L'*':
				case L'|':
				case L'(':
				case L')':
				case L'?':
				case L'+':
				case L'[':
				case L']':
				case L'\\':
					{
						RegexCharSet::RegexCharRange range;
						reg->CharSet->Neg = false;
						range.Begin = src[ptr];
						range.End = range.Begin;
						reg->CharSet->Ranges.Add(range);
						break;
					}
				default:
					{
						SyntaxError err;
						err.Position = ptr;
						err.Text = String(L"Illegal escape sequence \'\\") + src[ptr] + L"\'";
						Errors.Add(err);
						throw 0;
					}
				}
				ptr ++;
			}
			else if (!IsOperator())
			{
				RegexCharSet::RegexCharRange range;
				reg = new RegexCharSetNode();
				reg->CharSet->Neg = false;
				range.Begin = src[ptr];
				range.End = range.Begin;
				ptr ++;
				reg->CharSet->Ranges.Add(range);
			}
			else
			{
				SyntaxError err;
				err.Position = ptr;
				err.Text = String(L"Unexpected \'") + src[ptr] + L'\'';
				Errors.Add(err);
				throw 0;
			}
			content = reg.Release();
		}
		if (ptr < src.Length())
		{
			if (src[ptr] == L'*')
			{
				RefPtr<RegexRepeatNode> node = new RegexRepeatNode();
				node->Child = content;
				node->RepeatType = RegexRepeatNode::rtArbitary;
				ptr ++;
				return node.Release();
			}
			else if (src[ptr] == L'?')
			{
				RefPtr<RegexRepeatNode> node = new RegexRepeatNode();
				node->Child = content;
				node->RepeatType = RegexRepeatNode::rtOptional;
				ptr ++;
				return node.Release();
			}
			else if (src[ptr] == L'+')
			{
				RefPtr<RegexRepeatNode> node = new RegexRepeatNode();
				node->Child = content;
				node->RepeatType = RegexRepeatNode::rtMoreThanOnce;
				ptr ++;
				return node.Release();
			}
			else if (src[ptr] == L'{')
			{
				ptr++;
				RefPtr<RegexRepeatNode> node = new RegexRepeatNode();
				node->Child = content;
				node->RepeatType = RegexRepeatNode::rtSpecified;
				node->MinRepeat = ParseInteger();
				if (src[ptr] == L',')
				{
					ptr ++;
					node->MaxRepeat = ParseInteger();
				}
				else
					node->MaxRepeat = node->MinRepeat;
				if (src[ptr] == L'}')
					ptr++;
				else
				{
					SyntaxError err;
					err.Position = ptr;
					err.Text = L"\'}\' expected.";
					Errors.Add(err);
					throw 0;
				}
				if (node->MinRepeat < 0)
				{
					SyntaxError err;
					err.Position = ptr;
					err.Text = L"Minimun repeat cannot be less than 0.";
					Errors.Add(err);
					throw 0;
				}
				if (node->MaxRepeat != -1 && node->MaxRepeat < node->MinRepeat)
				{
					SyntaxError err;
					err.Position = ptr;
					err.Text = L"Max repeat cannot be less than min repeat.";
					Errors.Add(err);
					throw 0;
				}
				return node.Release();
			}
		}
		return content.Release();
	}

	bool IsDigit(wchar_t ch)
	{
		return ch>=L'0'&& ch <=L'9';
	}

	int RegexParser::ParseInteger()
	{
		StringBuilder number;
		while (IsDigit(src[ptr]))
		{
			number.Append(src[ptr]);
			ptr ++;
		}
		if (number.Length() == 0)
			return -1;
		else
			return StringToInt(number.ProduceString());
	}

	bool RegexParser::IsOperator()
	{
		return (src[ptr] == L'|' || src[ptr] == L'*' || src[ptr] == L'(' || src[ptr] == L')'
				|| src[ptr] == L'?' || src[ptr] == L'+');
	}

	wchar_t RegexParser::ReadNextCharInCharSet()
	{
		if (ptr < src.Length() && src[ptr] != L']')
		{
			if (src[ptr] == L'\\')
			{
				ptr ++;
				if (ptr >= src.Length())
				{
					SyntaxError err;
					err.Position = ptr;
					err.Text = String(L"Unexpected end of char-set when looking for escape sequence.");
					Errors.Add(err);
					throw 0;
				}
				wchar_t rs = 0;
				if (src[ptr] == L'\\')
					rs = L'\\';
				else if (src[ptr] == L'^')
					rs = L'^';
				else if (src[ptr] == L'-')
					rs = L'-';
				else if (src[ptr] == L']')
					rs = L']';
				else if (src[ptr] == L'n')
					rs = L'\n';
				else if (src[ptr] == L't')
					rs = L'\t';
				else if (src[ptr] == L'r')
					rs = L'\r';
				else if (src[ptr] == L'v')
					rs = L'\v';
				else if (src[ptr] == L'f')
					rs = L'\f';
				else
				{
					SyntaxError err;
					err.Position = ptr;
					err.Text = String(L"Illegal escape sequence inside charset definition \'\\") + src[ptr] + L"\'";
					Errors.Add(err);
					throw 0;
				}
				ptr ++;
				return rs;
			}
			else
				return src[ptr++];
		}
		else
		{
			SyntaxError err;
			err.Position = ptr;
			err.Text = String(L"Unexpected end of char-set.");
			Errors.Add(err);
			throw 0;
		}
	}

	RegexCharSet * RegexParser::ParseCharSet()
	{
		RefPtr<RegexCharSet> rs = new RegexCharSet();
		if (src[ptr] == L'^')
		{
			rs->Neg = true;
			ptr ++;
		}
		else
			rs->Neg = false;
		RegexCharSet::RegexCharRange range;
		while (ptr < src.Length() && src[ptr] != L']')
		{
			range.Begin = ReadNextCharInCharSet();
			//ptr ++;
			
			if (ptr >= src.Length())
			{
				break;
			}
			if (src[ptr] == L'-')
			{
				ptr ++;
				range.End = ReadNextCharInCharSet();	
			}
			else
			{
				range.End = range.Begin;
			}
			rs->Ranges.Add(range);
		
		}
		if (ptr >=src.Length() || src[ptr] != L']')
		{
			SyntaxError err;
			err.Position = ptr;
			err.Text = String(L"Unexpected end of char-set.");
			Errors.Add(err);
			throw 0;
		}
		return rs.Release();
	}
}
}
#endif

/***********************************************************************
CORELIB\REGEX\REGEXTREE.CPP
***********************************************************************/
#ifndef SPIRE_NO_CORE_LIB

namespace CoreLib
{
namespace Text
{
	void RegexNodeVisitor::VisitCharSetNode(RegexCharSetNode * )
	{
	}

	void RegexNodeVisitor::VisitRepeatNode(RegexRepeatNode * )
	{

	}

	void RegexNodeVisitor::VisitSelectionNode(RegexSelectionNode * )
	{
	}

	void RegexNodeVisitor::VisitConnectionNode(RegexConnectionNode * )
	{

	}

	void RegexCharSetNode::Accept(RegexNodeVisitor * visitor)
	{
		visitor->VisitCharSetNode(this);
	}

	void RegexSelectionNode::Accept(RegexNodeVisitor * visitor)
	{
		visitor->VisitSelectionNode(this);
	}

	void RegexConnectionNode::Accept(RegexNodeVisitor * visitor)
	{
		visitor->VisitConnectionNode(this);
	}

	void RegexRepeatNode::Accept(RegexNodeVisitor *visitor)
	{
		visitor->VisitRepeatNode(this);
	}

	String RegexConnectionNode::Reinterpret()
	{
		return LeftChild->Reinterpret() + RightChild->Reinterpret();
	}

	String RegexSelectionNode::Reinterpret()
	{
		return LeftChild->Reinterpret() + L"|" + RightChild->Reinterpret();
	}

	String RegexRepeatNode::Reinterpret()
	{
		wchar_t t;
		if (RepeatType == RegexRepeatNode::rtArbitary)
			t = L'*';
		else if (RepeatType == rtOptional)
			t = L'?';
		else
			t = L'+';
		return String(L"(") + Child->Reinterpret() + L")" + t;
	}

	String RegexCharSet::Reinterpret()
	{
		if (Ranges.Count()== 1 && Ranges[0].Begin == Ranges[0].End &&
			!Neg)
		{
			return (Ranges[0].Begin>=28 && Ranges[0].Begin <127)? String((wchar_t)Ranges[0].Begin):
				String(L"<") + String((int)Ranges[0].Begin) + String(L">");
		}
		else
		{
			StringBuilder rs;
			rs.Append(L"[");
			if (Neg)
				rs.Append(L'^');
			for (int i=0; i<Ranges.Count(); i++)
			{
				if (Ranges[i].Begin == Ranges[i].End)
					rs.Append(Ranges[i].Begin);
				else
				{
					rs.Append(Ranges[i].Begin>=28 && Ranges[i].Begin<128?Ranges[i].Begin:
						String(L"<") + String((int)Ranges[i].Begin) + L">");
					rs.Append(L'-');
					rs.Append(Ranges[i].End>=28 && Ranges[i].End<128?Ranges[i].End:
						String(L"<") + String((int)Ranges[i].End)+ L">");
				}
			}
			rs.Append(L']');
			return rs.ProduceString();
		}
	}

	String RegexCharSetNode::Reinterpret()
	{
		return CharSet->Reinterpret();
	}

	void RegexCharSet::Sort()
	{
		for (int i=0; i<Ranges.Count()-1; i++)
		{
			for (int j=i+1; j<Ranges.Count(); j++)
			{
				RegexCharRange ri,rj;
				ri = Ranges[i];
				rj = Ranges[j];
				if (Ranges[i].Begin > Ranges[j].Begin)
				{
					RegexCharRange range = Ranges[i];
					Ranges[i] = Ranges[j];
					Ranges[j] = range;
				}
			}
		}
	}

	void RegexCharSet::Normalize()
	{
		for (int i=0; i<Ranges.Count()-1; i++)
		{
			for (int j=i+1; j<Ranges.Count(); j++)
			{
				if ((Ranges[i].Begin >= Ranges[j].Begin && Ranges[i].Begin <= Ranges[j].End) ||
					(Ranges[j].Begin >= Ranges[i].Begin && Ranges[j].Begin <= Ranges[i].End) )
				{
					Ranges[i].Begin = Math::Min(Ranges[i].Begin, Ranges[j].Begin);
					Ranges[i].End = Math::Max(Ranges[i].End, Ranges[j].End);
					Ranges.RemoveAt(j);
					j--;
				}
			}
		}
		Sort();
		if (Neg)
		{
			List<RegexCharRange> nranges;
			nranges.AddRange(Ranges);
			Ranges.Clear();
			RegexCharRange range;
			range.Begin = 1;
			for (int i=0; i<nranges.Count(); i++)
			{
				range.End = nranges[i].Begin-1;
				Ranges.Add(range);
				range.Begin = nranges[i].End+1;
			}
			range.End = 65530;
			Ranges.Add(range);
			Neg = false;
		}
	}

	bool RegexCharSet::Contains(RegexCharRange r)
	{
		for (int i=0; i<Ranges.Count(); i++)
		{
			if (r.Begin >= Ranges[i].Begin && r.End <= Ranges[i].End)
				return true;
		}
		return false;
	}

	void RegexCharSet::RangeIntersection(RegexCharRange r1, RegexCharRange r2, RegexCharSet & rs)
	{
		RegexCharRange r;
		r.Begin = Math::Max(r1.Begin,r2.Begin);
		r.End = Math::Min(r1.End, r2.End);
		if (r.Begin <= r.End)
			rs.Ranges.Add(r);
	}
	
	void RegexCharSet::RangeMinus(RegexCharRange r1, RegexCharRange r2, RegexCharSet & rs)
	{
		if (r2.Begin <= r1.Begin && r2.End>= r1.Begin && r2.End <= r1.End)
		{
			RegexCharRange r;
			r.Begin = ((int)r2.End + 1)>0xFFFF?0xFFFF:r2.End+1;
			r.End = r1.End;
			if (r.Begin <= r.End && !(r.Begin == r.End && r.Begin == 65530))
				rs.Ranges.Add(r);
		}
		else if (r2.Begin >= r1.Begin && r2.Begin <= r1.End && r2.End >= r1.End)
		{
			RegexCharRange r;
			r.Begin = r1.Begin;
			r.End = r2.Begin == 1? 1: r2.Begin - 1;
			if (r.Begin <= r.End && !(r.Begin == r.End == 1))
				rs.Ranges.Add(r);
		}
		else if (r2.Begin >= r1.Begin && r2.End <= r1.End)
		{
			RegexCharRange r;
			r.Begin = r1.Begin;
			r.End = r2.Begin == 1? 1: r2.Begin - 1;
			if (r.Begin <= r.End && !(r.Begin == r.End && r.Begin  == 1))
				rs.Ranges.Add(r);
			r.Begin = r2.End == 0xFFFF? r2.End : r2.End + 1;
			r.End = r1.End;
			if (r.Begin <= r.End && !(r.Begin == r.End && r.Begin  == 65530))
				rs.Ranges.Add(r);
		}
		else if (r2.End<r1.Begin || r1.End < r2.Begin)
		{
			rs.Ranges.Add(r1);
		}
	}

	void RegexCharSet::CharSetMinus(RegexCharSet & s1, RegexCharSet & s2)
	{
		RegexCharSet s;
		for (int i=0; i<s1.Ranges.Count(); i++)
		{
			for (int j=0; j<s2.Ranges.Count(); j++)
			{
				if (i>=s1.Ranges.Count() || i<0)
					return;
				s.Ranges.Clear();
				RangeMinus(s1.Ranges[i], s2.Ranges[j], s);
				if (s.Ranges.Count() == 1)
					s1.Ranges[i] = s.Ranges[0];
				else if (s.Ranges.Count() == 2)
				{
					s1.Ranges[i] = s.Ranges[0];
					s1.Ranges.Add(s.Ranges[1]);
				}
				else
				{
					s1.Ranges.RemoveAt(i);
					i--;
				}
			}
		}
	}

	RegexCharSet & RegexCharSet::operator = (const RegexCharSet & set)
	{
		CopyCtor(set);
		return *this;
	}

	bool RegexCharSet::RegexCharRange::operator == (const RegexCharRange & r)
	{
		return r.Begin == Begin && r.End == End;
	}

	void RegexCharSet::AddRange(RegexCharRange newR)
	{
		//RegexCharSet set;
		//set.Ranges.Add(r);
		//for (int i=0; i<Ranges.Count(); i++)
		//{
		//	if (Ranges[i].Begin < r.Begin && Ranges[i].End > r.Begin)
		//	{
		//		RegexCharRange nrange;
		//		nrange.Begin = r.Begin;
		//		nrange.End = Ranges[i].End;
		//		Ranges[i].End = r.Begin == 1? 1:r.Begin-1;
		//		if (!Ranges.Contains(nrange))
		//			Ranges.Add(nrange);
		//	}
		//	if (r.End > Ranges[i].Begin && r.End < Ranges[i].End)
		//	{
		//		RegexCharRange nrange;
		//		nrange.Begin = r.End == 0xFFFF ? 0xFFFF : r.End+1;
		//		nrange.End = Ranges[i].End;
		//		Ranges[i].End = r.End;
		//		if (!Ranges.Contains(nrange))
		//			Ranges.Add(nrange);
		//	}
		//	if (r.Begin == Ranges[i].Begin && r.End == Ranges[i].End)
		//		return;
		//}
		//for (int i=0; i<Ranges.Count(); i++)
		//	set.SubtractRange(Ranges[i]);
		//for (int i=0; i<set.Ranges.Count(); i++)
		//{
		//	for (int j=0; j<Ranges.Count(); j++)
		//		if (Ranges[j].Begin == set.Ranges[i].Begin ||
		//			Ranges[j].Begin == set.Ranges[i].End ||
		//			Ranges[j].End == set.Ranges[i].End||
		//			Ranges[j].End == set.Ranges[i].Begin)
		//		{
		//			RegexCharRange sr = set.Ranges[i];
		//			RegexCharRange r = Ranges[j];
		//			throw 0;
		//		}
		//	if (!Ranges.Contains(set.Ranges[i]))
		//		Ranges.Add(set.Ranges[i]);
		//}
		//Normalize();
		if (newR.Begin > newR.End)
			return;
		Sort();
		int rangeCount = Ranges.Count();
		for (int i=0; i<rangeCount; i++)
		{
			RegexCharRange & oriR = Ranges[i];
			if (newR.Begin > oriR.Begin)
			{
				if (newR.Begin > oriR.End)
				{

				}
				else if (newR.End > oriR.End)
				{
					RegexCharRange nRange;
					nRange.Begin = newR.Begin;
					nRange.End = oriR.End;
					wchar_t newR_begin = newR.Begin;
					newR.Begin = oriR.End + 1;
					oriR.End = newR_begin-1;
					Ranges.Add(nRange);
				}
				else if (newR.End == oriR.End)
				{
					oriR.End = newR.Begin - 1;
					Ranges.Add(newR);
					return;
				}
				else if (newR.End < oriR.End)
				{
					RegexCharRange nRange;
					nRange.Begin = newR.End + 1;
					nRange.End = oriR.End;
					oriR.End = newR.Begin - 1;
					Ranges.Add(newR);
					Ranges.Add(nRange);
					return;
				}
			}
			else if (newR.Begin == oriR.Begin)
			{
				if (newR.End > oriR.End)
				{
					newR.Begin = oriR.End + 1;
				}
				else if (newR.End == oriR.End)
				{
					return;
				}
				else
				{
					wchar_t oriR_end = oriR.End;
					oriR.End = newR.End;
					newR.End = oriR_end;
					newR.Begin = oriR.End + 1;
					Ranges.Add(newR);
					return;
				}
			}
			else if (newR.Begin < oriR.Begin)
			{
				if (newR.End > oriR.End)
				{
					RegexCharRange nRange;
					nRange.Begin = newR.Begin;
					nRange.End = oriR.Begin-1;
					Ranges.Add(nRange);
					newR.Begin = oriR.Begin;
					i--;
				}
				else if (newR.End == oriR.End)
				{
					RegexCharRange nRange;
					nRange.Begin = newR.Begin;
					nRange.End = oriR.Begin-1;
					Ranges.Add(nRange);
					return;
				}
				else if (newR.End < oriR.End && newR.End >= oriR.Begin)
				{
					RegexCharRange nRange;
					nRange.Begin = newR.Begin;
					nRange.End = oriR.Begin-1;
					Ranges.Add(nRange);
					nRange.Begin = newR.End+1;
					nRange.End = oriR.End;
					Ranges.Add(nRange);
					oriR.End = newR.End;
					return;
				}
				else
					break;
			}
		}
		Ranges.Add(newR);
		
	}

	void RegexCharSet::SubtractRange(RegexCharRange r)
	{
		
		int rc = Ranges.Count();
		for (int i=0; i<rc; i++)
		{
			RegexCharSet rs;
			RangeMinus(Ranges[i], r, rs);
			if (rs.Ranges.Count() == 1)
				Ranges[i] = rs.Ranges[0];
			else if (rs.Ranges.Count() == 0)
			{
				Ranges.RemoveAt(i);
				i--;
				rc--;
			}
			else
			{
				Ranges[i] = rs.Ranges[0];
				Ranges.Add(rs.Ranges[1]);
			}
		}
		Normalize();
	}

	void RegexCharSet::CalcCharElementFromPair(RegexCharSet * c1, RegexCharSet * c2, RegexCharSet & AmB, RegexCharSet & BmA, RegexCharSet & AnB)
	{
		AmB = *c1;
		BmA = *c2;
		CharSetMinus(AmB, *c2);
		CharSetMinus(BmA, *c1);
		for (int i=0; i<c1->Ranges.Count(); i++)
		{
			if (c2->Ranges.Count())
			{
				for (int j=0; j<c2->Ranges.Count(); j++)
				{
					RangeIntersection(c1->Ranges[i], c2->Ranges[j], AnB);
				}
			}
		}
		AmB.Normalize();
		BmA.Normalize();
		AnB.Normalize();
	}

	bool RegexCharSet::operator ==(const RegexCharSet & set)
	{
		if (Ranges.Count() != set.Ranges.Count())
			return false;
		for (int i=0; i<Ranges.Count(); i++)
		{
			if (Ranges[i].Begin != set.Ranges[i].Begin ||
				Ranges[i].End != set.Ranges[i].End)
				return false;
		}
		return true;
	}

	void RegexCharSet::InsertElement(List<RefPtr<RegexCharSet>> &L, RefPtr<RegexCharSet> & elem)
	{
		bool find = false;
		for (int i=0; i<L.Count(); i++)
		{
			if ((*L[i]) == *elem)
			{
				for (int k=0; k<elem->OriSet.Count(); k++)
				{
					if (!L[i]->OriSet.Contains(elem->OriSet[k]))
						L[i]->OriSet.Add(elem->OriSet[k]);
				}
				find = true;
				break;
			}
		}
		if (!find)
			L.Add(elem);
	}

	void RegexCharSet::CalcCharElements(List<RegexCharSet *> &sets, List<RegexCharRange> & elements)
	{
		RegexCharSet set;
		for (int i=0; i<sets.Count(); i++)
			for (int j=0; j<sets[i]->Ranges.Count(); j++)
				set.AddRange(sets[i]->Ranges[j]);
		for (int j=0; j<set.Ranges.Count(); j++)
		{
			for (int i=0; i<sets.Count(); i++)
			{
				if (sets[i]->Contains(set.Ranges[j]))
					sets[i]->Elements.Add((unsigned short)j);
			}
			elements.Add(set.Ranges[j]);
		}
		/*
		List<RefPtr<RegexCharSet>> L;
		if (!sets.Count())
			return;
		int lastSetCount = sets.Count();
		for (int i=0; i<sets.Count(); i++)
			sets[i]->OriSet.Add(sets[i]);
		L.Add(new RegexCharSet(*(sets[0])));
		for (int i=1; i<sets.Count(); i++)
		{
			RefPtr<RegexCharSet> bma = new RegexCharSet(*sets[i]);
			bma->OriSet = sets[i]->OriSet;
			for (int j=L.Count()-1; j>=0; j--)
			{
				RefPtr<RegexCharSet> bma2 = new RegexCharSet();
				RefPtr<RegexCharSet> amb = new RegexCharSet();
				RefPtr<RegexCharSet> anb = new RegexCharSet();
				CalcCharElementFromPair(L[j].operator ->(), sets[i], *amb, *bma2, *anb);
				CharSetMinus(*bma, *L[j]);
				L[j]->Normalize();
				amb->OriSet = L[j]->OriSet;
				anb->OriSet = amb->OriSet;
				for (int k=0; k<bma->OriSet.Count(); k++)
				{
					if (!anb->OriSet.Contains(bma->OriSet[k]))
						anb->OriSet.Add(bma->OriSet[k]);
				}
				if (amb->Ranges.Count())
				{
					L[j] = amb;
				}
				else
				{
					L[j] = 0;
					L.RemoveAt(j);
				}
				if (anb->Ranges.Count())
				{
					InsertElement(L,anb);
				}
			}
			if (bma->Ranges.Count())
			{
				InsertElement(L,bma);
			}

		}
		for (int i=0; i<L.Count(); i++)
		{
			for (int j=0; j<L[i]->OriSet.Count(); j++)
			{
				L[i]->OriSet[j]->Elements.Add(i);
			}
			elements.Add(L[i].Release());
		}
		for (int i=lastSetCount; i<sets.Count(); i++)
			RemoveAt sets[i];
		sets.SetSize(lastSetCount);

		*/
	}

	void RegexCharSet::CopyCtor(const RegexCharSet & set)
	{
		Ranges = set.Ranges;
		Elements = set.Elements;
		Neg = set.Neg;
		OriSet = set.OriSet;
	}

	RegexCharSet::RegexCharSet(const RegexCharSet & set)
	{
		CopyCtor(set);
	}


}
}
#endif
