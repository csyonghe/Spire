/***********************************************************************

Spire - The MIT License (MIT)
Copyright (c) 2016, Carnegie Mellon University

Developers: Yong He, Haomin Long

Permission is hereby granted, free of charge, to any person obtaining a 
copy of this software and associated documentation files (the "Software"), 
to deal in the Software without restriction, including without limitation 
the rights to use, copy, modify, merge, publish, distribute, sublicense, 
and/or sell copies of the Software, and to permit persons to whom the 
Software is furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in 
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR 
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, 
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL 
THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER 
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING 
FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER 
DEALINGS IN THE SOFTWARE.


========================================================================
WARNING: THIS FILE IS AUTOMATICALLY GENERATED. DO NOT MODIFY
***********************************************************************/
#include "Spire.h"

/***********************************************************************
CORE\CLOSURE.CPP
***********************************************************************/

namespace Spire
{
	namespace Compiler
	{
		void CheckComponentRedefinition(ErrorWriter * err, ShaderClosure * parent, ShaderClosure * child)
		{
			for (auto & comp : child->Components)
			{
				RefPtr<ShaderComponentSymbol> ccomp;
				RefPtr<ShaderClosure> su;
				if ((comp.Value->Implementations.First()->SyntaxNode->IsPublic ||
					comp.Value->Implementations.First()->SyntaxNode->IsOutput))
				{
					if (parent->Components.TryGetValue(comp.Key, ccomp))
						err->Error(33022, L"\'" + comp.Key + L"\' is already defined in current scope.\nsee previous definition at " + ccomp->Implementations.First()->SyntaxNode->Position.ToString(),
							comp.Value->Implementations.First()->SyntaxNode->Position);
					else if (parent->SubClosures.TryGetValue(comp.Key, su))
						err->Error(33022, L"\'" + comp.Key + L"\' is already defined in current scope.\nsee previous definition at " + su->UsingPosition.ToString(),
							comp.Value->Implementations.First()->SyntaxNode->Position);
				}
			}
			for (auto & c : child->SubClosures)
			{
				if (c.Value->IsInPlace)
				{
					RefPtr<ShaderComponentSymbol> ccomp;
					RefPtr<ShaderClosure> su;
					if (parent->Components.TryGetValue(c.Key, ccomp))
						err->Error(33022, L"\'" + c.Key + L"\' is already defined in current scope.\nsee previous definition at " + ccomp->Implementations.First()->SyntaxNode->Position.ToString(),
							c.Value->UsingPosition);
					else if (parent->SubClosures.TryGetValue(c.Key, su))
						err->Error(33022, L"\'" + c.Key + L"\' is already defined in current scope.\nsee previous definition at " + su->UsingPosition.ToString(),
							c.Value->UsingPosition);
					for (auto & sc : c.Value->SubClosures)
						if (sc.Value->IsInPlace)
							CheckComponentRedefinition(err, parent, sc.Value.Ptr());
				}
			}
		}
		RefPtr<ShaderClosure> CreateShaderClosure(ErrorWriter * err, SymbolTable * symTable, ShaderSymbol * shader, CodePosition usingPos, 
			ShaderClosure * rootShader,
			const Dictionary<String, RefPtr<ShaderComponentSymbol>>& pRefMap)
		{
			RefPtr<ShaderClosure> rs = new ShaderClosure();
			if (rootShader == nullptr)
				rootShader = rs.Ptr();
			rs->Name = shader->SyntaxNode->Name.Content;
			rs->RefMap = pRefMap;
			rs->Pipeline = shader->Pipeline;
			rs->UsingPosition = usingPos;
			rs->Position = shader->SyntaxNode->Position;
			for (auto & mbr : shader->SyntaxNode->Members)
			{
				if (auto import = dynamic_cast<ImportSyntaxNode*>(mbr.Ptr()))
				{
					// create component for each argument
					Dictionary<String, RefPtr<ShaderComponentSymbol>> refMap;
					for (auto & arg : import->Arguments)
					{
						RefPtr<ShaderComponentSymbol> ccomp = new ShaderComponentSymbol();
						auto compName = L"arg" + String(rs->Components.Count()) + L"_" + 
							(import->ObjectName.Content.Length()==0?import->ShaderName.Content:import->ObjectName.Content) + arg->ArgumentName.Content;
						auto impl = new ShaderComponentImplSymbol();
						auto compSyntax = new ComponentSyntaxNode();
						compSyntax->Position = arg->Expression->Position;
						compSyntax->Name.Content = compName;
						CloneContext cloneCtx;
						compSyntax->Expression = arg->Expression->Clone(cloneCtx);
						compSyntax->TypeNode = TypeSyntaxNode::FromExpressionType(arg->Expression->Type.Ptr());
						compSyntax->TypeNode->Position = compSyntax->Position;
						impl->SyntaxNode = compSyntax;
						ccomp->Name = compName;
						ccomp->Type = new Type();
						ccomp->Type->DataType = arg->Expression->Type;
						ccomp->Implementations.Add(impl);
						rs->Components[compName] = ccomp;
						refMap[arg->ArgumentName.Content] = ccomp;
					}
					RefPtr<ShaderSymbol> shaderSym;
					if (symTable->Shaders.TryGetValue(import->ShaderName.Content, shaderSym))
					{
						// fill in automatic arguments
						for (auto & param : shaderSym->Components)
						{
							if (param.Value->IsParam() && !refMap.ContainsKey(param.Key))
							{
								auto arg = rs->FindComponent(param.Key);
								if (arg && arg->Type->DataType->Equals(param.Value->Type->DataType.Ptr()))
								{
									refMap[param.Key] = arg;
								}
							}
						}
						auto refClosure = CreateShaderClosure(err, symTable, shaderSym.Ptr(), import->Position, rootShader, refMap);
						refClosure->IsPublic = import->IsPublic;
						refClosure->Parent = rs.Ptr();
						if (import->IsInplace)
						{
							refClosure->IsInPlace = true;
							CheckComponentRedefinition(err, rs.Ptr(), refClosure.Ptr());
							rs->SubClosures[L"annonymousObj" + String(GUID::Next())] = refClosure;
						}
						else
						{
							rs->SubClosures[import->ObjectName.Content] = refClosure;
						}
					}
				}
				else if (auto compt = dynamic_cast<ComponentSyntaxNode*>(mbr.Ptr()))
				{
					RefPtr<ShaderComponentSymbol> comp;
					if (shader->Components.TryGetValue(compt->Name.Content, comp) &&
						!rs->Components.ContainsKey(compt->Name.Content))
					{
						RefPtr<ShaderComponentSymbol> ccomp = new ShaderComponentSymbol(*comp);
						rs->Components.Add(comp->Name, ccomp);
					}
				}
			}
			// check for unassigned arguments
			for (auto & comp : shader->Components)
			{
				if (comp.Value->Implementations.First()->SyntaxNode->IsParam &&
					!pRefMap.ContainsKey(comp.Key))
				{
					StringBuilder errMsg;
					errMsg << L"argument '" + comp.Key + L"' is unassigned.";
					// try to provide more info on why it is unassigned
					auto arg = rootShader->FindComponent(comp.Key, true, false);
					if (!arg)
						errMsg << L" automatic argument filling failed because shader '" << rootShader->Name << L"' does not define component '" + comp.Key + L"'.";
					else
					{
						errMsg << L" automatic argument filling failed because the component of the same name is not accessible from '" << rootShader->Name << L"'.";
						errMsg << L"\nsee requirement declaration at " << comp.Value->Implementations.First()->SyntaxNode->Position.ToString() << L".";
						errMsg << L"\nsee potential definition of component '" << comp.Key << L"' at " << arg->Implementations.First()->SyntaxNode->Position.ToString()
							<< L".\ndid you forget the 'public' qualifier?";
					}
					err->Error(33023,errMsg.ProduceString(), rs->UsingPosition);
				}
			}
			return rs;
		}

		RefPtr<ShaderClosure> CreateShaderClosure(ErrorWriter * err, SymbolTable * symTable, ShaderSymbol * shader)
		{
			return CreateShaderClosure(err, symTable, shader, shader->SyntaxNode->Position, nullptr, Dictionary<String, RefPtr<ShaderComponentSymbol>>());
		}


		class ResolveDependencyVisitor : public SyntaxVisitor
		{
		private:
			ShaderClosure * shaderClosure = nullptr;
			ShaderComponentSymbol * currentComponent = nullptr;
			ImportExpressionSyntaxNode * currentImport = nullptr;
			void AddReference(ShaderComponentSymbol * referee, ImportExpressionSyntaxNode * importOp, CodePosition pos)
			{
				referee->UserComponents.Add(currentComponent);
				if (auto * importOps = currentComponent->DependentComponents.TryGetValue(referee))
					importOps->Add(importOp);
				else
				{
					EnumerableHashSet<RefPtr<ImportExpressionSyntaxNode>> op;
					op.Add(importOp);
					currentComponent->DependentComponents.Add(referee, op);
				}

				if (auto * importOps = currentImpl->DependentComponents.TryGetValue(referee))
					importOps->Add(importOp);
				else
				{
					EnumerableHashSet<RefPtr<ImportExpressionSyntaxNode>> op;
					op.Add(importOp);
					currentImpl->DependentComponents.Add(referee, op);
				}
				currentImpl->ComponentReferencePositions[referee] = pos;
			}
		public:
			ShaderComponentImplSymbol * currentImpl = nullptr;

			ResolveDependencyVisitor(ErrorWriter * err, ShaderClosure * closure, ShaderComponentSymbol * comp)
				: SyntaxVisitor(err), shaderClosure(closure), currentComponent(comp)
			{}

			RefPtr<ExpressionSyntaxNode> VisitImportExpression(ImportExpressionSyntaxNode * import) override
			{
				currentImport = import;
				import->Component->Accept(this);
				if (!import->Component->Tags.ContainsKey(L"ComponentReference"))
				{
					Error(34043, L"first argument of an import operator call does not resolve to a component.", import->Component.Ptr());
				}
				else
				{
					import->ComponentUniqueName = import->Component->Tags[L"ComponentReference"]().As<StringObject>()->Content;
				}
				currentImport = nullptr;
				for (auto & arg : import->Arguments)
					arg->Accept(this);
				return import;
			}

			RefPtr<ExpressionSyntaxNode> VisitVarExpression(VarExpressionSyntaxNode * var) override
			{
				VariableEntry varEntry;
				if (!var->Scope->FindVariable(var->Variable, varEntry))
				{
					if (auto comp = shaderClosure->FindComponent(var->Variable))
					{
						if (comp->Implementations.First()->SyntaxNode->IsParam)
							shaderClosure->RefMap.TryGetValue(var->Variable, comp);
						var->Tags[L"ComponentReference"] = new StringObject(comp->UniqueName);

						AddReference(comp.Ptr(), currentImport, var->Position);
					}
					else if (auto closure = shaderClosure->FindClosure(var->Variable))
					{
						ShaderSymbol * originalShader = nullptr;
						if (var->Type->AsBasicType())
							originalShader = var->Type->AsBasicType()->Shader;
						var->Type = new BasicExpressionType(originalShader, closure.Ptr());
					}
					else
						throw InvalidProgramException(L"cannot resolve reference.");
				}
				return var;
			}

			RefPtr<ExpressionSyntaxNode> VisitMemberExpression(MemberExpressionSyntaxNode * member) override
			{
				member->BaseExpression->Accept(this);
				if (member->BaseExpression->Type->AsBasicType() && member->BaseExpression->Type->AsBasicType()->ShaderClosure)
				{
					if (auto comp = member->BaseExpression->Type->AsBasicType()->ShaderClosure->FindComponent(member->MemberName))
					{
						member->Tags[L"ComponentReference"] = new StringObject(comp->UniqueName);
						AddReference(comp.Ptr(), currentImport, member->Position);
					}
					else if (auto shader = member->BaseExpression->Type->AsBasicType()->ShaderClosure->FindClosure(member->MemberName))
					{
						ShaderSymbol * originalShader = nullptr;
						if (member->Type->AsBasicType())
							originalShader = member->Type->AsBasicType()->Shader;
						member->Type = new BasicExpressionType(originalShader, shader.Ptr());
					}
				}
				return member;
			}
		};

		void ResolveReference(ErrorWriter * err, ShaderClosure* shader)
		{
			for (auto & comp : shader->Components)
			{
				ResolveDependencyVisitor depVisitor(err, shader, comp.Value.Ptr());
				for (auto & impl : comp.Value->Implementations)
				{
					depVisitor.currentImpl = impl.Ptr();
					impl->SyntaxNode->Accept(&depVisitor);
				}
			}
			for (auto & subClosure : shader->SubClosures)
				ResolveReference(err, subClosure.Value.Ptr());
		}

		String GetUniqueCodeName(String name)
		{
			StringBuilder sb;
			for (auto ch : name)
			{
				if (ch == L'.')
					sb << L"I_I";
				else
					sb << ch;
			}
			return sb.ProduceString();
		}

		bool IsInAbstractWorld(PipelineSymbol * pipeline, ShaderComponentSymbol* comp)
		{
			return comp->Implementations.First()->Worlds.Count() && !comp->Implementations.First()->SyntaxNode->IsParam &&
				pipeline->IsAbstractWorld(comp->Implementations.First()->Worlds.First());
		}

		void AssignUniqueNames(ShaderClosure * shader, String namePrefix, String publicNamePrefix)
		{
			for (auto & comp : shader->Components)
			{
				if (IsInAbstractWorld(shader->Pipeline, comp.Value.Ptr()))
				{
					comp.Value->UniqueKey = comp.Value->UniqueName = comp.Value->Name;
				}
				else
				{
					String uniqueChoiceName;
					if (comp.Value->Implementations.First()->SyntaxNode->IsPublic)
						uniqueChoiceName = publicNamePrefix + comp.Key;
					else
						uniqueChoiceName = namePrefix + comp.Key;
					comp.Value->ChoiceNames.Add(uniqueChoiceName);
					comp.Value->UniqueKey = uniqueChoiceName;
					comp.Value->UniqueName = GetUniqueCodeName(uniqueChoiceName);
				}
			}
			for (auto & subClosure : shader->SubClosures)
			{
				if (subClosure.Value->IsInPlace)
					AssignUniqueNames(subClosure.Value.Ptr(), namePrefix + subClosure.Value->Name + L".", publicNamePrefix);
				else
					AssignUniqueNames(subClosure.Value.Ptr(), namePrefix + subClosure.Key + L".", publicNamePrefix + subClosure.Key + L".");
			}
		}

		bool IsConsistentGlobalComponentDefinition(ShaderComponentSymbol * comp0, ShaderComponentSymbol * comp1)
		{
			if (comp0->Type->DataType != comp1->Type->DataType)
				return false;
			if (comp0->Implementations.First()->Worlds.Count() != comp1->Implementations.First()->Worlds.Count())
				return false;
			for (auto w : comp0->Implementations.First()->Worlds)
				if (!comp1->Implementations.First()->Worlds.Contains(w))
					return false;
			return true;
		}

		void GatherComponents(ErrorWriter * err, ShaderClosure * closure, ShaderClosure * subClosure)
		{
			for (auto & comp : subClosure->Components)
			{
				ShaderComponentSymbol* existingComp = nullptr;
				if (comp.Value->IsParam())
					continue;
				if (closure->AllComponents.TryGetValue(comp.Value->UniqueName, existingComp))
				{
					if (IsInAbstractWorld(closure->Pipeline, comp.Value.Ptr()) &&
						IsInAbstractWorld(closure->Pipeline, existingComp))
					{
						// silently ignore consistently defined global components (components in abstract worlds)
						if (!IsConsistentGlobalComponentDefinition(comp.Value.Ptr(), existingComp))
						{
							err->Error(34025, L"'" + existingComp->Name + L"': global component conflicts with previous declaration.\nsee previous declaration at " + existingComp->Implementations.First()->SyntaxNode->Position.ToString(),
								comp.Value->Implementations.First()->SyntaxNode->Position);
						}
						else
						{
							for (auto & user : existingComp->UserComponents)
							{
								user->DependentComponents.Add(comp.Value.Ptr(), user->DependentComponents[existingComp]());
								user->DependentComponents.Remove(existingComp);
								for (auto & impl : user->Implementations)
									if (impl->DependentComponents.ContainsKey(existingComp))
									{
										impl->DependentComponents.Add(comp.Value.Ptr(), impl->DependentComponents[existingComp]());
										impl->DependentComponents.Remove(existingComp);
									}
							}
							err->Warning(34026, L"'" + existingComp->Name + L"': component is already defined when compiling shader '" + closure->Name + L"'. use 'require' to declare it as a parameter. \nsee previous declaration at " + existingComp->Implementations.First()->SyntaxNode->Position.ToString(),
								comp.Value->Implementations.First()->SyntaxNode->Position);
						}
					}
					else
					{
						StringBuilder errBuilder;
						errBuilder << L"component named '" << comp.Value->UniqueKey << L"\' is already defined when compiling '" << closure->Name << L"'.";
						auto currentClosure = subClosure;
						while (currentClosure != nullptr && currentClosure != closure)
						{
							errBuilder << L"\nsee inclusion of '" << currentClosure->Name << L"' at " << currentClosure->UsingPosition.ToString() << L".";
							currentClosure = currentClosure->Parent;
						}
						err->Error(34024, errBuilder.ProduceString(), comp.Value->Implementations.First()->SyntaxNode->Position);
					}
				}
				closure->AllComponents[comp.Value->UniqueName] = comp.Value.Ptr();
			}
			for (auto & sc : subClosure->SubClosures)
				GatherComponents(err, closure, sc.Value.Ptr());
		}

		bool IsWorldFeasible(PipelineSymbol * pipeline, ShaderComponentImplSymbol * impl, String world, ShaderComponentSymbol*& unaccessibleComp)
		{
			bool isWFeasible = true;
			for (auto & dcomp : impl->DependentComponents)
			{
				if (dcomp.Value.Contains(nullptr))
				{
					bool reachable = false;
					for (auto & dw : dcomp.Key->Type->FeasibleWorlds)
					{
						if (pipeline->IsWorldImplicitlyReachable(dw, world))
						{
							reachable = true;
							break;
						}
					}
					if (!reachable)
					{
						unaccessibleComp = dcomp.Key;
						isWFeasible = false;
						break;
					}
				}
			}
			return isWFeasible;
		}

		void SolveWorldConstraints(ErrorWriter * err, ShaderClosure * shader)
		{
			EnumerableHashSet<String> allWorlds;
			for (auto w : shader->Pipeline->Worlds)
				if (!shader->Pipeline->IsAbstractWorld(w.Key))
					allWorlds.Add(w.Key);
			auto depOrder = shader->GetDependencyOrder();
			for (auto & comp : depOrder)
			{
				Dictionary<String, EnumerableHashSet<String>> autoWorlds;
				comp->Type->FeasibleWorlds.Clear();
				for (auto & impl : comp->Implementations)
				{
					if (!autoWorlds.ContainsKey(impl->AlternateName))
						autoWorlds[impl->AlternateName] = allWorlds;
					auto & autoWorld = autoWorlds[impl->AlternateName]();
					for (auto & w : impl->Worlds)
					{
						ShaderComponentSymbol* unaccessibleComp = nullptr;
						if (!IsWorldFeasible(shader->Pipeline, impl.Ptr(), w, unaccessibleComp))
						{
							err->Error(33100, L"'" + comp->Name + L"' cannot be computed at '" + w + L"' because the dependent component '" + unaccessibleComp->Name + L"' is not accessible.\nsee definition of '"
								+ unaccessibleComp->Name + L"' at " + unaccessibleComp->Implementations.First()->SyntaxNode->Position.ToString(),
								impl->ComponentReferencePositions[unaccessibleComp]());
						}
						autoWorld.Remove(w);
					}
				}
				for (auto & impl : comp->Implementations)
				{
					if (impl->Worlds.Count() == 0)
					{
						EnumerableHashSet<String> deducedWorlds = autoWorlds[impl->AlternateName]();
						EnumerableHashSet<String> feasibleWorlds;
						for (auto & w : deducedWorlds)
						{
							ShaderComponentSymbol* unaccessibleComp = nullptr;
							bool isWFeasible = IsWorldFeasible(shader->Pipeline, impl.Ptr(), w, unaccessibleComp);
							if (isWFeasible)
								feasibleWorlds.Add(w);
						}
						impl->Worlds = feasibleWorlds;
					}
					for (auto & w : impl->Worlds)
						comp->Type->FeasibleWorlds.Add(w);
				}
			}
			for (auto & comp : depOrder)
			{
				comp->Type->ConstrainedWorlds = comp->Type->FeasibleWorlds;
			}
			auto useInWorld = [&](String comp, String world)
			{
				// comp is used in world, restrict comp.ContainedWorlds to guarantee
				// all candidate definitions can reach world
				RefPtr<ShaderComponentSymbol> compSym;
				if (shader->Components.TryGetValue(comp, compSym))
				{
					EnumerableHashSet<String> newWorlds;
					for (auto & w : compSym->Type->ConstrainedWorlds)
						if (shader->Pipeline->IsWorldReachable(w, world))
							newWorlds.Add(w);
					compSym->Type->ConstrainedWorlds = _Move(newWorlds);
				}
			};
			for (auto impOp : shader->Pipeline->SyntaxNode->ImportOperators)
			{
				for (auto comp : impOp->Usings)
				{
					useInWorld(comp, impOp->DestWorld.Content);
				}
			}
		}

		bool CheckCircularReference(ErrorWriter * err, ShaderClosure * shader)
		{
			bool rs = false;
			for (auto & comp : shader->AllComponents)
			{
				for (auto & impl : comp.Value->Implementations)
				{
					// check circular references
					HashSet<ShaderComponentSymbol*> set;
					List<ShaderComponentSymbol*> referredComponents;
					referredComponents.Add(comp.Value);
					for (int i = 0; i < referredComponents.Count(); i++)
					{
						auto xcomp = referredComponents[i];
						for (auto & xcompImpl : xcomp->Implementations)
						{
							for (auto & rcomp : xcompImpl->DependentComponents)
							{
								if (set.Add(rcomp.Key))
								{
									referredComponents.Add(rcomp.Key);
								}
								if (rcomp.Key == comp.Value)
								{
									err->Error(32013, L"'" + rcomp.Key->Name + L"': circular reference is not allowed.", impl->SyntaxNode->Position);
									rs = true;
								}
							}
						}
					}
				}
			}
			return rs;
		}

		void PropagateArgumentConstraints(ShaderComponentSymbol * requirement, ShaderComponentSymbol * arg)
		{
			for (auto w : requirement->Implementations.First()->ExportWorlds)
			{
				for (auto impl : arg->Implementations)
				{
					if (impl->Worlds.Contains(w))
						impl->ExportWorlds.Add(w);
				}
			}
			for (auto w : requirement->Implementations.First()->SrcPinnedWorlds)
			{
				for (auto impl : arg->Implementations)
				{
					if (impl->Worlds.Contains(w))
						impl->SrcPinnedWorlds.Add(w);
				}
			}
		}

		void VerifyAndPropagateArgumentConstraints(ErrorWriter * err, ShaderClosure * shader)
		{
			for (auto & map : shader->RefMap)
			{
				auto & arg = map.Value;
				RefPtr<ShaderComponentSymbol> requirement;
				if (shader->Components.TryGetValue(map.Key, requirement) && requirement->IsParam())
				{
					if (requirement->Implementations.First()->SyntaxNode->Rate)
					{
						for (auto w : requirement->Implementations.First()->Worlds)
						{
							if (!shader->Pipeline->IsWorldImplicitlyReachable(arg->Type->FeasibleWorlds, w))
							{
								err->Error(32015, L"argument '" + arg->Name + L"' is not available in world '" + w + L"' as required by '" + shader->Name
									+ L"'.\nsee requirement declaration at " +
									requirement->Implementations.First()->SyntaxNode->Position.ToString(), arg->Implementations.First()->SyntaxNode->Position);
							}
						}
						PropagateArgumentConstraints(requirement.Ptr(), arg.Ptr());
					}
				}
			}
			for (auto & subClosure : shader->SubClosures)
				VerifyAndPropagateArgumentConstraints(err, subClosure.Value.Ptr());
		}

		void AddPipelineComponents(ShaderClosure * shader)
		{
			for (auto & comp : shader->Pipeline->Components)
			{
				if (!comp.Value->IsParam())
					shader->Components.AddIfNotExists(comp.Key, new ShaderComponentSymbol(*comp.Value));
			}
		}

		void FlattenShaderClosure(ErrorWriter * err, ShaderClosure * shader)
		{
			// add input(extern) components from pipeline
			AddPipelineComponents(shader);
			// assign choice names
			AssignUniqueNames(shader, L"", L"");

			ResolveReference(err, shader);
			// traverse closures to get component list
			GatherComponents(err, shader, shader);
			// propagate world constraints
			if (CheckCircularReference(err, shader))
				return;
			SolveWorldConstraints(err, shader);
			// check pipeline constraints
			for (auto & requirement : shader->Pipeline->Components)
			{
				if (!requirement.Value->IsParam())
					continue;
				auto comp = shader->FindComponent(requirement.Key);
				if (!comp)
				{
					err->Error(32014, L"shader '" + shader->Name + L"' does not provide '" + requirement.Key + L"' as required by '" + shader->Pipeline->SyntaxNode->Name.Content
						+ L"'.\nsee requirement declaration at " +
						requirement.Value->Implementations.First()->SyntaxNode->Position.ToString(), shader->Position);
				}
				else
				{
					for (auto & impl : requirement.Value->Implementations)
					{
						for (auto w : impl->Worlds)
						{
							if (!shader->Pipeline->IsWorldImplicitlyReachable(comp->Type->FeasibleWorlds, w))
							{
								err->Error(32015, L"component '" + comp->Name + L"' is not available in world '" + w + L"' as required by '" + shader->Pipeline->SyntaxNode->Name.Content
									+ L"'.\nsee requirement declaration at " +
									requirement.Value->Implementations.First()->SyntaxNode->Position.ToString(), comp->Implementations.First()->SyntaxNode->Position);
							}
						}
					}
					PropagateArgumentConstraints(requirement.Value.Ptr(), comp.Ptr());
				}
			}
			// check argument constraints
			VerifyAndPropagateArgumentConstraints(err, shader);
		}
	}
}

/***********************************************************************
CORE\CODEGENERATOR.CPP
***********************************************************************/
#include <assert.h>

namespace Spire
{
	namespace Compiler
	{
		RefPtr<ILType> TranslateExpressionType(const ExpressionType * type, Dictionary<String, RefPtr<ILRecordType>> * recordTypes)
		{
			RefPtr<ILType> resultType = 0;
			if (auto basicType = type->AsBasicType())
			{
				if (basicType->BaseType == BaseType::Struct)
				{
					resultType = basicType->Struct->Type;
				}
				else if (basicType->BaseType == BaseType::Record)
				{
					if (recordTypes)
						return (*recordTypes)[basicType->RecordTypeName]();
					else
						throw InvalidProgramException(L"unexpected record type.");
				}
				else
				{
					auto base = new ILBasicType();
					base->Type = (ILBaseType)basicType->BaseType;
					resultType = base;
				}
			}
			else if (auto arrType = type->AsArrayType())
			{
				auto nArrType = new ILArrayType();
				nArrType->BaseType = TranslateExpressionType(arrType->BaseType.Ptr(), recordTypes);
				nArrType->ArrayLength = arrType->ArrayLength;
				resultType = nArrType;
			}
			else if (auto genType = type->AsGenericType())
			{
				auto gType = new ILGenericType();
				gType->GenericTypeName = genType->GenericTypeName;
				gType->BaseType = TranslateExpressionType(genType->BaseType.Ptr(), recordTypes);
				resultType = gType;
			}
			return resultType;
		}

		RefPtr<ILType> TranslateExpressionType(const ExpressionType * type)
		{
			return TranslateExpressionType(type, nullptr);
		}

		RefPtr<ILType> TranslateExpressionType(const RefPtr<ExpressionType> & type, Dictionary<String, RefPtr<ILRecordType>> * recordTypes = nullptr)
		{
			return TranslateExpressionType(type.Ptr(), recordTypes);
		}

		template<typename Func>
		class ImportNodeVisitor : public SyntaxVisitor
		{
		public:
			const Func & func;
			ImportNodeVisitor(const Func & f)
				: func(f), SyntaxVisitor(nullptr)
			{}
			virtual RefPtr<ExpressionSyntaxNode> VisitImportExpression(ImportExpressionSyntaxNode * expr) override
			{
				func(expr);
				return expr;
			}
		};

		template<typename Func>
		void EnumerateImportExpressions(SyntaxNode * node, const Func & f)
		{
			ImportNodeVisitor<Func> visitor(f);
			node->Accept(&visitor);
		}

		class CodeGenerator : public ICodeGenerator
		{
		private:
			SymbolTable * symTable;
			ILWorld * currentWorld = nullptr;
			ComponentDefinitionIR * currentComponent = nullptr;
			ILOperand * returnRegister = nullptr;
			ImportOperatorDefSyntaxNode * currentImportDef = nullptr;
			ShaderIR * currentShader = nullptr;
			CompileResult & result;
			List<ILOperand*> exprStack;
			CodeWriter codeWriter;
			ScopeDictionary<String, ILOperand*> variables;
			Dictionary<String, RefPtr<ILRecordType>> recordTypes;

			void PushStack(ILOperand * op)
			{
				exprStack.Add(op);
			}
			ILOperand * PopStack()
			{
				auto rs = exprStack.Last();
				exprStack.SetSize(exprStack.Count() - 1);
				return rs;
			}
			AllocVarInstruction * AllocVar(ExpressionType * etype)
			{
				AllocVarInstruction * varOp = 0;
				RefPtr<ILType> type = TranslateExpressionType(const_cast<const ExpressionType*>(etype), &recordTypes);
				auto arrType = dynamic_cast<ILArrayType*>(type.Ptr());

				if (arrType)
				{
					varOp = codeWriter.AllocVar(arrType->BaseType, result.Program->ConstantPool->CreateConstant(arrType->ArrayLength));
				}
				else
				{
					assert(type);
					varOp = codeWriter.AllocVar(type, result.Program->ConstantPool->CreateConstant(0));
				}
				return varOp;
			}
			FetchArgInstruction * FetchArg(ExpressionType * etype, int argId)
			{
				auto type = TranslateExpressionType(etype, &recordTypes);
				auto arrType = dynamic_cast<ILArrayType*>(type.Ptr());
				FetchArgInstruction * varOp = 0;
				if (arrType)
				{
					auto baseType = arrType->BaseType.Release();
					varOp = codeWriter.FetchArg(baseType, argId);
				}
				else
				{
					varOp = codeWriter.FetchArg(type, argId);
				}
				return varOp;
			}
			void TranslateStages(ILShader * compiledShader, PipelineSyntaxNode * pipeline)
			{
				for (auto & stage : pipeline->Stages)
				{
					RefPtr<ILStage> ilStage = new ILStage();
					ilStage->Position = stage->Position;
					ilStage->Name = stage->Name.Content;
					ilStage->StageType = stage->StageType.Content;
					for (auto & attrib : stage->Attributes)
					{
						StageAttribute sattrib;
						sattrib.Name = attrib.Key;
						sattrib.Position = attrib.Value.Position;
						sattrib.Value = attrib.Value.Content;
						ilStage->Attributes[attrib.Key] = sattrib;
					}
					compiledShader->Stages[stage->Name.Content] = ilStage;
				}
			}
		public:
			virtual RefPtr<StructSyntaxNode> VisitStruct(StructSyntaxNode * st) override
			{
				result.Program->Structs.Add(symTable->Structs[st->Name.Content]()->Type);
				return st;
			}
			virtual void ProcessFunction(FunctionSyntaxNode * func) override
			{
				VisitFunction(func);
			}
			virtual void ProcessStruct(StructSyntaxNode * st) override
			{
				VisitStruct(st);
			}

			virtual void ProcessShader(ShaderIR * shader) override
			{
				currentShader = shader;
				auto pipeline = shader->Shader->Pipeline;
				RefPtr<ILShader> compiledShader = new ILShader();
				compiledShader->Name = shader->Shader->Name;
				TranslateStages(compiledShader.Ptr(), pipeline->SyntaxNode);
				result.Program->Shaders.Add(compiledShader);

				recordTypes.Clear();

				// pass 1: iterating all worlds
				// create ILWorld and ILRecordType objects for all worlds

				for (auto & world : pipeline->Worlds)
				{
					auto w = new ILWorld();
					auto recordType = new ILRecordType();
					recordType->TypeName = world.Key;
					recordTypes[world.Key] = recordType;
					w->Name = world.Key;
					w->OutputType = recordType;
					w->Attributes = world.Value.SyntaxNode->LayoutAttributes;
					w->Shader = compiledShader.Ptr();
					w->IsAbstract = world.Value.IsAbstract;
					auto impOps = pipeline->GetImportOperatorsFromSourceWorld(world.Key);
					w->Position = world.Value.SyntaxNode->Position;
					compiledShader->Worlds[world.Key] = w;
				}

				// pass 2: iterating all worlds:
				// 1) Gather list of components for each world, and store it in worldComps dictionary.
				// 2) For each abstract world, add its components to record type

				Dictionary<String, List<ComponentDefinitionIR*>> worldComps;
				
				for (auto & world : pipeline->Worlds)
				{
					// gather list of components
					List<ComponentDefinitionIR*> components;
					for (auto & compDef : shader->Definitions)
						if (compDef->World == world.Key)
							components.Add(compDef.Ptr());

					// for abstract world, fill in record type now
					if (world.Value.IsAbstract)
					{
						auto compiledWorld = compiledShader->Worlds[world.Key]();
						for (auto & comp : components)
						{
							ILObjectDefinition compDef;
							compDef.Attributes = comp->SyntaxNode->LayoutAttributes;
							compDef.Name = comp->UniqueName;
							compDef.Type = TranslateExpressionType(comp->Type.Ptr(), &recordTypes);
							compDef.Position = comp->SyntaxNode->Position;
							compiledWorld->OutputType->Members.AddIfNotExists(compDef.Name, compDef);
						}
					}

					// sort components by dependency
					DependencySort(components, [](ComponentDefinitionIR * def)
					{
						return def->Dependency;
					});
					// put the list in worldComps
					worldComps[world.Key] = components;
				}

				// now we need to deal with import operators
				// create world input declarations base on input components
				for (auto & world : compiledShader->Worlds)
				{
					auto components = worldComps[world.Key]();
					for (auto & comp : components)
					{
						if (comp->SyntaxNode->IsInput)
						{
							ILObjectDefinition def;
							def.Name = comp->UniqueName;
							def.Type = TranslateExpressionType(comp->Type.Ptr(), &recordTypes);
							def.Position = comp->SyntaxNode->Position;
							world.Value->Inputs.Add(def);
						}
					}
				}

				// fill in record types
				for (auto & comps : worldComps)
				{
					for (auto & comp : comps.Value)
					{
						// for each import operator call "import[w0->w1](x)", add x to w0's record type
						EnumerateImportExpressions(comp->SyntaxNode.Ptr(), [&](ImportExpressionSyntaxNode * importExpr)
						{
							auto & recType = recordTypes[importExpr->ImportOperatorDef->SourceWorld.Content]();
							ILObjectDefinition entryDef;
							entryDef.Attributes = comp->SyntaxNode->LayoutAttributes;
							entryDef.Name = importExpr->ComponentUniqueName;
							entryDef.Type = TranslateExpressionType(importExpr->Type.Ptr(), &recordTypes);
							entryDef.Position = importExpr->Position;
							recType->Members.AddIfNotExists(importExpr->ComponentUniqueName, entryDef);
						});
						// if comp is output, add comp to its world's record type
						if (comp->SyntaxNode->IsOutput)
						{
							auto & recType = recordTypes[comp->World]();
							ILObjectDefinition entryDef;
							entryDef.Attributes = comp->SyntaxNode->LayoutAttributes;
							entryDef.Name = comp->UniqueName;
							entryDef.Type = TranslateExpressionType(comp->Type.Ptr(), &recordTypes);
							entryDef.Position = comp->SyntaxNode->Position;
							recType->Members.AddIfNotExists(comp->UniqueName, entryDef);
						}
					}
				}
				
				for (auto & world : pipeline->Worlds)
				{
					if (world.Value.IsAbstract)
						continue;
					NamingCounter = 0;

					auto & components = worldComps[world.Key].GetValue();
					auto compiledWorld = compiledShader->Worlds[world.Key].GetValue().Ptr();
					currentWorld = compiledWorld;
					codeWriter.PushNode();
					variables.PushScope();
					HashSet<String> localComponents;
					for (auto & comp : components)
						localComponents.Add(comp->UniqueName);

					DependencySort(components, [](ComponentDefinitionIR * def)
					{
						return def->Dependency;
					});

					for (auto & comp : components)
					{
						VisitComponent(comp);
					}
					
					variables.PopScope();
					compiledWorld->Code = codeWriter.PopNode();
					EvalReferencedFunctionClosure(compiledWorld);
					currentWorld = nullptr;
				}
				currentShader = nullptr;
			}

			void EvalReferencedFunctionClosure(ILWorld * world)
			{
				List<String> workList;
				for (auto & rfunc : world->ReferencedFunctions)
					workList.Add(rfunc);
				for (int i = 0; i < workList.Count(); i++)
				{
					auto rfunc = workList[i];
					RefPtr<FunctionSymbol> funcSym;
					if (symTable->Functions.TryGetValue(rfunc, funcSym))
					{
						for (auto & rrfunc : funcSym->ReferencedFunctions)
						{
							world->ReferencedFunctions.Add(rrfunc);
							workList.Add(rrfunc);
						}
					}
				}
			}
			virtual RefPtr<ComponentSyntaxNode> VisitComponent(ComponentSyntaxNode *) override
			{
				throw NotImplementedException();
			}
			void VisitComponent(ComponentDefinitionIR * comp)
			{
				currentComponent = comp;
				String varName = L"_vcmp" + currentComponent->UniqueName;
				RefPtr<ILType> type = TranslateExpressionType(currentComponent->Type, &recordTypes);

				if (comp->SyntaxNode->IsInput)
				{
					auto loadInput = new LoadInputInstruction(type.Ptr(), comp->UniqueName);
					codeWriter.Insert(loadInput);
					variables.Add(currentComponent->UniqueName, loadInput);
					return;
				}

				ILOperand * componentVar = nullptr;
				

				if (currentComponent->SyntaxNode->Expression)
				{
					currentComponent->SyntaxNode->Expression->Accept(this);
					componentVar = exprStack.Last();
					if (currentWorld->OutputType->Members.ContainsKey(currentComponent->UniqueName))
					{
						auto exp = new ExportInstruction(currentComponent->UniqueName, currentWorld, componentVar);
						codeWriter.Insert(exp);
					}
					exprStack.Clear();
				}
				else if (currentComponent->SyntaxNode->BlockStatement)
				{
					returnRegister = nullptr;
					currentComponent->SyntaxNode->BlockStatement->Accept(this);
					componentVar = returnRegister;
				}
				currentWorld->Components[currentComponent->UniqueName] = componentVar;
				variables.Add(currentComponent->UniqueName, componentVar);
				componentVar->Name = varName;
				currentComponent = nullptr;
			}
			virtual RefPtr<FunctionSyntaxNode> VisitFunction(FunctionSyntaxNode* function) override
			{
				if (function->IsExtern)
					return function;
				RefPtr<ILFunction> func = new ILFunction();
				result.Program->Functions.Add(func);
				func->Name = function->InternalName;
				func->ReturnType = TranslateExpressionType(function->ReturnType);
				variables.PushScope();
				codeWriter.PushNode();
				int id = 0;
				for (auto &param : function->Parameters)
				{
					func->Parameters.Add(param->Name, TranslateExpressionType(param->Type));
					auto op = FetchArg(param->Type.Ptr(), ++id);
					op->Name = String(L"p_") + param->Name;
					variables.Add(param->Name, op);
				}
				function->Body->Accept(this);
				func->Code = codeWriter.PopNode();
				variables.PopScope();
				return function;
			}
			virtual RefPtr<StatementSyntaxNode> VisitBlockStatement(BlockStatementSyntaxNode* stmt) override
			{
				variables.PushScope();
				for (auto & subStmt : stmt->Statements)
					subStmt->Accept(this);
				variables.PopScope();
				return stmt;
			}
			virtual RefPtr<StatementSyntaxNode> VisitWhileStatement(WhileStatementSyntaxNode* stmt) override
			{
				RefPtr<WhileInstruction> instr = new WhileInstruction();
				variables.PushScope();
				codeWriter.PushNode();
				stmt->Predicate->Accept(this);
				codeWriter.Insert(new ReturnInstruction(PopStack()));
				instr->ConditionCode = codeWriter.PopNode();
				codeWriter.PushNode();
				stmt->Statement->Accept(this);
				instr->BodyCode = codeWriter.PopNode();
				codeWriter.Insert(instr.Release());
				variables.PopScope();
				return stmt;
			}
			virtual RefPtr<StatementSyntaxNode> VisitDoWhileStatement(DoWhileStatementSyntaxNode* stmt) override
			{
				RefPtr<DoInstruction> instr = new DoInstruction();
				variables.PushScope();
				codeWriter.PushNode();
				stmt->Predicate->Accept(this);
				codeWriter.Insert(new ReturnInstruction(PopStack()));
				instr->ConditionCode = codeWriter.PopNode();
				codeWriter.PushNode();
				stmt->Statement->Accept(this);
				instr->BodyCode = codeWriter.PopNode();
				codeWriter.Insert(instr.Release());
				variables.PopScope();
				return stmt;
			}
			virtual RefPtr<StatementSyntaxNode> VisitForStatement(ForStatementSyntaxNode* stmt) override
			{
				RefPtr<ForInstruction> instr = new ForInstruction();
				variables.PushScope();
				if (stmt->TypeDef)
				{
					AllocVarInstruction * varOp = AllocVar(stmt->IterationVariableType.Ptr());
					varOp->Name = L"v_" + String(NamingCounter++) + stmt->IterationVariable.Content;
					variables.Add(stmt->IterationVariable.Content, varOp);
				}
				ILOperand * iterVar = nullptr;
				if (!variables.TryGetValue(stmt->IterationVariable.Content, iterVar))
					throw InvalidProgramException(L"Iteration variable not found in variables dictionary. This should have been checked by semantics analyzer.");
				stmt->InitialExpression->Accept(this);
				Assign(iterVar, PopStack());

				codeWriter.PushNode();
				stmt->EndExpression->Accept(this);
				auto val = PopStack();
				codeWriter.Insert(new CmpleInstruction(codeWriter.Load(iterVar), val));
				instr->ConditionCode = codeWriter.PopNode();

				codeWriter.PushNode();
				ILOperand * stepVal = nullptr;
				if (stmt->StepExpression)
				{
					stmt->StepExpression->Accept(this);
					stepVal = PopStack();
				}
				else
				{
					if (iterVar->Type->IsFloat())
						stepVal = result.Program->ConstantPool->CreateConstant(1.0f);
					else
						stepVal = result.Program->ConstantPool->CreateConstant(1);
				}
				auto afterVal = new AddInstruction(codeWriter.Load(iterVar), stepVal);
				codeWriter.Insert(afterVal);
				Assign(iterVar, afterVal);
				instr->SideEffectCode = codeWriter.PopNode();

				codeWriter.PushNode();
				stmt->Statement->Accept(this);
				instr->BodyCode = codeWriter.PopNode();
				codeWriter.Insert(instr.Release());
				variables.PopScope();
				return stmt;
			}
			virtual RefPtr<StatementSyntaxNode> VisitIfStatement(IfStatementSyntaxNode* stmt) override
			{
				RefPtr<IfInstruction> instr = new IfInstruction();
				variables.PushScope();
				stmt->Predicate->Accept(this);
				instr->Operand = PopStack();
				codeWriter.PushNode();
				stmt->PositiveStatement->Accept(this);
				instr->TrueCode = codeWriter.PopNode();
				if (stmt->NegativeStatement)
				{
					codeWriter.PushNode();
					stmt->NegativeStatement->Accept(this);
					instr->FalseCode = codeWriter.PopNode();
				}
				codeWriter.Insert(instr.Release());
				variables.PopScope();
				return stmt;
			}
			virtual RefPtr<StatementSyntaxNode> VisitReturnStatement(ReturnStatementSyntaxNode* stmt) override
			{
				returnRegister = nullptr;
				if (currentComponent != nullptr && !currentImportDef)
				{
					if (stmt->Expression)
					{
						stmt->Expression->Accept(this);
						auto val = PopStack();
						if (currentWorld->OutputType->Members.ContainsKey(currentComponent->UniqueName))
						{
							auto exp = new ExportInstruction(currentComponent->UniqueName, currentWorld, val);
							codeWriter.Insert(exp);
						}
						returnRegister = val;
					}
				}
				else
				{
					if (stmt->Expression)
					{
						stmt->Expression->Accept(this);
						returnRegister = PopStack();
					}
					codeWriter.Insert(new ReturnInstruction(returnRegister));
				}
				return stmt;
			}
			virtual RefPtr<StatementSyntaxNode> VisitBreakStatement(BreakStatementSyntaxNode* stmt) override
			{
				codeWriter.Insert(new BreakInstruction());
				return stmt;
			}
			virtual RefPtr<StatementSyntaxNode> VisitContinueStatement(ContinueStatementSyntaxNode* stmt) override
			{
				codeWriter.Insert(new ContinueInstruction());
				return stmt;
			}
			virtual RefPtr<ExpressionSyntaxNode> VisitSelectExpression(SelectExpressionSyntaxNode * expr) override
			{
				expr->SelectorExpr->Accept(this);
				auto predOp = PopStack();
				expr->Expr0->Accept(this);
				auto v0 = PopStack();
				expr->Expr1->Accept(this);
				auto v1 = PopStack();
				PushStack(codeWriter.Select(predOp, v0, v1));
				return expr;
			}
			ILOperand * EnsureBoolType(ILOperand * op, RefPtr<ExpressionType> type)
			{
				if (!type->Equals(ExpressionType::Bool.Ptr()))
				{
					auto cmpeq = new CmpneqInstruction();
					cmpeq->Operands[0] = op;
					cmpeq->Operands[1] = result.Program->ConstantPool->CreateConstant(0);
					cmpeq->Type = new ILBasicType(ILBaseType::Int);
					codeWriter.Insert(cmpeq);
					return cmpeq;
				}
				else
					return op;
			}
			virtual RefPtr<StatementSyntaxNode> VisitDiscardStatement(DiscardStatementSyntaxNode * stmt) override
			{
				codeWriter.Discard();
				return stmt;
			}
			virtual RefPtr<StatementSyntaxNode> VisitVarDeclrStatement(VarDeclrStatementSyntaxNode* stmt) override
			{
				for (auto & v : stmt->Variables)
				{
					AllocVarInstruction * varOp = AllocVar(stmt->Type.Ptr());
					varOp->Name = L"v" + String(NamingCounter++) + L"_" + v->Name;
					variables.Add(v->Name, varOp);
					if (v->Expression)
					{
						v->Expression->Accept(this);
						Assign(varOp, PopStack());
					}
				}
				return stmt;
			}
			virtual RefPtr<StatementSyntaxNode> VisitExpressionStatement(ExpressionStatementSyntaxNode* stmt) override
			{
				stmt->Expression->Accept(this);
				PopStack();
				return stmt;
			}
			void Assign(ILOperand * left, ILOperand * right)
			{
				if (auto add = dynamic_cast<AddInstruction*>(left))
				{
					auto baseOp = add->Operands[0].Ptr();
					codeWriter.Store(add->Operands[0].Ptr(), codeWriter.Update(codeWriter.Load(baseOp), add->Operands[1].Ptr(), right));
					add->Erase();
				}
				else
					codeWriter.Store(left, right);
			}
			virtual RefPtr<ExpressionSyntaxNode> VisitBinaryExpression(BinaryExpressionSyntaxNode* expr) override
			{
				expr->RightExpression->Accept(this);
				auto right = PopStack();
				if (expr->Operator == Operator::Assign)
				{
					expr->LeftExpression->Access = ExpressionAccess::Write;
					expr->LeftExpression->Accept(this);
					auto left = PopStack();
					Assign(left, right);
					PushStack(left);
				}
				else
				{
					expr->LeftExpression->Access = ExpressionAccess::Read;
					expr->LeftExpression->Accept(this);
					auto left = PopStack();
					BinaryInstruction * rs = 0;
					switch (expr->Operator)
					{
					case Operator::Add:
					case Operator::AddAssign:
						rs = new AddInstruction();
						break;
					case Operator::Sub:
					case Operator::SubAssign:
						rs = new SubInstruction();
						break;
					case Operator::Mul:
					case Operator::MulAssign:
						rs = new MulInstruction();
						break;
					case Operator::Mod:
					case Operator::ModAssign:
						rs = new ModInstruction();
						break;
					case Operator::Div:
					case Operator::DivAssign:
						rs = new DivInstruction();
						break;
					case Operator::And:
						rs = new AndInstruction();
						break;
					case Operator::Or:
						rs = new OrInstruction();
						break;
					case Operator::BitAnd:
					case Operator::AndAssign:
						rs = new BitAndInstruction();
						break;
					case Operator::BitOr:
					case Operator::OrAssign:
						rs = new BitOrInstruction();
						break;
					case Operator::BitXor:
					case Operator::XorAssign:
						rs = new BitXorInstruction();
						break;
					case Operator::Lsh:
					case Operator::LshAssign:
						rs = new ShlInstruction();
						break;
					case Operator::Rsh:
					case Operator::RshAssign:
						rs = new ShrInstruction();
						break;
					case Operator::Eql:
						rs = new CmpeqlInstruction();
						break;
					case Operator::Neq:
						rs = new CmpneqInstruction();
						break;
					case Operator::Greater:
						rs = new CmpgtInstruction();
						break;
					case Operator::Geq:
						rs = new CmpgeInstruction();
						break;
					case Operator::Leq:
						rs = new CmpleInstruction();
						break;
					case Operator::Less:
						rs = new CmpltInstruction();
						break;
					default:
						throw NotImplementedException(L"Code gen not implemented for this operator.");
					}
					rs->Operands.SetSize(2);
					rs->Operands[0] = left;
					rs->Operands[1] = right;
					rs->Type = TranslateExpressionType(expr->Type, &recordTypes);
					codeWriter.Insert(rs);
					switch (expr->Operator)
					{
					case Operator::AddAssign:
					case Operator::SubAssign:
					case Operator::MulAssign:
					case Operator::DivAssign:
					case Operator::ModAssign:
					case Operator::LshAssign:
					case Operator::RshAssign:
					case Operator::AndAssign:
					case Operator::OrAssign:
					case Operator::XorAssign:
					{
						expr->LeftExpression->Access = ExpressionAccess::Write;
						expr->LeftExpression->Accept(this);
						auto target = PopStack();
						Assign(target, rs);
						break;
					}
					default:
						break;
					}
					PushStack(rs);
				}
				return expr;
			}
			virtual RefPtr<ExpressionSyntaxNode> VisitConstantExpression(ConstantExpressionSyntaxNode* expr) override
			{
				ILConstOperand * op;
				if (expr->ConstType == ConstantExpressionSyntaxNode::ConstantType::Float)
				{
					op = result.Program->ConstantPool->CreateConstant(expr->FloatValue);
				}
				else
				{
					op = result.Program->ConstantPool->CreateConstant(expr->IntValue);
				}
				PushStack(op);
				return expr;
			}
			void GenerateIndexExpression(ILOperand * base, ILOperand * idx, bool read)
			{
				if (read)
				{
					auto ldInstr = codeWriter.Retrieve(base, idx);
					ldInstr->Attribute = base->Attribute;
					PushStack(ldInstr);
				}
				else
				{
					PushStack(codeWriter.Add(base, idx));
				}
			}
			virtual RefPtr<ExpressionSyntaxNode> VisitImportExpression(ImportExpressionSyntaxNode * expr) override
			{
				variables.PushScope();
				List<ILOperand*> arguments;
				for (int i = 0; i < expr->Arguments.Count(); i++)
				{
					expr->Arguments[i]->Accept(this);
					auto argOp = PopStack();
					arguments.Add(argOp);
					variables.Add(expr->ImportOperatorDef->Parameters[i]->Name, argOp);
				}
				currentImportDef = expr->ImportOperatorDef.Ptr();
				codeWriter.PushNode();
				expr->ImportOperatorDef->Body->Accept(this);
				currentImportDef = nullptr;
				auto impInstr = new ImportInstruction(expr->Arguments.Count());
				for (int i = 0; i < expr->Arguments.Count(); i++)
					impInstr->Arguments[i] = arguments[i];
				impInstr->ImportOperator = codeWriter.PopNode();
				variables.PopScope();
				impInstr->ComponentName = expr->ComponentUniqueName;
				impInstr->Type = TranslateExpressionType(expr->Type, &recordTypes);
				codeWriter.Insert(impInstr);
				PushStack(impInstr);
				return expr;
			}
			virtual RefPtr<ExpressionSyntaxNode> VisitIndexExpression(IndexExpressionSyntaxNode* expr) override
			{
				expr->BaseExpression->Access = expr->Access;
				expr->BaseExpression->Accept(this);
				auto base = PopStack();
				expr->IndexExpression->Access = ExpressionAccess::Read;
				expr->IndexExpression->Accept(this);
				auto idx = PopStack();
				GenerateIndexExpression(base, idx,
					expr->Access == ExpressionAccess::Read);
				return expr;
			}
			virtual RefPtr<ExpressionSyntaxNode> VisitMemberExpression(MemberExpressionSyntaxNode * expr) override
			{
				RefPtr<Object> refObj;
				if (expr->Tags.TryGetValue(L"ComponentReference", refObj))
				{
					if (auto refComp = refObj.As<StringObject>())
					{
						ILOperand * op;
						if (variables.TryGetValue(refComp->Content, op))
							PushStack(op);
						else
							throw InvalidProgramException(L"referencing undefined component/variable. probable cause: unchecked circular reference.");
					}
				}
				else
				{
					expr->BaseExpression->Access = expr->Access;
					expr->BaseExpression->Accept(this);
					auto base = PopStack();
					auto generateSingleMember = [&](wchar_t memberName)
					{
						int idx = 0;
						if (memberName == L'y' || memberName == L'g')
							idx = 1;
						else if (memberName == L'z' || memberName == L'b')
							idx = 2;
						else if (memberName == L'w' || memberName == L'a')
							idx = 3;

						GenerateIndexExpression(base, result.Program->ConstantPool->CreateConstant(idx),
							expr->Access == ExpressionAccess::Read);
					};
					if (expr->BaseExpression->Type->IsVectorType())
					{
						if (expr->MemberName.Length() == 1)
						{
							generateSingleMember(expr->MemberName[0]);
						}
						else
						{
							if (expr->Access != ExpressionAccess::Read)
								throw InvalidOperationException(L"temporary vector (vec.xyz) is read-only.");
							auto rs = AllocVar(expr->Type.Ptr());
							ILOperand* tmp = codeWriter.Load(rs);
							for (int i = 0; i < expr->MemberName.Length(); i++)
							{
								generateSingleMember(expr->MemberName[i]);
								tmp = codeWriter.Update(tmp, result.Program->ConstantPool->CreateConstant(i), PopStack());
							}
							codeWriter.Store(rs, tmp);
							PushStack(codeWriter.Load(rs));
						}
					}
					else if (expr->BaseExpression->Type->IsStruct())
					{
						if (expr->Access == ExpressionAccess::Read)
						{
							int id = expr->BaseExpression->Type->AsBasicType()->Struct->SyntaxNode->FindField(expr->MemberName);
							GenerateIndexExpression(base, result.Program->ConstantPool->CreateConstant(id),
								expr->Access == ExpressionAccess::Read);
						}
						else
						{
						}
					}
					else
						throw NotImplementedException(L"member expression codegen");
				}
				return expr;
			}
			virtual RefPtr<ExpressionSyntaxNode> VisitInvokeExpression(InvokeExpressionSyntaxNode* expr) override
			{
				List<ILOperand*> args;
				if (currentWorld)
					currentWorld->ReferencedFunctions.Add(expr->FunctionExpr->Variable);
				for (auto arg : expr->Arguments)
				{
					arg->Accept(this);
					args.Add(PopStack());
				}
				auto instr = new CallInstruction(args.Count());
				instr->Function = expr->FunctionExpr->Variable;
				for (int i = 0; i < args.Count(); i++)
					instr->Arguments[i] = args[i];
				instr->Type = TranslateExpressionType(expr->Type, &recordTypes);
				codeWriter.Insert(instr);
				PushStack(instr);
				return expr;
			}
			virtual RefPtr<ExpressionSyntaxNode> VisitTypeCastExpression(TypeCastExpressionSyntaxNode * expr) override
			{
				expr->Expression->Accept(this);
				auto base = PopStack();
				if (expr->Expression->Type == expr->Type)
				{
					PushStack(base);
				}
				else if (expr->Expression->Type == ExpressionType::Float &&
					expr->Type == ExpressionType::Int)
				{
					auto instr = new Float2IntInstruction(base);
					codeWriter.Insert(instr);
					PushStack(instr);
				}
				else if (expr->Expression->Type == ExpressionType::Int &&
					expr->Type == ExpressionType::Float)
				{
					auto instr = new Int2FloatInstruction(base);
					codeWriter.Insert(instr);
					PushStack(instr);
				}
				else
				{
					Error(40001, L"Invalid type cast: \"" + expr->Expression->Type->ToString() + L"\" to \"" +
						expr->Type->ToString() + L"\"", expr);
				}
				return expr;
			}
			virtual RefPtr<ExpressionSyntaxNode> VisitUnaryExpression(UnaryExpressionSyntaxNode* expr) override
			{
				if (expr->Operator == Operator::PostDec || expr->Operator == Operator::PostInc
					|| expr->Operator == Operator::PreDec || expr->Operator == Operator::PreInc)
				{
					expr->Expression->Access = ExpressionAccess::Read;
					expr->Expression->Accept(this);
					auto base = PopStack();
					BinaryInstruction * instr;
					if (expr->Operator == Operator::PostDec)
						instr = new SubInstruction();
					else
						instr = new AddInstruction();
					instr->Operands.SetSize(2);
					instr->Operands[0] = base;
					if (expr->Type == ExpressionType::Float)
						instr->Operands[1] = result.Program->ConstantPool->CreateConstant(1.0f);
					else
						instr->Operands[1] = result.Program->ConstantPool->CreateConstant(1);
					instr->Type = TranslateExpressionType(expr->Type, &recordTypes);
					codeWriter.Insert(instr);

					expr->Expression->Access = ExpressionAccess::Write;
					expr->Expression->Accept(this);
					auto dest = PopStack();
					auto store = new StoreInstruction(dest, instr);
					codeWriter.Insert(store);
					PushStack(base);
				}
				else if (expr->Operator == Operator::PreDec || expr->Operator == Operator::PreInc)
				{
					expr->Expression->Access = ExpressionAccess::Read;
					expr->Expression->Accept(this);
					auto base = PopStack();
					BinaryInstruction * instr;
					if (expr->Operator == Operator::PostDec)
						instr = new SubInstruction();
					else
						instr = new AddInstruction();
					instr->Operands.SetSize(2);
					instr->Operands[0] = base;
					if (expr->Type == ExpressionType::Float)
						instr->Operands[1] = result.Program->ConstantPool->CreateConstant(1.0f);
					else
						instr->Operands[1] = result.Program->ConstantPool->CreateConstant(1);
					instr->Type = TranslateExpressionType(expr->Type, &recordTypes);
					codeWriter.Insert(instr);

					expr->Expression->Access = ExpressionAccess::Write;
					expr->Expression->Accept(this);
					auto dest = PopStack();
					auto store = new StoreInstruction(dest, instr);
					codeWriter.Insert(store);
					PushStack(instr);
				}
				else
				{
					expr->Expression->Accept(this);
					auto base = PopStack();
					auto genUnaryInstr = [&](ILOperand * input)
					{
						UnaryInstruction * rs = 0;
						switch (expr->Operator)
						{
						case Operator::Not:
							input = EnsureBoolType(input, expr->Expression->Type);
							rs = new NotInstruction();
							break;
						case Operator::Neg:
							rs = new NegInstruction();
							break;
						case Operator::BitNot:
							rs = new BitNotInstruction();
							break;
						default:
							throw NotImplementedException(L"Code gen is not implemented for this operator.");
						}
						rs->Operand = input;
						rs->Type = input->Type;
						codeWriter.Insert(rs);
						return rs;
					};
					PushStack(genUnaryInstr(base));
				}
				return expr;
			}
			bool GenerateVarRef(String name, ExpressionAccess access)
			{
				ILOperand * var = 0;
				String srcName = name;
				if (!variables.TryGetValue(srcName, var))
				{
					return false;
				}
				if (access == ExpressionAccess::Read)
				{
					PushStack(var);
				}
				else
				{
					PushStack(var);
				}
				return true;
			}
			virtual RefPtr<ExpressionSyntaxNode> VisitVarExpression(VarExpressionSyntaxNode* expr) override
			{
				RefPtr<Object> refObj;
				if (expr->Tags.TryGetValue(L"ComponentReference", refObj))
				{
					if (auto refComp = refObj.As<StringObject>())
					{
						ILOperand * op;
						if (variables.TryGetValue(refComp->Content, op))
							PushStack(op);
						else
							throw InvalidProgramException(L"referencing undefined component/variable. probable cause: unchecked circular reference.");
					}
				}
				else if (!GenerateVarRef(expr->Variable, expr->Access))
				{
					throw InvalidProgramException(L"identifier is neither a variable nor a recognized component.");
				}
				return expr;
			}
		private:
			CodeGenerator & operator = (const CodeGenerator & other) = delete;
		public:
			CodeGenerator(SymbolTable * symbols, ErrorWriter * pErr, CompileResult & _result)
				: ICodeGenerator(pErr), symTable(symbols), result(_result)
			{
				result.Program = new ILProgram();
				codeWriter.SetConstantPool(result.Program->ConstantPool.Ptr());
			}
		};

		ICodeGenerator * CreateCodeGenerator(SymbolTable * symbols, CompileResult & result)
		{
			return new CodeGenerator(symbols, result.GetErrorWriter(), result);
		}
	}
}

/***********************************************************************
CORE\COMPILEDPROGRAM.CPP
***********************************************************************/
namespace Spire
{
	namespace Compiler
	{
		void IndentString(StringBuilder & sb, String src)
		{
			int indent = 0;
			bool beginTrim = true;
			for (int c = 0; c < src.Length(); c++)
			{
				auto ch = src[c];
				if (ch == L'\n')
				{
					sb << L"\n";

					beginTrim = true;
				}
				else
				{
					if (beginTrim)
					{
						while (c < src.Length() - 1 && (src[c] == L'\t' || src[c] == L'\n' || src[c] == L'\r' || src[c] == L' '))
						{
							c++;
							ch = src[c];
						}
						for (int i = 0; i < indent - 1; i++)
							sb << L'\t';
						if (ch != '}' && indent > 0)
							sb << L'\t';
						beginTrim = false;
					}

					if (ch == L'{')
						indent++;
					else if (ch == L'}')
						indent--;
					if (indent < 0)
						indent = 0;

					sb << ch;
				}
			}
		}
		ShaderChoiceValue ShaderChoiceValue::Parse(String str)
		{
			ShaderChoiceValue result;
			int idx = str.IndexOf(L':');
			if (idx == -1)
				return ShaderChoiceValue(str, L"");
			return ShaderChoiceValue(str.SubString(0, idx), str.SubString(idx + 1, str.Length() - idx - 1));
		}
		
}
}

/***********************************************************************
CORE\CONSTANTPOOL.CPP
***********************************************************************/
#ifndef CONSTANT_POOL_H
#define CONSTANT_POOL_H


namespace Spire
{
	namespace Compiler
	{
		class ConstantPoolImpl
		{
		private:
			ILUndefinedOperand undefOperand;
			Dictionary<ConstKey<int>, ILConstOperand*> intConsts;
			Dictionary<ConstKey<float>, ILConstOperand*> floatConsts;
			List<RefPtr<ILConstOperand>> constants;
		public:
			ILUndefinedOperand * GetUndefinedOperand()
			{
				return &undefOperand;
			}
			ILOperand * CreateDefaultValue(ILType * type)
			{
				ILOperand * value = 0;
				if (type->IsFloat())
					value = CreateConstant(0.0f);
				else if (type->IsInt())
					value = CreateConstant(0);
				else if (auto baseType = dynamic_cast<ILBasicType*>(type))
				{
					if (baseType->Type == ILBaseType::Int2)
					{
						value = CreateConstant(0, 2);
					}
					else if (baseType->Type == ILBaseType::Int3)
					{
						value = CreateConstant(0, 3);
					}
					else if (baseType->Type == ILBaseType::Int4)
					{
						value = CreateConstant(0, 4);
					}
					else if (baseType->Type == ILBaseType::Float2)
					{
						value = CreateConstant(0.0f, 2);
					}
					else if (baseType->Type == ILBaseType::Float3)
					{
						value = CreateConstant(0.0f, 3);
					}
					else if (baseType->Type == ILBaseType::Float4)
					{
						value = CreateConstant(0.0f, 4);
					}
					else if (baseType->Type == ILBaseType::Float3x3)
					{
						value = CreateConstant(0.0f, 9);
					}
					else if (baseType->Type == ILBaseType::Float4x4)
					{
						value = CreateConstant(0.0f, 16);
					}
					else
						throw NotImplementedException(L"default value for this type is not implemented.");
				}
				else
					throw NotImplementedException(L"default value for this type is not implemented.");
				return value;
			}
			ILConstOperand * CreateConstantIntVec(int val, int val2)
			{
				ILConstOperand * rs = 0;
				auto key = ConstKey<int>::FromValues(val, val2);
				if (intConsts.TryGetValue(key, rs))
					return rs;
				rs = new ILConstOperand();
				rs->Type = new ILBasicType(ILBaseType::Int2);
				rs->IntValues[0] = val;
				rs->IntValues[1] = val2;
				intConsts[key] = rs;
				rs->Name = rs->ToString();
				constants.Add(rs);
				return rs;
			}

			ILConstOperand * CreateConstantIntVec(int val, int val2, int val3)
			{
				ILConstOperand * rs = 0;
				auto key = ConstKey<int>::FromValues(val, val2, val3);
				if (intConsts.TryGetValue(key, rs))
					return rs;
				rs = new ILConstOperand();
				rs->Type = new ILBasicType(ILBaseType::Int3);
				rs->IntValues[0] = val;
				rs->IntValues[1] = val2;
				rs->IntValues[2] = val3;

				intConsts[key] = rs;
				rs->Name = rs->ToString();
				constants.Add(rs);

				return rs;
			}
			ILConstOperand * CreateConstantIntVec(int val, int val2, int val3, int val4)
			{
				ILConstOperand * rs = 0;
				auto key = ConstKey<int>::FromValues(val, val2, val3, val4);
				if (intConsts.TryGetValue(key, rs))
					return rs;
				rs = new ILConstOperand();
				rs->Type = new ILBasicType(ILBaseType::Int4);
				rs->IntValues[0] = val;
				rs->IntValues[1] = val2;
				rs->IntValues[2] = val3;
				rs->IntValues[3] = val4;
				intConsts[key] = rs;
				rs->Name = rs->ToString();
				constants.Add(rs);

				return rs;
			}

			ILConstOperand * CreateConstant(ILConstOperand * c)
			{
				auto baseType = dynamic_cast<ILBasicType*>(c->Type.Ptr())->Type;
				switch (baseType)
				{
				case ILBaseType::Float:
					return CreateConstant(c->FloatValues[0]);
				case ILBaseType::Float2:
					return CreateConstant(c->FloatValues[0], c->FloatValues[1]);
				case ILBaseType::Float3:
					return CreateConstant(c->FloatValues[0], c->FloatValues[1], c->FloatValues[2]);
				case ILBaseType::Float4:
					return CreateConstant(c->FloatValues[0], c->FloatValues[1], c->FloatValues[2], c->FloatValues[3]);
				case ILBaseType::Int:
					return CreateConstant(c->IntValues[0]);
				case ILBaseType::Int2:
					return CreateConstantIntVec(c->IntValues[0], c->IntValues[1]);
				case ILBaseType::Int3:
					return CreateConstantIntVec(c->IntValues[0], c->IntValues[1], c->IntValues[2]);
				case ILBaseType::Int4:
					return CreateConstantIntVec(c->IntValues[0], c->IntValues[1], c->IntValues[2], c->IntValues[3]);
				default:
					if (constants.IndexOf(c) != -1)
						return c;
					else
					{
						auto rs = new ILConstOperand(*c);
						constants.Add(rs);
						return rs;
					}
				}
			}

			ILConstOperand * CreateConstant(int val, int size = 0)
			{
				ILConstOperand * rs = 0;
				if (intConsts.TryGetValue(ConstKey<int>(val, size), rs))
					return rs;
				rs = new ILConstOperand();
				ILBaseType baseType;
				switch (size)
				{
				case 0:
				case 1:
					baseType = ILBaseType::Int;
					break;
				case 2:
					baseType = ILBaseType::Int2;
					break;
				case 3:
					baseType = ILBaseType::Int3;
					break;
				case 4:
					baseType = ILBaseType::Int4;
					break;
				default:
					throw InvalidOperationException(L"Invalid vector size.");
				}
				rs->Type = new ILBasicType(baseType);
				rs->IntValues[0] = val;
				intConsts[ConstKey<int>(val, size)] = rs;
				rs->Name = rs->ToString();
				constants.Add(rs);

				return rs;
			}

			ILConstOperand * CreateConstant(float val, int size = 0)
			{
				ILConstOperand * rs = 0;
				if (floatConsts.TryGetValue(ConstKey<float>(val, size), rs))
					return rs;
				if (Math::IsNaN(val) || Math::IsInf(val))
				{
					throw InvalidOperationException(L"Attempting to create NAN constant.");
				}
				rs = new ILConstOperand();
				ILBaseType baseType;
				switch (size)
				{
				case 0:
				case 1:
					baseType = ILBaseType::Float;
					break;
				case 2:
					baseType = ILBaseType::Float2;
					break;
				case 3:
					baseType = ILBaseType::Float3;
					break;
				case 4:
					baseType = ILBaseType::Float4;
					break;
				case 9:
					baseType = ILBaseType::Float3x3;
					break;
				case 16:
					baseType = ILBaseType::Float4x4;
					break;
				default:
					throw InvalidOperationException(L"Invalid vector size.");
				}
				rs->Type = new ILBasicType(baseType);
				for (int i = 0; i < 16; i++)
					rs->FloatValues[i] = val;
				floatConsts[ConstKey<float>(val, size)] = rs;
				rs->Name = rs->ToString();
				constants.Add(rs);

				return rs;
			}

			ILConstOperand * CreateConstant(float val, float val2)
			{
				ILConstOperand * rs = 0;
				if (Math::IsNaN(val) || Math::IsInf(val) || Math::IsNaN(val2) || Math::IsInf(val2))
				{
					throw InvalidOperationException(L"Attempting to create NAN constant.");
				}
				auto key = ConstKey<float>::FromValues(val, val2);
				if (floatConsts.TryGetValue(key, rs))
					return rs;
				rs = new ILConstOperand();
				rs->Type = new ILBasicType(ILBaseType::Float2);
				rs->FloatValues[0] = val;
				rs->FloatValues[1] = val2;
				floatConsts[key] = rs;
				rs->Name = rs->ToString();
				constants.Add(rs);

				return rs;
			}

			ILConstOperand * CreateConstant(float val, float val2, float val3)
			{
				ILConstOperand * rs = 0;
				if (Math::IsNaN(val) || Math::IsInf(val) || Math::IsNaN(val2) || Math::IsInf(val2) || Math::IsNaN(val3) || Math::IsInf(val3))
				{
					throw InvalidOperationException(L"Attempting to create NAN constant.");
				}
				auto key = ConstKey<float>::FromValues(val, val2, val3);
				if (floatConsts.TryGetValue(key, rs))
					return rs;
				rs = new ILConstOperand();
				rs->Type = new ILBasicType(ILBaseType::Float3);
				rs->FloatValues[0] = val;
				rs->FloatValues[1] = val2;
				rs->FloatValues[2] = val3;

				floatConsts[key] = rs;
				rs->Name = rs->ToString();
				constants.Add(rs);

				return rs;
			}

			ILConstOperand * CreateConstant(float val, float val2, float val3, float val4)
			{
				if (Math::IsNaN(val) || Math::IsInf(val) || Math::IsNaN(val2) || Math::IsInf(val2) || Math::IsNaN(val3) || Math::IsInf(val3) || Math::IsNaN(val4) || Math::IsInf(val4))
				{
					throw InvalidOperationException(L"Attempting to create NAN constant.");
				}
				ILConstOperand * rs = 0;
				auto key = ConstKey<float>::FromValues(val, val2, val3, val4);
				if (floatConsts.TryGetValue(key, rs))
					return rs;
				rs = new ILConstOperand();
				rs->Type = new ILBasicType(ILBaseType::Float4);
				rs->FloatValues[0] = val;
				rs->FloatValues[1] = val2;
				rs->FloatValues[2] = val3;
				rs->FloatValues[3] = val4;

				floatConsts[key] = rs;
				rs->Name = rs->ToString();
				constants.Add(rs);

				return rs;
			}
		};

		ConstantPool::ConstantPool()
		{
			impl = new ConstantPoolImpl();
		}
		ConstantPool::~ConstantPool()
		{
			delete impl;
		}
		ILUndefinedOperand * ConstantPool::GetUndefinedOperand()
		{
			return impl->GetUndefinedOperand();
		}
		ILConstOperand * ConstantPool::CreateConstant(ILConstOperand * c)
		{
			return impl->CreateConstant(c);
		}
		ILConstOperand * ConstantPool::CreateConstantIntVec(int val0, int val1)
		{
			return impl->CreateConstantIntVec(val0, val1);

		}
		ILConstOperand * ConstantPool::CreateConstantIntVec(int val0, int val1, int val2)
		{
			return impl->CreateConstantIntVec(val0, val1, val2);
		}
		ILConstOperand * ConstantPool::CreateConstantIntVec(int val0, int val1, int val3, int val4)
		{
			return impl->CreateConstantIntVec(val0, val1, val3, val4);
		}
		ILConstOperand * ConstantPool::CreateConstant(int val, int vectorSize)
		{
			return impl->CreateConstant(val, vectorSize);
		}
		ILConstOperand * ConstantPool::CreateConstant(float val, int vectorSize)
		{
			return impl->CreateConstant(val, vectorSize);
		}
		ILConstOperand * ConstantPool::CreateConstant(float val, float val1)
		{
			return impl->CreateConstant(val, val1);
		}
		ILConstOperand * ConstantPool::CreateConstant(float val, float val1, float val2)
		{
			return impl->CreateConstant(val, val1, val2);
		}
		ILConstOperand * ConstantPool::CreateConstant(float val, float val1, float val2, float val3)
		{
			return impl->CreateConstant(val, val1, val2, val3);
		}
		ILOperand * ConstantPool::CreateDefaultValue(ILType * type)
		{
			return impl->CreateDefaultValue(type);
		}
	}
}

#endif

/***********************************************************************
CORE\GLSLCODEGEN.CPP
***********************************************************************/

using namespace CoreLib::Basic;

namespace Spire
{
	namespace Compiler
	{
		ILRecordType * ExtractRecordType(ILType * type)
		{
			if (auto recType = dynamic_cast<ILRecordType*>(type))
				return recType;
			else if (auto arrType = dynamic_cast<ILArrayType*>(type))
				return ExtractRecordType(arrType->BaseType.Ptr());
			else if (auto genType = dynamic_cast<ILGenericType*>(type))
				return ExtractRecordType(genType->BaseType.Ptr());
			else
				return nullptr;
		}

		class GLSLCodeGen;

		class CodeGenContext
		{
		public:
			GLSLCodeGen * codeGen;
			HashSet<String> GeneratedDefinitions;
			Dictionary<String, String> SubstituteNames;
			Dictionary<ILOperand*, String> VarName;
			CompileResult * Result = nullptr;
			HashSet<String> UsedVarNames;
			StringBuilder Body, Header, GlobalHeader;
			List<ILType*> Arguments;
			String ReturnVarName;
			String GenerateCodeName(String name, String prefix)
			{
				StringBuilder nameBuilder;
				int startPos = 0;
				if (name.StartsWith(L"_sys_"))
					startPos = name.IndexOf(L'_', 5) + 1;
				nameBuilder << prefix;
				for (int i = startPos; i < name.Length(); i++)
				{
					if ((name[i] >= L'a' && name[i] <= L'z') || 
						(name[i] >= L'A' && name[i] <= L'Z') ||
						name[i] == L'_' || 
						(name[i] >= L'0' && name[i] <= L'9'))
					{
						nameBuilder << name[i];
					}
					else
						nameBuilder << L'_';
				}
				auto rs = nameBuilder.ToString();
				int i = 0;
				while (UsedVarNames.Contains(rs))
				{
					i++;
					rs = nameBuilder.ToString() + String(i);
				}
				UsedVarNames.Add(rs);

				return rs;
			}


			String DefineVariable(ILOperand * op);
		};

		class ExternComponentCodeGenInfo
		{
		public:
			enum class DataStructureType
			{
				StandardInput, UniformBuffer, StorageBuffer, PackedBuffer, Texture, Patch
			};
			DataStructureType DataStructure = DataStructureType::StandardInput;
			RefPtr<ILType> Type;
			bool IsArray = false;
			int ArrayLength = 0;
			int Binding = -1;
		};

		class OutputStrategy : public Object
		{
		protected:
			GLSLCodeGen * codeGen = nullptr;
			ILWorld * world = nullptr;
		public:
			OutputStrategy(GLSLCodeGen * pCodeGen, ILWorld * pWorld)
			{
				codeGen = pCodeGen;
				world = pWorld;
			}

			virtual void DeclareOutput(CodeGenContext & ctx, ILStage * stage) = 0;
			virtual void ProcessExportInstruction(CodeGenContext & ctx, ExportInstruction * instr) = 0;
		};

		OutputStrategy * CreateStandardOutputStrategy(GLSLCodeGen * codeGen, ILWorld * world, String prefix);
		OutputStrategy * CreatePackedBufferOutputStrategy(GLSLCodeGen * codeGen, ILWorld * world);
		OutputStrategy * CreateArrayOutputStrategy(GLSLCodeGen * codeGen, ILWorld * world, bool pIsPatch, int pArraySize, String arrayIndex);


		class GLSLCodeGen : public CodeGenBackend
		{
		private:
			//ILWorld * currentWorld = nullptr;
			//ILRecordType * currentRecordType = nullptr;
			//bool exportWriteToPackedBuffer = false;
			RefPtr<OutputStrategy> outputStrategy;
			Dictionary<String, ExternComponentCodeGenInfo> extCompInfo;
			ImportInstruction * currentImportInstr = nullptr;
			bool useBindlessTexture = false;
			ErrorWriter * errWriter;
		public:
			void Error(int errId, String msg, CodePosition pos)
			{
				errWriter->Error(errId, msg, pos);
			}
			void PrintType(StringBuilder & sbCode, ILType* type)
			{
				if (dynamic_cast<ILRecordType*>(type))
					PrintType(sbCode, currentImportInstr->Type.Ptr());
				else
					sbCode << type->ToString();
			}

			void PrintDef(StringBuilder & sbCode, ILType* type, const String & name)
			{
				PrintType(sbCode, type);
				sbCode << L" ";
				sbCode << name;
			}

			String GetFunctionCallName(String name)
			{
				StringBuilder rs;
				for (int i = 0; i < name.Length(); i++)
				{
					if ((name[i] >= L'a' && name[i] <= L'z') || (name[i] >= L'A' && name[i] <= L'Z') || 
						name[i] == L'_' || (name[i] >= L'0' && name[i] <= L'9'))
					{
						rs << name[i];
					}
					else if (i != name.Length() - 1)
						rs << L'_';
				}
				return rs.ProduceString();
			}

			String GetFuncOriginalName(const String & name)
			{
				String originalName;
				int splitPos = name.IndexOf(L'@');
				if (splitPos == 0)
					return name;
				if (splitPos != -1)
					originalName = name.SubString(0, splitPos);
				else
					originalName = name;
				return originalName;
			}

			void PrintOp(CodeGenContext & ctx, ILOperand * op, bool forceExpression = false)
			{
				auto makeFloat = [](float v)
				{
					String rs(v, L"%.12e");
					if (!rs.Contains(L'.') && !rs.Contains(L'e') && !rs.Contains(L'E'))
						rs = rs + L".0";
					if (rs.StartsWith(L"-"))
						rs = L"(" + rs + L")";
					return rs;
				};
				if (auto c = dynamic_cast<ILConstOperand*>(op))
				{
					auto type = c->Type.Ptr();
					if (type->IsFloat())
						ctx.Body << makeFloat(c->FloatValues[0]);
					else if (type->IsInt())
						ctx.Body << (c->IntValues[0]);
					else if (auto baseType = dynamic_cast<ILBasicType*>(type))
					{
						if (baseType->Type == ILBaseType::Float2)
							ctx.Body << L"vec2(" << makeFloat(c->FloatValues[0]) << L", " << makeFloat(c->FloatValues[1]) << L")";
						else if (baseType->Type == ILBaseType::Float3)
							ctx.Body << L"vec3(" << makeFloat(c->FloatValues[0]) << L", " << makeFloat(c->FloatValues[1]) << L", " << makeFloat(c->FloatValues[2]) << L")";
						else if (baseType->Type == ILBaseType::Float4)
							ctx.Body << L"vec4(" << makeFloat(c->FloatValues[0]) << L", " << makeFloat(c->FloatValues[1]) << L", " << makeFloat(c->FloatValues[2]) << L", " << makeFloat(c->FloatValues[3]) << L")";
						else if (baseType->Type == ILBaseType::Float3x3)
						{
							ctx.Body << L"mat3(";
							for (int i = 0; i < 9; i++)
							{
								ctx.Body << makeFloat(c->FloatValues[i]);
								if (i != 8)
									ctx.Body << L", ";
							}
							ctx.Body << L")";
						}
						else if (baseType->Type == ILBaseType::Float4x4)
						{
							ctx.Body << L"mat4(";
							for (int i = 0; i < 16; i++)
							{
								ctx.Body << makeFloat(c->FloatValues[i]);
								if (i != 15)
									ctx.Body << L", ";
							}
							ctx.Body << L")";
						}
						else if (baseType->Type == ILBaseType::Int2)
							ctx.Body << L"ivec2(" << c->IntValues[0] << L", " << c->IntValues[1] << L")";
						else if (baseType->Type == ILBaseType::Int3)
							ctx.Body << L"ivec3(" << c->IntValues[0] << L", " << c->IntValues[1] << L", " << c->IntValues[2] << L")";
						else if (baseType->Type == ILBaseType::Int4)
							ctx.Body << L"ivec4(" << c->IntValues[0] << L", " << c->IntValues[1] << L", " << c->IntValues[2] << L", " << c->IntValues[3] << L")";
					}
					else
						throw InvalidOperationException(L"Illegal constant.");
				}
				else if (auto instr = dynamic_cast<ILInstruction*>(op))
				{
					if (AppearAsExpression(*instr, forceExpression))
					{
						PrintInstrExpr(ctx, *instr);
					}
					else
					{
						if (forceExpression)
							throw InvalidProgramException(L"cannot generate code block as an expression.");
						String substituteName;
						if (ctx.SubstituteNames.TryGetValue(instr->Name, substituteName))
							ctx.Body << substituteName;
						else
							ctx.Body << instr->Name;
					}
				}
				else
					throw InvalidOperationException(L"Unsupported operand type.");
			}

			void PrintBinaryInstrExpr(CodeGenContext & ctx, BinaryInstruction * instr)
			{
				if (instr->Is<StoreInstruction>())
				{
					auto op0 = instr->Operands[0].Ptr();
					auto op1 = instr->Operands[1].Ptr();
					ctx.Body << L"(";
					PrintOp(ctx, op0);
					ctx.Body << L" = ";
					PrintOp(ctx, op1);
					ctx.Body << L")";
					return;
				}
				auto op0 = instr->Operands[0].Ptr();
				auto op1 = instr->Operands[1].Ptr();
				if (instr->Is<StoreInstruction>())
				{
					throw InvalidOperationException(L"store instruction cannot appear as expression.");
				}
				if (instr->Is<MemberLoadInstruction>())
				{
					auto genType = dynamic_cast<ILGenericType*>(op0->Type.Ptr());
					if (genType && genType->GenericTypeName == L"PackedBuffer")
					{
						// load record type from packed buffer
						String conversionFunction;
						int size = 0;
						if (instr->Type->ToString() == L"int")
						{
							conversionFunction = L"floatBitsToInt";
							size = 1;
						}
						else if (instr->Type->ToString() == L"ivec2")
						{
							conversionFunction = L"floatBitsToInt";
							size = 2;
						}
						else if (instr->Type->ToString() == L"ivec3")
						{
							conversionFunction = L"floatBitsToInt";
							size = 3;
						}
						else if (instr->Type->ToString() == L"ivec4")
						{
							conversionFunction = L"floatBitsToInt";
							size = 4;
						}
						else if (instr->Type->ToString() == L"uint")
						{
							conversionFunction = L"floatBitsToUint";
							size = 1;
						}
						else if (instr->Type->ToString() == L"uvec2")
						{
							conversionFunction = L"floatBitsToUint";
							size = 2;
						}
						else if (instr->Type->ToString() == L"uvec3")
						{
							conversionFunction = L"floatBitsToUint";
							size = 3;
						}
						else if (instr->Type->ToString() == L"uvec4")
						{
							conversionFunction = L"floatBitsToUint";
							size = 4;
						}
						else if (instr->Type->ToString() == L"float")
						{
							conversionFunction = L"";
							size = 1;
						}
						else if (instr->Type->ToString() == L"vec2")
						{
							conversionFunction = L"";
							size = 2;
						}
						else if (instr->Type->ToString() == L"vec3")
						{
							conversionFunction = L"";
							size = 3;
						}
						else if (instr->Type->ToString() == L"vec4")
						{
							conversionFunction = L"";
							size = 4;
						}
						else if (instr->Type->ToString() == L"mat3")
						{
							conversionFunction = L"";
							size = 9;
						}
						else if (instr->Type->ToString() == L"mat4")
						{
							conversionFunction = L"";
							size = 16;
						}
						else
						{
							errWriter->Error(50082, L"importing type '" + instr->Type->ToString() + L"' from PackedBuffer is not supported by the GLSL backend.",
								CodePosition());
						}
						ctx.Body << instr->Type->ToString() << L"(";
						auto recType = dynamic_cast<ILRecordType*>(genType->BaseType.Ptr());
						int recTypeSize = 0;
						EnumerableDictionary<String, int> memberOffsets;
						for (auto & member : recType->Members)
						{
							memberOffsets[member.Key] = recTypeSize;
							recTypeSize += member.Value.Type->GetVectorSize();
						}
						for (int i = 0; i < size; i++)
						{
							ctx.Body << conversionFunction << L"(";
							PrintOp(ctx, op0);
							ctx.Body << L"[(";
							PrintOp(ctx, op1);
							ctx.Body << L") * " << recTypeSize << L" + " << memberOffsets[currentImportInstr->ComponentName]() << L"])";
							if (i != size - 1)
								ctx.Body << L", ";
						}
						ctx.Body << L")";
					}
					else
					{
						PrintOp(ctx, op0);
						bool printDefault = true;
						if (op0->Type->IsVector())
						{
							if (auto c = dynamic_cast<ILConstOperand*>(op1))
							{
								switch (c->IntValues[0])
								{
								case 0:
									ctx.Body << L".x";
									break;
								case 1:
									ctx.Body << L".y";
									break;
								case 2:
									ctx.Body << L".z";
									break;
								case 3:
									ctx.Body << L".w";
									break;
								default:
									throw InvalidOperationException(L"Invalid member access.");
								}
								printDefault = false;
							}
						}
						else if (auto structType = dynamic_cast<ILStructType*>(op0->Type.Ptr()))
						{
							if (auto c = dynamic_cast<ILConstOperand*>(op1))
							{
								ctx.Body << L"." << structType->Members[c->IntValues[0]].FieldName;
							}
							printDefault = false;
						}
						if (printDefault)
						{
							ctx.Body << L"[";
							PrintOp(ctx, op1);
							ctx.Body << L"]";
						}
						if (auto genType = dynamic_cast<ILGenericType*>(op0->Type.Ptr()))
						{
							if (genType->GenericTypeName == L"Buffer" && dynamic_cast<ILRecordType*>(genType->BaseType.Ptr()))
								ctx.Body << L"." << currentImportInstr->ComponentName;
						}
					}
					return;
				}
				const wchar_t * op = L"";
				if (instr->Is<AddInstruction>())
				{
					op = L"+";
				}
				else if (instr->Is<SubInstruction>())
				{
					op = L"-";
				}
				else if (instr->Is<MulInstruction>())
				{
					op = L"*";
				}
				else if (instr->Is<DivInstruction>())
				{
					op = L"/";
				}
				else if (instr->Is<ModInstruction>())
				{
					op = L"%";
				}
				else if (instr->Is<ShlInstruction>())
				{
					op = L"<<";
				}
				else if (instr->Is<ShrInstruction>())
				{
					op = L">>";
				}
				else if (instr->Is<CmpeqlInstruction>())
				{
					op = L"==";
					//ctx.Body << L"int";
				}
				else if (instr->Is<CmpgeInstruction>())
				{
					op = L">=";
					//ctx.Body << L"int";
				}
				else if (instr->Is<CmpgtInstruction>())
				{
					op = L">";
					//ctx.Body << L"int";
				}
				else if (instr->Is<CmpleInstruction>())
				{
					op = L"<=";
					//ctx.Body << L"int";
				}
				else if (instr->Is<CmpltInstruction>())
				{
					op = L"<";
					//ctx.Body << L"int";
				}
				else if (instr->Is<CmpneqInstruction>())
				{
					op = L"!=";
					//ctx.Body << L"int";
				}
				else if (instr->Is<AndInstruction>())
				{
					op = L"&&";
				}
				else if (instr->Is<OrInstruction>())
				{
					op = L"||";
				}
				else if (instr->Is<BitXorInstruction>())
				{
					op = L"^";
				}
				else if (instr->Is<BitAndInstruction>())
				{
					op = L"&";
				}
				else if (instr->Is<BitOrInstruction>())
				{
					op = L"|";
				}
				else
					throw InvalidProgramException(L"unsupported binary instruction.");
				ctx.Body << L"(";
				PrintOp(ctx, op0);
				ctx.Body << L" " << op << L" ";
				PrintOp(ctx, op1);
				ctx.Body << L")";
			}

			void PrintBinaryInstr(CodeGenContext & ctx, BinaryInstruction * instr)
			{
				auto op0 = instr->Operands[0].Ptr();
				auto op1 = instr->Operands[1].Ptr();
				if (instr->Is<StoreInstruction>())
				{
					PrintOp(ctx, op0);
					ctx.Body << L" = ";
					PrintOp(ctx, op1);
					ctx.Body << L";\n";
					return;
				}
				auto varName = ctx.DefineVariable(instr);
				if (instr->Is<MemberLoadInstruction>())
				{
					ctx.Body << varName << L" = ";
					PrintBinaryInstrExpr(ctx, instr);
					ctx.Body << L";\n";
					return;
				}
				ctx.Body << varName << L" = ";
				PrintBinaryInstrExpr(ctx, instr);
				ctx.Body << L";\n";
			}

			void PrintUnaryInstrExpr(CodeGenContext & ctx, UnaryInstruction * instr)
			{
				auto op0 = instr->Operand.Ptr();
				if (instr->Is<LoadInstruction>())
				{
					PrintOp(ctx, op0);
					return;
				}
				const wchar_t * op = L"";
				if (instr->Is<BitNotInstruction>())
					op = L"~";
				else if (instr->Is<Float2IntInstruction>())
					op = L"(int)";
				else if (instr->Is<Int2FloatInstruction>())
					op = L"(float)";
				else if (instr->Is<CopyInstruction>())
					op = L"";
				else if (instr->Is<NegInstruction>())
					op = L"-";
				else if (instr->Is<NotInstruction>())
					op = L"!";
				else
					throw InvalidProgramException(L"unsupported unary instruction.");
				ctx.Body << L"(" << op;
				PrintOp(ctx, op0);
				ctx.Body << L")";
			}

			void PrintUnaryInstr(CodeGenContext & ctx, UnaryInstruction * instr)
			{
				auto varName = ctx.DefineVariable(instr);
				ctx.Body << varName << L" = ";
				PrintUnaryInstrExpr(ctx, instr);
				ctx.Body << L";\n";
			}

			void PrintAllocVarInstrExpr(CodeGenContext & ctx, AllocVarInstruction * instr)
			{
				ctx.Body << instr->Name;
			}

			void PrintAllocVarInstr(CodeGenContext & ctx, AllocVarInstruction * instr)
			{
				if (dynamic_cast<ILConstOperand*>(instr->Size.Ptr()))
				{
					PrintDef(ctx.Header, instr->Type.Ptr(), instr->Name);
					ctx.Header << L";\n";
				}
				else
					throw InvalidProgramException(L"size operand of allocVar instr is not an intermediate.");
			}

			void PrintFetchArgInstrExpr(CodeGenContext & ctx, FetchArgInstruction * instr)
			{
				ctx.Body << instr->Name;
			}

			void PrintFetchArgInstr(CodeGenContext & ctx, FetchArgInstruction * instr)
			{
				if (instr->ArgId == 0)
				{
					ctx.ReturnVarName = ctx.DefineVariable(instr);
				}
			}

			void PrintSelectInstrExpr(CodeGenContext & ctx, SelectInstruction * instr)
			{
				ctx.Body << L"(";
				PrintOp(ctx, instr->Operands[0].Ptr());
				ctx.Body << L"?";
				PrintOp(ctx, instr->Operands[1].Ptr());
				ctx.Body << L":";
				PrintOp(ctx, instr->Operands[2].Ptr());
				ctx.Body << L")";
			}

			void PrintSelectInstr(CodeGenContext & ctx, SelectInstruction * instr)
			{
				auto varName = ctx.DefineVariable(instr);
				ctx.Body << varName << L" = ";
				PrintSelectInstrExpr(ctx, instr);
				ctx.Body << L";\n";
			}

			void PrintCallInstrExpr(CodeGenContext & ctx, CallInstruction * instr)
			{
				String callName;
				callName = GetFuncOriginalName(instr->Function);
				ctx.Body << callName;
				ctx.Body << L"(";
				int id = 0;
				for (auto & arg : instr->Arguments)
				{
					PrintOp(ctx, arg.Ptr());
					if (id != instr->Arguments.Count() - 1)
						ctx.Body << L", ";
					id++;
				}
				ctx.Body << L")";
			}

			void PrintCallInstr(CodeGenContext & ctx, CallInstruction * instr)
			{
				auto varName = ctx.DefineVariable(instr);
				ctx.Body << varName;
				ctx.Body << L" = ";
				PrintCallInstrExpr(ctx, instr);
				ctx.Body << L";\n";
			}

			void PrintCastF2IInstrExpr(CodeGenContext & ctx, Float2IntInstruction * instr)
			{
				ctx.Body << L"((int)(";
				PrintOp(ctx, instr->Operand.Ptr());
				ctx.Body << L"))";
			}
			void PrintCastF2IInstr(CodeGenContext & ctx, Float2IntInstruction * instr)
			{
				auto varName = ctx.DefineVariable(instr);
				ctx.Body << varName;
				ctx.Body << L" = ";
				PrintCastF2IInstrExpr(ctx, instr);
				ctx.Body << L";\n";
			}
			void PrintCastI2FInstrExpr(CodeGenContext & ctx, Int2FloatInstruction * instr)
			{
				ctx.Body << L"((float)(";
				PrintOp(ctx, instr->Operand.Ptr());
				ctx.Body << L"))";
			}
			void PrintCastI2FInstr(CodeGenContext & ctx, Int2FloatInstruction * instr)
			{
				auto varName = ctx.DefineVariable(instr);
				ctx.Body << varName;
				ctx.Body << L" = ";
				PrintCastI2FInstrExpr(ctx, instr);
				ctx.Body << L";\n";
			}

			bool AppearAsExpression(ILInstruction & instr, bool force)
			{
				if (instr.Is<LoadInputInstruction>())
					return true;
				if (auto arg = instr.As<FetchArgInstruction>())
				{
					if (arg->ArgId == 0)
						return false;
				}
				if (auto import = instr.As<ImportInstruction>())
				{
					if (!useBindlessTexture && import->Type->IsTexture())
						return true;
				}
				for (auto &&usr : instr.Users)
				{
					if (auto update = dynamic_cast<MemberUpdateInstruction*>(usr))
					{
						if (&instr == update->Operands[0].Ptr())
							return false;
					}
					else if (dynamic_cast<MemberLoadInstruction*>(usr))
						return false;
					else if (dynamic_cast<ExportInstruction*>(usr))
						return false;
					else if (dynamic_cast<ImportInstruction*>(usr))
						return false;
				}
				if (instr.Is<StoreInstruction>() && force)
					return true;

				return (instr.Users.Count() <= 1 && !instr.HasSideEffect() && !instr.Is<MemberUpdateInstruction>()
					&& !instr.Is<AllocVarInstruction>() && !instr.Is<ImportInstruction>())
					|| instr.Is<FetchArgInstruction>() ;
			}

			void PrintExportInstr(CodeGenContext &ctx, ExportInstruction * exportInstr)
			{
				outputStrategy->ProcessExportInstruction(ctx, exportInstr);
			}

			void PrintUpdateInstr(CodeGenContext & ctx, MemberUpdateInstruction * instr)
			{
				auto genCode = [&](String varName, ILType * srcType, ILOperand * op1, ILOperand * op2)
				{
					ctx.Body << varName;
					if (auto structType = dynamic_cast<ILStructType*>(srcType))
					{
						ctx.Body << L".";
						ctx.Body << structType->Members[dynamic_cast<ILConstOperand*>(op1)->IntValues[0]].FieldName;
					}
					else
					{
						ctx.Body << L"[";
						PrintOp(ctx, op1);
						ctx.Body << L"]";
					}
					ctx.Body << L" = ";
					PrintOp(ctx, op2);
					ctx.Body << L";\n";
				};
				if (auto srcInstr = dynamic_cast<ILInstruction*>(instr->Operands[0].Ptr()))
				{
					if (srcInstr->Users.Count() == 1)
					{
						auto srcName = srcInstr->Name;
						while (ctx.SubstituteNames.TryGetValue(srcName, srcName));
						genCode(srcName, srcInstr->Type.Ptr(), instr->Operands[1].Ptr(), instr->Operands[2].Ptr());
						ctx.SubstituteNames[instr->Name] = srcName;
						return;
					}
				}
				auto varName = ctx.DefineVariable(instr);
				ctx.Body << varName << L" = ";
				PrintOp(ctx, instr->Operands[0].Ptr());
				ctx.Body << L";\n";
				genCode(varName, instr->Operands[0]->Type.Ptr(), instr->Operands[1].Ptr(), instr->Operands[2].Ptr());
			}

			void PrintImportInstr(CodeGenContext & ctx, ImportInstruction * importInstr)
			{
				currentImportInstr = importInstr;
				
				PrintDef(ctx.Header, importInstr->Type.Ptr(), importInstr->Name);
				ctx.Header << L";\n";
				GenerateCode(ctx, importInstr->ImportOperator.Ptr());
				
				currentImportInstr = nullptr;
			}

			void PrintImportInstrExpr(CodeGenContext & ctx, ImportInstruction * importInstr)
			{
				currentImportInstr = importInstr;
				PrintOp(ctx, importInstr->ImportOperator->GetLastInstruction()->As<ReturnInstruction>()->Operand.Ptr());
				currentImportInstr = nullptr;
			}

			void PrintInstrExpr(CodeGenContext & ctx, ILInstruction & instr)
			{
				if (auto binInstr = instr.As<BinaryInstruction>())
					PrintBinaryInstrExpr(ctx, binInstr);
				else if (auto unaryInstr = instr.As<UnaryInstruction>())
					PrintUnaryInstrExpr(ctx, unaryInstr);
				else if (auto allocVar = instr.As<AllocVarInstruction>())
					PrintAllocVarInstrExpr(ctx, allocVar);
				else if (auto fetchArg = instr.As<FetchArgInstruction>())
					PrintFetchArgInstrExpr(ctx, fetchArg);
				else if (auto select = instr.As<SelectInstruction>())
					PrintSelectInstrExpr(ctx, select);
				else if (auto call = instr.As<CallInstruction>())
					PrintCallInstrExpr(ctx, call);
				else if (auto castf2i = instr.As<Float2IntInstruction>())
					PrintCastF2IInstrExpr(ctx, castf2i);
				else if (auto casti2f = instr.As<Int2FloatInstruction>())
					PrintCastI2FInstrExpr(ctx, casti2f);
				else if (auto ldInput = instr.As<LoadInputInstruction>())
					PrintLoadInputInstrExpr(ctx, ldInput);
				else if (auto import = instr.As<ImportInstruction>())
					PrintImportInstrExpr(ctx, import);
				else if (instr.As<MemberUpdateInstruction>())
					throw InvalidOperationException(L"member update instruction cannot appear as expression.");
			}

			void PrintInstr(CodeGenContext & ctx, ILInstruction & instr)
			{
				// ctx.Body << L"// " << instr.ToString() << L";\n";
				if (!AppearAsExpression(instr, false))
				{
					if (auto binInstr = instr.As<BinaryInstruction>())
						PrintBinaryInstr(ctx, binInstr);
					else if (auto exportInstr = instr.As<ExportInstruction>())
						PrintExportInstr(ctx, exportInstr);
					else if (auto unaryInstr = instr.As<UnaryInstruction>())
						PrintUnaryInstr(ctx, unaryInstr);
					else if (auto allocVar = instr.As<AllocVarInstruction>())
						PrintAllocVarInstr(ctx, allocVar);
					else if (auto fetchArg = instr.As<FetchArgInstruction>())
						PrintFetchArgInstr(ctx, fetchArg);
					else if (auto select = instr.As<SelectInstruction>())
						PrintSelectInstr(ctx, select);
					else if (auto call = instr.As<CallInstruction>())
						PrintCallInstr(ctx, call);
					else if (auto castf2i = instr.As<Float2IntInstruction>())
						PrintCastF2IInstr(ctx, castf2i);
					else if (auto casti2f = instr.As<Int2FloatInstruction>())
						PrintCastI2FInstr(ctx, casti2f);
					else if (auto update = instr.As<MemberUpdateInstruction>())
						PrintUpdateInstr(ctx, update);
					else if (auto importInstr = instr.As<ImportInstruction>())
						PrintImportInstr(ctx, importInstr);
					
				}
			}

			void PrintLoadInputInstrExpr(CodeGenContext & ctx, LoadInputInstruction * instr)
			{
				PrintInputReference(ctx.Body, instr->InputName);
			}

			void GenerateCode(CodeGenContext & context, CFGNode * code)
			{
				for (auto & instr : *code)
				{
					if (auto ifInstr = instr.As<IfInstruction>())
					{
						context.Body << L"if (bool(";
						PrintOp(context, ifInstr->Operand.Ptr(), true);
						context.Body << L"))\n{\n";
						GenerateCode(context, ifInstr->TrueCode.Ptr());
						context.Body << L"}\n";
						if (ifInstr->FalseCode)
						{
							context.Body << L"else\n{\n";
							GenerateCode(context, ifInstr->FalseCode.Ptr());
							context.Body << L"}\n";
						}
					}
					else if (auto forInstr = instr.As<ForInstruction>())
					{
						context.Body << L"for (;bool(";
						PrintOp(context, forInstr->ConditionCode->GetLastInstruction(), true);
						context.Body << L"); ";
						PrintOp(context, forInstr->SideEffectCode->GetLastInstruction(), true);
						context.Body << L")\n{\n";
						GenerateCode(context, forInstr->BodyCode.Ptr());
						context.Body << L"}\n";
					}
					else if (auto doInstr = instr.As<DoInstruction>())
					{
						context.Body << L"do\n{\n";
						GenerateCode(context, doInstr->BodyCode.Ptr());
						context.Body << L"} while (bool(";
						PrintOp(context, doInstr->ConditionCode->GetLastInstruction()->As<ReturnInstruction>()->Operand.Ptr(), true);
						context.Body << L"));\n";
					}
					else if (auto whileInstr = instr.As<WhileInstruction>())
					{
						context.Body << L"while (bool(";
						PrintOp(context, whileInstr->ConditionCode->GetLastInstruction()->As<ReturnInstruction>()->Operand.Ptr(), true);
						context.Body << L"))\n{\n";
						GenerateCode(context, whileInstr->BodyCode.Ptr());
						context.Body << L"}\n";
					}
					else if (auto ret = instr.As<ReturnInstruction>())
					{
						if (currentImportInstr) 
						{
							context.Body << currentImportInstr->Name << L" = ";
							PrintOp(context, ret->Operand.Ptr());
							context.Body << L";\n";
						}
						else
						{
							context.Body << L"return ";
							PrintOp(context, ret->Operand.Ptr());
							context.Body << L";\n";
						}
					}
					else if (instr.Is<BreakInstruction>())
					{
						context.Body << L"break;\n";
					}
					else if (instr.Is<ContinueInstruction>())
					{
						context.Body << L"continue;\n";
					}
					else if (instr.Is<DiscardInstruction>())
					{
						context.Body << L"discard;\n";
					}
					
					else
						PrintInstr(context, instr);
				}
			}
		public:
			virtual CompiledShaderSource GenerateShader(CompileResult & result, SymbolTable *, ILShader * shader, ErrorWriter * err) override
			{
				this->errWriter = err;

				CompiledShaderSource rs;

				for (auto & stage : shader->Stages)
				{
					StageSource src;
					if (stage.Value->StageType == L"VertexShader" || stage.Value->StageType == L"FragmentShader" || stage.Value->StageType == L"DomainShader")
						src = GenerateVertexFragmentDomainShader(result.Program.Ptr(), shader, stage.Value.Ptr());
					else if (stage.Value->StageType == L"ComputeShader")
						src = GenerateComputeShader(result.Program.Ptr(), shader, stage.Value.Ptr());
					else if (stage.Value->StageType == L"HullShader")
						src = GenerateHullShader(result.Program.Ptr(), shader, stage.Value.Ptr());
					else
						errWriter->Error(50020, L"Unknown stage type '" + stage.Value->StageType + L"'.", stage.Value->Position);
					rs.Stages[stage.Key] = src;
				}
				
				// TODO: fill metadatas
				rs.MetaData.ShaderName = shader->Name;
				
				return rs;
			}

			void GenerateStructs(StringBuilder & sb, ILProgram * program)
			{
				for (auto & st : program->Structs)
				{
					sb << L"struct " << st->TypeName << L"\n{\n";
					for (auto & f : st->Members)
					{
						sb << f.Type->ToString();
						sb << " " << f.FieldName << L";\n";
					}
					sb << L"};\n";
				}
			}

			void GenerateHeader(StringBuilder & sb, ILStage * stage)
			{
				sb << L"#version 440\n";
				if (stage->Attributes.ContainsKey(L"BindlessTexture"))
					sb << L"#extension GL_ARB_bindless_texture: require\n#extension GL_NV_gpu_shader5 : require\n";
				if (stage->Attributes.ContainsKey(L"NV_CommandList"))
					sb << L"#extension GL_NV_command_list: require\n";
			}

			void GenerateReferencedFunctions(StringBuilder & sb, ILProgram * program, ArrayView<ILWorld*> worlds)
			{
				EnumerableHashSet<String> refFuncs;
				for (auto & world : worlds)
					for (auto & func : world->ReferencedFunctions)
						refFuncs.Add(func);
				for (auto & func : program->Functions)
				{
					if (refFuncs.Contains(func->Name))
						GenerateFunctionDeclaration(sb, func.Ptr());
				}
				for (auto & func : program->Functions)
				{
					if (refFuncs.Contains(func->Name))
						sb << GenerateFunction(func.Ptr());
				}
			}

			ExternComponentCodeGenInfo ExtractExternComponentInfo(const ILObjectDefinition & input)
			{
				auto type = input.Type.Ptr();
				auto recType = ExtractRecordType(type);
				ExternComponentCodeGenInfo info;
				info.Type = type;
				String bindingVal;
				if (input.Attributes.TryGetValue(L"Binding", bindingVal))
					info.Binding = StringToInt(bindingVal);
				if (recType)
				{
					if (auto genType = dynamic_cast<ILGenericType*>(type))
					{
						type = genType->BaseType.Ptr();
						if (genType->GenericTypeName == L"Uniform")
							info.DataStructure = ExternComponentCodeGenInfo::DataStructureType::UniformBuffer;
						else if (genType->GenericTypeName == L"Patch")
							info.DataStructure = ExternComponentCodeGenInfo::DataStructureType::Patch;
						else if (genType->GenericTypeName == L"Texture")
							info.DataStructure = ExternComponentCodeGenInfo::DataStructureType::Texture;
						else if (genType->GenericTypeName == L"PackedBuffer")
							info.DataStructure = ExternComponentCodeGenInfo::DataStructureType::PackedBuffer;
						else if (genType->GenericTypeName == L"Buffer")
							info.DataStructure = ExternComponentCodeGenInfo::DataStructureType::StorageBuffer;
					}
					if (auto arrType = dynamic_cast<ILArrayType*>(type))
					{
						if (info.DataStructure != ExternComponentCodeGenInfo::DataStructureType::StandardInput &&
							info.DataStructure != ExternComponentCodeGenInfo::DataStructureType::UniformBuffer &&
							info.DataStructure != ExternComponentCodeGenInfo::DataStructureType::Patch)
							errWriter->Error(51090, L"cannot generate code for extern component type '" + type->ToString() + L"'.",
								input.Position);
						type = arrType->BaseType.Ptr();
						info.IsArray = true;
						info.ArrayLength = arrType->ArrayLength;
					}
					if (type != recType)
					{
						errWriter->Error(51090, L"cannot generate code for extern component type '" + type->ToString() + L"'.",
							input.Position);
					}
				}
				else
				{
					// check for attributes 
				}
				return info;
			}

			void PrintInputReference(StringBuilder & sb, String input)
			{
				auto info = extCompInfo[input]();

				if (info.DataStructure == ExternComponentCodeGenInfo::DataStructureType::UniformBuffer)
				{
					if (!currentImportInstr->Type->IsTexture() || useBindlessTexture)
						sb << L"blk" << input << L"." << currentImportInstr->ComponentName;
					else
						sb << currentImportInstr->ComponentName;
				}
				else if (info.DataStructure == ExternComponentCodeGenInfo::DataStructureType::StorageBuffer)
				{
					sb << L"blk" << input << L".content";
				}
				else if (info.DataStructure == ExternComponentCodeGenInfo::DataStructureType::PackedBuffer)
				{
					sb << L"blk" << input << L".content";
				}
				else if (ExtractRecordType(info.Type.Ptr()))
				{
					sb << currentImportInstr->ComponentName;
				}
				else
				{
					sb << input;
				}
			}

			void DeclareInput(CodeGenContext & sb, const ILObjectDefinition & input)
			{
				auto info = ExtractExternComponentInfo(input);
				extCompInfo[input.Name] = info;
				auto recType = ExtractRecordType(input.Type.Ptr());
				if (recType)
				{
					if (info.DataStructure == ExternComponentCodeGenInfo::DataStructureType::UniformBuffer)
					{
						sb.GlobalHeader << L"layout(std140";
						if (info.Binding != -1)
							sb.GlobalHeader << L", binding = " << info.Binding;
						sb.GlobalHeader << L") uniform " << input.Name << L"\n{\n";
					}
					else if (info.DataStructure == ExternComponentCodeGenInfo::DataStructureType::StorageBuffer)
					{
						sb.GlobalHeader << L"struct T" << input.Name << L"\n{\n";
					}
					
					if (info.DataStructure == ExternComponentCodeGenInfo::DataStructureType::PackedBuffer)
					{
						sb.GlobalHeader << L"layout(std430";
						if (info.Binding != -1)
							sb.GlobalHeader << L", binding = " << info.Binding;
						sb.GlobalHeader << L") uniform " << input.Name << L"\n{\nfloat content[];\n} blk" << input.Name << L";\n";
					}
					else
					{
						int index = 0;
						for (auto & field : recType->Members)
						{
							if (info.DataStructure == ExternComponentCodeGenInfo::DataStructureType::Texture)
							{
								if (field.Value.Type->IsFloat() || field.Value.Type->IsFloatVector() && !field.Value.Type->IsFloatMatrix())
									sb.GlobalHeader << L"uniform sampler2D " << field.Key << L";\n";
								else
									errWriter->Error(51091, L"type '" + field.Value.Type->ToString() + L"' cannot be placed in a texture.",
										field.Value.Position);
							}
							else
							{
								if (input.Attributes.ContainsKey(L"Flat"))
									sb.GlobalHeader << L"flat ";
								if (!useBindlessTexture && info.DataStructure == ExternComponentCodeGenInfo::DataStructureType::UniformBuffer &&
									field.Value.Type->IsTexture())
									continue;
								if (info.DataStructure == ExternComponentCodeGenInfo::DataStructureType::StandardInput)
									sb.GlobalHeader << L"in ";
								else if (info.DataStructure == ExternComponentCodeGenInfo::DataStructureType::Patch)
									sb.GlobalHeader << L"patch in ";
								PrintDef(sb.GlobalHeader, field.Value.Type.Ptr(), field.Key);
								if (info.IsArray)
								{
									sb.GlobalHeader << L"[";
									if (info.ArrayLength)
										sb.GlobalHeader << String(info.ArrayLength);
									sb.GlobalHeader << L"]";
								}
								sb.GlobalHeader << L";\n";
							}
							index++;
						}
					}

					if (info.DataStructure == ExternComponentCodeGenInfo::DataStructureType::UniformBuffer)
						sb.GlobalHeader << L"} blk" << input.Name << L";\n";
					else if (info.DataStructure == ExternComponentCodeGenInfo::DataStructureType::StorageBuffer)
						sb.GlobalHeader << L"};\nbuffer " << input.Name << L"\n{\nT" << input.Name << L"content[];\n} blk" << input.Name << L";\n";
					if (!useBindlessTexture && info.DataStructure == ExternComponentCodeGenInfo::DataStructureType::UniformBuffer)
					{
						for (auto & field : recType->Members)
						{
							if (field.Value.Type->IsTexture())
							{
								if (field.Value.Attributes.ContainsKey(L"Binding"))
									sb.GlobalHeader << L"layout(binding = " << field.Value.Attributes[L"Binding"]() << L") ";
								sb.GlobalHeader << L"uniform ";
								PrintDef(sb.GlobalHeader, field.Value.Type.Ptr(), field.Key);
								sb.GlobalHeader << L";\n";
							}
						}
					}
				}
				else
				{
					if (input.Attributes.ContainsKey(L"TessCoord"))
					{
						if (input.Type->IsFloatVector() && input.Type->GetVectorSize() == 3)
							PrintDef(sb.Header, input.Type.Ptr(), input.Name);
						else
							errWriter->Error(50053, L"component as '[TessCoord]' attribute must be a vec3.", input.Position);
						sb.Header << input.Name << L" = gl_TessCoord;\n";
					}
					else if (input.Attributes.ContainsKey(L"InvocationId") || input.Attributes.ContainsKey(L"InvocationID"))
					{
						if (input.Type->IsInt())
							PrintDef(sb.Header, input.Type.Ptr(), input.Name);
						else
							errWriter->Error(50053, L"component as '[InvocationId]' attribute must be an int.", input.Position);
						sb.Header << input.Name << L" = gl_InvocationID;\n";
					}
					else if (input.Attributes.ContainsKey(L"PrimitiveId") || input.Attributes.ContainsKey(L"PrimitiveID"))
					{
						if (input.Type->IsInt())
							PrintDef(sb.Header, input.Type.Ptr(), input.Name);
						else
							errWriter->Error(50053, L"component as '[PrimitiveID]' attribute must be an int.", input.Position);
						sb.Header << input.Name << L" = gl_PrimitiveID;\n";
					}
					else if (input.Attributes.ContainsKey(L"PatchVerticesIn"))
					{
						if (input.Type->IsInt())
							PrintDef(sb.Header, input.Type.Ptr(), input.Name);
						else
							errWriter->Error(50053, L"component as '[PatchVerticesIn]' attribute must be an int.", input.Position);
						sb.Header << input.Name << L" = gl_PatchVerticesIn;\n";
					}
					else if (input.Attributes.ContainsKey(L"ThreadId") || input.Attributes.ContainsKey(L"GlobalInvocationId"))
					{
						if (input.Type->IsInt())
							PrintDef(sb.Header, input.Type.Ptr(), input.Name);
						else
							errWriter->Error(50053, L"component as '[ThreadId]' attribute must be an int.", input.Position);
						sb.Header << input.Name << L" = gl_GlobalInvocationID.x;\n";
					}
				}
			}

			void DeclareOutput(CodeGenContext & sb, ILRecordType * output, ILStage * stage)
			{
				outputStrategy->DeclareOutput(sb, stage);
			}

			void GenerateVertexShaderEpilog(CodeGenContext & ctx, ILWorld * world, ILStage * stage)
			{
				StageAttribute positionVar;
				if (stage->Attributes.TryGetValue(L"Position", positionVar))
				{
					ILOperand * operand;
					if (world->Components.TryGetValue(positionVar.Value, operand))
					{
						if (operand->Type->IsFloatVector() && operand->Type->GetVectorSize() == 4)
							ctx.Body << L"gl_Position = " << operand->Name << L";\n";
						else
							errWriter->Error(50040, L"'" + positionVar.Value + L"': component used as 'Position' output must be of vec4 type.",
								positionVar.Position);
					}
					else
						errWriter->Error(50041, L"'" + positionVar.Value + L"': component not defined.",
							positionVar.Position);
				}
			}

			void GenerateDomainShaderProlog(CodeGenContext & ctx, ILStage * stage)
			{
				ctx.GlobalHeader << L"layout(";
				StageAttribute val;
				if (stage->Attributes.TryGetValue(L"Domain", val))
					ctx.GlobalHeader << ((val.Value == L"quads") ? L"quads" : L"triangles");
				else
					ctx.GlobalHeader << L"triangles";
				if (val.Value != L"triangles" && val.Value != L"quads")
					Error(50093, L"'Domain' should be either 'triangles' or 'quads'.", val.Position);
				if (stage->Attributes.TryGetValue(L"Winding", val))
				{
					if (val.Value == L"cw")
						ctx.GlobalHeader << L", cw";
					else
						ctx.GlobalHeader << L", ccw";
				}
				if (stage->Attributes.TryGetValue(L"EqualSpacing", val))
				{
					if (val.Value == L"1" || val.Value == L"true")
						ctx.GlobalHeader << L", equal_spacing";
				}
				ctx.GlobalHeader << L") in;\n";
			}

			StageSource GenerateSingleWorldShader(ILProgram * program, ILShader * shader, ILStage * stage)
			{
				StageSource rs;
				CodeGenContext ctx;
				GenerateHeader(ctx.GlobalHeader, stage);
				if (stage->StageType == L"DomainShader")
					GenerateDomainShaderProlog(ctx, stage);

				GenerateStructs(ctx.GlobalHeader, program);
				StageAttribute worldName;
				RefPtr<ILWorld> world = nullptr;
				if (stage->Attributes.TryGetValue(L"World", worldName))
				{
					if (!shader->Worlds.TryGetValue(worldName.Value, world))
						errWriter->Error(50022, L"world '" + worldName.Value + L"' is not defined.", worldName.Position);
				}
				else
					errWriter->Error(50023, L"'" + stage->StageType + L"' should provide 'World' attribute.", stage->Position);
				if (!world)
					return rs;
				GenerateReferencedFunctions(ctx.GlobalHeader, program, MakeArrayView(world.Ptr()));
				extCompInfo.Clear();
				for (auto & input : world->Inputs)
				{
					DeclareInput(ctx, input);
				}
		
				outputStrategy->DeclareOutput(ctx, stage);
				ctx.codeGen = this;
				world->Code->NameAllInstructions();
				GenerateCode(ctx, world->Code.Ptr());
				if (stage->StageType == L"VertexShader" || stage->StageType == L"DomainShader")
					GenerateVertexShaderEpilog(ctx, world.Ptr(), stage);

				StringBuilder sb;
				sb << ctx.GlobalHeader.ProduceString();
				sb << L"void main()\n{\n";
				sb << ctx.Header.ProduceString() << ctx.Body.ProduceString();
				sb << L"}";
				rs.MainCode = sb.ProduceString();
				return rs;
			}

			StageSource GenerateVertexFragmentDomainShader(ILProgram * program, ILShader * shader, ILStage * stage)
			{
				RefPtr<ILWorld> world = nullptr;
				StageAttribute worldName;
				if (stage->Attributes.TryGetValue(L"World", worldName))
				{
					if (!shader->Worlds.TryGetValue(worldName.Value, world))
						errWriter->Error(50022, L"world '" + worldName.Value + L"' is not defined.", worldName.Position);
				}
				outputStrategy = CreateStandardOutputStrategy(this, world.Ptr(), L"");
				return GenerateSingleWorldShader(program, shader, stage);
			}

			StageSource GenerateComputeShader(ILProgram * program, ILShader * shader, ILStage * stage)
			{
				RefPtr<ILWorld> world = nullptr;
				StageAttribute worldName;
				if (stage->Attributes.TryGetValue(L"World", worldName))
				{
					if (!shader->Worlds.TryGetValue(worldName.Value, world))
						errWriter->Error(50022, L"world '" + worldName.Value + L"' is not defined.", worldName.Position);
				}
				outputStrategy = CreatePackedBufferOutputStrategy(this, world.Ptr());
				return GenerateSingleWorldShader(program, shader, stage);
			}

			StageSource GenerateHullShader(ILProgram * program, ILShader * shader, ILStage * stage)
			{
				StageSource rs;
				StageAttribute patchWorldName, controlPointWorldName, cornerPointWorldName, domain, innerLevel, outterLevel, numControlPoints;
				RefPtr<ILWorld> patchWorld, controlPointWorld, cornerPointWorld;
				if (!stage->Attributes.TryGetValue(L"PatchWorld", patchWorldName))
				{
					errWriter->Error(50052, L"'HullShader' requires attribute 'PatchWorld'.", stage->Position);
					return rs;
				}
				if (!shader->Worlds.TryGetValue(patchWorldName.Value, patchWorld))
					errWriter->Error(50022, L"world '" + patchWorldName.Value + L"' is not defined.", patchWorldName.Position);
				if (!stage->Attributes.TryGetValue(L"ControlPointWorld", controlPointWorldName))
				{
					errWriter->Error(50052, L"'HullShader' requires attribute 'ControlPointWorld'.", stage->Position); 
					return rs;
				}
				if (!shader->Worlds.TryGetValue(controlPointWorldName.Value, controlPointWorld))
					errWriter->Error(50022, L"world '" + controlPointWorldName.Value + L"' is not defined.", controlPointWorldName.Position);
				if (!stage->Attributes.TryGetValue(L"CornerPointWorld", cornerPointWorldName))
				{
					errWriter->Error(50052, L"'HullShader' requires attribute 'CornerPointWorld'.", stage->Position);
					return rs;
				}
				if (!shader->Worlds.TryGetValue(cornerPointWorldName.Value, cornerPointWorld))
					errWriter->Error(50022, L"world '" + cornerPointWorldName.Value + L"' is not defined.", cornerPointWorldName.Position);
				if (!stage->Attributes.TryGetValue(L"Domain", domain))
				{
					errWriter->Error(50052, L"'HullShader' requires attribute 'Domain'.", stage->Position);
					return rs;
				}
				if (domain.Value != L"triangles" && domain.Value != L"quads")
				{
					errWriter->Error(50053, L"'Domain' should be either 'triangles' or 'quads'.", domain.Position);
					return rs;
				}
				if (!stage->Attributes.TryGetValue(L"TessLevelOutter", outterLevel))
				{
					errWriter->Error(50052, L"'HullShader' requires attribute 'TessLevelOutter'.", stage->Position);
					return rs;
				}
				if (!stage->Attributes.TryGetValue(L"TessLevelInner", innerLevel))
				{
					errWriter->Error(50052, L"'HullShader' requires attribute 'TessLevelInner'.", stage->Position);
					return rs;
				}
				if (!stage->Attributes.TryGetValue(L"ControlPointCount", numControlPoints))
				{
					errWriter->Error(50052, L"'HullShader' requires attribute 'ControlPointCount'.", stage->Position);
					return rs;
				}
				CodeGenContext ctx;
				ctx.codeGen = this;
				List<ILWorld*> worlds;
				worlds.Add(patchWorld.Ptr());
				worlds.Add(controlPointWorld.Ptr());
				worlds.Add(cornerPointWorld.Ptr());
				GenerateHeader(ctx.GlobalHeader, stage);
				ctx.GlobalHeader << L"layout(vertices = " << numControlPoints.Value << L") out;\n";
				GenerateStructs(ctx.GlobalHeader, program);
				GenerateReferencedFunctions(ctx.GlobalHeader, program, worlds.GetArrayView());
				extCompInfo.Clear();

				HashSet<String> declaredInputs;

				patchWorld->Code->NameAllInstructions();
				outputStrategy = CreateStandardOutputStrategy(this, patchWorld.Ptr(), L"patch");
				for (auto & input : patchWorld->Inputs)
				{
					if (declaredInputs.Add(input.Name))
						DeclareInput(ctx, input);
				}
				outputStrategy->DeclareOutput(ctx, stage);
				GenerateCode(ctx, patchWorld->Code.Ptr());

				controlPointWorld->Code->NameAllInstructions();
				outputStrategy = CreateArrayOutputStrategy(this, controlPointWorld.Ptr(), false, 0, L"gl_InvocationID");
				for (auto & input : controlPointWorld->Inputs)
				{
					if (declaredInputs.Add(input.Name))
						DeclareInput(ctx, input);
				}
				outputStrategy->DeclareOutput(ctx, stage);
				GenerateCode(ctx, controlPointWorld->Code.Ptr());

				cornerPointWorld->Code->NameAllInstructions();
				outputStrategy = CreateArrayOutputStrategy(this, cornerPointWorld.Ptr(), true, (domain.Value == L"triangles" ? 3 : 4), L"sysLocalIterator");
				for (auto & input : cornerPointWorld->Inputs)
				{
					if (declaredInputs.Add(input.Name))
						DeclareInput(ctx, input);
				}
				outputStrategy->DeclareOutput(ctx, stage);
				ctx.Body << L"for (int sysLocalIterator = 0; sysLocalIterator < gl_PatchVerticesIn; sysLocalIterator++)\n{\n";
				GenerateCode(ctx, cornerPointWorld->Code.Ptr());
				auto debugStr = cornerPointWorld->Code->ToString();
				ctx.Body << L"}\n";

				// generate epilog
				bool found = false;
				for (auto & world : worlds)
				{
					ILOperand * operand;
					if (world->Components.TryGetValue(innerLevel.Value, operand))
					{
						for (int i = 0; i < 2; i++)
						{
							ctx.Body << L"gl_TessLevelInner[" << i << L"] = ";
							PrintOp(ctx, operand);
							ctx.Body << L"[" << i << L"];\n";
						}
						found = true;
						break;
					}
				}
				if (!found)
					errWriter->Error(50041, L"'" + innerLevel.Value + L"': component not defined.",
						innerLevel.Position);

				found = false;
				for (auto & world : worlds)
				{
					ILOperand * operand;
					if (world->Components.TryGetValue(outterLevel.Value, operand))
					{
						for (int i = 0; i < 4; i++)
						{
							ctx.Body << L"gl_TessLevelOutter[" << i << L"] = ";
							PrintOp(ctx, operand);
							ctx.Body << L"[" << i << L"];\n";
						}
						found = true;
						break;
					}

				}
				if (!found)
					errWriter->Error(50041, L"'" + outterLevel.Value + L"': component not defined.",
						outterLevel.Position);

				StringBuilder sb;
				sb << ctx.GlobalHeader.ProduceString();
				sb << L"void main()\n{\n" << ctx.Header.ProduceString() << ctx.Body.ProduceString() << L"}";
				rs.MainCode = sb.ProduceString();
				return rs;
			}

			void GenerateFunctionDeclaration(StringBuilder & sbCode, ILFunction * function)
			{
				auto retType = function->ReturnType.Ptr();
				if (retType)
					PrintType(sbCode, retType);
				else
					sbCode << L"void";
				sbCode << L" " << GetFuncOriginalName(function->Name) << L"(";
				int id = 0;
				for (auto & instr : *function->Code)
				{
					if (auto arg = instr.As<FetchArgInstruction>())
					{
						if (arg->ArgId != 0)
						{
							if (id > 0)
							{
								sbCode << L", ";
							}
							PrintDef(sbCode, arg->Type.Ptr(), arg->Name);
							id++;
						}
					}
				}
				sbCode << L")";
			}
			String GenerateFunction(ILFunction * function)
			{
				StringBuilder sbCode;
				CodeGenContext ctx;
				ctx.codeGen = this;
				ctx.UsedVarNames.Clear();
				ctx.Body.Clear();
				ctx.Header.Clear();
				ctx.Arguments.Clear();
				ctx.ReturnVarName = L"";
				ctx.VarName.Clear();
				
				function->Code->NameAllInstructions();
				GenerateFunctionDeclaration(sbCode, function);
				sbCode << L"\n{\n";
				GenerateCode(ctx, function->Code.Ptr());
				sbCode << ctx.Header.ToString() << ctx.Body.ToString();
				if (ctx.ReturnVarName.Length())
					sbCode << L"return " << ctx.ReturnVarName << L";\n";
				sbCode << L"}\n";
				return sbCode.ProduceString();
			}
		};


		class StandardOutputStrategy : public OutputStrategy
		{
		private:
			String declPrefix;
		public:
			StandardOutputStrategy(GLSLCodeGen * pCodeGen, ILWorld * world, String prefix)
				: OutputStrategy(pCodeGen, world), declPrefix(prefix)
			{}
			virtual void DeclareOutput(CodeGenContext & ctx, ILStage *) override
			{
				for (auto & field : world->OutputType->Members)
				{
					ctx.GlobalHeader << declPrefix << L" out ";
					codeGen->PrintDef(ctx.GlobalHeader, field.Value.Type.Ptr(), field.Key);
					ctx.GlobalHeader << L";\n";
				}
			}
			virtual void ProcessExportInstruction(CodeGenContext & ctx, ExportInstruction * instr) override
			{
				ctx.Body << instr->ComponentName << L" = ";
				codeGen->PrintOp(ctx, instr->Operand.Ptr());
				ctx.Body << L";\n";
			}
		};

		class ArrayOutputStrategy : public OutputStrategy
		{
		protected:
			bool isPatch = false;
			int arraySize = 0;
		public:
			String outputIndex;
			ArrayOutputStrategy(GLSLCodeGen * pCodeGen, ILWorld * world, bool pIsPatch, int pArraySize, String pOutputIndex)
				: OutputStrategy(pCodeGen, world)
			{
				isPatch = pIsPatch;
				arraySize = pArraySize;
				outputIndex = pOutputIndex;
			}
			virtual void DeclareOutput(CodeGenContext & ctx, ILStage *) override
			{
				for (auto & field : world->OutputType->Members)
				{
					if (isPatch)
						ctx.GlobalHeader << L"patch ";
					ctx.GlobalHeader << L"out ";
					codeGen->PrintDef(ctx.GlobalHeader, field.Value.Type.Ptr(), field.Key);
					ctx.GlobalHeader << L"[";
					if (arraySize != 0)
						ctx.GlobalHeader << arraySize;
					ctx.GlobalHeader<<L"]; \n";
				}
			}
			virtual void ProcessExportInstruction(CodeGenContext & ctx, ExportInstruction * instr) override
			{
				ctx.Body << instr->ComponentName << L"[" << outputIndex << L"] = ";
				codeGen->PrintOp(ctx, instr->Operand.Ptr());
				ctx.Body << L";\n";
			}
		};

		class PackedBufferOutputStrategy : public OutputStrategy
		{
		public:
			PackedBufferOutputStrategy(GLSLCodeGen * pCodeGen, ILWorld * world)
				: OutputStrategy(pCodeGen, world)
			{}
			virtual void DeclareOutput(CodeGenContext & ctx, ILStage *) override
			{
				for (auto & field : world->OutputType->Members)
				{
					ctx.GlobalHeader << L"out ";
					codeGen->PrintDef(ctx.GlobalHeader, field.Value.Type.Ptr(), field.Key);
					ctx.GlobalHeader << L";\n";
				}
			}
			virtual void ProcessExportInstruction(CodeGenContext & ctx, ExportInstruction * exportInstr) override
			{
				String conversionFunction;
				int size = 0;
				String typeName = exportInstr->Type->ToString();
				if (typeName == L"int")
				{
					conversionFunction = L"intBitsToFloat";
					size = 1;
				}
				else if (typeName == L"ivec2")
				{
					conversionFunction = L"intBitsToFloat";
					size = 2;
				}
				else if (typeName == L"ivec3")
				{
					conversionFunction = L"intBitsToFloat";
					size = 3;
				}
				else if (typeName == L"ivec4")
				{
					conversionFunction = L"intBitsToFloat";
					size = 4;
				}
				else if (typeName == L"uint")
				{
					conversionFunction = L"uintBitsToFloat";
					size = 1;
				}
				else if (typeName == L"uvec2")
				{
					conversionFunction = L"uintBitsToFloat";
					size = 2;
				}
				else if (typeName == L"uvec3")
				{
					conversionFunction = L"uintBitsToFloat";
					size = 3;
				}
				else if (typeName == L"uvec4")
				{
					conversionFunction = L"uintBitsToFloat";
					size = 4;
				}
				else if (typeName == L"float")
				{
					conversionFunction = L"";
					size = 1;
				}
				else if (typeName == L"vec2")
				{
					conversionFunction = L"";
					size = 2;
				}
				else if (typeName == L"vec3")
				{
					conversionFunction = L"";
					size = 3;
				}
				else if (typeName == L"vec4")
				{
					conversionFunction = L"";
					size = 4;
				}
				else if (typeName == L"mat3")
				{
					conversionFunction = L"";
					size = 9;
				}
				else if (typeName == L"mat4")
				{
					conversionFunction = L"";
					size = 16;
				}
				else
				{
					codeGen->Error(50082, L"importing type '" + typeName + L"' from PackedBuffer is not supported by the GLSL backend.",
						CodePosition());
				}
				auto recType = world->OutputType.Ptr();
				int recTypeSize = 0;
				EnumerableDictionary<String, int> memberOffsets;
				for (auto & member : recType->Members)
				{
					memberOffsets[member.Key] = recTypeSize;
					recTypeSize += member.Value.Type->GetVectorSize();
				}
				for (int i = 0; i < size; i++)
				{
					ctx.Body << L"sysOutputBuffer.content[gl_InvocationId.x * " << recTypeSize << L" + " + memberOffsets[exportInstr->ComponentName]()
						<< L"] = " << conversionFunction << L"(";
					codeGen->PrintOp(ctx, exportInstr->Operand.Ptr());
					if (size <= 4)
						ctx.Body << L"[" << i << L"]";
					else
					{
						int width = size == 9 ? 3 : 4;
						ctx.Body << L"[" << i / width << L"][" << i % width << L"]";
					}
					ctx.Body << L");\n";
				}
			}
		};

		String CodeGenContext::DefineVariable(ILOperand * op)
		{
			String rs;
			if (VarName.TryGetValue(op, rs))
			{
				return rs;
			}
			else
			{
				auto name = GenerateCodeName(op->Name, L"");
				codeGen->PrintDef(Header, op->Type.Ptr(), name);
				if (op->Type->IsInt() || op->Type->IsUInt())
				{
					Header << L" = 0;";
				}
				Header << L";\n";
				VarName.Add(op, name);
				op->Name = name;
				return op->Name;
			}
		}

		OutputStrategy * CreateStandardOutputStrategy(GLSLCodeGen * codeGen, ILWorld * world, String layoutPrefix)
		{
			return new StandardOutputStrategy(codeGen, world, layoutPrefix);
		}
		OutputStrategy * CreatePackedBufferOutputStrategy(GLSLCodeGen * codeGen, ILWorld * world)
		{
			return new PackedBufferOutputStrategy(codeGen, world);
		}
		OutputStrategy * CreateArrayOutputStrategy(GLSLCodeGen * codeGen, ILWorld * world, bool pIsPatch, int pArraySize, String arrayIndex)
		{
			return new ArrayOutputStrategy(codeGen, world, pIsPatch, pArraySize, arrayIndex);
		}

		CodeGenBackend * CreateGLSLCodeGen()
		{
			return new GLSLCodeGen();
		}
	}
}

/***********************************************************************
CORE\IL.CPP
***********************************************************************/

namespace Spire
{
	namespace Compiler
	{
		using namespace CoreLib::IO;

		RefPtr<ILType> BaseTypeFromString(CoreLib::Text::Parser & parser)
		{
			if (parser.LookAhead(L"int"))
				return new ILBasicType(ILBaseType::Int);
			else if (parser.LookAhead(L"uint"))
				return new ILBasicType(ILBaseType::UInt);
			else if (parser.LookAhead(L"uvec2"))
				return new ILBasicType(ILBaseType::UInt2);
			else if (parser.LookAhead(L"uvec3"))
				return new ILBasicType(ILBaseType::UInt3);
			else if (parser.LookAhead(L"uvec4"))
				return new ILBasicType(ILBaseType::UInt4);
			if (parser.LookAhead(L"float"))
				return new ILBasicType(ILBaseType::Float);
			if (parser.LookAhead(L"vec2"))
				return new ILBasicType(ILBaseType::Float2);
			if (parser.LookAhead(L"vec3"))
				return new ILBasicType(ILBaseType::Float3);
			if (parser.LookAhead(L"vec4"))
				return new ILBasicType(ILBaseType::Float4);
			if (parser.LookAhead(L"ivec2"))
				return new ILBasicType(ILBaseType::Int2);
			if (parser.LookAhead(L"mat3"))
				return new ILBasicType(ILBaseType::Float3x3);
			if (parser.LookAhead(L"mat4"))
				return new ILBasicType(ILBaseType::Float4x4);
			if (parser.LookAhead(L"ivec3"))
				return new ILBasicType(ILBaseType::Int3);
			if (parser.LookAhead(L"ivec4"))
				return new ILBasicType(ILBaseType::Int4);
			if (parser.LookAhead(L"sampler2D"))
				return new ILBasicType(ILBaseType::Texture2D);
			if (parser.LookAhead(L"sampler2DShadow"))
				return new ILBasicType(ILBaseType::TextureShadow);
			if (parser.LookAhead(L"samplerCube"))
				return new ILBasicType(ILBaseType::TextureCube);
			if (parser.LookAhead(L"samplerCubeShadow"))
				return new ILBasicType(ILBaseType::TextureCubeShadow);
			if (parser.LookAhead(L"bool"))
				return new ILBasicType(ILBaseType::Bool);
			return nullptr;
		}

		RefPtr<ILType> TypeFromString(CoreLib::Text::Parser & parser)
		{
			auto result = BaseTypeFromString(parser);
			parser.ReadToken();
			while (parser.LookAhead(L"["))
			{
				parser.ReadToken();
				RefPtr<ILArrayType> newResult = new ILArrayType();
				newResult->BaseType = result;
				if (!parser.LookAhead(L"]"))
					newResult->ArrayLength = parser.ReadInt();
				result = newResult;
				parser.Read(L"]");
			}
			return result;
		}

		int RoundToAlignment(int offset, int alignment)
		{
			int remainder = offset % alignment;
			if (remainder == 0)
				return offset;
			else
				return offset + (alignment - remainder);
		}

		int SizeofBaseType(ILBaseType type)
		{
			if (type == ILBaseType::Int)
				return 4;
			if (type == ILBaseType::UInt)
				return 4;
			if (type == ILBaseType::UInt2)
				return 8;
			if (type == ILBaseType::UInt3)
				return 12;
			if (type == ILBaseType::UInt4)
				return 16;
			else if (type == ILBaseType::Int2)
				return 8;
			else if (type == ILBaseType::Int3)
				return 12;
			else if (type == ILBaseType::Int4)
				return 16;
			else if (type == ILBaseType::Float)
				return 4;
			else if (type == ILBaseType::Float2)
				return 8;
			else if (type == ILBaseType::Float3)
				return 12;
			else if (type == ILBaseType::Float4)
				return 16;
			else if (type == ILBaseType::Float3x3)
				return 48;
			else if (type == ILBaseType::Float4x4)
				return 64;
			else if (type == ILBaseType::Texture2D)
				return 8;
			else if (type == ILBaseType::TextureCube)
				return 8;
			else if (type == ILBaseType::TextureCubeShadow)
				return 8;
			else if (type == ILBaseType::TextureShadow)
				return 8;
			else if (type == ILBaseType::Bool)
				return 4;
			else
				return 0;
		}

		bool ILType::IsBool()
		{
			auto basicType = dynamic_cast<ILBasicType*>(this);
			if (basicType)
				return basicType->Type == ILBaseType::Bool;
			else
				return false;
		}

		bool ILType::IsInt()
		{
			auto basicType = dynamic_cast<ILBasicType*>(this);
			if (basicType)
				return basicType->Type == ILBaseType::Int;
			else
				return false;
		}

		bool ILType::IsUInt()
		{
			auto basicType = dynamic_cast<ILBasicType*>(this);
			if (basicType)
				return basicType->Type == ILBaseType::UInt;
			else
				return false;
		}

		bool ILType::IsIntegral()
		{
			auto basicType = dynamic_cast<ILBasicType*>(this);
			if (basicType)
				return basicType->Type == ILBaseType::Int || basicType->Type == ILBaseType::Int2 || basicType->Type == ILBaseType::Int3 || basicType->Type == ILBaseType::Int4 
				|| basicType->Type == ILBaseType::UInt || basicType->Type == ILBaseType::UInt2 || basicType->Type == ILBaseType::UInt3 || basicType->Type == ILBaseType::UInt4;
			else
				return false;
		}

		bool ILType::IsFloat()
		{
			auto basicType = dynamic_cast<ILBasicType*>(this);
			if (basicType)
				return basicType->Type == ILBaseType::Float;
			else
				return false;
		}

		bool ILType::IsIntVector()
		{
			auto basicType = dynamic_cast<ILBasicType*>(this);
			if (basicType)
				return basicType->Type == ILBaseType::Int2 || basicType->Type == ILBaseType::Int3 || basicType->Type == ILBaseType::Int4;
			else
				return false;
		}

		bool ILType::IsUIntVector()
		{
			auto basicType = dynamic_cast<ILBasicType*>(this);
			if (basicType)
				return basicType->Type == ILBaseType::UInt2 || basicType->Type == ILBaseType::UInt3 || basicType->Type == ILBaseType::UInt4;
			else
				return false;
		}

		bool ILType::IsFloatVector()
		{
			auto basicType = dynamic_cast<ILBasicType*>(this);
			if (basicType)
				return basicType->Type == ILBaseType::Float2 || basicType->Type == ILBaseType::Float3 || basicType->Type == ILBaseType::Float4 ||
					basicType->Type == ILBaseType::Float3x3 || basicType->Type == ILBaseType::Float4x4;
			else
				return false;
		}

		bool ILType::IsFloatMatrix()
		{
			auto basicType = dynamic_cast<ILBasicType*>(this);
			if (basicType)
				return basicType->Type == ILBaseType::Float3x3 || basicType->Type == ILBaseType::Float4x4;
			else
				return false;
		}

		bool ILType::IsNonShadowTexture()
		{
			auto basicType = dynamic_cast<ILBasicType*>(this);
			if (basicType)
				return basicType->Type == ILBaseType::Texture2D || basicType->Type == ILBaseType::TextureCube;
			else
				return false;
		}

		bool ILType::IsTexture()
		{
			auto basicType = dynamic_cast<ILBasicType*>(this);
			if (basicType)
				return basicType->Type == ILBaseType::Texture2D || basicType->Type == ILBaseType::TextureCube || basicType->Type == ILBaseType::TextureCubeShadow ||
				basicType->Type == ILBaseType::TextureShadow;
			else
				return false;
		}

		int ILType::GetVectorSize()
		{
			if (auto basicType = dynamic_cast<ILBasicType*>(this))
			{
				switch (basicType->Type)
				{
				case ILBaseType::Int2:
				case ILBaseType::Float2:
				case ILBaseType::UInt2:
					return 2;
				case ILBaseType::Int3:
				case ILBaseType::Float3:
				case ILBaseType::UInt3:
					return 3;
				case ILBaseType::Int4:
				case ILBaseType::Float4:
				case ILBaseType::UInt4:
					return 4;
				case ILBaseType::Float3x3:
					return 9;
				case ILBaseType::Float4x4:
					return 16;
				default:
					return 1;
				}
			}
			return 1;
		}

		bool CFGNode::HasPhiInstruction()
		{
			return headInstr && headInstr->GetNext() && headInstr->GetNext()->Is<PhiInstruction>();
		}

		ILInstruction * CFGNode::GetFirstNonPhiInstruction()
		{
			for (auto & instr : *this)
			{
				if (!instr.Is<PhiInstruction>())
					return &instr;
			}
			return tailInstr;
		}

		int NamingCounter = 0;

		void CFGNode::NameAllInstructions()
		{
			// name all operands
			StringBuilder numBuilder;
			for (auto & instr : GetAllInstructions())
			{
				numBuilder.Clear();
				for (auto & c : instr.Name)
				{
					if (c >= L'0' && c <= '9')
						numBuilder.Append(c);
					else
						numBuilder.Clear();
				}
				auto num = numBuilder.ToString();
				if (num.Length())
				{
					int id = StringToInt(num);
					NamingCounter = Math::Max(NamingCounter, id + 1);
				}
			}
			for (auto & instr : GetAllInstructions())
			{
				if (instr.Name.Length() == 0)
					instr.Name = String(L"t") + String(NamingCounter++, 16);
			}
		}

		void CFGNode::DebugPrint()
		{
			printf("===========\n");
			for (auto& instr : *this)
			{
				printf("%s\n", instr.ToString().ToMultiByteString());
			}
			printf("===========\n");
		}

		LoadInstruction::LoadInstruction(ILOperand * dest)
		{
			Deterministic = false;
			Operand = dest;
			Type = dest->Type->Clone();
			if (!Spire::Compiler::Is<AllocVarInstruction>(dest) && !Spire::Compiler::Is<FetchArgInstruction>(dest))
				throw L"invalid address operand";
		}
		void MemberUpdateInstruction::Accept(InstructionVisitor * visitor)
		{
			visitor->VisitMemberUpdateInstruction(this);
		}
		void SubInstruction::Accept(InstructionVisitor * visitor)
		{
			visitor->VisitSubInstruction(this);
		}
		void MulInstruction::Accept(InstructionVisitor * visitor)
		{
			visitor->VisitMulInstruction(this);
		}
		void DivInstruction::Accept(InstructionVisitor * visitor)
		{
			visitor->VisitDivInstruction(this);
		}
		void ModInstruction::Accept(InstructionVisitor * visitor)
		{
			visitor->VisitModInstruction(this);
		}
		void AndInstruction::Accept(InstructionVisitor * visitor)
		{
			visitor->VisitAndInstruction(this);
		}
		void OrInstruction::Accept(InstructionVisitor * visitor)
		{
			visitor->VisitOrInstruction(this);
		}
		void BitAndInstruction::Accept(InstructionVisitor * visitor)
		{
			visitor->VisitBitAndInstruction(this);
		}
		void BitOrInstruction::Accept(InstructionVisitor * visitor)
		{
			visitor->VisitBitOrInstruction(this);
		}
		void BitXorInstruction::Accept(InstructionVisitor * visitor)
		{
			visitor->VisitBitXorInstruction(this);
		}
		void ShlInstruction::Accept(InstructionVisitor * visitor)
		{
			visitor->VisitShlInstruction(this);
		}
		void ShrInstruction::Accept(InstructionVisitor * visitor)
		{
			visitor->VisitShrInstruction(this);
		}
		void CmpgtInstruction::Accept(InstructionVisitor * visitor)
		{
			visitor->VisitCmpgtInstruction(this);
		}
		void CmpgeInstruction::Accept(InstructionVisitor * visitor)
		{
			visitor->VisitCmpgeInstruction(this);
		}
		void CmpltInstruction::Accept(InstructionVisitor * visitor)
		{
			visitor->VisitCmpltInstruction(this);
		}
		void CmpleInstruction::Accept(InstructionVisitor * visitor)
		{
			visitor->VisitCmpleInstruction(this);
		}
		void CmpeqlInstruction::Accept(InstructionVisitor * visitor)
		{
			visitor->VisitCmpeqlInstruction(this);
		}
		void CmpneqInstruction::Accept(InstructionVisitor * visitor)
		{
			visitor->VisitCmpneqInstruction(this);
		}
		void Float2IntInstruction::Accept(InstructionVisitor * visitor)
		{
			visitor->VisitFloat2IntInstruction(this);
		}
		void Int2FloatInstruction::Accept(InstructionVisitor * visitor)
		{
			visitor->VisitInt2FloatInstruction(this);
		}
		void CopyInstruction::Accept(InstructionVisitor * visitor)
		{
			visitor->VisitCopyInstruction(this);
		}
		void LoadInstruction::Accept(InstructionVisitor * visitor)
		{
			visitor->VisitLoadInstruction(this);
		}
		void StoreInstruction::Accept(InstructionVisitor * visitor)
		{
			visitor->VisitStoreInstruction(this);
		}
		void AllocVarInstruction::Accept(InstructionVisitor * visitor)
		{
			visitor->VisitAllocVarInstruction(this);
		}
		void FetchArgInstruction::Accept(InstructionVisitor * visitor)
		{
			visitor->VisitFetchArgInstruction(this);
		}
		void PhiInstruction::Accept(InstructionVisitor * visitor)
		{
			visitor->VisitPhiInstruction(this);
		}
		void SelectInstruction::Accept(InstructionVisitor * visitor)
		{
			visitor->VisitSelectInstruction(this);
		}
		void CallInstruction::Accept(InstructionVisitor * visitor)
		{
			visitor->VisitCallInstruction(this);
		}
		void SwitchInstruction::Accept(InstructionVisitor * visitor)
		{
			visitor->VisitSwitchInstruction(this);
		}
		void NotInstruction::Accept(InstructionVisitor * visitor)
		{
			visitor->VisitNotInstruction(this);
		}
		void NegInstruction::Accept(InstructionVisitor * visitor)
		{
			visitor->VisitNegInstruction(this);
		}
		void BitNotInstruction::Accept(InstructionVisitor * visitor)
		{
			visitor->VisitBitNotInstruction(this);
		}
		void AddInstruction::Accept(InstructionVisitor * visitor)
		{
			visitor->VisitAddInstruction(this);
		}
		void MemberLoadInstruction::Accept(InstructionVisitor * visitor)
		{
			visitor->VisitMemberLoadInstruction(this);
		}
		AllInstructionsIterator & AllInstructionsIterator::operator++()
		{
			bool done = false;
			do
			{
				done = true;
				if (subBlockPtr < curInstr->GetSubBlockCount())
				{
					StackItem item;
					item.instr = curInstr;
					item.subBlockPtr = subBlockPtr + 1;
					stack.Add(item);
					curInstr = curInstr->GetSubBlock(subBlockPtr)->begin().Current;
					subBlockPtr = 0;
				}
				else
					curInstr = curInstr->GetNext();
				while (curInstr->GetNext() == nullptr && stack.Count() > 0)
				{
					auto item = stack.Last();
					stack.RemoveAt(stack.Count() - 1);
					curInstr = item.instr;
					subBlockPtr = item.subBlockPtr;
					if (subBlockPtr >= curInstr->GetSubBlockCount())
					{
						subBlockPtr = 0;
						curInstr = curInstr->GetNext();
					}
					done = false;
				}
				if (curInstr->GetNext() == nullptr)
					break;
			} while (!done);

			return *this;
		}
		AllInstructionsIterator AllInstructionsCollection::begin()
		{
			return AllInstructionsIterator(node->begin().Current);
		}
		AllInstructionsIterator AllInstructionsCollection::end()
		{
			return AllInstructionsIterator(node->end().Current);
		}
		String ImportInstruction::ToString()
		{
			StringBuilder rs;
			rs << Name << L" = import [" << ComponentName << L"](";
			for (auto & arg : Arguments)
			{
				rs << arg->ToString() << L", ";
			}
			rs << L")";
			rs << L"\n{";
			rs << ImportOperator->ToString() << L"}\n";
			return rs.ProduceString();
		}
		String ImportInstruction::GetOperatorString()
		{
			return L"import";
		}
		void ImportInstruction::Accept(InstructionVisitor * visitor)
		{
			visitor->VisitImportInstruction(this);
		}
		void ExportInstruction::Accept(InstructionVisitor * visitor)
		{
			visitor->VisitExportInstruction(this);
		}
		ILType * ILStructType::Clone()
		{
			auto rs = new ILStructType(*this);
			rs->Members.Clear();
			for (auto & m : Members)
			{
				ILStructField f;
				f.FieldName = m.FieldName;
				f.Type = m.Type->Clone();
				rs->Members.Add(f);
			}
			return rs;
		}
		String ILStructType::ToString()
		{
			return TypeName;
		}
		bool ILStructType::Equals(ILType * type)
		{
			auto st = dynamic_cast<ILStructType*>(type);
			if (st && st->TypeName == this->TypeName)
				return true;
			return false;
		}
		void Align(int & ptr, int alignment)
		{
			if (ptr % alignment != 0)
			{
				ptr = (ptr / alignment + 1) * alignment;
			}
		}
		int ILStructType::GetSize()
		{
			int rs = 0;
			for (auto & m : Members)
			{
				int size = m.Type->GetSize();
				int alignment = m.Type->GetAlignment();
				Align(rs, alignment);
				rs += size;
			}
			return rs;
		}
		int ILStructType::GetAlignment()
		{
			int rs = 1;
			for (auto & m : Members)
			{
				int alignment = m.Type->GetAlignment();
				rs = Math::Max(rs, alignment);
			}
			return rs;
		}

		ILType * ILRecordType::Clone()
		{
			auto rs = new ILRecordType(*this);
			rs->Members.Clear();
			for (auto & m : Members)
			{
				ILObjectDefinition f;
				f.Type = m.Value.Type->Clone();
				f.Name = m.Value.Name;
				f.Attributes = m.Value.Attributes;
				rs->Members.Add(m.Key, f);
			}
			return rs;
		}
		String ILRecordType::ToString()
		{
			return TypeName;
		}
		bool ILRecordType::Equals(ILType * type)
		{
			auto recType = dynamic_cast<ILRecordType*>(type);
			if (recType)
				return TypeName == recType->TypeName;
			else
				return false;
		}
		int ILRecordType::GetSize()
		{
			return 0;
		}
		int ILRecordType::GetAlignment()
		{
			return 0;
		}
		void DiscardInstruction::Accept(InstructionVisitor * visitor)
		{
			visitor->VisitDiscardInstruction(this);
		}
		void LoadInputInstruction::Accept(InstructionVisitor * visitor)
		{
			visitor->VisitLoadInputInstruction(this);
		}
}
}

/***********************************************************************
CORE\INSERTIMPLICITIMPORTOPERATOR.CPP
***********************************************************************/

namespace Spire
{
	namespace Compiler
	{
		class InsertImplicitImportOperatorVisitor : public SyntaxVisitor
		{
		private:
			ShaderIR * shaderIR;
		public:
			ComponentDefinitionIR * currentCompDef = nullptr;
			EnumerableDictionary<String, RefPtr<ComponentDefinitionIR>> passThroughComponents;
		public:
			InsertImplicitImportOperatorVisitor(ShaderIR * ir, ErrorWriter* err)
				: SyntaxVisitor(err), shaderIR(ir)
			{}

			ComponentDefinitionIR * MakeComponentAvailableAtWorld(String componentUniqueName, String world)
			{
				HashSet<String> visitedComponents;
				return MakeComponentAvailableAtWorldInternal(visitedComponents, componentUniqueName, world);
			}

			ComponentDefinitionIR * MakeComponentAvailableAtWorldInternal(HashSet<String> & visitedComponents, String componentUniqueName, String world)
			{
				RefPtr<ComponentDefinitionIR> refDef;
				if (passThroughComponents.TryGetValue(componentUniqueName + L"I_at_I" + world, refDef))
					return refDef.Ptr();
				if (visitedComponents.Contains(componentUniqueName + "@" + world))
				{
					StringBuilder refs;
					int count = 0;
					for (auto & comp : visitedComponents)
					{
						refs << comp;
						if (count != visitedComponents.Count() - 1)
							refs << L", ";
						count++;
					}
					Error(34062, L"cyclic reference: " + refs.ProduceString(), currentCompDef->SyntaxNode.Ptr());
					return nullptr;
				}
				visitedComponents.Add(componentUniqueName);
				ImportPath importPath;
				int currentPathLength = 1 << 30;
				ComponentDefinitionIR * referencedDef = nullptr;
				for (auto & compDef : shaderIR->DefinitionsByComponent[componentUniqueName]())
				{
					if (compDef.Value->World == world)
						return compDef.Value;
				}
				for (auto & compDef : shaderIR->DefinitionsByComponent[componentUniqueName]())
				{
					auto path = shaderIR->Shader->Pipeline->FindImplicitImportOperatorChain(compDef.Value->World, world);
					if (path.Count() && path.First().Nodes.Count() < currentPathLength)
					{
						importPath = path.First();
						currentPathLength = importPath.Nodes.Count();
						referencedDef = compDef.Value;
					}
				}
				if (referencedDef)
				{
					auto & node = importPath.Nodes.Last();
					RefPtr<ComponentDefinitionIR> thruDef;
					auto thruDefName = componentUniqueName + L"I_at_I" + node.TargetWorld;
					if (!passThroughComponents.TryGetValue(thruDefName, thruDef))
					{
						auto srcDef = MakeComponentAvailableAtWorldInternal(visitedComponents, componentUniqueName, node.ImportOperator->SourceWorld.Content);
						thruDef = new ComponentDefinitionIR();
						thruDef->World = world;
						thruDef->Dependency.Add(srcDef);
						srcDef->Users.Add(thruDef.Ptr());
						thruDef->OriginalName = referencedDef->OriginalName;
						thruDef->UniqueName = thruDefName;
						thruDef->UniqueKey = referencedDef->UniqueKey + L"@" + node.TargetWorld;
						thruDef->IsEntryPoint = false;
						thruDef->SyntaxNode = new ComponentSyntaxNode();
						thruDef->SyntaxNode->Type = thruDef->Type = srcDef->SyntaxNode->Type;
						thruDef->SyntaxNode->Rate = new RateSyntaxNode();
						thruDef->SyntaxNode->Rate->Worlds.Add(RateWorld(node.TargetWorld));
						thruDef->SyntaxNode->Name.Content = thruDefName;
						CloneContext cloneCtx;
						thruDef->SyntaxNode->TypeNode = srcDef->SyntaxNode->TypeNode->Clone(cloneCtx);
						auto importExpr = new ImportExpressionSyntaxNode();
						importExpr->Type = thruDef->Type;
						importExpr->ImportOperatorDef = node.ImportOperator->Clone(cloneCtx);
						importExpr->ImportOperatorDef->Scope->Parent = thruDef->SyntaxNode->Scope.Ptr();
						importExpr->ComponentUniqueName = srcDef->UniqueName;
						for (auto & arg : importExpr->Arguments)
							arg->Accept(this);
						importExpr->ImportOperatorDef->Body->Accept(this);
						thruDef->SyntaxNode->Expression = importExpr;
						passThroughComponents[thruDefName] = thruDef;
					}
					visitedComponents.Remove(componentUniqueName + "@" + world);
					return thruDef.Ptr();
				}
				else
				{
					throw InvalidProgramException(L"import operator not found, should have been checked in semantics pass.");
				}
			}

			RefPtr<ExpressionSyntaxNode> ProcessComponentReference(String componentUniqueName)
			{
				auto refDef = MakeComponentAvailableAtWorld(componentUniqueName, currentCompDef->World);
				auto refNode = new VarExpressionSyntaxNode();
				if (refDef)
				{
					refNode->Variable = refDef->UniqueName;
					refNode->Type = refDef->Type;
					refNode->Tags[L"ComponentReference"] = new StringObject(refDef->UniqueName);
					currentCompDef->Dependency.Add(refDef);
					refDef->Users.Add(currentCompDef);
				}
				return refNode;
			}
			RefPtr<ExpressionSyntaxNode> VisitVarExpression(VarExpressionSyntaxNode * var) override
			{
				RefPtr<Object> refCompObj;
				if (var->Tags.TryGetValue(L"ComponentReference", refCompObj))
				{
					auto refComp = refCompObj.As<StringObject>().Ptr();
					return ProcessComponentReference(refComp->Content);
				}
				return var;
			}

			RefPtr<ExpressionSyntaxNode> VisitMemberExpression(MemberExpressionSyntaxNode * member) override
			{
				RefPtr<Object> refCompObj;
				if (member->Tags.TryGetValue(L"ComponentReference", refCompObj))
				{
					auto refComp = refCompObj.As<StringObject>().Ptr();
					return ProcessComponentReference(refComp->Content);
				}
				else
					member->BaseExpression->Accept(this);
				return member;
			}
			RefPtr<ExpressionSyntaxNode> VisitImportExpression(ImportExpressionSyntaxNode * import) override
			{
				auto refDef = MakeComponentAvailableAtWorld(import->ComponentUniqueName, import->ImportOperatorDef->SourceWorld.Content);
				if (refDef)
					import->ComponentUniqueName = refDef->UniqueName;
				return import;
			}
		};
		void InsertImplicitImportOperators(ShaderIR * shader)
		{
			InsertImplicitImportOperatorVisitor visitor(shader, nullptr);
			for (auto & comp : shader->Definitions)
			{
				visitor.currentCompDef = comp.Ptr();
				comp->SyntaxNode->Accept(&visitor);
			}
			for (auto & comp : visitor.passThroughComponents)
			{
				shader->Definitions.Add(comp.Value);
				EnumerableDictionary<String, ComponentDefinitionIR*> defs;
				defs[comp.Value->World] = comp.Value.Ptr();
				shader->DefinitionsByComponent[comp.Key] = defs;
			}
		}
	}
}

/***********************************************************************
CORE\KEYHOLEMATCHING.CPP
***********************************************************************/

namespace Spire
{
	namespace Compiler
	{
		RefPtr<KeyHoleNode> ParseInternal(CoreLib::Text::Parser & parser)
		{
			RefPtr<KeyHoleNode> result = new KeyHoleNode();
			result->NodeType = parser.ReadWord();
			if (parser.LookAhead(L"<"))
			{
				parser.ReadToken();
				result->CaptureId = parser.ReadInt();
				parser.ReadToken();
			}
			if (parser.LookAhead(L"("))
			{
				while (!parser.LookAhead(L")"))
				{
					result->Children.Add(ParseInternal(parser));
					if (parser.LookAhead(L","))
						parser.ReadToken();
					else
					{
						break;
					}
				}
				parser.Read(L")");
			}
			return result;
		}

		RefPtr<KeyHoleNode> KeyHoleNode::Parse(String format)
		{
			CoreLib::Text::Parser parser(format);
			return ParseInternal(parser);
		}

		bool KeyHoleNode::Match(List<ILOperand*> & matchResult, ILOperand * instr)
		{
			bool matches = false;
			if (NodeType == L"store")
				matches = dynamic_cast<StoreInstruction*>(instr) != nullptr;
			else if (NodeType == L"op")
				matches = true;
			else if (NodeType == L"load")
				matches = dynamic_cast<LoadInstruction*>(instr) != nullptr;
			else if (NodeType == L"add")
				matches = dynamic_cast<AddInstruction*>(instr) != nullptr;
			else if (NodeType == L"mul")
				matches = dynamic_cast<MulInstruction*>(instr) != nullptr;
			else if (NodeType == L"sub")
				matches = dynamic_cast<SubInstruction*>(instr) != nullptr;
			else if (NodeType == L"call")
				matches = dynamic_cast<CallInstruction*>(instr) != nullptr;
			else if (NodeType == L"switch")
				matches = dynamic_cast<SwitchInstruction*>(instr) != nullptr;
			if (matches)
			{
				if (Children.Count() > 0)
				{
					ILInstruction * cinstr = dynamic_cast<ILInstruction*>(instr);
					if (cinstr != nullptr)
					{
						int opId = 0;
						for (auto & op : *cinstr)
						{
							if (opId >= Children.Count())
							{
								matches = false;
								break;
							}
							matches = matches && Children[opId]->Match(matchResult, &op);
							opId++;
						}
						if (opId != Children.Count())
							matches = false;
					}
					else
						matches = false;
				}
			}
			if (matches && CaptureId != -1)
			{
				matchResult.SetSize(Math::Max(matchResult.Count(), CaptureId + 1));
				matchResult[CaptureId] = instr;
			}
			return matches;
		}
	}
}

/***********************************************************************
CORE\LEXER.CPP
***********************************************************************/

namespace Spire
{
	namespace Compiler
	{
		enum class State
		{
			Start, Identifier, Operator, Int, Fixed, Double, Char, String, MultiComment, SingleComment
		};

		bool IsLetter(wchar_t ch)
		{
			return ((ch >= L'a' && ch <= L'z') ||
				(ch >= L'A' && ch <= L'Z') || ch == L'_' || ch == L'#');
		}

		bool IsDigit(wchar_t ch)
		{
			return ch >= L'0' && ch <= L'9';
		}

		bool IsPunctuation(wchar_t ch)
		{
			return  ch == L'+' || ch == L'-' || ch == L'*' || ch == L'/' || ch == L'%' ||
					ch == L'!' || ch == L'^' || ch == L'&' || ch == L'(' || ch == L')' ||
					ch == L'=' || ch == L'{' || ch == L'}' || ch == L'[' || ch == L']' ||
					ch == L'|' || ch == L';' || ch == L',' || ch == L'.' || ch == L'<' ||
					ch == L'>' || ch == L'~' || ch == L'@' || ch == L':' || ch == L'?';
		}

		TokenType GetKeywordTokenType(const String & str)
		{
			if (str == L"return")
				return TokenType::KeywordReturn;
			else if (str == L"break")
				return TokenType::KeywordBreak;
			else if (str == L"continue")
				return TokenType::KeywordContinue;
			else if (str == L"if")
				return TokenType::KeywordIf;
			else if (str == L"else")
				return TokenType::KeywordElse;
			else if (str == L"for")
				return TokenType::KeywordFor;
			else if (str == L"while")
				return TokenType::KeywordWhile;
			else if (str == L"do")
				return TokenType::KeywordDo;
			else
				return TokenType::Identifier;
		}

		void ParseOperators(const String & str, List<Token> & tokens, int line, int col, String fileName)
		{
			int pos = 0;
			while (pos < str.Length())
			{
				wchar_t curChar = str[pos];
				wchar_t nextChar = (pos < str.Length()-1)? str[pos + 1] : L'\0';
				wchar_t nextNextChar = (pos < str.Length() - 2) ? str[pos + 2] : L'\0';
				auto InsertToken = [&](TokenType type, const String & ct)
				{
					tokens.Add(Token(type, ct, line, col + pos, fileName));
				};
				switch(curChar)
				{
				case L'+':
					if (nextChar == L'+')
					{
						InsertToken(TokenType::OpInc, L"++");
						pos += 2;
					}
					else if (nextChar == L'=')
					{
						InsertToken(TokenType::OpAddAssign, L"+=");
						pos += 2;
					}
					else
					{
						InsertToken(TokenType::OpAdd, L"+");
						pos++;
					}
					break;
				case L'-':
					if (nextChar == L'-')
					{
						InsertToken(TokenType::OpDec, L"--");
						pos += 2;
					}
					else if (nextChar == L'=')
					{
						InsertToken(TokenType::OpSubAssign, L"-=");
						pos += 2;
					}
					else if (nextChar == L'>')
					{
						InsertToken(TokenType::RightArrow, L"->");
						pos += 2;
					}
					else
					{
						InsertToken(TokenType::OpSub, L"-");
						pos++;
					}
					break;
				case L'*':
					if (nextChar == L'=')
					{
						InsertToken(TokenType::OpMulAssign, L"*=");
						pos += 2;
					}
					else
					{
						InsertToken(TokenType::OpMul, L"*");
						pos++;
					}
					break;
				case L'/':
					if (nextChar == L'=')
					{
						InsertToken(TokenType::OpDivAssign, L"/=");
						pos += 2;
					}
					else
					{
						InsertToken(TokenType::OpDiv, L"/");
						pos++;
					}
					break;
				case L'%':
					if (nextChar == L'=')
					{
						InsertToken(TokenType::OpModAssign, L"%=");
						pos += 2;
					}
					else
					{
						InsertToken(TokenType::OpMod, L"%");
						pos++;
					}
					break;
				case L'|':
					if (nextChar == L'|')
					{
						InsertToken(TokenType::OpOr, L"||");
						pos += 2;
					}
					else if (nextChar == L'=')
					{
						InsertToken(TokenType::OpOrAssign, L"|=");
						pos += 2;
					}
					else
					{
						InsertToken(TokenType::OpBitOr, L"|");
						pos++;
					}
					break;
				case L'&':
					if (nextChar == L'&')
					{
						InsertToken(TokenType::OpAnd, L"&&");
						pos += 2;
					}
					else if (nextChar == L'=')
					{
						InsertToken(TokenType::OpAndAssign, L"&=");
						pos += 2;
					}
					else
					{
						InsertToken(TokenType::OpBitAnd, L"&");
						pos++;
					}
					break;
				case L'^':
					if (nextChar == L'=')
					{
						InsertToken(TokenType::OpXorAssign, L"^=");
						pos += 2;
					}
					else
					{
						InsertToken(TokenType::OpBitXor, L"^");
						pos++;
					}
					break;
				case L'>':
					if (nextChar == L'>')
					{
						if (nextNextChar == L'=')
						{
							InsertToken(TokenType::OpShrAssign, L">>=");
							pos += 3;
						}
						else
						{
							InsertToken(TokenType::OpRsh, L">>");
							pos += 2;
						}
					}
					else if (nextChar == L'=')
					{
						InsertToken(TokenType::OpGeq, L">=");
						pos += 2;
					}
					else
					{
						InsertToken(TokenType::OpGreater, L">");
						pos++;
					}
					break;
				case L'<':
					if (nextChar == L'<')
					{
						if (nextNextChar == L'=')
						{
							InsertToken(TokenType::OpShlAssign, L"<<=");
							pos += 3;
						}
						else
						{
							InsertToken(TokenType::OpLsh, L"<<");
							pos += 2;
						}
					}
					else if (nextChar == L'=')
					{
						InsertToken(TokenType::OpLeq, L"<=");
						pos += 2;
					}
					else
					{
						InsertToken(TokenType::OpLess, L"<");
						pos++;
					}
					break;
				case L'=':
					if (nextChar == L'=')
					{
						InsertToken(TokenType::OpEql, L"==");
						pos += 2;
					}
					else
					{
						InsertToken(TokenType::OpAssign, L"=");
						pos++;
					}
					break;
				case L'!':
					if (nextChar == L'=')
					{
						InsertToken(TokenType::OpNeq, L"!=");
						pos += 2;
					}
					else
					{
						InsertToken(TokenType::OpNot, L"!");
						pos++;
					}
					break;
				case L'?':
					InsertToken(TokenType::QuestionMark, L"?");
					pos++;
					break;
				case L'@':
					InsertToken(TokenType::At, L"@");
					pos++;
					break;
				case L':':
					InsertToken(TokenType::Colon, L":");
					pos++;
					break;
				case L'~':
					InsertToken(TokenType::OpBitNot, L"~");
					pos++;
					break;
				case L';':
					InsertToken(TokenType::Semicolon, L";");
					pos++;
					break;
				case L',':
					InsertToken(TokenType::Comma, L","); 
					pos++;
					break;
				case L'.':
					InsertToken(TokenType::Dot, L".");
					pos++;
					break;
				case L'{':
					InsertToken(TokenType::LBrace, L"{"); 
					pos++;
					break;
				case L'}':
					InsertToken(TokenType::RBrace, L"}"); 
					pos++;
					break;
				case L'[':
					InsertToken(TokenType::LBracket, L"["); 
					pos++;
					break;
				case L']':
					InsertToken(TokenType::RBracket, L"]"); 
					pos++;
					break;
				case L'(':
					InsertToken(TokenType::LParent, L"("); 
					pos++;
					break;
				case L')':
					InsertToken(TokenType::RParent, L")"); 
					pos++;
					break;
				}
			}
		}

		List<Token> Lexer::Parse(const String & fileName, const String & str, List<CompileError> & errorList)
		{
			int lastPos = 0, pos = 0;
			int line = 1, col = 0;
			State state = State::Start;
			StringBuilder tokenBuilder;
			int tokenLine, tokenCol;
			List<Token> tokenList;
			auto InsertToken = [&](TokenType type)
			{
				tokenList.Add(Token(type, tokenBuilder.ToString(), tokenLine, tokenCol, fileName));
				tokenBuilder.Clear();
			};
			auto ProcessTransferChar = [&](wchar_t nextChar)
			{
				switch(nextChar)
				{
				case L'\\':
				case L'\"':
				case L'\'':
					tokenBuilder.Append(nextChar);
					break;
				case L't':
					tokenBuilder.Append('\t');
					break;
				case L's':
					tokenBuilder.Append(' ');
					break;
				case L'n':
					tokenBuilder.Append('\n');
					break;
				case L'r':
					tokenBuilder.Append('\r');
					break;
				case L'b':
					tokenBuilder.Append('\b');
					break;
				}
			};
			while (pos <= str.Length())
			{
				wchar_t curChar = (pos < str.Length()?str[pos]:L' ');
				wchar_t nextChar = (pos < str.Length()-1)? str[pos + 1] : L'\0';
				if (lastPos != pos)
				{
					if (curChar == L'\n')
					{
						line++;
						col = 0;
					}
					else
						col++;
					lastPos = pos;
				}

				switch (state)
				{
				case State::Start:
					if (IsLetter(curChar))
					{
						state = State::Identifier;
						tokenLine = line;
						tokenCol = col;
					}
					else if (IsDigit(curChar))
					{
						state = State::Int;
						tokenLine = line;
						tokenCol = col;
					}
					else if (curChar == L'\'')
					{
						state = State::Char;
						pos++;
						tokenLine = line;
						tokenCol = col;
					}
					else if (curChar == L'"')
					{
						state = State::String;
						pos++;
						tokenLine = line;
						tokenCol = col;
					}
					else if (curChar == L' ' || curChar == L'\t' || curChar == L'\r' || curChar == L'\n' || curChar == 160) // 160:non-break space
						pos++;
					else if (curChar == L'/' && nextChar == L'/')
					{
						state = State::SingleComment;
						pos += 2;
					}
					else if (curChar == L'/' && nextChar == L'*')
					{
						pos += 2;
						state = State::MultiComment;
					}
					else if (IsPunctuation(curChar))
					{
						state = State::Operator;
						tokenLine = line;
						tokenCol = col;
					}
					else
					{
						errorList.Add(CompileError(L"Illegal character '" + String(curChar) + L"'", 10000, CodePosition(line, col, fileName)));
						pos++;
					}
					break;
				case State::Identifier:
					if (IsLetter(curChar) || IsDigit(curChar))
					{
						tokenBuilder.Append(curChar);
						pos++;
					}
					else
					{
						auto tokenStr = tokenBuilder.ToString();
						if (tokenStr == L"#line_reset#")
						{
							line = 0;
							col = 0;
							tokenBuilder.Clear();
						}
						else
							InsertToken(GetKeywordTokenType(tokenStr));
						state = State::Start;
					}
					break;
				case State::Operator:
					if (IsPunctuation(curChar) && !((curChar == L'/' && nextChar == L'/') || (curChar == L'/' && nextChar == L'*')))
					{
						tokenBuilder.Append(curChar);
						pos++;
					}
					else
					{
						//do token analyze
						ParseOperators(tokenBuilder.ToString(), tokenList, tokenLine, tokenCol, fileName);
						tokenBuilder.Clear();
						state = State::Start;
					}
					break;
				case State::Int:
					if (IsDigit(curChar))
					{
						tokenBuilder.Append(curChar);
						pos++;
					}
					else if (curChar == L'.')
					{
						state = State::Fixed;
						tokenBuilder.Append(curChar);
						pos++;
					}
					else if (curChar == L'e' || curChar == L'E')
					{
						state = State::Double;
						tokenBuilder.Append(curChar);
						if (nextChar == L'-' || nextChar == L'+')
						{
							tokenBuilder.Append(nextChar);
							pos++;
						}
						pos++;
					}
					else
					{
						InsertToken(TokenType::IntLiterial);
						state = State::Start;
					}
					break;
				case State::Fixed:
					if (IsDigit(curChar))
					{
						tokenBuilder.Append(curChar);
						pos++;
					}
					else if (curChar == L'e' || curChar == L'E')
					{
						state = State::Double;
						tokenBuilder.Append(curChar);
						if (nextChar == L'-' || nextChar == L'+')
						{
							tokenBuilder.Append(nextChar);
							pos++;
						}
						pos++;
					}
					else
					{
						if (curChar == L'f')
							pos++;
						InsertToken(TokenType::DoubleLiterial);
						state = State::Start;
					}
					break;
				case State::Double:
					if (IsDigit(curChar))
					{
						tokenBuilder.Append(curChar);
						pos++;
					}
					else
					{
						if (curChar == L'f')
							pos++;
						InsertToken(TokenType::DoubleLiterial);
						state = State::Start;
					}
					break;
				case State::String:
					if (curChar != L'"')
					{
						if (curChar == L'\\')
						{
							ProcessTransferChar(nextChar);
							pos++;
						}
						else
							tokenBuilder.Append(curChar);
					}
					else
					{
						InsertToken(TokenType::StringLiterial);
						state = State::Start;
					}
					pos++;
					break;
				case State::Char:
					if (curChar != L'\'')
					{
						if (curChar == L'\\')
						{
							ProcessTransferChar(nextChar);
							pos++;
						}
						else
							tokenBuilder.Append(curChar);
					}
					else
					{
						if (tokenBuilder.Length() > 1)
							errorList.Add(CompileError(L"Illegal character literial.", 10001, CodePosition(line, col-tokenBuilder.Length(), fileName)));
						InsertToken(TokenType::CharLiterial);
						state = State::Start;
					}
					pos++;
					break;
				case State::SingleComment:
					if (curChar == L'\n')
						state = State::Start;
					pos++;
					break;
				case State::MultiComment:
					if (curChar == L'*' && nextChar == '/')
					{
						state = State::Start;
						pos += 2;
					}
					else
						pos++;
					break;
				}
			}
			return tokenList;
		}

		String TokenTypeToString(TokenType type)
		{
			switch (type)
			{
			case TokenType::Unkown:
				return L"UnknownToken";
			case TokenType::Identifier:
				return L"Identifier";

			case TokenType::KeywordReturn:
				return L"\"return\"";
			case TokenType::KeywordBreak:
				return L"\"break\"";
			case TokenType::KeywordContinue:
				return L"\"continue\"";
			case TokenType::KeywordIf:
				return L"\"if\"";
			case TokenType::KeywordElse:
				return L"\"else\"";
			case TokenType::KeywordFor:
				return L"\"for\"";
			case TokenType::KeywordWhile:
				return L"\"while\"";
			case TokenType::KeywordDo:
				return L"\"do\"";
			case TokenType::IntLiterial:
				return L"Int Literial";
			case TokenType::DoubleLiterial:
				return L"Double Literial";
			case TokenType::StringLiterial:
				return L"String Literial";
			case TokenType::CharLiterial:
				return L"CharLiterial";
			case TokenType::QuestionMark:
				return L"'?'";
			case TokenType::Colon:
				return L"':'";
			case TokenType::Semicolon:
				return L"';'";
			case TokenType::Comma:
				return L"','";
			case TokenType::LBrace:
				return L"'{'";
			case TokenType::RBrace:
				return L"'}'";
			case TokenType::LBracket:
				return L"'['";
			case TokenType::RBracket:
				return L"']'";
			case TokenType::LParent:
				return L"'('";
			case TokenType::RParent:
				return L"')'";
			case TokenType::At:
				return L"'@'";
			case TokenType::OpAssign:
				return L"'='";
			case TokenType::OpAdd:
				return L"'+'";
			case TokenType::OpSub:
				return L"'-'";
			case TokenType::OpMul:
				return L"'*'";
			case TokenType::OpDiv:
				return L"'/'";
			case TokenType::OpMod:
				return L"'%'";
			case TokenType::OpNot:
				return L"'!'";
			case TokenType::OpLsh:
				return L"'<<'";
			case TokenType::OpRsh:
				return L"'>>'";
			case TokenType::OpAddAssign:
				return L"'+='";
			case TokenType::OpSubAssign:
				return L"'-='";
			case TokenType::OpMulAssign:
				return L"'*='";
			case TokenType::OpDivAssign:
				return L"'/='";
			case TokenType::OpModAssign:
				return L"'%='";
			case TokenType::OpEql:
				return L"'=='";
			case TokenType::OpNeq:
				return L"'!='";
			case TokenType::OpGreater:
				return L"'>'";
			case TokenType::OpLess:
				return L"'<'";
			case TokenType::OpGeq:
				return L"'>='";
			case TokenType::OpLeq:
				return L"'<='";
			case TokenType::OpAnd:
				return L"'&&'";
			case TokenType::OpOr:
				return L"'||'";
			case TokenType::OpBitXor:
				return L"'^'";
			case TokenType::OpBitAnd:
				return L"'&'";
			case TokenType::OpBitOr:
				return L"'|'";
			case TokenType::OpInc:
				return L"'++'";
			case TokenType::OpDec:
				return L"'--'";
			default:
				return L"";
			}
		}
		
	}
}

/***********************************************************************
CORE\PARSER.CPP
***********************************************************************/

namespace Spire
{
	namespace Compiler
	{
		Token & Parser::ReadToken(const wchar_t * string)
		{
			if (pos >= tokens.Count())
			{
				errors.Add(CompileError(String(L"\"") + string + String(L"\" expected but end of file encountered."), 20001, CodePosition(0, 0, fileName)));
				throw 0;
			}
			else if (tokens[pos].Content != string)
			{
				errors.Add(CompileError(String(L"\"") + string + String(L"\" expected"), 20001, tokens[pos].Position));
				throw 20001;
			}
			return tokens[pos++];
		}

		Token & Parser::ReadToken()
		{
			if (pos >= tokens.Count())
			{
				errors.Add(CompileError(String(L" Unexpected end of file."), 20001, CodePosition(0, 0, fileName)));
				throw 0;
			}
			return tokens[pos++];
		}

		Token & Parser::ReadToken(TokenType type)
		{
			if (pos >= tokens.Count())
			{
				errors.Add(CompileError(TokenTypeToString(type) + String(L" expected but end of file encountered."), 20001, CodePosition(0, 0, fileName)));
				throw 0;
			}
			else if(tokens[pos].Type != type)
			{
				errors.Add(CompileError(TokenTypeToString(type) + String(L" expected"), 20001, tokens[pos].Position));
				throw 20001;
			}
			return tokens[pos++];
		}

		bool Parser::LookAheadToken(const wchar_t * string, int offset)
		{
			if (pos + offset >= tokens.Count())
			{
				errors.Add(CompileError(String(L"\'") + string + String(L"\' expected but end of file encountered."), 20001, CodePosition(0, 0, fileName)));
				return false;
			}
			else
			{
				if (tokens[pos + offset].Content == string)
					return true;
				else
					return false;
			}
		}

		bool Parser::LookAheadToken(TokenType type, int offset)
		{
			if (pos + offset >= tokens.Count())
			{
				errors.Add(CompileError(TokenTypeToString(type) + String(L" expected but end of file encountered."), 20001, CodePosition(0, 0, fileName)));
				return false;
			}
			else
			{
				if(tokens[pos + offset].Type == type)
					return true;
				else
					return false;
			}
		}

		Token & Parser::ReadTypeKeyword()
		{
			if (pos >= tokens.Count())
			{
				errors.Add(CompileError(String(L"type name expected but end of file encountered."), 20001, CodePosition(0, 0, fileName)));
				throw 0;
			}
			if(!IsTypeKeyword())
			{
				errors.Add(CompileError(String(L"type name expected but '" + tokens[pos].Content + L"' encountered."), 20001, tokens[pos].Position));
				throw 20001;
			}
			return tokens[pos++];
		}

		bool Parser::IsTypeKeyword()
		{
			if (pos >= tokens.Count())
			{
				errors.Add(CompileError(String(L"Unexpected end of file."), 20001, tokens[pos].Position));
				throw 0;
			}

			return typeNames.Contains(tokens[pos].Content);
		}

		RefPtr<ProgramSyntaxNode> Parser::Parse()
		{
			return ParseProgram();
		}

		EnumerableDictionary<String, String> Parser::ParseAttribute()
		{
			EnumerableDictionary<String, String> rs;
			while (LookAheadToken(TokenType::LBracket))
			{
				ReadToken(TokenType::LBracket);
				auto name = ReadToken(TokenType::Identifier).Content;
				String value;
				if (LookAheadToken(L":"))
				{
					ReadToken(L":");
					value = ReadToken(TokenType::StringLiterial).Content;
				}
				rs[name] = value;
				ReadToken(TokenType::RBracket);
			}
			return rs;
		}

		RefPtr<ProgramSyntaxNode> Parser::ParseProgram()
		{
			scopeStack.Add(new Scope());
			RefPtr<ProgramSyntaxNode> program = new ProgramSyntaxNode();
			program->Position = CodePosition(0, 0, fileName);
			program->Scope = scopeStack.Last();
			try
			{
				int lastPosBeforeError = 0;
				while (pos < tokens.Count())
				{
					try
					{
						if (LookAheadToken(L"shader") || LookAheadToken(L"module"))
							program->Shaders.Add(ParseShader());
						else if (LookAheadToken(L"pipeline"))
							program->Pipelines.Add(ParsePipeline());
						else if (LookAheadToken(L"struct"))
							program->Structs.Add(ParseStruct());
						else if (LookAheadToken(L"using"))
						{
							ReadToken(L"using");
							program->Usings.Add(ReadToken(TokenType::StringLiterial));
							ReadToken(TokenType::Semicolon);
						}
						else if (IsTypeKeyword() || LookAheadToken(L"inline") || LookAheadToken(L"extern")
							|| LookAheadToken(L"__intrinsic") || LookAheadToken(TokenType::Identifier))
							program->Functions.Add(ParseFunction());
						else if (LookAheadToken(TokenType::Semicolon))
							ReadToken(TokenType::Semicolon);
						else
						{
							if (lastPosBeforeError == 0 && pos < tokens.Count())
								errors.Add(CompileError(L"unexpected token \'" + tokens[pos].Content + L"\'.", 20003, tokens[pos].Position));
							throw 0;
						}
					}
					catch (int)
					{
						if (pos == lastPosBeforeError)
							pos++;
						lastPosBeforeError = pos;
					}
				}
			}
			catch(int)
			{}
			scopeStack.Clear();
			return program;
		}

		RefPtr<ShaderSyntaxNode> Parser::ParseShader()
		{
			RefPtr<ShaderSyntaxNode> shader = new ShaderSyntaxNode();
			if (LookAheadToken(L"module"))
			{
				shader->IsModule = true;
				ReadToken(L"module");
			}
			else
				ReadToken(L"shader");
			PushScope();
			FillPosition(shader.Ptr());
			shader->Name = ReadToken(TokenType::Identifier);
			try
			{
				if (LookAheadToken(L":"))
				{
					ReadToken(L":");
					shader->Pipeline = ReadToken(TokenType::Identifier);
				}
			}
			catch (int)
			{
			}
			
			ReadToken(TokenType::LBrace);
			int lastErrorPos = 0;
			while (!LookAheadToken(TokenType::RBrace))
			{
				try
				{
					if (LookAheadToken(L"inline") || (LookAheadToken(L"public") && !LookAheadToken(L"using", 1)) ||
						LookAheadToken(L"out") || LookAheadToken(L"@") || IsTypeKeyword()
						|| LookAheadToken(L"[") || LookAheadToken(L"require") || LookAheadToken(L"extern"))
						shader->Members.Add(ParseComponent());
					else if (LookAheadToken(L"using") || (LookAheadToken(L"public") && LookAheadToken(L"using", 1)))
					{
						shader->Members.Add(ParseImport());
					}
					else
					{
						if (lastErrorPos == 0 && pos < tokens.Count())
							errors.Add(CompileError(L"unexpected token \'" + tokens[pos].Content + L"\', only component definitions are allowed in a shader scope.", 
								20004, tokens[pos].Position));
						throw 0;
					}
				}
				catch (int)
				{
					if (pos == lastErrorPos)
						pos++;
					lastErrorPos = pos;
				}
			}
			ReadToken(TokenType::RBrace);
			
			PopScope();
			return shader;
		}

		RefPtr<PipelineSyntaxNode> Parser::ParsePipeline()
		{
			RefPtr<PipelineSyntaxNode> pipeline = new PipelineSyntaxNode();
			ReadToken(L"pipeline");
			PushScope();
			FillPosition(pipeline.Ptr());
			pipeline->Name = ReadToken(TokenType::Identifier);
			ReadToken(TokenType::LBrace);
			while (!LookAheadToken(TokenType::RBrace))
			{
				auto attribs = ParseAttribute();
				if (LookAheadToken(L"input") || LookAheadToken(L"world"))
				{
					auto w = ParseWorld();
					w->LayoutAttributes = attribs;
					pipeline->Worlds.Add(w);
				}
				else if (LookAheadToken(L"import"))
				{
					auto op = ParseImportOperator();
					op->LayoutAttributes = attribs;
					pipeline->ImportOperators.Add(op);
				}
				else if (LookAheadToken(L"stage"))
				{
					pipeline->Stages.Add(ParseStage());
				}
				else
				{
					auto comp = ParseComponent();
					comp->LayoutAttributes = attribs;
					pipeline->AbstractComponents.Add(comp);
				}
			}
			ReadToken(TokenType::RBrace);
			PopScope();
			return pipeline;
		}

		RefPtr<StageSyntaxNode> Parser::ParseStage()
		{
			RefPtr<StageSyntaxNode> stage = new StageSyntaxNode();
			ReadToken(L"stage");
			stage->Name = ReadToken(TokenType::Identifier);
			ReadToken(TokenType::Colon);
			stage->StageType = ReadToken(TokenType::Identifier);
			ReadToken(TokenType::LBrace);
			while (!LookAheadToken(TokenType::RBrace))
			{
				auto attribName = ReadToken(TokenType::Identifier);
				ReadToken(TokenType::Colon);
				Token attribValue;
				if (LookAheadToken(TokenType::StringLiterial) || LookAheadToken(TokenType::DoubleLiterial) || LookAheadToken(TokenType::IntLiterial))
					attribValue = ReadToken();
				else
					attribValue = ReadToken(TokenType::Identifier);
				stage->Attributes[attribName.Content] = attribValue;
				ReadToken(TokenType::Semicolon);
			}
			ReadToken(TokenType::RBrace);
			return stage;
		}

		RefPtr<ComponentSyntaxNode> Parser::ParseComponent()
		{
			RefPtr<ComponentSyntaxNode> component = new ComponentSyntaxNode();
			component->LayoutAttributes = ParseAttribute();
			while (LookAheadToken(L"inline") || LookAheadToken(L"out") || LookAheadToken(L"require") || LookAheadToken(L"public") ||
				LookAheadToken(L"extern"))
			{
				if (LookAheadToken(L"inline"))
				{
					component->IsInline = true;
					ReadToken(L"inline");
				}
				else if (LookAheadToken(L"out"))
				{
					component->IsOutput = true;
					ReadToken(L"out");
				}
				else if (LookAheadToken(L"public"))
				{
					component->IsPublic = true;
					ReadToken(L"public");
				}
				else if (LookAheadToken(L"require"))
				{
					component->IsParam = true;
					ReadToken(L"require");
				}
				else if (LookAheadToken(L"extern"))
				{
					component->IsInput = true;
					ReadToken(L"extern");
				}
				else
					break;
			}
			if (LookAheadToken(L"@"))
				component->Rate = ParseRate();
			component->TypeNode = ParseType();
			FillPosition(component.Ptr());
			component->Name = ReadToken(TokenType::Identifier);
			if (LookAheadToken(L":"))
			{
				ReadToken(L":");
				component->AlternateName = ReadToken(TokenType::Identifier);
			}
			if (!component->IsParam && LookAheadToken(TokenType::OpAssign))
			{
				ReadToken(TokenType::OpAssign);
				component->Expression = ParseExpression();
				ReadToken(TokenType::Semicolon);
			}
			else if (!component->IsParam && LookAheadToken(TokenType::LBrace))
			{
				component->BlockStatement = ParseBlockStatement();
			}
			else
				ReadToken(TokenType::Semicolon);
			return component;
		}

		RefPtr<WorldSyntaxNode> Parser::ParseWorld()
		{
			RefPtr<WorldSyntaxNode> world = new WorldSyntaxNode();
			world->LayoutAttributes = ParseAttribute();
			world->IsAbstract = LookAheadToken(L"input");
			if (world->IsAbstract)
				ReadToken(L"input");
			ReadToken(L"world");
			FillPosition(world.Ptr());
			world->Name = ReadToken(TokenType::Identifier);
			ReadToken(TokenType::Semicolon);
			return world;
		}

		RefPtr<RateSyntaxNode> Parser::ParseRate()
		{
			RefPtr<RateSyntaxNode> rate = new RateSyntaxNode();
			FillPosition(rate.Ptr());
			ReadToken(TokenType::At);
			auto readWorldRate = [this]()
			{
				RateWorld rw;
				rw.World = ReadToken(TokenType::Identifier);
				if (LookAheadToken(TokenType::OpMul))
				{
					ReadToken(TokenType::OpMul);
					rw.Pinned = true;
				}
				return rw;
			};
			if (LookAheadToken(TokenType::LParent))
			{
				ReadToken(TokenType::LParent);
				while (!LookAheadToken(TokenType::RParent))
				{
					RateWorld rw = readWorldRate();
					rate->Worlds.Add(rw);
					if (LookAheadToken(TokenType::Comma))
					{
						ReadToken(TokenType::Comma);
					}
					else
						break;
				}
				ReadToken(TokenType::RParent);
			}
			else
				rate->Worlds.Add(readWorldRate());
			return rate;
		}

		RefPtr<ImportSyntaxNode> Parser::ParseImport()
		{
			RefPtr<ImportSyntaxNode> rs = new ImportSyntaxNode();
			if (LookAheadToken(L"public"))
			{
				rs->IsPublic = true;
				ReadToken(L"public");
			}
			ReadToken(L"using");
			rs->IsInplace = !LookAheadToken(TokenType::OpAssign, 1);
			if (!rs->IsInplace)
			{
				rs->ObjectName = ReadToken(TokenType::Identifier);
				ReadToken(TokenType::OpAssign);
			}
			FillPosition(rs.Ptr());
			rs->ShaderName = ReadToken(TokenType::Identifier);
			if (LookAheadToken(TokenType::Semicolon))
				ReadToken(TokenType::Semicolon);
			else
			{
				ReadToken(TokenType::LParent);
				while (!LookAheadToken(TokenType::RParent))
				{
					RefPtr<ImportArgumentSyntaxNode> arg = new ImportArgumentSyntaxNode();
					FillPosition(arg.Ptr());
					auto expr = ParseExpression();
					if (LookAheadToken(L":"))
					{
						if (auto varExpr = dynamic_cast<VarExpressionSyntaxNode*>(expr.Ptr()))
						{
							arg->ArgumentName.Content = varExpr->Variable;
							arg->ArgumentName.Position = varExpr->Position;
						}
						else
							errors.Add(CompileError(L"unexpected ':'.", 20011, pos < tokens.Count() ? tokens[pos].Position : CodePosition(0, 0, fileName)));
						ReadToken(L":");
						arg->Expression = ParseExpression();
					}
					else
						arg->Expression = expr;
					rs->Arguments.Add(arg);
					if (LookAheadToken(TokenType::Comma))
						ReadToken(TokenType::Comma);
					else
						break;
				}
				ReadToken(TokenType::RParent);
				ReadToken(TokenType::Semicolon);
			}
			return rs;
		}

		RefPtr<ImportStatementSyntaxNode> Parser::ParseImportStatement()
		{
			RefPtr<ImportStatementSyntaxNode> rs = new ImportStatementSyntaxNode();
			FillPosition(rs.Ptr());
			rs->Import = ParseImport();
			return rs;
		}

		RefPtr<ImportOperatorDefSyntaxNode> Parser::ParseImportOperator()
		{
			RefPtr<ImportOperatorDefSyntaxNode> op = new ImportOperatorDefSyntaxNode();
			PushScope();
			FillPosition(op.Ptr());
			ReadToken(L"import");
			ReadToken(TokenType::LParent);
			op->SourceWorld = ReadToken(TokenType::Identifier);
			ReadToken(TokenType::RightArrow);
			op->DestWorld = ReadToken(TokenType::Identifier);
			ReadToken(TokenType::RParent);
			FillPosition(op.Ptr());
			op->Name = ReadToken(TokenType::Identifier);
			ReadToken(TokenType::LParent);
			while (!LookAheadToken(TokenType::RParent))
			{
				op->Parameters.Add(ParseParameter());
				if (LookAheadToken(TokenType::Comma))
					ReadToken(TokenType::Comma);
				else
					break;
			}
			ReadToken(TokenType::RParent);
			op->Body = ParseBlockStatement();
			PopScope();
			return op;
		}

		RefPtr<FunctionSyntaxNode> Parser::ParseFunction()
		{
			RefPtr<FunctionSyntaxNode> function = new FunctionSyntaxNode();
			if (LookAheadToken(L"__intrinsic"))
			{
				function->HasSideEffect = false;
				function->IsExtern = true;
				pos++;
			}
			else if (LookAheadToken(L"extern"))
			{
				function->IsExtern = true;
				pos++;
			}
			else
				function->IsExtern = false;
			function->IsInline = true;
			if (LookAheadToken(L"inline"))
			{
				function->IsInline = true;
				pos++;
			}
			
			PushScope();
			function->ReturnTypeNode = ParseType();
			try
			{
				FillPosition(function.Ptr());
				Token name = ReadToken();
				function->Name = name.Content;
				ReadToken(TokenType::LParent);
				while(pos < tokens.Count() && tokens[pos].Type != TokenType::RParent)
				{
					function->Parameters.Add(ParseParameter());
					if (LookAheadToken(TokenType::Comma))
						ReadToken(TokenType::Comma);
					else
						break;
				}
				ReadToken(TokenType::RParent);
			}
			catch(int e)
			{
				if (e == 0)
					return function;
				while (pos < tokens.Count() && tokens[pos].Type != TokenType::LBrace)
				{
					pos++;
				}
			}
			if (!function->IsExtern)
				function->Body = ParseBlockStatement();
			else
				ReadToken(TokenType::Semicolon);
			PopScope();
			return function;
		}

		RefPtr<StructSyntaxNode> Parser::ParseStruct()
		{
			RefPtr<StructSyntaxNode> rs = new StructSyntaxNode();
			FillPosition(rs.Ptr());
			ReadToken(L"struct");
			rs->Name = ReadToken(TokenType::Identifier);
			ReadToken(L"{");
			while (!LookAheadToken(L"}") && pos < tokens.Count())
			{
				RefPtr<TypeSyntaxNode> type = ParseType();
				do
				{
					RefPtr<StructField> field = new StructField();
					FillPosition(field.Ptr());
					field->TypeNode = type;
					field->Name = ReadToken(TokenType::Identifier);
					rs->Fields.Add(field);
					if (!LookAheadToken(TokenType::Comma))
						break;
					ReadToken(TokenType::Comma);
				} while (pos < tokens.Count());
				ReadToken(TokenType::Semicolon);
			}
			ReadToken(L"}");
			return rs;
		}

		RefPtr<StatementSyntaxNode> Parser::ParseStatement()
		{
			RefPtr<StatementSyntaxNode> statement;
			if (LookAheadToken(TokenType::LBrace))
				statement = ParseBlockStatement();
			else if (IsTypeKeyword() || LookAheadToken(L"const"))
				statement = ParseVarDeclrStatement();
			else if (LookAheadToken(TokenType::KeywordIf))
				statement = ParseIfStatement();
			else if (LookAheadToken(TokenType::KeywordFor))
				statement = ParseForStatement();
			else if (LookAheadToken(TokenType::KeywordWhile))
				statement = ParseWhileStatement();
			else if (LookAheadToken(TokenType::KeywordDo))
				statement = ParseDoWhileStatement();
			else if (LookAheadToken(TokenType::KeywordBreak))
				statement = ParseBreakStatement();
			else if (LookAheadToken(TokenType::KeywordContinue))
				statement = ParseContinueStatement();
			else if (LookAheadToken(TokenType::KeywordReturn))
				statement = ParseReturnStatement();
			else if (LookAheadToken(L"using") || (LookAheadToken(L"public") && LookAheadToken(L"using", 1)))
				statement = ParseImportStatement();
			else if (LookAheadToken(L"discard"))
			{
				statement = new DiscardStatementSyntaxNode();
				FillPosition(statement.Ptr());
				ReadToken(L"discard");
				ReadToken(TokenType::Semicolon);
			}
			else if (LookAheadToken(TokenType::Identifier))
			{
				int startPos = pos;
				bool isVarDeclr = false;
				try
				{
					RefPtr<TypeSyntaxNode> type = ParseType();
					if (LookAheadToken(TokenType::Identifier))
					{
						type = nullptr;
						pos = startPos;
						statement = ParseVarDeclrStatement();
						isVarDeclr = true;
					}
				}
				catch (...)
				{
				}
				if (!isVarDeclr)
				{
					pos = startPos;
					statement = ParseExpressionStatement();
				}
			}
			else if (LookAheadToken(TokenType::Semicolon))
			{
				statement = new EmptyStatementSyntaxNode();
				FillPosition(statement.Ptr());
				ReadToken(TokenType::Semicolon);
			}
			else
			{
				errors.Add(CompileError(String(L"syntax error."), 20002, tokens[pos].Position));
				throw 20002;
			}
			return statement;
		}

		RefPtr<BlockStatementSyntaxNode> Parser::ParseBlockStatement()
		{
			RefPtr<BlockStatementSyntaxNode> blockStatement = new BlockStatementSyntaxNode();
			PushScope();
			ReadToken(TokenType::LBrace);
			if(pos < tokens.Count())
			{
				FillPosition(blockStatement.Ptr());
			}
			int lastErrorPos = 0;
			while (pos < tokens.Count() && !LookAheadToken(TokenType::RBrace))
			{
				try
				{
					blockStatement->Statements.Add(ParseStatement());
				}
				catch (int)
				{
					if (pos == lastErrorPos)
						pos++;
					lastErrorPos = pos;
				}
			}
			ReadToken(TokenType::RBrace);
			PopScope();
			return blockStatement;
		}

		VariableModifier Parser::ReadVariableModifier()
		{
			auto & token = ReadToken(TokenType::Identifier);
			if (token.Content == L"in")
				return VariableModifier::In;
			else if (token.Content == L"out")
				return VariableModifier::Out;
			else if (token.Content == L"uniform")
				return VariableModifier::Uniform;
			else if (token.Content == L"parameter")
				return VariableModifier::Parameter;
			else if (token.Content == L"const")
				return VariableModifier::Const;
			else if (token.Content == L"centroid")
				return VariableModifier::Centroid;
			else if (token.Content == L"instance")
				return VariableModifier::Instance;
			else if (token.Content == L"__builtin")
				return VariableModifier::Builtin;
			return VariableModifier::None; 
		}

		RefPtr<VarDeclrStatementSyntaxNode> Parser::ParseVarDeclrStatement()
		{
			RefPtr<VarDeclrStatementSyntaxNode>varDeclrStatement = new VarDeclrStatementSyntaxNode();
		
			if (pos < tokens.Count())
				FillPosition(varDeclrStatement.Ptr());
			while (pos < tokens.Count())
			{
				if (LookAheadToken(L"layout"))
				{
					ReadToken(L"layout");
					ReadToken(TokenType::LParent);
					StringBuilder layoutSB;
					while (!LookAheadToken(TokenType::RParent))
					{
						layoutSB.Append(ReadToken(TokenType::Identifier).Content);
						if (LookAheadToken(TokenType::OpAssign))
						{
							layoutSB.Append(ReadToken(TokenType::OpAssign).Content);
							layoutSB.Append(ReadToken(TokenType::IntLiterial).Content);
						}
						if (!LookAheadToken(TokenType::Comma))
							break;
						else
							layoutSB.Append(L", ");
					}
					ReadToken(TokenType::RParent);
					varDeclrStatement->LayoutString = layoutSB.ProduceString();
				}
				else
					break;
			}
			varDeclrStatement->TypeNode = ParseType();
			while (pos < tokens.Count())
			{
				RefPtr<Variable> var = new Variable();
				FillPosition(var.Ptr());
				Token & name = ReadToken(TokenType::Identifier);
				var->Name = name.Content;
				if (LookAheadToken(TokenType::OpAssign))
				{
					ReadToken(TokenType::OpAssign);
					var->Expression = ParseExpression();
				}

				varDeclrStatement->Variables.Add(var);
				if (LookAheadToken(TokenType::Comma))
					ReadToken(TokenType::Comma);
				else
					break;
			}
			ReadToken(TokenType::Semicolon);
			
			return varDeclrStatement;
		}

		RefPtr<IfStatementSyntaxNode> Parser::ParseIfStatement()
		{
			RefPtr<IfStatementSyntaxNode> ifStatement = new IfStatementSyntaxNode();
			FillPosition(ifStatement.Ptr());
			ReadToken(TokenType::KeywordIf);
			ReadToken(TokenType::LParent);
			ifStatement->Predicate = ParseExpression();
			ReadToken(TokenType::RParent);
			ifStatement->PositiveStatement = ParseStatement();
			if (LookAheadToken(TokenType::KeywordElse))
			{
				ReadToken(TokenType::KeywordElse);
				ifStatement->NegativeStatement = ParseStatement();
			}
			return ifStatement;
		}

		RefPtr<ForStatementSyntaxNode> Parser::ParseForStatement()
		{
			RefPtr<ForStatementSyntaxNode> stmt = new ForStatementSyntaxNode();
			PushScope();
			FillPosition(stmt.Ptr());
			ReadToken(TokenType::KeywordFor);
			ReadToken(TokenType::LParent);
			if (IsTypeKeyword())
				stmt->TypeDef = ParseType();
			stmt->IterationVariable = ReadToken(TokenType::Identifier);
			ReadToken(TokenType::OpAssign);
			stmt->InitialExpression = ParseExpression();
			ReadToken(TokenType::Colon);
			stmt->EndExpression = ParseExpression();
			if (LookAheadToken(TokenType::Colon))
			{
				stmt->StepExpression = stmt->EndExpression;
				ReadToken(TokenType::Colon);
				stmt->EndExpression = ParseExpression();
			}
			ReadToken(TokenType::RParent);
			stmt->Statement = ParseStatement();
			PopScope();
			return stmt;
		}

		RefPtr<WhileStatementSyntaxNode> Parser::ParseWhileStatement()
		{
			RefPtr<WhileStatementSyntaxNode> whileStatement = new WhileStatementSyntaxNode();
			PushScope();
			FillPosition(whileStatement.Ptr());
			ReadToken(TokenType::KeywordWhile);
			ReadToken(TokenType::LParent);
			whileStatement->Predicate = ParseExpression();
			ReadToken(TokenType::RParent);
			whileStatement->Statement = ParseStatement();
			PopScope();
			return whileStatement;
		}

		RefPtr<DoWhileStatementSyntaxNode> Parser::ParseDoWhileStatement()
		{
			RefPtr<DoWhileStatementSyntaxNode> doWhileStatement = new DoWhileStatementSyntaxNode();
			PushScope();
			FillPosition(doWhileStatement.Ptr());
			ReadToken(TokenType::KeywordDo);
			doWhileStatement->Statement = ParseStatement();
			ReadToken(TokenType::KeywordWhile);
			ReadToken(TokenType::LParent);
			doWhileStatement->Predicate = ParseExpression();
			ReadToken(TokenType::RParent);
			ReadToken(TokenType::Semicolon);
			PopScope();
			return doWhileStatement;
		}

		RefPtr<BreakStatementSyntaxNode> Parser::ParseBreakStatement()
		{
			RefPtr<BreakStatementSyntaxNode> breakStatement = new BreakStatementSyntaxNode();
			FillPosition(breakStatement.Ptr());
			ReadToken(TokenType::KeywordBreak);
			ReadToken(TokenType::Semicolon);
			return breakStatement;
		}

		RefPtr<ContinueStatementSyntaxNode>	Parser::ParseContinueStatement()
		{
			RefPtr<ContinueStatementSyntaxNode> continueStatement = new ContinueStatementSyntaxNode();
			FillPosition(continueStatement.Ptr());
			ReadToken(TokenType::KeywordContinue);
			ReadToken(TokenType::Semicolon);
			return continueStatement;
		}

		RefPtr<ReturnStatementSyntaxNode> Parser::ParseReturnStatement()
		{
			RefPtr<ReturnStatementSyntaxNode> returnStatement = new ReturnStatementSyntaxNode();
			FillPosition(returnStatement.Ptr());
			ReadToken(TokenType::KeywordReturn);
			if (!LookAheadToken(TokenType::Semicolon))
				returnStatement->Expression = ParseExpression();
			ReadToken(TokenType::Semicolon);
			return returnStatement;
		}

		RefPtr<ExpressionStatementSyntaxNode> Parser::ParseExpressionStatement()
		{
			RefPtr<ExpressionStatementSyntaxNode> statement = new ExpressionStatementSyntaxNode();
			
			FillPosition(statement.Ptr());
			statement->Expression = ParseExpression();
			
			ReadToken(TokenType::Semicolon);
			return statement;
		}

		RefPtr<ParameterSyntaxNode> Parser::ParseParameter()
		{
			RefPtr<ParameterSyntaxNode> parameter = new ParameterSyntaxNode();
			
			parameter->TypeNode = ParseType();
			Token & name = ReadToken(TokenType::Identifier);
			parameter->Name = name.Content;
			FillPosition(parameter.Ptr());
			
			return parameter;
		}

		RefPtr<TypeSyntaxNode> Parser::ParseType()
		{
			Token typeName;
			if (LookAheadToken(TokenType::Identifier))
				typeName = ReadToken(TokenType::Identifier);
			else
				typeName = ReadTypeKeyword();
			RefPtr<TypeSyntaxNode> rs;
			if (LookAheadToken(TokenType::OpLess))
			{
				RefPtr<GenericTypeSyntaxNode> gtype = new GenericTypeSyntaxNode();
				gtype->Position = typeName.Position;
				gtype->GenericTypeName = typeName.Content;
				ReadToken(TokenType::OpLess);
				gtype->BaseType = ParseType();
				ReadToken(TokenType::OpGreater);
				rs = gtype;
			}
			else
			{
				auto basicType = new BasicTypeSyntaxNode();
				basicType->Position = typeName.Position;
				basicType->TypeName = typeName.Content;
				rs = basicType;
			}
			while (LookAheadToken(TokenType::LBracket))
			{
				RefPtr<ArrayTypeSyntaxNode> arrType = new ArrayTypeSyntaxNode();
				arrType->Position = rs->Position;
				arrType->BaseType = rs;
				ReadToken(TokenType::LBracket);
				if (LookAheadToken(TokenType::IntLiterial))
					arrType->ArrayLength = atoi(ReadToken(TokenType::IntLiterial).Content.ToMultiByteString());
				else
					arrType->ArrayLength = 0;
				ReadToken(TokenType::RBracket);
				rs = arrType;
			}
			return rs;
		}

		enum class Associativity
		{
			Left, Right
		};

		Associativity GetAssociativityFromLevel(int level)
		{
			if (level == 0)
				return Associativity::Right;
			else
				return Associativity::Left;
		}

		int GetOpLevel(TokenType type)
		{
			switch(type)
			{
			case TokenType::OpAssign:
			case TokenType::OpMulAssign:
			case TokenType::OpDivAssign:
			case TokenType::OpAddAssign:
			case TokenType::OpSubAssign:
			case TokenType::OpModAssign:
			case TokenType::OpShlAssign:
			case TokenType::OpShrAssign:
			case TokenType::OpOrAssign:
			case TokenType::OpAndAssign:
			case TokenType::OpXorAssign:
				return 0;
			case TokenType::OpOr:
				return 2;
			case TokenType::OpAnd:
				return 3;
			case TokenType::OpBitOr:
				return 4;
			case TokenType::OpBitXor:
				return 5;
			case TokenType::OpBitAnd:
				return 6;
			case TokenType::OpEql:
			case TokenType::OpNeq:
				return 7;
			case TokenType::OpGeq:
			case TokenType::OpLeq:
			case TokenType::OpGreater:
			case TokenType::OpLess:
				return 8;
			case TokenType::OpLsh:
			case TokenType::OpRsh:
				return 9;
			case TokenType::OpAdd:
			case TokenType::OpSub:
				return 10;
			case TokenType::OpMul:
			case TokenType::OpDiv:
			case TokenType::OpMod:
				return 11;
			default:
				return -1;
			}
		}

		Operator GetOpFromToken(Token & token)
		{
			switch(token.Type)
			{
			case TokenType::OpAssign:
				return Operator::Assign;
			case TokenType::OpAddAssign:
				return Operator::AddAssign;
			case TokenType::OpSubAssign:
				return Operator::SubAssign;
			case TokenType::OpMulAssign:
				return Operator::MulAssign;
			case TokenType::OpDivAssign:
				return Operator::DivAssign;
			case TokenType::OpModAssign:
				return Operator::ModAssign;
			case TokenType::OpShlAssign:
				return Operator::LshAssign;
			case TokenType::OpShrAssign:
				return Operator::RshAssign;
			case TokenType::OpOrAssign:
				return Operator::OrAssign;
			case TokenType::OpAndAssign:
				return Operator::AddAssign;
			case TokenType::OpXorAssign:
				return Operator::XorAssign;
			case TokenType::OpOr:
				return Operator::Or;
			case TokenType::OpAnd:
				return Operator::And;
			case TokenType::OpBitOr:
				return Operator::BitOr;
			case TokenType::OpBitXor:
				return Operator::BitXor;
			case TokenType::OpBitAnd:
				return Operator::BitAnd;
			case TokenType::OpEql:
				return Operator::Eql;
			case TokenType::OpNeq:
				return Operator::Neq;
			case TokenType::OpGeq:
				return Operator::Geq;
			case TokenType::OpLeq:
				return Operator::Leq;
			case TokenType::OpGreater:
				return Operator::Greater;
			case TokenType::OpLess:
				return Operator::Less;
			case TokenType::OpLsh:
				return Operator::Lsh;
			case TokenType::OpRsh:
				return Operator::Rsh;
			case TokenType::OpAdd:
				return Operator::Add;
			case TokenType::OpSub:
				return Operator::Sub;
			case TokenType::OpMul:
				return Operator::Mul;
			case TokenType::OpDiv:
				return Operator::Div;
			case TokenType::OpMod:
				return Operator::Mod;
			case TokenType::OpInc:
				return Operator::PostInc;
			case TokenType::OpDec:
				return Operator::PostDec;
			case TokenType::OpNot:
				return Operator::Not;
			case TokenType::OpBitNot:
				return Operator::BitNot;
			default:
				throw L"Illegal TokenType.";
			}
		}

		RefPtr<ExpressionSyntaxNode> Parser::ParseExpression(int level)
		{
			if (level == MaxExprLevel)
				return ParseLeafExpression();
			if (level == 1)
			{
				// parse select clause
				auto condition = ParseExpression(level + 1);
				if (LookAheadToken(TokenType::QuestionMark))
				{
					RefPtr<SelectExpressionSyntaxNode> select = new SelectExpressionSyntaxNode();
					FillPosition(select.Ptr());
					ReadToken(TokenType::QuestionMark);
					select->SelectorExpr = condition;
					select->Expr0 = ParseExpression(level);
					ReadToken(TokenType::Colon);
					select->Expr1 = ParseExpression(level);
					return select;
				}
				else
					return condition;
			}
			else
			{
				if (GetAssociativityFromLevel(level) == Associativity::Left)
				{
					auto left = ParseExpression(level + 1);
					while (pos < tokens.Count() && GetOpLevel(tokens[pos].Type) == level)
					{
						RefPtr<BinaryExpressionSyntaxNode> tmp = new BinaryExpressionSyntaxNode();
						tmp->LeftExpression = left;
						FillPosition(tmp.Ptr());
						Token & opToken = ReadToken(tokens[pos].Type);
						tmp->Operator = GetOpFromToken(opToken);
						tmp->RightExpression = ParseExpression(level + 1);
						left = tmp;
					}
					return left;
				}
				else
				{
					auto left = ParseExpression(level + 1);
					if (pos < tokens.Count() && GetOpLevel(tokens[pos].Type) == level)
					{
						RefPtr<BinaryExpressionSyntaxNode> tmp = new BinaryExpressionSyntaxNode();
						tmp->LeftExpression = left;
						FillPosition(tmp.Ptr());
						Token & opToken = ReadToken(tokens[pos].Type);
						tmp->Operator = GetOpFromToken(opToken);
						tmp->RightExpression = ParseExpression(level);
						left = tmp;
					}
					return left;
				}
			}
		}

		RefPtr<ExpressionSyntaxNode> Parser::ParseLeafExpression()
		{
			RefPtr<ExpressionSyntaxNode> rs;

			if (LookAheadToken(TokenType::OpInc) ||
				LookAheadToken(TokenType::OpDec) ||
				LookAheadToken(TokenType::OpNot) ||
				LookAheadToken(TokenType::OpBitNot) ||
				LookAheadToken(TokenType::OpSub))
			{
				RefPtr<UnaryExpressionSyntaxNode> unaryExpr = new UnaryExpressionSyntaxNode();
				Token & token = tokens[pos++];
				FillPosition(unaryExpr.Ptr());
				unaryExpr->Operator = GetOpFromToken(token);
				if (unaryExpr->Operator == Operator::PostInc)
					unaryExpr->Operator = Operator::PreInc;
				else if (unaryExpr->Operator == Operator::PostDec)
					unaryExpr->Operator = Operator::PreDec;
				else if (unaryExpr->Operator == Operator::Sub)
					unaryExpr->Operator = Operator::Neg;

				unaryExpr->Expression = ParseLeafExpression();
				rs = unaryExpr;
				return rs;
			}

			if (LookAheadToken(TokenType::LParent))
			{
				ReadToken(TokenType::LParent);
				RefPtr<ExpressionSyntaxNode> expr;
				if (IsTypeKeyword() && pos + 1 < tokens.Count() && tokens[pos+1].Type == TokenType::RParent)
				{
					RefPtr<TypeCastExpressionSyntaxNode> tcexpr = new TypeCastExpressionSyntaxNode();
					FillPosition(tcexpr.Ptr());
					tcexpr->TargetType = ParseType();
					ReadToken(TokenType::RParent);
					tcexpr->Expression = ParseExpression();
					expr = tcexpr;
				}
				else
				{
					expr = ParseExpression();
					ReadToken(TokenType::RParent);
				}
				rs = expr;
			}
			else if (LookAheadToken(TokenType::IntLiterial) ||
				LookAheadToken(TokenType::DoubleLiterial))
			{
				RefPtr<ConstantExpressionSyntaxNode> constExpr = new ConstantExpressionSyntaxNode();
				auto token = tokens[pos++];
				FillPosition(constExpr.Ptr());
				if (token.Type == TokenType::IntLiterial)
				{
					constExpr->ConstType = ConstantExpressionSyntaxNode::ConstantType::Int;
					constExpr->IntValue = StringToInt(token.Content);
				}
				else if (token.Type == TokenType::DoubleLiterial)
				{
					constExpr->ConstType = ConstantExpressionSyntaxNode::ConstantType::Float;
					constExpr->FloatValue = (float)StringToDouble(token.Content);
				}
				rs = constExpr;
			}
			else if (LookAheadToken(TokenType::Identifier))
			{
				RefPtr<VarExpressionSyntaxNode> varExpr = new VarExpressionSyntaxNode();
				FillPosition(varExpr.Ptr());
				auto & token = ReadToken(TokenType::Identifier);
				varExpr->Variable = token.Content;
				rs = varExpr;
			}

			while (pos < tokens.Count() &&
				(LookAheadToken(TokenType::OpInc) ||
				LookAheadToken(TokenType::OpDec) ||
				LookAheadToken(TokenType::Dot) ||
				LookAheadToken(TokenType::LBracket) ||
				LookAheadToken(TokenType::LParent)))
			{
				if (LookAheadToken(TokenType::OpInc))
				{
					RefPtr<UnaryExpressionSyntaxNode> unaryExpr = new UnaryExpressionSyntaxNode();
					FillPosition(unaryExpr.Ptr());
					ReadToken(TokenType::OpInc);
					unaryExpr->Operator = Operator::PostInc;
					unaryExpr->Expression = rs;
					rs = unaryExpr;
				}
				else if (LookAheadToken(TokenType::OpDec))
				{
					RefPtr<UnaryExpressionSyntaxNode> unaryExpr = new UnaryExpressionSyntaxNode();
					FillPosition(unaryExpr.Ptr());
					ReadToken(TokenType::OpDec);
					unaryExpr->Operator = Operator::PostDec;
					unaryExpr->Expression = rs;
					rs = unaryExpr;
				}
				else if (LookAheadToken(TokenType::LBracket))
				{
					RefPtr<IndexExpressionSyntaxNode> indexExpr = new IndexExpressionSyntaxNode();
					indexExpr->BaseExpression = rs;
					FillPosition(indexExpr.Ptr());
					ReadToken(TokenType::LBracket);
					indexExpr->IndexExpression = ParseExpression();
					ReadToken(TokenType::RBracket);
					rs = indexExpr;
				}
				else if (LookAheadToken(TokenType::LParent))
				{
					RefPtr<InvokeExpressionSyntaxNode> invokeExpr = new InvokeExpressionSyntaxNode();
					invokeExpr->FunctionExpr = rs.As<VarExpressionSyntaxNode>();
					if (!invokeExpr->FunctionExpr)
					{
						errors.Add(CompileError(L"syntax error.", 20002, tokens[pos].Position));
					}
					FillPosition(invokeExpr.Ptr());
					ReadToken(TokenType::LParent);
					while (pos < tokens.Count())
					{
						if (!LookAheadToken(TokenType::RParent))
							invokeExpr->Arguments.Add(ParseExpression());
						else
						{
							break;
						}
						if (!LookAheadToken(TokenType::Comma))
							break;
						ReadToken(TokenType::Comma);
					}
					ReadToken(TokenType::RParent);
					rs = invokeExpr;
				}
				else if (LookAheadToken(TokenType::Dot))
				{
					RefPtr<MemberExpressionSyntaxNode> memberExpr = new MemberExpressionSyntaxNode();
					FillPosition(memberExpr.Ptr());
					memberExpr->BaseExpression = rs;
					ReadToken(TokenType::Dot); 
					memberExpr->MemberName = ReadToken(TokenType::Identifier).Content;
					rs = memberExpr;
				}
			}
			if (!rs)
			{
				CodePosition codePos;
				if (pos < tokens.Count())
				{
					codePos = tokens[pos].Position;
				}
				errors.Add(CompileError(String(L"syntax error."), 20002, codePos));
				throw 20005;
			}
			return rs;
		}
	}
}

/***********************************************************************
CORE\SCHEDULE.CPP
***********************************************************************/
using namespace CoreLib::Basic;

namespace Spire
{
	namespace Compiler
	{
		class ScheduleParser
		{
		private:
			List<CompileError>& errors;
			List<Token> tokens;
			int pos;
			String fileName;
			Token & ReadToken(const wchar_t * string)
			{
				if (pos >= tokens.Count())
				{
					errors.Add(CompileError(String(L"\"") + string + String(L"\" expected but end of file encountered."), 0, CodePosition(0, 0, fileName)));
					throw 0;
				}
				else if (tokens[pos].Content != string)
				{
					errors.Add(CompileError(String(L"\"") + string + String(L"\" expected"), 0, tokens[pos].Position));
					throw 20001;
				}
				return tokens[pos++];
			}

			Token & ReadToken(TokenType type)
			{
				if (pos >= tokens.Count())
				{
					errors.Add(CompileError(TokenTypeToString(type) + String(L" expected but end of file encountered."), 0, CodePosition(0, 0, fileName)));
					throw 0;
				}
				else if (tokens[pos].Type != type)
				{
					errors.Add(CompileError(TokenTypeToString(type) + String(L" expected"), 20001, tokens[pos].Position));
					throw 20001;
				}
				return tokens[pos++];
			}

			bool LookAheadToken(const wchar_t * string)
			{
				if (pos >= tokens.Count())
				{
					errors.Add(CompileError(String(L"\'") + string + String(L"\' expected but end of file encountered."), 0, CodePosition(0, 0, fileName)));
					return false;
				}
				else
				{
					if (tokens[pos].Content == string)
						return true;
					else
						return false;
				}
			}
		public:
			ScheduleParser(List<CompileError>& _errorList)
				: errors(_errorList)
			{}
			Schedule Parse(String source, String _fileName)
			{
				this->fileName = _fileName;
				Schedule schedule;
				Lexer lex;
				tokens = lex.Parse(fileName, source, errors);
				pos = 0;
				try
				{
					while (pos < tokens.Count())
					{
						if (LookAheadToken(L"attrib"))
						{
							EnumerableDictionary<String, String> additionalAttributes;
							ReadToken(L"attrib");
							String choiceName = ReadToken(TokenType::Identifier).Content;
							while (LookAheadToken(L"."))
							{
								choiceName = choiceName + L".";
								ReadToken(TokenType::Dot);
								choiceName = choiceName + ReadToken(TokenType::Identifier).Content;
							}
							ReadToken(TokenType::OpAssign);

							while (pos < tokens.Count())
							{
								auto name = ReadToken(TokenType::Identifier).Content;
								String value;
								if (LookAheadToken(L":"))
								{
									ReadToken(L":");
									value = ReadToken(TokenType::StringLiterial).Content;
								}
								additionalAttributes[name] = value;
								if (LookAheadToken(L","))
									ReadToken(TokenType::Comma);
								else
									break;
							}
							schedule.AddtionalAttributes[choiceName] = additionalAttributes;
						}
						else
						{
							String choiceName = ReadToken(TokenType::Identifier).Content;
							while (LookAheadToken(L"."))
							{
								choiceName = choiceName + L".";
								ReadToken(TokenType::Dot);
								choiceName = choiceName + ReadToken(TokenType::Identifier).Content;
							}
							ReadToken(TokenType::OpAssign);
							List<RefPtr<ChoiceValueSyntaxNode>> worlds;
							while (pos < tokens.Count())
							{
								auto & token = ReadToken(TokenType::StringLiterial);
								RefPtr<ChoiceValueSyntaxNode> choiceValue = new ChoiceValueSyntaxNode();
								choiceValue->Position = token.Position;
								int splitterPos = token.Content.IndexOf(L':');
								if (splitterPos != -1)
								{
									choiceValue->WorldName = token.Content.SubString(0, splitterPos);
									choiceValue->AlternateName = token.Content.SubString(splitterPos + 1, token.Content.Length() - splitterPos - 1);
								}
								else
								{
									choiceValue->WorldName = token.Content;
								}
								worlds.Add(choiceValue);
								if (LookAheadToken(L","))
									ReadToken(TokenType::Comma);
								else
									break;
							}
							schedule.Choices[choiceName] = worlds;
						}
						ReadToken(TokenType::Semicolon);
					}
				}
				catch (...)
				{
				}
				return schedule;
			}
		};
	
		Schedule Schedule::Parse(String source, String fileName, List<CompileError>& errorList)
		{
			return ScheduleParser(errorList).Parse(source, fileName);
		}
	}
}

/***********************************************************************
CORE\SEMANTICSVISITOR.CPP
***********************************************************************/

namespace Spire
{
	namespace Compiler
	{
		bool IsNumeric(BaseType t)
		{
			return t == BaseType::Int || t == BaseType::Float || t == BaseType::UInt;
		}

		String TranslateHLSLTypeNames(String name)
		{
			if (name == L"float2")
				return L"vec2";
			else if (name == L"float3")
				return L"vec3";
			else if (name == L"float4")
				return L"vec4";
			else if (name == L"int2")
				return L"ivec2";
			else if (name == L"int3")
				return L"ivec3";
			else if (name == L"int4")
				return L"ivec4";
			else if (name == L"uint2")
				return L"uvec2";
			else if (name == L"uint3")
				return L"uvec3";
			else if (name == L"uint4")
				return L"uvec4";
			else if (name == L"float3x3")
				return L"mat3";
			else if (name == L"float4x4")
				return L"mat4";
			else
				return name;
		}

		class SemanticsVisitor : public SyntaxVisitor
		{
			ProgramSyntaxNode * program = nullptr;
			FunctionSyntaxNode * function = nullptr;
			FunctionSymbol * currentFunc = nullptr;
			ShaderSymbol * currentShader = nullptr;
			PipelineSymbol * currentPipeline = nullptr;
			ImportOperatorDefSyntaxNode * currentImportOperator = nullptr;
			ShaderComponentSymbol * currentComp = nullptr;
			ComponentSyntaxNode * currentCompNode = nullptr;
			List<SyntaxNode *> loops;
			SymbolTable * symbolTable;
		public:
			SemanticsVisitor(SymbolTable * symbols, ErrorWriter * pErr)
				:SyntaxVisitor(pErr), symbolTable(symbols)
			{
			}
			// return true if world0 depends on world1 (there exists a series of import operators that converts world1 variables to world0)
			bool IsWorldDependent(PipelineSymbol * pipeline, String world0, String world1)
			{
				HashSet<String> depWorldsSet;
				List<String> depWorlds;
				depWorlds.Add(world0);
				for (int i = 0; i < depWorlds.Count(); i++)
				{
					auto & dep = pipeline->WorldDependency[world0].GetValue();
					if (dep.Contains(world1))
						return true;
					else
					{
						for (auto w : dep)
							if (depWorldsSet.Add(w))
								depWorlds.Add(w);
					}
				}
				return false;
			}
		public:
			// Translate Types
			RefPtr<ExpressionType> typeResult;
			RefPtr<ExpressionType> TranslateTypeNode(const RefPtr<TypeSyntaxNode> & node)
			{
				node->Accept(this);
				return typeResult;
			}
			RefPtr<TypeSyntaxNode> VisitBasicType(BasicTypeSyntaxNode * typeNode) override
			{
				RefPtr<BasicExpressionType> expType = new BasicExpressionType();
				if (typeNode->TypeName == L"int")
					expType->BaseType = BaseType::Int;
				else if (typeNode->TypeName == L"uint")
					expType->BaseType = BaseType::UInt;
				else if (typeNode->TypeName == L"float")
					expType->BaseType = BaseType::Float;
				else if (typeNode->TypeName == L"ivec2" || typeNode->TypeName == L"int2")
					expType->BaseType = BaseType::Int2;
				else if (typeNode->TypeName == L"ivec3" || typeNode->TypeName == L"int3")
					expType->BaseType = BaseType::Int3;
				else if (typeNode->TypeName == L"ivec4" || typeNode->TypeName == L"int4")
					expType->BaseType = BaseType::Int4;
				else if (typeNode->TypeName == L"uvec2" || typeNode->TypeName == L"uint2")
					expType->BaseType = BaseType::UInt2;
				else if (typeNode->TypeName == L"uvec3" || typeNode->TypeName == L"uint3")
					expType->BaseType = BaseType::UInt3;
				else if (typeNode->TypeName == L"uvec4" || typeNode->TypeName == L"uint4")
					expType->BaseType = BaseType::UInt4;
				else if (typeNode->TypeName == L"vec2" || typeNode->TypeName == L"float2")
					expType->BaseType = BaseType::Float2;
				else if (typeNode->TypeName == L"vec3" || typeNode->TypeName == L"float3")
					expType->BaseType = BaseType::Float3;
				else if (typeNode->TypeName == L"vec4" || typeNode->TypeName == L"float4")
					expType->BaseType = BaseType::Float4;
				else if (typeNode->TypeName == L"mat3" || typeNode->TypeName == L"mat3x3" || typeNode->TypeName == L"float3x3")
					expType->BaseType = BaseType::Float3x3;
				else if (typeNode->TypeName == L"mat4" || typeNode->TypeName == L"mat4x4" || typeNode->TypeName == L"float4x4")
					expType->BaseType = BaseType::Float4x4;
				else if (typeNode->TypeName == L"sampler2D")
					expType->BaseType = BaseType::Texture2D;
				else if (typeNode->TypeName == L"samplerCube")
					expType->BaseType = BaseType::TextureCube;
				else if (typeNode->TypeName == L"sampler2DShadow")
					expType->BaseType = BaseType::TextureShadow;
				else if (typeNode->TypeName == L"samplerCubeShadow")
					expType->BaseType = BaseType::TextureCubeShadow;
				else if (typeNode->TypeName == L"void")
					expType->BaseType = BaseType::Void;
				else if (typeNode->TypeName == L"bool")
					expType->BaseType = BaseType::Bool;
				else
				{
					expType->BaseType = BaseType::Struct;
					RefPtr<StructSymbol> ssym;
					if (symbolTable->Structs.TryGetValue(typeNode->TypeName, ssym))
					{
						expType->Struct = ssym.Ptr();
					}
					else if (currentPipeline || currentShader)
					{
						PipelineSymbol * pipe = currentPipeline ? currentPipeline : currentShader->Pipeline;
						if (pipe)
						{
							if (pipe->Worlds.ContainsKey(typeNode->TypeName))
							{
								expType->BaseType = BaseType::Record;
								expType->RecordTypeName = typeNode->TypeName;
							}
							else
								Error(31040, L"undefined type name: '" + typeNode->TypeName + L"'.", typeNode);
						}
						else
							typeResult = ExpressionType::Error;
					}
					else
					{
						Error(31040, L"undefined type name: '" + typeNode->TypeName + L"'.", typeNode);
						typeResult = ExpressionType::Error;
						return typeNode;
					}
				}
				typeResult = expType;
				return typeNode;
			}
			RefPtr<TypeSyntaxNode> VisitArrayType(ArrayTypeSyntaxNode * typeNode) override
			{
				RefPtr<ArrayExpressionType> rs = new ArrayExpressionType();
				rs->ArrayLength = typeNode->ArrayLength;
				typeNode->BaseType->Accept(this);
				rs->BaseType = typeResult;
				typeResult = rs;
				return typeNode;
			}
			RefPtr<TypeSyntaxNode> VisitGenericType(GenericTypeSyntaxNode * typeNode) override
			{
				RefPtr<GenericExpressionType> rs = new GenericExpressionType();
				typeNode->BaseType->Accept(this);
				rs->BaseType = typeResult;
				rs->GenericTypeName = typeNode->GenericTypeName;
				typeResult = rs;
				return typeNode;
			}
		public:
			RefPtr<PipelineSyntaxNode> VisitPipeline(PipelineSyntaxNode * pipeline)
			{
				RefPtr<PipelineSymbol> psymbol = new PipelineSymbol();
				psymbol->SyntaxNode = pipeline;
				currentPipeline = psymbol.Ptr();
				symbolTable->Pipelines.Add(pipeline->Name.Content, psymbol);
				for (auto world : pipeline->Worlds)
				{
					WorldSymbol worldSym;
					worldSym.IsAbstract = world->IsAbstract;
					worldSym.SyntaxNode = world.Ptr();
					if (!psymbol->Worlds.ContainsKey(world->Name.Content))
					{
						psymbol->Worlds.Add(world->Name.Content, worldSym);
						psymbol->WorldDependency.Add(world->Name.Content, EnumerableHashSet<String>());
						psymbol->ReachableWorlds.Add(world->Name.Content, EnumerableHashSet<String>());
						psymbol->ImplicitWorldDependency.Add(world->Name.Content, EnumerableHashSet<String>());
						psymbol->ImplicitlyReachableWorlds.Add(world->Name.Content, EnumerableHashSet<String>());

					}
					else
					{
						Error(33001, L"world \'" + world->Name.Content + L"\' is already defined.", world.Ptr());
					}
				}
				for (auto comp : pipeline->AbstractComponents)
				{
					comp->Type = TranslateTypeNode(comp->TypeNode);
					if (comp->IsParam || comp->IsInput || (comp->Rate && comp->Rate->Worlds.Count() == 1
						&& psymbol->IsAbstractWorld(comp->Rate->Worlds.First().World.Content)))
						AddNewComponentSymbol(psymbol->Components, comp);
					else
						Error(33003, L"cannot define components in a pipeline.",
							comp.Ptr());
				}
				for (auto & op : pipeline->ImportOperators)
				{
					if (auto list = psymbol->ImportOperators.TryGetValue(op->Name.Content))
					{
						list->Add(op);
					}
					else
					{
						List<RefPtr<ImportOperatorDefSyntaxNode>> nlist;
						nlist.Add(op);
						psymbol->ImportOperators[op->Name.Content] = nlist;
						for (auto & param : op->Parameters)
							param->Type = TranslateTypeNode(param->TypeNode);
					}
				}
				// add initial world dependency edges
				for (auto op : pipeline->ImportOperators)
				{
					if (!psymbol->WorldDependency.ContainsKey(op->DestWorld.Content))
						Error(33004, L"undefined world name '" + op->DestWorld.Content + L"'.", op->DestWorld);
					else
					{
						if (psymbol->Worlds[op->DestWorld.Content].GetValue().IsAbstract)
							Error(33005, L"abstract world cannot appear as target as an import operator.", op->DestWorld);
						else if (!psymbol->WorldDependency.ContainsKey(op->SourceWorld.Content))
							Error(33006, L"undefined world name '" + op->SourceWorld.Content + L"'.", op->SourceWorld);
						else
						{
							if (IsWorldDependent(psymbol.Ptr(), op->SourceWorld.Content, op->DestWorld.Content))
							{
								Error(33007, L"import operator '" + op->Name.Content + L"' creates a circular dependency between world '" + op->SourceWorld.Content + L"' and '" + op->DestWorld.Content + L"'",
									op->Name);
							}
							else
							{
								psymbol->WorldDependency[op->DestWorld.Content].GetValue().Add(op->SourceWorld.Content);
								if (op->Parameters.Count() == 0)
									psymbol->ImplicitWorldDependency[op->DestWorld.Content].GetValue().Add(op->SourceWorld.Content);

							}
						}
					}
					
				}
				// propagate world dependency graph
				bool changed = true;
				while (changed)
				{
					changed = false;
					for (auto world : pipeline->Worlds)
					{
						EnumerableHashSet<String> & dependentWorlds = psymbol->WorldDependency[world->Name.Content].GetValue();
						List<String> loopRange;
						for (auto w : dependentWorlds)
							loopRange.Add(w);
						for (auto w : loopRange)
						{
							EnumerableHashSet<String> & ddw = psymbol->WorldDependency[w].GetValue();
							for (auto ww : ddw)
							{
								if (!dependentWorlds.Contains(ww))
								{
									dependentWorlds.Add(ww);
									changed = true;
								}
							}
						}
					}
				}
				changed = true;
				while (changed)
				{
					changed = false;
					for (auto world : pipeline->Worlds)
					{
						EnumerableHashSet<String> & dependentWorlds = psymbol->ImplicitWorldDependency[world->Name.Content].GetValue();
						List<String> loopRange;
						for (auto w : dependentWorlds)
							loopRange.Add(w);
						for (auto w : loopRange)
						{
							EnumerableHashSet<String> & ddw = psymbol->ImplicitWorldDependency[w].GetValue();
							for (auto ww : ddw)
							{
								if (!dependentWorlds.Contains(ww))
								{
									dependentWorlds.Add(ww);
									changed = true;
								}
							}
						}
					}
				}
				// fill in reachable worlds
				for (auto world : psymbol->Worlds)
				{
					if (auto depWorlds = psymbol->WorldDependency.TryGetValue(world.Key))
					{
						for (auto & dep : *depWorlds)
						{
							psymbol->ReachableWorlds[dep].GetValue().Add(world.Key);
						}
					}
					if (auto depWorlds = psymbol->ImplicitWorldDependency.TryGetValue(world.Key))
					{
						for (auto & dep : *depWorlds)
						{
							psymbol->ImplicitlyReachableWorlds[dep].GetValue().Add(world.Key);
						}
					}
				}

				for (auto & op : pipeline->ImportOperators)
				{
					currentImportOperator = op.Ptr();
					HashSet<String> paraNames;
					for (auto & para : op->Parameters)
					{
						if (paraNames.Contains(para->Name))
							Error(30002, L"parameter \'" + para->Name + L"\' already defined.", para.Ptr());
						else
							paraNames.Add(para->Name);
						VariableEntry varEntry;
						varEntry.Name = para->Name;
						para->Type = TranslateTypeNode(para->TypeNode);
						varEntry.Type.DataType = para->Type;
						op->Scope->Variables.AddIfNotExists(varEntry.Name, varEntry);
						if (varEntry.Type.DataType->Equals(ExpressionType::Void.Ptr()))
							Error(30016, L"'void' can not be parameter type.", para.Ptr());
					}
					op->Body->Accept(this);
					currentImportOperator = nullptr;
				}
				currentPipeline = nullptr;
				return pipeline;
			}

			virtual RefPtr<ImportSyntaxNode> VisitImport(ImportSyntaxNode * import) override
			{
				RefPtr<ShaderSymbol> refShader;
				symbolTable->Shaders.TryGetValue(import->ShaderName.Content, refShader);
				if (refShader)
				{
					// type check
					List<ShaderComponentSymbol*> paramList;
					for (auto & comp : refShader->Components)
						if (comp.Value->IsParam())
							paramList.Add(comp.Value.Ptr());
					int position = 0;
					bool namedArgumentAppeared = false;
					for (auto & arg : import->Arguments)
					{
						if (arg->ArgumentName.Content.Length())
							namedArgumentAppeared = true;
						else
						{
							if (namedArgumentAppeared)
							{
								Error(33030, L"positional argument cannot appear after a named argument.", arg->Expression.Ptr());
								break;
							}
							if (position >= paramList.Count())
							{
								Error(33031, L"too many arguments.", arg->Expression.Ptr());
								break;
							}
							arg->ArgumentName.Content = paramList[position]->Name;
							arg->ArgumentName.Position = arg->Position;
						}
						position++;
						arg->Accept(this);
						RefPtr<ShaderComponentSymbol> refComp;
						if (refShader->Components.TryGetValue(arg->ArgumentName.Content, refComp))
						{
							if (!refComp->Type->DataType->Equals(arg->Expression->Type.Ptr()))
							{
								Error(33027, L"argument type (" + arg->Expression->Type->ToString() + L") does not match parameter type (" + refComp->Type->DataType->ToString() + L")", arg->Expression.Ptr());
							}
							if (!refComp->IsParam())
								Error(33028, L"'" + arg->ArgumentName.Content + L"' is not a parameter of '" + import->ShaderName.Content + L"'.", arg->ArgumentName);
						}
						else
							Error(33028, L"'" + arg->ArgumentName.Content + L"' is not a parameter of '" + import->ShaderName.Content + L"'.", arg->ArgumentName);
					}
				}
				return import;
			}

			class ShaderImportVisitor : public SyntaxVisitor
			{
			private:
				SymbolTable * symbolTable = nullptr;
				ShaderSymbol * currentShader = nullptr;
				ShaderComponentSymbol * currentComp = nullptr;
			public:
				ShaderImportVisitor(ErrorWriter * writer, SymbolTable * symTable)
					: SyntaxVisitor(writer), symbolTable(symTable)
				{}
				virtual RefPtr<ShaderSyntaxNode> VisitShader(ShaderSyntaxNode * shader) override
				{
					currentShader = symbolTable->Shaders[shader->Name.Content].GetValue().Ptr();
					SyntaxVisitor::VisitShader(shader);
					currentShader = nullptr;
					return shader;
				}
				virtual RefPtr<ComponentSyntaxNode> VisitComponent(ComponentSyntaxNode * comp) override
				{
					RefPtr<ShaderComponentSymbol> compSym;
					currentShader->Components.TryGetValue(comp->Name.Content, compSym);
					currentComp = compSym.Ptr();
					SyntaxVisitor::VisitComponent(comp);
					if (!compSym->IsParam() && (compSym->Type->DataType->IsArray() || compSym->Type->DataType->IsStruct() ||
						compSym->Type->DataType->IsTexture()))
					{
						bool valid = true;
						bool isInStorageBuffer = true;
						if (comp->Rate)
						{
							for (auto & w : comp->Rate->Worlds)
							{
								auto world = currentShader->Pipeline->Worlds.TryGetValue(w.World.Content);
								if (world)
								{
									if (!world->IsAbstract)
										valid = false;
									isInStorageBuffer = isInStorageBuffer && world->SyntaxNode->LayoutAttributes.ContainsKey(L"ShaderStorageBlock");
								}
							}
						}
						else 
							valid = false;
						if (!valid)
						{
							Error(33035, L"\'" + compSym->Name + L"\': sampler, struct and array types only allowed in input worlds.", comp->Name);
						}
						else
						{
							auto basicType = compSym->Type->DataType->AsBasicType();

							if (!isInStorageBuffer && basicType && basicType->Struct != nullptr)
							{
								Error(33036, L"\'" + compSym->Name + L"\': struct must only be defined in a input world with [ShaderStorageBlock] attribute.", comp->Name);
							}
						}
					}
					currentComp = nullptr;
					return comp;
				}
				virtual RefPtr<ImportSyntaxNode> VisitImport(ImportSyntaxNode * import) override
				{
					RefPtr<ShaderSymbol> refShader;
					symbolTable->Shaders.TryGetValue(import->ShaderName.Content, refShader);
					if (!refShader)
						Error(33015, L"undefined identifier \'" + import->ShaderName.Content + L"\'.", import->ShaderName);
					currentShader->DependentShaders.Add(refShader.Ptr());
					if (!currentComp)
					{
						ShaderUsing su;
						su.Shader = refShader.Ptr();
						su.IsPublic = import->IsPublic;
						if (import->IsInplace)
						{
							currentShader->ShaderUsings.Add(su);
						}
						else
						{
							if (currentShader->ShaderObjects.ContainsKey(import->ObjectName.Content) ||
								currentShader->Components.ContainsKey(import->ObjectName.Content))
							{
								Error(33018, L"\'" + import->ShaderName.Content + L"\' is already defined.", import->ShaderName);
							}
							currentShader->ShaderObjects[import->ObjectName.Content] = su;
						}
					}
					if (currentComp)
						Error(33016, L"'using': importing not allowed in component definition.", import->ShaderName);
					return import;
				}
			};

			// pass 1: fill components in shader symbol table
			void VisitShaderPass1(ShaderSyntaxNode * shader)
			{
				HashSet<String> inheritanceSet;
				auto curShader = shader;
				inheritanceSet.Add(curShader->Name.Content);
				auto & shaderSymbol = symbolTable->Shaders[curShader->Name.Content].GetValue();
				this->currentShader = shaderSymbol.Ptr();
				if (shader->Pipeline.Content.Length() == 0) // implicit pipeline
				{
					if (program->Pipelines.Count() == 1)
					{
						shader->Pipeline = shader->Name; // get line and col from shader name
						shader->Pipeline.Content = program->Pipelines.First()->Name.Content;
					}
					else
					{
						// current compilation context has more than one pipeline defined,
						// in which case we do not allow implicit pipeline specification
						Error(33002, L"explicit pipeline specification required for shader '" +
							shader->Name.Content + L"' because multiple pipelines are defined in current context.", curShader->Name);
					}
				}
				
				auto pipelineName = shader->Pipeline.Content;
				auto pipeline = symbolTable->Pipelines.TryGetValue(pipelineName);
				if (pipeline)
					shaderSymbol->Pipeline = pipeline->Ptr();
				else
				{
					Error(33010, L"pipeline \'" + pipelineName + L"' is not defined.", shader->Pipeline);
					throw 0;
				}
				if (shader->IsModule)
					shaderSymbol->IsAbstract = true;
				// add components to symbol table
				for (auto & mbr : shader->Members)
				{
					if (auto comp = dynamic_cast<ComponentSyntaxNode*>(mbr.Ptr()))
					{
						comp->Type = TranslateTypeNode(comp->TypeNode);
						if (comp->IsParam)
						{
							shaderSymbol->IsAbstract = true;
							if (!shaderSymbol->SyntaxNode->IsModule)
							{
								Error(33009, L"parameters can only be defined in modules.", shaderSymbol->SyntaxNode);
							}
						}
						AddNewComponentSymbol(shaderSymbol->Components, comp);
					}
				}
				// add shader objects to symbol table
				ShaderImportVisitor importVisitor(err, symbolTable);
				shader->Accept(&importVisitor);

				for (auto & comp : shaderSymbol->Components)
				{
					for (auto & impl : comp.Value->Implementations)
					{
						bool inAbstractWorld = false;
						if (impl->SyntaxNode->Rate)
						{
							auto & userSpecifiedWorlds = impl->SyntaxNode->Rate->Worlds;
							for (auto & world : userSpecifiedWorlds)
							{
								if (!shaderSymbol->Pipeline->WorldDependency.ContainsKey(world.World.Content))
									Error(33012, L"\'" + world.World.Content + L"' is not a defined world in '" +
										pipelineName + L"'.", world.World);
								WorldSymbol worldSym;

								if (shaderSymbol->Pipeline->Worlds.TryGetValue(world.World.Content, worldSym))
								{
									if (worldSym.IsAbstract)
									{
										inAbstractWorld = true;
										if (userSpecifiedWorlds.Count() > 1)
										{
											Error(33013, L"abstract world cannot appear with other worlds.",
												world.World);
										}
									}
								}
							}
						}
						if (!inAbstractWorld && !impl->SyntaxNode->IsParam
							&& !impl->SyntaxNode->Expression && !impl->SyntaxNode->BlockStatement)
						{
							Error(33014, L"non-abstract component must have an implementation.",
								impl->SyntaxNode.Ptr());
						}
					}
				}
				this->currentShader = nullptr;
			}
			// pass 2: type checking component definitions
			void VisitShaderPass2(ShaderSyntaxNode * shaderNode)
			{
				RefPtr<ShaderSymbol> shaderSym;
				if (!symbolTable->Shaders.TryGetValue(shaderNode->Name.Content, shaderSym))
					return;
				this->currentShader = shaderSym.Ptr();
				for (auto & comp : shaderNode->Members)
				{
					comp->Accept(this);
				}
				this->currentShader = nullptr;
			}

			bool MatchType_RecordType(String recTypeName, ExpressionType * valueType)
			{
				if (valueType->IsGenericType(L"Uniform") || valueType->IsGenericType(L"Patch"))
				{
					valueType = valueType->AsGenericType()->BaseType.Ptr();
				}
				if (auto basicType = valueType->AsBasicType())
					return basicType->RecordTypeName == recTypeName;
				return false;
			}

			bool MatchType_ValueReceiver(ExpressionType * receiverType, ExpressionType * valueType)
			{
				if (receiverType->Equals(valueType))
					return true;
				if (receiverType->IsIntegral() && valueType->Equals(ExpressionType::Int.Ptr()))
					return true;
				if (receiverType->Equals(ExpressionType::Float.Ptr()) && valueType->IsIntegral())
					return true;
				if (receiverType->IsVectorType() && valueType->IsVectorType())
				{
					auto recieverBasicType = receiverType->AsBasicType();
					auto valueBasicType = valueType->AsBasicType();
					if (GetVectorBaseType(recieverBasicType->BaseType) == BaseType::Float &&
						GetVectorSize(recieverBasicType->BaseType) == GetVectorSize(valueBasicType->BaseType))
						return true;
					if (GetVectorBaseType(recieverBasicType->BaseType) == BaseType::UInt &&
						GetVectorBaseType(valueBasicType->BaseType) == BaseType::Int &&
						GetVectorSize(recieverBasicType->BaseType) == GetVectorSize(valueBasicType->BaseType))
						return true;
				}
				return false;
			}
			virtual RefPtr<ComponentSyntaxNode> VisitComponent(ComponentSyntaxNode * comp) override
			{
				this->currentCompNode = comp;
				RefPtr<ShaderComponentSymbol> compSym;
				currentShader->Components.TryGetValue(comp->Name.Content, compSym);
				this->currentComp = compSym.Ptr();
				if (comp->Expression)
				{
					comp->Expression = comp->Expression->Accept(this).As<ExpressionSyntaxNode>();
					if (!MatchType_ValueReceiver(compSym->Type->DataType.Ptr(), comp->Expression->Type.Ptr()) && 
						!comp->Expression->Type->Equals(ExpressionType::Error.Ptr()))
						Error(30019, L"type mismatch \'" + comp->Expression->Type->ToString() + L"\' and \'" +
							currentComp->Type->DataType->ToString() + L"\'", comp->Name);
				}
				if (comp->BlockStatement)
					comp->BlockStatement->Accept(this);
				this->currentComp = nullptr;
				this->currentCompNode = nullptr;
				return comp;
			}
			virtual RefPtr<StatementSyntaxNode> VisitImportStatement(ImportStatementSyntaxNode * importStmt) override
			{
				importStmt->Import->Accept(this);
				return importStmt;
			}
			void AddNewComponentSymbol(EnumerableDictionary<String, RefPtr<ShaderComponentSymbol>> & components, RefPtr<ComponentSyntaxNode> comp)
			{
				RefPtr<ShaderComponentSymbol> compSym;
				RefPtr<ShaderComponentImplSymbol> compImpl = new ShaderComponentImplSymbol();
				if (comp->Rate)
					for (auto w : comp->Rate->Worlds)
						compImpl->Worlds.Add(w.World.Content);
				compImpl->SyntaxNode = comp;
				if (compImpl->SyntaxNode->Rate)
				{
					for (auto & w : compImpl->SyntaxNode->Rate->Worlds)
						if (w.Pinned)
							compImpl->SrcPinnedWorlds.Add(w.World.Content);
				}
				if (compImpl->SyntaxNode->AlternateName.Type == TokenType::Identifier)
				{
					compImpl->AlternateName = compImpl->SyntaxNode->AlternateName.Content;
				}
				if (compImpl->SyntaxNode->IsOutput)
				{
					if (compImpl->SyntaxNode->Rate)
					{
						for (auto & w : compImpl->SyntaxNode->Rate->Worlds)
							compImpl->ExportWorlds.Add(w.World.Content);
					}
					else
					{
						Error(33019, L"component \'" + compImpl->SyntaxNode->Name.Content + L"\': definition marked as 'export' must have an explicitly specified world.",
							compImpl->SyntaxNode.Ptr());
					}
				}
				if (!components.TryGetValue(comp->Name.Content, compSym))
				{
					compSym = new ShaderComponentSymbol();
					compSym->Type = new Type();
					compSym->Name = comp->Name.Content;
					compSym->Type->DataType = comp->Type;
					components.Add(comp->Name.Content, compSym);
				}
				else
				{
					if (comp->IsParam)
						Error(33029, L"\'" + compImpl->SyntaxNode->Name.Content + L"\': requirement clash with previous definition.",
							compImpl->SyntaxNode.Ptr());
					symbolTable->CheckComponentImplementationConsistency(err, compSym.Ptr(), compImpl.Ptr());
				}
				compSym->Implementations.Add(compImpl);
			}
			virtual RefPtr<ProgramSyntaxNode> VisitProgram(ProgramSyntaxNode * programNode) override
			{
				HashSet<String> funcNames;
				this->program = programNode;
				this->function = nullptr;
				for (auto & s : program->Structs)
				{
					RefPtr<StructSymbol> ssym = new StructSymbol();
					ssym->Name = s->Name.Content;
					ssym->SyntaxNode = s;
					ssym->Type = new ILStructType();
					symbolTable->Structs.Add(s->Name.Content, ssym);
				}
				for (auto & s : program->Structs)
					VisitStruct(s.Ptr());
				for (auto & pipeline : program->Pipelines)
				{
					VisitPipeline(pipeline.Ptr());
				}
				for (auto & func : program->Functions)
				{
					VisitFunctionDeclaration(func.Ptr());
					if (funcNames.Contains(func->InternalName))
					{
						StringBuilder argList;
						argList << L"(";
						for (auto & param : func->Parameters)
						{
							argList << param->Type->ToString();
							if (param != func->Parameters.Last())
								argList << L", ";
						}
						argList << L")";
						Error(30001, L"function \'" + func->Name + argList.ProduceString() + L"\' redefinition.", func.Ptr());
					}
					else
						funcNames.Add(func->InternalName);
				}
				for (auto & func : program->Functions)
				{
					func->Accept(this);
				}
				// build initial symbol table for shaders
				for (auto & shader : program->Shaders)
				{
					RefPtr<ShaderSymbol> shaderSym = new ShaderSymbol();
					shaderSym->SyntaxNode = shader.Ptr();
					if (symbolTable->Shaders.ContainsKey(shader->Name.Content))
					{
						Error(33018, L"shader '" + shader->Name.Content + "' has already been defined.", shader->Name);
					}
					symbolTable->Shaders[shader->Name.Content] = shaderSym;
				}
				HashSet<ShaderSyntaxNode*> validShaders;
				for (auto & shader : program->Shaders)
				{
					int lastErrorCount = err->GetErrorCount();
					VisitShaderPass1(shader.Ptr());
					if (err->GetErrorCount() == lastErrorCount)
						validShaders.Add(shader.Ptr());
				}
				if (err->GetErrorCount() != 0)
					return programNode;
				// shader dependency is discovered in pass 1, we can now sort the shaders
				if (!symbolTable->SortShaders())
				{
					HashSet<ShaderSymbol*> sortedShaders;
					for (auto & shader : symbolTable->ShaderDependenceOrder)
						sortedShaders.Add(shader);
					for (auto & shader : symbolTable->Shaders)
						if (!sortedShaders.Contains(shader.Value.Ptr()))
						{
							Error(33011, L"shader '" + shader.Key + L"' involves circular reference.", shader.Value->SyntaxNode->Name);
						}
				}

				for (auto & shader : symbolTable->ShaderDependenceOrder)
				{
					if (!validShaders.Contains(shader->SyntaxNode))
						continue;
					int lastErrorCount = err->GetErrorCount();
					VisitShaderPass2(shader->SyntaxNode);
					if (err->GetErrorCount() != lastErrorCount)
						validShaders.Remove(shader->SyntaxNode);
				}
				// update symbol table with only valid shaders
				EnumerableDictionary<String, RefPtr<ShaderSymbol>> newShaderSymbols;
				for (auto & shader : symbolTable->Shaders)
				{
					if (validShaders.Contains(shader.Value->SyntaxNode))
						newShaderSymbols.AddIfNotExists(shader.Key, shader.Value);
				}
				symbolTable->Shaders = _Move(newShaderSymbols);
				return programNode;
			}

			virtual RefPtr<StructSyntaxNode> VisitStruct(StructSyntaxNode * structNode) override
			{
				RefPtr<StructSymbol> st;
				if (symbolTable->Structs.TryGetValue(structNode->Name.Content, st))
				{
					st->Type->TypeName = structNode->Name.Content;
					for (auto node : structNode->Fields)
					{
						node->Type = TranslateTypeNode(node->TypeNode);
						ILStructType::ILStructField f;
						f.FieldName = node->Name.Content;
						f.Type = TranslateExpressionType(node->Type.Ptr());
						st->Type->Members.Add(f);
					}
				}
				return structNode;
			}

			virtual RefPtr<FunctionSyntaxNode> VisitFunction(FunctionSyntaxNode *functionNode) override
			{
				if (!functionNode->IsExtern)
				{
					currentFunc = symbolTable->Functions.TryGetValue(functionNode->InternalName)->Ptr();
					this->function = functionNode;
					functionNode->Body->Accept(this);
					this->function = NULL;
					currentFunc = nullptr;
				}
				return functionNode;
			}

			void VisitFunctionDeclaration(FunctionSyntaxNode *functionNode)
			{
				this->function = functionNode;
				auto returnType = TranslateTypeNode(functionNode->ReturnTypeNode);
				functionNode->ReturnType = returnType;
				StringBuilder internalName;
				internalName << functionNode->Name;
				HashSet<String> paraNames;
				for (auto & para : functionNode->Parameters)
				{
					if (paraNames.Contains(para->Name))
						Error(30002, L"parameter \'" + para->Name + L"\' already defined.", para.Ptr());
					else
						paraNames.Add(para->Name);
					VariableEntry varEntry;
					varEntry.Name = para->Name;
					para->Type = TranslateTypeNode(para->TypeNode);
					varEntry.Type.DataType = para->Type;
					functionNode->Scope->Variables.AddIfNotExists(varEntry.Name, varEntry);
					if (varEntry.Type.DataType->Equals(ExpressionType::Void.Ptr()))
						Error(30016, L"'void' can not be parameter type.", para.Ptr());
					internalName << L"@" << varEntry.Type.DataType->ToString();
				}
				functionNode->InternalName = internalName.ProduceString();	
				RefPtr<FunctionSymbol> symbol = new FunctionSymbol();
				symbol->SyntaxNode = functionNode;
				symbolTable->Functions[functionNode->InternalName] = symbol;
				this->function = NULL;
			}
			
			virtual RefPtr<StatementSyntaxNode> VisitBlockStatement(BlockStatementSyntaxNode *stmt) override
			{
				for (auto & node : stmt->Statements)
				{
					node->Accept(this);
				}
				return stmt;
			}
			virtual RefPtr<StatementSyntaxNode> VisitBreakStatement(BreakStatementSyntaxNode *stmt) override
			{
				if (!loops.Count())
					Error(30003, L"'break' must appear inside loop constructs.", stmt);
				return stmt;
			}
			virtual RefPtr<StatementSyntaxNode> VisitContinueStatement(ContinueStatementSyntaxNode *stmt) override
			{
				if (!loops.Count())
					Error(30004, L"'continue' must appear inside loop constructs.", stmt);
				return stmt;
			}
			virtual RefPtr<StatementSyntaxNode> VisitDoWhileStatement(DoWhileStatementSyntaxNode *stmt) override
			{
				loops.Add(stmt);
				if (stmt->Predicate != NULL)
					stmt->Predicate = stmt->Predicate->Accept(this).As<ExpressionSyntaxNode>();
				if (!stmt->Predicate->Type->Equals(ExpressionType::Error.Ptr()) && 
					!stmt->Predicate->Type->Equals(ExpressionType::Int.Ptr()) &&
					!stmt->Predicate->Type->Equals(ExpressionType::Bool.Ptr()))
					Error(30005, L"'while': expression must evaluate to int.", stmt);
				stmt->Statement->Accept(this);

				loops.RemoveAt(loops.Count() - 1);
				return stmt;
			}
			virtual RefPtr<StatementSyntaxNode> VisitForStatement(ForStatementSyntaxNode *stmt) override
			{
				loops.Add(stmt);
				VariableEntry iterVar;
				if (stmt->TypeDef != nullptr)
				{
					stmt->IterationVariableType = TranslateTypeNode(stmt->TypeDef);
					VariableEntry varEntry;
					varEntry.IsComponent = false;
					varEntry.Name = stmt->IterationVariable.Content;
					varEntry.Type.DataType = stmt->IterationVariableType;
					stmt->Scope->Variables.AddIfNotExists(stmt->IterationVariable.Content, varEntry);
				}
				if (!stmt->Scope->FindVariable(stmt->IterationVariable.Content, iterVar))
					Error(30015, L"undefined identifier \'" + stmt->IterationVariable.Content + L"\'", stmt->IterationVariable);
				else
				{
					if (!iterVar.Type.DataType->Equals(ExpressionType::Float.Ptr()) && !iterVar.Type.DataType->Equals(ExpressionType::Int.Ptr()))
						Error(30035, L"iteration variable \'" + stmt->IterationVariable.Content + L"\' can only be a int or float", stmt->IterationVariable);
					stmt->InitialExpression = stmt->InitialExpression->Accept(this).As<ExpressionSyntaxNode>();
					if (stmt->InitialExpression->Type != iterVar.Type.DataType)
						Error(30019, L"type mismatch \'" + stmt->InitialExpression->Type->ToString() + L"\' and \'" +
							iterVar.Type.DataType->ToString() + L"\'", stmt->InitialExpression.Ptr());
					stmt->EndExpression = stmt->EndExpression->Accept(this).As<ExpressionSyntaxNode>();
					if (stmt->EndExpression->Type != iterVar.Type.DataType)
						Error(30019, L"type mismatch \'" + stmt->EndExpression->Type->ToString() + L"\' and \'" +
							iterVar.Type.DataType->ToString() + L"\'", stmt->EndExpression.Ptr());
					if (stmt->StepExpression != nullptr)
					{
						stmt->StepExpression = stmt->StepExpression->Accept(this).As<ExpressionSyntaxNode>();
						if (stmt->StepExpression->Type != iterVar.Type.DataType)
							Error(30019, L"type mismatch \'" + stmt->StepExpression->Type->ToString() + L"\' and \'" +
								iterVar.Type.DataType->ToString() + L"\'", stmt->StepExpression.Ptr());
					}
				}

				stmt->Statement->Accept(this);

				loops.RemoveAt(loops.Count() - 1);
				return stmt;
			}
			virtual RefPtr<StatementSyntaxNode> VisitIfStatement(IfStatementSyntaxNode *stmt) override
			{
				if (stmt->Predicate != NULL)
					stmt->Predicate = stmt->Predicate->Accept(this).As<ExpressionSyntaxNode>();
				if (!stmt->Predicate->Type->Equals(ExpressionType::Error.Ptr()) 
					&& (!stmt->Predicate->Type->Equals(ExpressionType::Int.Ptr()) && 
						!stmt->Predicate->Type->Equals(ExpressionType::Bool.Ptr())))
					Error(30006, L"'if': expression must evaluate to int.", stmt);

				if (stmt->PositiveStatement != NULL)
					stmt->PositiveStatement->Accept(this);
				
				if (stmt->NegativeStatement != NULL)
					stmt->NegativeStatement->Accept(this);
				return stmt;
			}
			virtual RefPtr<StatementSyntaxNode> VisitReturnStatement(ReturnStatementSyntaxNode *stmt) override
			{
				if (currentCompNode && currentCompNode->BlockStatement->Statements.Count() &&
					stmt != currentCompNode->BlockStatement->Statements.Last().Ptr())
				{
					Error(30026, L"'return' can only appear as the last statement in component definition.", stmt);
				}
				if (!stmt->Expression)
				{
					if (function && !function->ReturnType->Equals(ExpressionType::Void.Ptr()))
						Error(30006, L"'return' should have an expression.", stmt);
				}
				else
				{
					stmt->Expression = stmt->Expression->Accept(this).As<ExpressionSyntaxNode>();
					if (!stmt->Expression->Type->Equals(ExpressionType::Error.Ptr()))
					{
						if (function && !MatchType_ValueReceiver(function->ReturnType.Ptr(), stmt->Expression->Type.Ptr()))
							Error(30007, L"expression type '" + stmt->Expression->Type->ToString()
								+ L"' does not match function's return type '"
								+ function->ReturnType->ToString() + L"'", stmt);
						if (currentComp && !MatchType_ValueReceiver(currentComp->Type->DataType.Ptr(), stmt->Expression->Type.Ptr()))
						{
							Error(30007, L"expression type '" + stmt->Expression->Type->ToString()
								+ L"' does not match component's type '"
								+ currentComp->Type->DataType->ToString() + L"'", stmt);
						}
						if (currentImportOperator && !MatchType_RecordType(currentImportOperator->SourceWorld.Content, stmt->Expression->Type.Ptr()))
							Error(30007, L"expression type '" + stmt->Expression->Type->ToString() + L"' does not match import operator's type '" + currentImportOperator->SourceWorld.Content
								+ L"'.", stmt);
					}
				}
				return stmt;
			}
			virtual RefPtr<StatementSyntaxNode> VisitVarDeclrStatement(VarDeclrStatementSyntaxNode *stmt) override
			{
				stmt->Type = TranslateTypeNode(stmt->TypeNode);
				if (stmt->Type->IsTexture())
				{
					Error(30033, L"cannot declare a local variable of 'texture' type.", stmt);
				}
				if (stmt->Type->AsGenericType())
				{
					Error(30033, L"cannot declare a local variable of this type.", stmt);
				}
				for (auto & para : stmt->Variables)
				{
					VariableEntry varDeclr;
					varDeclr.Name = para->Name;
					if (stmt->Scope->Variables.ContainsKey(para->Name))
						Error(30008, L"variable " + para->Name + L" already defined.", para.Ptr());

					varDeclr.Type.DataType = stmt->Type;
					if (varDeclr.Type.DataType->Equals(ExpressionType::Void.Ptr()))
						Error(30009, L"invalid type 'void'.", stmt);
					if (varDeclr.Type.DataType->IsArray() && varDeclr.Type.DataType->AsArrayType()->ArrayLength <= 0)
						Error(30025, L"array size must be larger than zero.", stmt);

					stmt->Scope->Variables.AddIfNotExists(para->Name, varDeclr);
					if (para->Expression != NULL)
					{
						para->Expression = para->Expression->Accept(this).As<ExpressionSyntaxNode>();
						if (!MatchType_ValueReceiver(varDeclr.Type.DataType.Ptr(), para->Expression->Type.Ptr())
							&& !para->Expression->Type->Equals(ExpressionType::Error.Ptr()))
						{
							Error(30019, L"type mismatch \'" + para->Expression->Type->ToString() + L"\' and \'" +
								varDeclr.Type.DataType->ToString() + L"\'", para.Ptr());
						}
					}
				}
				return stmt;
			}
			virtual RefPtr<StatementSyntaxNode> VisitWhileStatement(WhileStatementSyntaxNode *stmt) override
			{
				loops.Add(stmt);
				stmt->Predicate = stmt->Predicate->Accept(this).As<ExpressionSyntaxNode>();
				if (!stmt->Predicate->Type->Equals(ExpressionType::Error.Ptr()) && 
					!stmt->Predicate->Type->Equals(ExpressionType::Int.Ptr()) &&
					!stmt->Predicate->Type->Equals(ExpressionType::Bool.Ptr()))
					Error(30010, L"'while': expression must evaluate to int.", stmt);

				stmt->Statement->Accept(this);
				loops.RemoveAt(loops.Count() - 1);
				return stmt;
			}
			virtual RefPtr<StatementSyntaxNode> VisitExpressionStatement(ExpressionStatementSyntaxNode *stmt) override
			{
				stmt->Expression = stmt->Expression->Accept(this).As<ExpressionSyntaxNode>();
				return stmt;
			}
			bool MatchType_BinaryImplicit(RefPtr<ExpressionType> & resultType, RefPtr<ExpressionType> &leftType, RefPtr<ExpressionType> &rightType)
			{
				if (leftType->Equals(rightType.Ptr()) && !leftType->IsTexture())
				{
					resultType = leftType;
					return true;
				}
				else if (leftType->IsVectorType() && rightType->AsBasicType() &&
					rightType->AsBasicType()->BaseType == GetVectorBaseType(leftType->AsBasicType()->BaseType))
				{
					resultType = leftType;
					return true;
				}
				else if (rightType->IsVectorType() && leftType->AsBasicType() 
					&& leftType->AsBasicType()->BaseType == GetVectorBaseType(rightType->AsBasicType()->BaseType))
				{
					resultType = rightType;
					return true;
				}
				else if ((rightType->Equals(ExpressionType::Float.Ptr()) && leftType->Equals(ExpressionType::Int.Ptr())) ||
					(leftType->Equals(ExpressionType::Float.Ptr()) && rightType->Equals(ExpressionType::Int.Ptr())))
				{
					resultType = ExpressionType::Float;
					return true;
				}
				else if ((rightType->Equals(ExpressionType::Float2.Ptr()) && leftType->Equals(ExpressionType::Int2.Ptr())) ||
					(leftType->Equals(ExpressionType::Float2.Ptr()) && rightType->Equals(ExpressionType::Int2.Ptr())))
				{
					resultType = ExpressionType::Float2;
					return true;
				}
				else if ((rightType->Equals(ExpressionType::Float3.Ptr()) && leftType->Equals(ExpressionType::Int3.Ptr())) ||
					(leftType->Equals(ExpressionType::Float3.Ptr()) && rightType->Equals(ExpressionType::Int3.Ptr())))
				{
					resultType = ExpressionType::Float3;
					return true;
				}
				else if ((rightType->Equals(ExpressionType::Float4.Ptr()) && leftType->Equals(ExpressionType::Int4.Ptr())) ||
					(leftType->Equals(ExpressionType::Float4.Ptr()) && rightType->Equals(ExpressionType::Int4.Ptr())))
				{
					resultType = ExpressionType::Float4;
					return true;
				}
				else if ((rightType->Equals(ExpressionType::Float.Ptr()) && leftType->Equals(ExpressionType::UInt.Ptr())) ||
					(leftType->Equals(ExpressionType::Float.Ptr()) && rightType->Equals(ExpressionType::UInt.Ptr())))
				{
					resultType = ExpressionType::Float;
					return true;
				}
				else if ((rightType->Equals(ExpressionType::Float2.Ptr()) && leftType->Equals(ExpressionType::UInt2.Ptr())) ||
					(leftType->Equals(ExpressionType::Float2.Ptr()) && rightType->Equals(ExpressionType::UInt2.Ptr())))
				{
					resultType = ExpressionType::Float2;
					return true;
				}
				else if ((rightType->Equals(ExpressionType::Float3.Ptr()) && leftType->Equals(ExpressionType::UInt3.Ptr())) ||
					(leftType->Equals(ExpressionType::Float3.Ptr()) && rightType->Equals(ExpressionType::UInt3.Ptr())))
				{
					resultType = ExpressionType::Float3;
					return true;
				}
				else if ((rightType->Equals(ExpressionType::Float4.Ptr()) && leftType->Equals(ExpressionType::UInt4.Ptr())) ||
					(leftType->Equals(ExpressionType::Float4.Ptr()) && rightType->Equals(ExpressionType::UInt4.Ptr())))
				{
					resultType = ExpressionType::Float4;
					return true;
				}
				else if ((rightType->Equals(ExpressionType::Int.Ptr()) && leftType->Equals(ExpressionType::UInt.Ptr())) ||
					(leftType->Equals(ExpressionType::Int.Ptr()) && rightType->Equals(ExpressionType::UInt.Ptr())))
				{
					resultType = ExpressionType::Int;
					return true;
				}
				else if ((rightType->Equals(ExpressionType::Int2.Ptr()) && leftType->Equals(ExpressionType::UInt2.Ptr())) ||
					(leftType->Equals(ExpressionType::Int2.Ptr()) && rightType->Equals(ExpressionType::UInt2.Ptr())))
				{
					resultType = ExpressionType::Int2;
					return true;
				}
				else if ((rightType->Equals(ExpressionType::Int3.Ptr()) && leftType->Equals(ExpressionType::UInt3.Ptr())) ||
					(leftType->Equals(ExpressionType::Int3.Ptr()) && rightType->Equals(ExpressionType::UInt3.Ptr())))
				{
					resultType = ExpressionType::Int3;
					return true;
				}
				else if ((rightType->Equals(ExpressionType::Int4.Ptr()) && leftType->Equals(ExpressionType::UInt4.Ptr())) ||
					(leftType->Equals(ExpressionType::Int4.Ptr()) && rightType->Equals(ExpressionType::UInt4.Ptr())))
				{
					resultType = ExpressionType::Int4;
					return true;
				}
				else if (leftType->AsBasicType() && leftType->AsBasicType()->BaseType == BaseType::Record)
				{
					resultType = leftType;
					return true;
				}
				else if (rightType->AsBasicType() && rightType->AsBasicType()->BaseType == BaseType::Record)
				{
					resultType = rightType;
					return true;
				}
				return false;
			}
			virtual RefPtr<ExpressionSyntaxNode> VisitBinaryExpression(BinaryExpressionSyntaxNode *expr) override
			{
				expr->LeftExpression = expr->LeftExpression->Accept(this).As<ExpressionSyntaxNode>();
				expr->RightExpression = expr->RightExpression->Accept(this).As<ExpressionSyntaxNode>();
				auto & leftType = expr->LeftExpression->Type;
				auto & rightType = expr->RightExpression->Type;
				RefPtr<ExpressionType> matchedType;
				switch (expr->Operator)
				{
				case Operator::Add:
				case Operator::Sub:
				case Operator::Div:
					if (MatchType_BinaryImplicit(matchedType, leftType, rightType))
						expr->Type = matchedType;
					else
						expr->Type = ExpressionType::Error;
					break;
				case Operator::Mul:
					if (leftType->AsBasicType() && leftType->AsBasicType()->BaseType != BaseType::Shader)
					{
						auto basicType = leftType->AsBasicType();
						if (MatchType_BinaryImplicit(matchedType, leftType, rightType))
							expr->Type = matchedType;
						else if ((basicType->BaseType == BaseType::Float3x3 && rightType->Equals(ExpressionType::Float3.Ptr())) ||
							(basicType->BaseType == BaseType::Float3 && rightType->AsBasicType() && rightType->AsBasicType()->BaseType == BaseType::Float3x3))
							expr->Type = ExpressionType::Float3;
						else if ((basicType->BaseType == BaseType::Float4x4 && rightType->Equals(ExpressionType::Float4.Ptr())) ||
							(basicType->BaseType == BaseType::Float4 && rightType->AsBasicType() && rightType->AsBasicType()->BaseType == BaseType::Float4x4))
							expr->Type = ExpressionType::Float4;
						else
							expr->Type = ExpressionType::Error;
					}
					else
						expr->Type = ExpressionType::Error;
					break;
				case Operator::Mod:
				case Operator::Rsh:
				case Operator::Lsh:
				case Operator::BitAnd:
				case Operator::BitOr:
				case Operator::BitXor:
				case Operator::And:
				case Operator::Or:
					if (leftType->Equals(rightType.Ptr()) && !leftType->IsArray() && !leftType->IsTexture()
						&& !leftType->IsShader() &&
						leftType->AsBasicType() && GetVectorBaseType(leftType->AsBasicType()->BaseType) != BaseType::Float)
						expr->Type = (expr->Operator == Operator::And || expr->Operator == Operator::Or ? ExpressionType::Bool : leftType);
					else if (leftType->IsIntegral() && rightType->IsIntegral())
						expr->Type = leftType;
					else
						expr->Type = ExpressionType::Error;
					break;
				case Operator::Neq:
				case Operator::Eql:
					if (leftType->Equals(rightType.Ptr()) && !leftType->IsArray() && !leftType->IsTexture() && !leftType->IsShader())
						expr->Type = ExpressionType::Bool;
					else if ((leftType->Equals(ExpressionType::Int.Ptr()) || leftType->Equals(ExpressionType::UInt.Ptr())) &&
						(rightType->Equals(ExpressionType::Int.Ptr()) || rightType->Equals(ExpressionType::UInt.Ptr())))
						expr->Type = ExpressionType::Bool;
					else if (leftType->IsIntegral() && rightType->IsIntegral())
						expr->Type = ExpressionType::Bool;
					else if (leftType->Equals(ExpressionType::Float.Ptr()) && rightType->IsIntegral() ||
						leftType->IsIntegral() && rightType->Equals(ExpressionType::Float.Ptr()))
						expr->Type = ExpressionType::Bool;
					else
						expr->Type = ExpressionType::Error;
					break;
				case Operator::Greater:
				case Operator::Geq:
				case Operator::Less:
				case Operator::Leq:
					if ((leftType->Equals(ExpressionType::Int.Ptr()) || leftType->Equals(ExpressionType::UInt.Ptr())) && 
						(rightType->Equals(ExpressionType::Int.Ptr()) || rightType->Equals(ExpressionType::UInt.Ptr())))
						expr->Type = ExpressionType::Bool;
					else if (leftType->Equals(ExpressionType::Float.Ptr()) && rightType->Equals(ExpressionType::Float.Ptr()))
						expr->Type = ExpressionType::Bool;
					else if (leftType->Equals(ExpressionType::Float.Ptr()) && rightType->IsIntegral() ||
						leftType->IsIntegral() && rightType->Equals(ExpressionType::Float.Ptr()))
						expr->Type = ExpressionType::Bool;
					else
						expr->Type = ExpressionType::Error;
					break;
				case Operator::Assign:
				case Operator::AddAssign:
				case Operator::MulAssign:
				case Operator::DivAssign:
				case Operator::SubAssign:
				case Operator::ModAssign:
				case Operator::AndAssign:
				case Operator::OrAssign:
				case Operator::XorAssign:
				case Operator::LshAssign:
				case Operator::RshAssign:
					if (!(leftType->AsBasicType() && leftType->AsBasicType()->IsLeftValue) && 
						!leftType->Equals(ExpressionType::Error.Ptr()))
						Error(30011, L"left of '=' is not an l-value.", expr->LeftExpression.Ptr());
					if (expr->Operator == Operator::AndAssign ||
						expr->Operator == Operator::OrAssign ||
						expr->Operator == Operator::XorAssign ||
						expr->Operator == Operator::LshAssign ||
						expr->Operator == Operator::RshAssign)
					{
						if (!(leftType->IsIntegral() && rightType->IsIntegral()))
						{
							Error(30041, L"bit operation: operand must be integral type.", expr);
						}
					}
					expr->LeftExpression->Access = ExpressionAccess::Write;
					if (MatchType_ValueReceiver(leftType.Ptr(), rightType.Ptr()))
						expr->Type = ExpressionType::Void;
					else
						expr->Type = ExpressionType::Error;
					break;
				default:
						expr->Type = ExpressionType::Error;
					break;
				}
				
				if (expr->Type->Equals(ExpressionType::Error.Ptr()) &&
					!leftType->Equals(ExpressionType::Error.Ptr()) && 
					!rightType->Equals(ExpressionType::Error.Ptr()))
					Error(30012, L"no overload found for operator " + OperatorToString(expr->Operator)  + L" (" + leftType->ToString() + L", " 
						+ rightType->ToString() + L").", expr);
				return expr;
			}
			virtual RefPtr<ExpressionSyntaxNode> VisitConstantExpression(ConstantExpressionSyntaxNode *expr) override
			{
				switch (expr->ConstType)
				{
				case ConstantExpressionSyntaxNode::ConstantType::Int:
					expr->Type = ExpressionType::Int;
					break;
				case ConstantExpressionSyntaxNode::ConstantType::Float:
					expr->Type = ExpressionType::Float;
					break;
				default:
					expr->Type = ExpressionType::Error;
					throw "Invalid constant type.";
					break;
				}
				return expr;
			}
			virtual RefPtr<ExpressionSyntaxNode> VisitIndexExpression(IndexExpressionSyntaxNode *expr) override
			{
				expr->BaseExpression = expr->BaseExpression->Accept(this).As<ExpressionSyntaxNode>();
				expr->IndexExpression = expr->IndexExpression->Accept(this).As<ExpressionSyntaxNode>();
				if (expr->BaseExpression->Type->Equals(ExpressionType::Error.Ptr()))
					expr->Type = ExpressionType::Error;
				else
				{
					if (expr->BaseExpression->Type->AsGenericType() && 
						(expr->BaseExpression->Type->AsGenericType()->GenericTypeName != L"Buffer" || expr->BaseExpression->Type->AsGenericType()->GenericTypeName != L"PackedBuffer") ||
						expr->BaseExpression->Type->AsBasicType() &&
						GetVectorSize(expr->BaseExpression->Type->AsBasicType()->BaseType) == 0)
					{
						Error(30013, L"'[]' can only index on arrays.", expr);
						expr->Type = ExpressionType::Error;
					}
					if (!expr->IndexExpression->Type->Equals(ExpressionType::Int.Ptr()) && 
						!expr->IndexExpression->Type->Equals(ExpressionType::UInt.Ptr()))
					{
						Error(30014, L"index expression must evaluate to int.", expr);
						expr->Type = ExpressionType::Error;
					}
				}
				if (expr->BaseExpression->Type->IsArray())
				{
					expr->Type = expr->BaseExpression->Type->AsArrayType()->BaseType;
				}
				else if (auto genType = expr->BaseExpression->Type->AsGenericType())
				{
					expr->Type = genType->BaseType;
				}
				else if (auto basicType = expr->BaseExpression->Type->AsBasicType())
				{
					if (basicType->BaseType == BaseType::Float3x3)
						expr->Type = ExpressionType::Float3;
					else if (basicType->BaseType == BaseType::Float4x4)
						expr->Type = ExpressionType::Float4;
					else
						expr->Type = new BasicExpressionType(GetVectorBaseType(basicType->BaseType));
				}
				expr->Type = expr->Type->Clone();
				if (auto basicType = expr->Type->AsBasicType())
				{
					basicType->IsLeftValue = true;
					basicType->IsReference = true;
				}
				return expr;
			}
			bool MatchArguments(FunctionSyntaxNode * functionNode, List <RefPtr<ExpressionSyntaxNode>> &args)
			{
				if (functionNode->Parameters.Count() != args.Count())
					return false;
				for (int i = 0; i < functionNode->Parameters.Count(); i++)
				{
					if (!functionNode->Parameters[i]->Type->Equals(args[i]->Type.Ptr()))
						return false;
				}
				return true;
			}
			virtual RefPtr<ExpressionSyntaxNode> VisitInvokeExpression(InvokeExpressionSyntaxNode *expr) override
			{
				expr->FunctionExpr->Variable = TranslateHLSLTypeNames(expr->FunctionExpr->Variable);
				for (auto & arg : expr->Arguments)
					arg = arg->Accept(this).As<ExpressionSyntaxNode>();

				// check if this is an import operator call
				if (currentShader && currentCompNode && expr->Arguments.Count() > 0)
				{
					if (auto impOpList = currentShader->Pipeline->ImportOperators.TryGetValue(expr->FunctionExpr->Variable))
					{
						// component with explicit import operator call must be qualified with explicit rate
						if (!currentCompNode->Rate)
						{
							Error(33071, L"cannot call an import operator from an auto-placed component '" + currentCompNode->Name.Content + L"'. try qualify the component with explicit worlds.",
								expr);
							expr->Type = ExpressionType::Error;
							return expr;
						}
						// for now we do not support calling import operator from a multi-world component definition
						if (currentCompNode->Rate->Worlds.Count() > 1)
							Error(33073, L"cannot call an import operator from a multi-world component definition. consider qualify the component with only one explicit world.",
								expr);
						int bestMatchConversions = 1 << 30;
						bool found = false;
						RefPtr<ImportOperatorDefSyntaxNode> func;
						for (auto & f : *impOpList)
						{
							if (f->Parameters.Count() == expr->Arguments.Count() - 1 &&
								f->DestWorld.Content == currentCompNode->Rate->Worlds.First().World.Content)
							{
								int conversions = 0;
								bool match = true;
								for (int i = 1; i < expr->Arguments.Count(); i++)
								{
									auto argType = expr->Arguments[i]->Type;
									auto paramType = f->Parameters[i - 1]->Type;
									if (argType->Equals(paramType.Ptr()))
										continue;
									else if (MatchType_ValueReceiver(paramType.Ptr(), argType.Ptr()))
									{
										conversions++;
										continue;
									}
									else
									{
										match = false;
										break;
									}
								}
								if (match && conversions < bestMatchConversions)
								{
									func = f;
									found = true;
									bestMatchConversions = conversions;
								}
							}
						}
						if (found)
						{
							RefPtr<ImportExpressionSyntaxNode> importExpr = new ImportExpressionSyntaxNode();
							importExpr->Position = expr->Position;
							importExpr->Component = expr->Arguments[0];
							CloneContext cloneCtx;
							importExpr->ImportOperatorDef = func->Clone(cloneCtx);
							importExpr->ImportOperatorDef->Scope->Parent = expr->Scope->Parent;
							importExpr->Type = expr->Arguments[0]->Type->Clone();
							importExpr->Scope = expr->Scope;
							importExpr->Access = ExpressionAccess::Read;
							for (int i = 1; i < expr->Arguments.Count(); i++)
								importExpr->Arguments.Add(expr->Arguments[i]);
							return importExpr;
						}
						else
						{
							StringBuilder argList;
							for (int i = 1; i < expr->Arguments.Count(); i++)
							{
								argList << expr->Arguments[i]->Type->ToString();
								if (i != expr->Arguments.Count() - 1)
									argList << L", ";
							}
							Error(33072, L"'" + expr->FunctionExpr->Variable + L"' is an import operator defined in pipeline '" + currentShader->Pipeline->SyntaxNode->Name.Content
								+ L"', but none of the import operator overloads matches argument list '(" +
								argList.ProduceString() + L"').",
								expr);
							expr->Type = ExpressionType::Error;
						}
						return expr;
					}
				}

				// this is not an import operator call, resolve as function call
				String funcName;
				bool found = false;
				bool functionNameFound = false;
				RefPtr<FunctionSymbol> func;
				if (expr->FunctionExpr->Variable == L"texture" && expr->Arguments.Count() > 0 &&
					expr->Arguments[0]->Type->IsGenericType(L"Buffer"))
				{
					if (expr->Arguments.Count() != 2)
					{
						expr->Type = ExpressionType::Error;
						found = false;
					}
					else
					{
						if (auto genType = expr->Arguments[0]->Type->AsGenericType())
						{
							expr->Type = genType->BaseType;
							if (!expr->Arguments[1]->Type->Equals(ExpressionType::Float2.Ptr()))
							{
								found = false;
								expr->Type = ExpressionType::Error;
							}
						}
						else
						{
							expr->Type = ExpressionType::Error;
							found = false;
						}
					}
				}
				else
				{
					// find function overload with implicit argument type conversions
					auto namePrefix = expr->FunctionExpr->Variable + L"@";
					int bestMatchConversions = 1 << 30;
					for (auto & f : symbolTable->Functions)
					{
						if (f.Key.StartsWith(namePrefix))
						{
							functionNameFound = true;
							if (f.Value->SyntaxNode->Parameters.Count() == expr->Arguments.Count())
							{
								int conversions = 0;
								bool match = true;
								for (int i = 0; i < expr->Arguments.Count(); i++)
								{
									auto argType = expr->Arguments[i]->Type;
									auto paramType = f.Value->SyntaxNode->Parameters[i]->Type;
									if (argType->Equals(paramType.Ptr()))
										continue;
									else if (MatchType_ValueReceiver(paramType.Ptr(), argType.Ptr()))
									{
										conversions++;
										continue;
									}
									else
									{
										match = false;
										break;
									}
								}
								if (match && conversions < bestMatchConversions)
								{
									func = f.Value;
									funcName = f.Key;
									found = true;
									bestMatchConversions = conversions;
								}
							}
						}
					}
				}
				if (!found)
				{
					expr->Type = ExpressionType::Error;
					StringBuilder argList;
					for (int i = 0; i < expr->Arguments.Count(); i++)
					{
						argList << expr->Arguments[i]->Type->ToString();
						if (i != expr->Arguments.Count() - 1)
							argList << L", ";
					}
					if (functionNameFound)
						Error(30021, expr->FunctionExpr->Variable + L": no overload takes arguments (" + argList.ProduceString() + L")", expr);
					else
						Error(30015, L"undefined identifier '" + expr->FunctionExpr->Variable + L"'.", expr->FunctionExpr.Ptr());

				}
				else if (func)
				{
					if (!func->SyntaxNode->IsExtern)
					{
						expr->FunctionExpr->Variable = funcName;
						if (currentFunc)
							currentFunc->ReferencedFunctions.Add(funcName);
					}
					expr->Type = func->SyntaxNode->ReturnType;
				}
				return expr;
			}

			String OperatorToString(Operator op)
			{
				switch (op)
				{
				case Spire::Compiler::Operator::Neg:
					return L"-";
				case Spire::Compiler::Operator::Not:
					return L"!";
				case Spire::Compiler::Operator::PreInc:
					return L"++";
				case Spire::Compiler::Operator::PreDec:
					return L"--";
				case Spire::Compiler::Operator::PostInc:
					return L"++";
				case Spire::Compiler::Operator::PostDec:
					return L"--";
				case Spire::Compiler::Operator::Mul:
					return L"*";
				case Spire::Compiler::Operator::Div:
					return L"/";
				case Spire::Compiler::Operator::Mod:
					return L"%";
				case Spire::Compiler::Operator::Add:
					return L"+";
				case Spire::Compiler::Operator::Sub:
					return L"-";
				case Spire::Compiler::Operator::Lsh:
					return L"<<";
				case Spire::Compiler::Operator::Rsh:
					return L">>";
				case Spire::Compiler::Operator::Eql:
					return L"==";
				case Spire::Compiler::Operator::Neq:
					return L"!=";
				case Spire::Compiler::Operator::Greater:
					return L">";
				case Spire::Compiler::Operator::Less:
					return L"<";
				case Spire::Compiler::Operator::Geq:
					return L">=";
				case Spire::Compiler::Operator::Leq:
					return L"<=";
				case Spire::Compiler::Operator::BitAnd:
					return L"&";
				case Spire::Compiler::Operator::BitXor:
					return L"^";
				case Spire::Compiler::Operator::BitOr:
					return L"|";
				case Spire::Compiler::Operator::And:
					return L"&&";
				case Spire::Compiler::Operator::Or:
					return L"||";
				case Spire::Compiler::Operator::Assign:
					return L"=";
				default:
					return L"ERROR";
				}
			}
			virtual RefPtr<ExpressionSyntaxNode> VisitUnaryExpression(UnaryExpressionSyntaxNode *expr) override
			{
				expr->Expression = expr->Expression->Accept(this).As<ExpressionSyntaxNode>();
				
				switch (expr->Operator)
				{
				case Operator::Neg:
					if (expr->Expression->Type->Equals(ExpressionType::Int.Ptr()) ||
						expr->Expression->Type->Equals(ExpressionType::Bool.Ptr()) ||
						expr->Expression->Type->Equals(ExpressionType::Float.Ptr()) ||
						expr->Expression->Type->IsVectorType())
						expr->Type = expr->Expression->Type;
					else
						expr->Type = ExpressionType::Error;
					break;
				case Operator::Not:
				case Operator::BitNot:
					if (expr->Expression->Type->Equals(ExpressionType::Int.Ptr()) || expr->Expression->Type->Equals(ExpressionType::Bool.Ptr()) ||
						expr->Expression->Type->Equals(ExpressionType::Int2.Ptr())
						|| expr->Expression->Type->Equals(ExpressionType::Int3.Ptr()) || expr->Expression->Type->Equals(ExpressionType::Int4.Ptr()))
						expr->Type = (expr->Operator == Operator::Not ? ExpressionType::Bool : expr->Expression->Type);
					else
						expr->Type = ExpressionType::Error;
					break;
				case Operator::PostDec:
				case Operator::PostInc:
				case Operator::PreDec:
				case Operator::PreInc:
					if (expr->Expression->Type->Equals(ExpressionType::Int.Ptr()))
						expr->Type = ExpressionType::Int;
					else
						expr->Type = ExpressionType::Error;
					break;
				default:
					expr->Type = ExpressionType::Error;
					break;
				}

				if(expr->Type->Equals(ExpressionType::Error.Ptr()) && !expr->Expression->Type->Equals(ExpressionType::Error.Ptr()))
					Error(30020, L"operator " + OperatorToString(expr->Operator) + L" can not be applied to " + expr->Expression->Type->ToString(), expr);
				return expr;
			}
			virtual RefPtr<ExpressionSyntaxNode> VisitVarExpression(VarExpressionSyntaxNode *expr) override
			{
				VariableEntry variable;
				ShaderUsing shaderObj;
				expr->Type = ExpressionType::Error;
				if (expr->Scope->FindVariable(expr->Variable, variable))
				{
					expr->Type = variable.Type.DataType->Clone();
					if (auto basicType = expr->Type->AsBasicType())
						basicType->IsLeftValue = !variable.IsComponent;
				}
				else if (currentShader && currentShader->ShaderObjects.TryGetValue(expr->Variable, shaderObj))
				{
					auto basicType = new BasicExpressionType(BaseType::Shader);
					basicType->Shader = shaderObj.Shader;
					basicType->IsLeftValue = false;
					expr->Type = basicType;
				}
				else if (currentPipeline && currentImportOperator)
				{
					RefPtr<ShaderComponentSymbol> comp;
					if (currentPipeline->Components.TryGetValue(expr->Variable, comp))
					{
						currentImportOperator->Usings.Add(comp->Name);
						expr->Type = comp->Type->DataType;
					}
					else
						Error(30015, L"undefined identifier \'" + expr->Variable + L"\'", expr);
				}
				else if (currentShader)
				{
					auto compRef = currentShader->ResolveComponentReference(expr->Variable);
					if (compRef.IsAccessible)
					{
						expr->Type = compRef.Component->Type->DataType->Clone();
						if (auto basicType = expr->Type->AsBasicType())
							basicType->IsLeftValue = false;
					}
					else if (compRef.Component)
					{
						Error(30017, L"component \'" + expr->Variable + L"\' is not accessible from shader '" + currentShader->SyntaxNode->Name.Content + L"'.", expr);
					}
					else
						Error(30015, L"undefined identifier \'" + expr->Variable + L"\'", expr);
				}
				else
					Error(30015, L"undefined identifier \'" + expr->Variable + L"\'", expr);

				if (expr->Type->IsGenericType(L"Uniform") || expr->Type->IsGenericType(L"Patch"))
					expr->Type = expr->Type->AsGenericType()->BaseType;

				return expr;
			}
			virtual RefPtr<ExpressionSyntaxNode> VisitTypeCastExpression(TypeCastExpressionSyntaxNode * expr) override
			{
				expr->Expression = expr->Expression->Accept(this).As<ExpressionSyntaxNode>();
				auto targetType = TranslateTypeNode(expr->TargetType);
				
				if (!expr->Expression->Type->Equals(ExpressionType::Error.Ptr()) && targetType->AsBasicType())
				{
					if (!expr->Expression->Type->AsBasicType())
						expr->Type = ExpressionType::Error;
					else if (!IsNumeric(GetVectorBaseType(expr->Expression->Type->AsBasicType()->BaseType)) 
						|| !IsNumeric(GetVectorBaseType(targetType->AsBasicType()->BaseType)))
						expr->Type = ExpressionType::Error;
					else if (targetType->AsBasicType()->BaseType == BaseType::Void || expr->Expression->Type->AsBasicType()->BaseType == BaseType::Void)
						expr->Type = ExpressionType::Error;
					else
						expr->Type = targetType;
				}
				else
					expr->Type = ExpressionType::Error;
				if (expr->Type->Equals(ExpressionType::Error.Ptr()) && !expr->Expression->Type->Equals(ExpressionType::Error.Ptr()))
				{
					Error(30022, L"invalid type cast between \"" + expr->Expression->Type->ToString() + L"\" and \"" +
						targetType->ToString() + L"\".", expr);
				}
				return expr;
			}
			virtual RefPtr<ExpressionSyntaxNode> VisitSelectExpression(SelectExpressionSyntaxNode * expr) override
			{
				expr->SelectorExpr = expr->SelectorExpr->Accept(this).As<ExpressionSyntaxNode>();
				if (!expr->SelectorExpr->Type->Equals(ExpressionType::Int.Ptr()) && !expr->SelectorExpr->Type->Equals(ExpressionType::Bool.Ptr()) 
					&& !expr->SelectorExpr->Type->Equals(ExpressionType::Error.Ptr()))
				{
					expr->Type = ExpressionType::Error;
					Error(30079, L"selector must evaluate to int.", expr);
				}
				expr->Expr0 = expr->Expr0->Accept(this).As<ExpressionSyntaxNode>();
				expr->Expr1 = expr->Expr1->Accept(this).As<ExpressionSyntaxNode>();
				if (expr->Expr0->Type != expr->Expr1->Type)
				{
					Error(30080, L"the two value expressions in a select clause must evaluate to same type.", expr);
				}
				expr->Type = expr->Expr0->Type;
				return expr;
			}
			virtual RefPtr<ExpressionSyntaxNode> VisitMemberExpression(MemberExpressionSyntaxNode * expr) override
			{
				expr->BaseExpression = expr->BaseExpression->Accept(this).As<ExpressionSyntaxNode>();
				auto & baseType = expr->BaseExpression->Type;
				if (!baseType->AsBasicType())
					expr->Type = ExpressionType::Error;
				else if (IsVector(baseType->AsBasicType()->BaseType))
				{
					Array<int, 4> children;
					if (expr->MemberName.Length() > 4)
						expr->Type = ExpressionType::Error;
					else
					{
						bool error = false;

						for (int i = 0; i < expr->MemberName.Length(); i++)
						{
							auto ch = expr->MemberName[i];
							switch (ch)
							{
							case L'x':
							case L'r':
								children.Add(0);
								break;
							case L'y':
							case L'g':
								children.Add(1);
								break;
							case L'z':
							case L'b':
								children.Add(2);
								break;
							case L'w':
							case L'a':
								children.Add(3);
								break;
							default:
								error = true;
								expr->Type = ExpressionType::Error;
								break;
							}
						}
						int vecLen = GetVectorSize(baseType->AsBasicType()->BaseType);
						for (auto m : children)
						{
							if (m >= vecLen)
							{
								error = true;
								expr->Type = ExpressionType::Error;
								break;
							}
						}
						if ((vecLen == 9 || vecLen == 16) && children.Count() > 1)
						{
							error = true;
							expr->Type = ExpressionType::Error;
						}
						if (!error)
						{
							if (vecLen == 9)
								expr->Type = new BasicExpressionType((BaseType)((int)GetVectorBaseType(baseType->AsBasicType()->BaseType) + 2));
							else if (vecLen == 16)
								expr->Type = new BasicExpressionType((BaseType)((int)GetVectorBaseType(baseType->AsBasicType()->BaseType) + 3));
							else
							{
								expr->Type = new BasicExpressionType((BaseType)((int)GetVectorBaseType(baseType->AsBasicType()->BaseType) + children.Count() - 1));
							}
						}
						if (auto bt = expr->Type->AsBasicType())
							bt->IsLeftValue = true;
					}
				}
				else if (baseType->AsBasicType()->BaseType == BaseType::Shader)
				{
					ShaderUsing shaderObj;
					auto refComp = baseType->AsBasicType()->Shader->ResolveComponentReference(expr->MemberName);
					if (refComp.IsAccessible)
						expr->Type = refComp.Component->Type->DataType;
					else if (baseType->AsBasicType()->Shader->ShaderObjects.TryGetValue(expr->MemberName, shaderObj))
					{
						if (shaderObj.IsPublic)
						{
							auto shaderType = new BasicExpressionType(BaseType::Shader);
							shaderType->Shader = shaderObj.Shader;
							expr->Type = shaderType;
						}
						else
							expr->Type = ExpressionType::Error;
					}
					else
						expr->Type = ExpressionType::Error;
				}
				else if (baseType->IsStruct())
				{
					int id = baseType->AsBasicType()->Struct->SyntaxNode->FindField(expr->MemberName);
					if (id == -1)
					{
						expr->Type = ExpressionType::Error;
						Error(30027, L"\'" + expr->MemberName + L"\' is not a member of \'" +
							baseType->AsBasicType()->Struct->Name + L"\'.", expr);
					}
					else
						expr->Type = baseType->AsBasicType()->Struct->SyntaxNode->Fields[id]->Type;
				}
				else
					expr->Type = ExpressionType::Error;
				if (!baseType->Equals(ExpressionType::Error.Ptr()) &&
					expr->Type->Equals(ExpressionType::Error.Ptr()))
				{
					Error(30023, L"\"" + baseType->ToString() + L"\" does not have public member \"" +
						expr->MemberName + L"\".", expr);
				}
				return expr;
			}
			SemanticsVisitor & operator = (const SemanticsVisitor &) = delete;
		};

		SyntaxVisitor * CreateSemanticsVisitor(SymbolTable * symbols, ErrorWriter * err)
		{
			return new SemanticsVisitor(symbols, err);
		}
		
	}
}

/***********************************************************************
CORE\SHADERCOMPILER.CPP
***********************************************************************/
// Compiler.cpp : Defines the entry point for the console application.
//

#ifdef CreateDirectory
#undef CreateDirectory
#endif

using namespace CoreLib::Basic;
using namespace CoreLib::IO;
using namespace Spire::Compiler;

namespace Spire
{
	namespace Compiler
	{
		int compilerInstances = 0;

		class ShaderCompilerImpl : public ShaderCompiler
		{
		private:
			Dictionary<String, RefPtr<CodeGenBackend>> backends;

			void ResolveAttributes(SymbolTable * symTable)
			{
				for (auto & shader : symTable->ShaderDependenceOrder)
				{
					auto comps = shader->GetComponentDependencyOrder();
					for (auto & comp : comps)
					{
						for (auto & impl : comp->Implementations)
							for (auto & attrib : impl->SyntaxNode->LayoutAttributes)
							{
								try
								{
									if (attrib.Value.StartsWith(L"%"))
									{
										CoreLib::Text::Parser parser(attrib.Value.SubString(1, attrib.Value.Length() - 1));
										auto compName = parser.ReadWord();
										parser.Read(L".");
										auto compAttrib = parser.ReadWord();
										RefPtr<ShaderComponentSymbol> compSym;
										if (shader->Components.TryGetValue(compName, compSym))
										{
											for (auto & timpl : compSym->Implementations)
											{
												String attribValue;
												if (timpl->SyntaxNode->LayoutAttributes.TryGetValue(compAttrib, attribValue))
													attrib.Value = attribValue;
											}
										}
									}
								}
								catch (Exception)
								{
								}
							}
					}
				}
			}

			/* Generate a shader variant by applying mechanic choice rules and the choice file.
			   The choice file provides "preferred" definitions, as represented in ShaderComponentSymbol::Type::PinnedWorlds
		       The process resolves the component references by picking a pinned definition if one is available, or a definition
			   with the preferred import path as defined by import operator ordering.
			   After all references are resolved, all unreferenced definitions (dead code) are eliminated, 
			   resulting a shader variant ready for code generation.
			*/
			RefPtr<ShaderIR> GenerateShaderVariantIR(CompileResult & cresult, ShaderClosure * shader, Schedule & schedule)
			{
				RefPtr<ShaderIR> result = new ShaderIR();
				result->Shader = shader;
				// mark pinned worlds
				for (auto & comp : shader->Components)
				{
					for (auto & impl : comp.Value->Implementations)
					{
						for (auto & w : impl->Worlds)
						{
							if (impl->SrcPinnedWorlds.Contains(w) || impl->SyntaxNode->IsInline || impl->ExportWorlds.Contains(w) || impl->SyntaxNode->IsInput)
							{
								comp.Value->Type->PinnedWorlds.Add(w);
							}
						}
					}
				}
				// apply choices
				Dictionary<String, ShaderComponentSymbol*> choiceComps;
				for (auto & comp : shader->AllComponents)
				{
					for (auto & choiceName : comp.Value->ChoiceNames)
						choiceComps[choiceName] = comp.Value;
				}
				HashSet<ShaderComponentImplSymbol*> pinnedImpl;
				for (auto & choice : schedule.Choices)
				{
					ShaderComponentSymbol * comp = nullptr;
					if (choiceComps.TryGetValue(choice.Key, comp))
					{
						comp->Type->PinnedWorlds.Clear();
						for (auto & selectedDef : choice.Value)
						{
							if (comp->Type->ConstrainedWorlds.Contains(selectedDef->WorldName))
							{
								comp->Type->PinnedWorlds.Add(selectedDef->WorldName);
								// find specified impl
								for (auto & impl : comp->Implementations)
								{
									if (impl->AlternateName == selectedDef->AlternateName && impl->Worlds.Contains(selectedDef->WorldName))
										pinnedImpl.Add(impl.Ptr());
								}
							}
							else
							{
								cresult.GetErrorWriter()->Warning(33101, L"'" + selectedDef->WorldName + L"' is not a valid choice for '" + choice.Key
									+ L"'.", selectedDef.Ptr()->Position);
							}
						}
					}
				}
				for (auto & attribs : schedule.AddtionalAttributes)
				{
					ShaderComponentSymbol * comp = nullptr;
					if (choiceComps.TryGetValue(attribs.Key, comp))
					{
						// apply attributes
						for (auto & impl : comp->Implementations)
						{
							for (auto & attrib : attribs.Value)
								impl->SyntaxNode->LayoutAttributes[attrib.Key] = attrib.Value;
						}
					}
				}
				// generate definitions
				for (auto & comp : shader->AllComponents)
				{
					EnumerableDictionary<String, ComponentDefinitionIR*> defs;
					Dictionary<String, ShaderComponentImplSymbol*> impls;
					for (auto & impl : comp.Value->Implementations)
					{
						for (auto & w : impl->Worlds)
						{
							RefPtr<ComponentDefinitionIR> def = new ComponentDefinitionIR();
							def->OriginalName = comp.Value->Name;
							def->UniqueKey = comp.Value->UniqueKey;
							def->UniqueName = comp.Value->UniqueName;
							def->Type = comp.Value->Type->DataType;
							def->IsEntryPoint = (impl->ExportWorlds.Contains(w) ||
								(shader->Pipeline->IsAbstractWorld(w) &&
								(impl->SyntaxNode->LayoutAttributes.ContainsKey(L"Pinned") || shader->Pipeline->Worlds[w]().SyntaxNode->LayoutAttributes.ContainsKey(L"Pinned"))));
							CloneContext cloneCtx;
							def->SyntaxNode = impl->SyntaxNode->Clone(cloneCtx);
							def->World = w;
							result->Definitions.Add(def);
							bool existingDefIsPinned = false;
							if (defs.ContainsKey(w))
								existingDefIsPinned = pinnedImpl.Contains(impls[w]());
							if (!existingDefIsPinned)
							{
								defs[w] = def.Ptr();
								impls[w] = impl.Ptr();
							}
						}
					}
					result->DefinitionsByComponent[comp.Key] = defs;
				}
				bool changed = true;
				while (changed)
				{
					changed = false;
					result->ResolveComponentReference();
					result->EliminateDeadCode();
					// check circular references
					for (auto & def : result->Definitions)
					{
						if (def->Dependency.Contains(def.Ptr()))
						{
							cresult.GetErrorWriter()->Error(33102, L"component definition \'" + def->OriginalName + L"\' involves circular reference.",
								def->SyntaxNode->Position);
							return nullptr;
						}
					}
					/*
					// eliminate redundant (downstream) definitions, one at a time
					auto comps = result->GetComponentDependencyOrder();
					for (int i = comps.Count() - 1; i >= 0; i--)
					{
						auto comp = comps[i];
						auto & defs = result->DefinitionsByComponent[comp->UniqueName]();
						EnumerableHashSet<ComponentDefinitionIR*> removedDefs;
						for (auto & def : defs)
							if (!def.Value->IsEntryPoint && !comp->Type->PinnedWorlds.Contains(def.Value->World))
							{
								for (auto & otherDef : defs)
								{
									if (otherDef.Value != def.Value && !removedDefs.Contains(otherDef.Value)
										&& shader->Pipeline->IsWorldReachable(otherDef.Value->World, def.Value->World))
									{
										removedDefs.Add(def.Value);
										break;
									}
								}
							}
						if (removedDefs.Count())
						{
							result->RemoveDefinitions([&](ComponentDefinitionIR* def) {return removedDefs.Contains(def); });
							changed = true;
						}
					}
					*/
				}
				return result;
			}
		public:
			virtual CompileUnit Parse(CompileResult & result, String source, String fileName) override
			{
				result.Success = false;
				Lexer lexer;
				auto tokens = lexer.Parse(fileName, source, result.ErrorList);
				Parser parser(tokens, result.ErrorList, fileName);
				CompileUnit rs;
				rs.SyntaxNode = parser.Parse();
				return rs;
			}
			virtual void Compile(CompileResult & result, List<CompileUnit> & units, const CompileOptions & options) override
			{
				result.Success = false;
				RefPtr<ProgramSyntaxNode> programSyntaxNode = new ProgramSyntaxNode();
				for (auto & unit : units)
				{
					programSyntaxNode->Include(unit.SyntaxNode.Ptr());
				}

				SymbolTable symTable;
				RefPtr<SyntaxVisitor> visitor = CreateSemanticsVisitor(&symTable, result.GetErrorWriter());
				try
				{
					programSyntaxNode->Accept(visitor.Ptr());
					visitor = nullptr;
					if (result.ErrorList.Count() > 0)
						return;
					symTable.EvalFunctionReferenceClosure();
					if (result.ErrorList.Count() > 0)
						return;
					List<RefPtr<ShaderClosure>> shaderClosures;

					for (auto & shader : symTable.ShaderDependenceOrder)
					{
						if (shader->IsAbstract)
							continue;
						auto shaderClosure = CreateShaderClosure(result.GetErrorWriter(), &symTable, shader);
						FlattenShaderClosure(result.GetErrorWriter(), shaderClosure.Ptr());
						shaderClosures.Add(shaderClosure);
					}
					
					ResolveAttributes(&symTable);

					if (result.ErrorList.Count() > 0)
						return;
					CodeGenBackend * backend = nullptr;
					if (options.Target == CodeGenTarget::SPIRV)
						backend = backends[L"spirv"]().Ptr();
					else
						backend = backends[L"glsl"]().Ptr();

					Schedule schedule;
					if (options.ScheduleSource != L"")
					{
						schedule = Schedule::Parse(options.ScheduleSource, options.ScheduleFileName, result.ErrorList);
					}
					for (auto shader : shaderClosures)
					{
						// generate shader variant from schedule file, and also apply mechanic deduction rules
						shader->IR = GenerateShaderVariantIR(result, shader.Ptr(), schedule);
					}
					if (options.Mode == CompilerMode::ProduceShader)
					{
						if (result.ErrorList.Count() > 0)
							return;
						// generate IL code
						RefPtr<ICodeGenerator> codeGen = CreateCodeGenerator(&symTable, result);
						for (auto & s : programSyntaxNode->Structs)
							codeGen->ProcessStruct(s.Ptr());
						for (auto & func : programSyntaxNode->Functions)
							codeGen->ProcessFunction(func.Ptr());
						for (auto & shader : shaderClosures)
						{
							InsertImplicitImportOperators(shader->IR.Ptr());
						}
						if (result.ErrorList.Count() > 0)
							return;
						for (auto & shader : shaderClosures)
						{
							codeGen->ProcessShader(shader->IR.Ptr());
						}
						if (result.ErrorList.Count() > 0)
							return;
						// emit target code
						EnumerableHashSet<String> symbolsToGen;
						for (auto & unit : units)
						{
							for (auto & shader : unit.SyntaxNode->Shaders)
								if (!shader->IsModule)
									symbolsToGen.Add(shader->Name.Content);
							for (auto & func : unit.SyntaxNode->Functions)
								symbolsToGen.Add(func->Name);
						}
						auto IsSymbolToGen = [&](String & shaderName)
						{
							if (symbolsToGen.Contains(shaderName))
								return true;
							for (auto & symbol : symbolsToGen)
								if (shaderName.StartsWith(symbol))
									return true;
							return false;
						};
						ErrorWriter errWriter(result.ErrorList, result.WarningList);
						for (auto & shader : result.Program->Shaders)
						{
							if ((options.SymbolToCompile.Length() == 0 && IsSymbolToGen(shader->Name))
								|| options.SymbolToCompile == shader->Name)
							{
								StringBuilder glslBuilder;
								Dictionary<String, String> targetCode;
								result.CompiledSource[shader->Name] = backend->GenerateShader(result, &symTable, shader.Ptr(), &errWriter);
							}
						}
						result.Success = result.ErrorList.Count() == 0;
					}
					else if (options.Mode == CompilerMode::GenerateChoice)
					{
						for (auto shader : shaderClosures)
						{
							if (options.SymbolToCompile.Length() == 0 || shader->Name == options.SymbolToCompile)
							{
								auto &worldOrder = shader->Pipeline->GetWorldTopologyOrder();
								for (auto & comp : shader->AllComponents)
								{
									ShaderChoice choice;
									if (comp.Value->ChoiceNames.Count() == 0)
										continue;
									if (comp.Value->IsParam())
										continue;
									choice.ChoiceName = comp.Value->ChoiceNames.First();
									for (auto & impl : comp.Value->Implementations)
									{
										for (auto w : impl->Worlds)
											if (comp.Value->Type->ConstrainedWorlds.Contains(w))
												choice.Options.Add(ShaderChoiceValue(w, impl->AlternateName));
									}
									if (auto defs = shader->IR->DefinitionsByComponent.TryGetValue(comp.Key))
									{
										int latestWorldOrder = -1;
										for (auto & def : *defs)
										{
											int order = worldOrder.IndexOf(def.Key);
											if (latestWorldOrder < order)
											{
												choice.DefaultValue = def.Key;
												latestWorldOrder = order;
											}
										}
									}
									result.Choices.Add(choice);
								}
							}
						}
					}
					else
					{
						result.GetErrorWriter()->Error(2, L"unsupported compiler mode.", CodePosition());
						return;
					}
					result.Success = true;
				}
				catch (int)
				{
				}
				catch (...)
				{
					throw;
				}
				return;
			}

			ShaderCompilerImpl()
			{
				if (compilerInstances == 0)
				{
					BasicExpressionType::Init();
				}
				compilerInstances++;
				backends.Add(L"glsl", CreateGLSLCodeGen());
				//backends.Add(L"spirv", CreateSpirVCodeGen());
			}

			~ShaderCompilerImpl()
			{
				compilerInstances--;
				if (compilerInstances == 0)
				{
					BasicExpressionType::Finalize();
				}
			}
		};

		ShaderCompiler * CreateShaderCompiler()
		{
			return new ShaderCompilerImpl();
		}

	}
}

/***********************************************************************
CORE\SPIRVCODEGEN.CPP
***********************************************************************/
#include <vector>
#include <fstream>

using namespace CoreLib::Basic;

namespace Spire
{
	namespace Compiler
	{

		enum class ExecutionModel
		{
			Invalid = 777,
			Vertex = 0,
			TessellationControl = 1,
			TessellationEvaluation = 2,
			Geometry = 3,
			Fragment = 4,
			GLCompute = 5,
			Kernel = 6
		};

		String ExecutionModelToString(ExecutionModel em)
		{
			switch (em)
			{
			case ExecutionModel::Invalid:
				return L"invalid";
			case ExecutionModel::Vertex:
				return L"Vertex";
			case ExecutionModel::TessellationControl:
				return L"TessellationControl";
			case ExecutionModel::TessellationEvaluation:
				return L"TessellationEvaluation";
			case ExecutionModel::Geometry:
				return L"Geometry";
			case ExecutionModel::Fragment:
				return L"Fragment";
			case ExecutionModel::GLCompute:
				return L"GLCompute";
			case ExecutionModel::Kernel:
				return L"Kernel";
			default:
				throw NotImplementedException(L"unknown ExecutionModel");
			}
		}

		enum class ExecutionMode
		{
			Invalid = 777,
			Invocations = 0,
			PixelCenterInteger = 6,
			OriginUpperLeft = 7,
			OriginLowerLeft = 8,
			EarlyFragmentTests = 9,
			DepthReplacing = 12,
			DepthGreater = 14,
			DepthLess = 15,
			DepthUnchanged = 16,
			LocalSize = 17
		};

		String ExecutionModeToString(ExecutionMode em)
		{
			switch (em)
			{
			case ExecutionMode::Invalid:
				return L"invalid";
			case ExecutionMode::Invocations:
				return L"Invocations";
			case ExecutionMode::PixelCenterInteger:
				return L"PixelCenterInteger";
			case ExecutionMode::OriginUpperLeft:
				return L"OriginUpperLeft";
			case ExecutionMode::OriginLowerLeft:
				return L"OriginLowerLeft";
			case ExecutionMode::EarlyFragmentTests:
				return L"EarlyFragmentTests";
			case ExecutionMode::DepthReplacing:
				return L"DepthReplacing";
			case ExecutionMode::DepthGreater:
				return L"DepthGreater";
			case ExecutionMode::DepthLess:
				return L"DepthLess";
			case ExecutionMode::DepthUnchanged:
				return L"DepthUnchanged";
			case ExecutionMode::LocalSize:
				return L"LocalSize";
			default:
				throw NotImplementedException(L"unknown ExecutionMode");
			}
		}

		enum class StorageClass
		{
			Invalid = 777,
			UniformConstant = 0,
			Input = 1,
			Uniform = 2,
			Output = 3,
			Workgroup = 4,
			CrossWorkGroup = 5,
			Private = 6,
			Function = 7,
			Generic = 8,
			PushConstant = 9,
			AtomicCounter = 10,
			Image = 11
		};

		String StorageClassToString(StorageClass store)
		{
			switch (store)
			{
			case StorageClass::UniformConstant:
				return L"UniformConstant";
			case StorageClass::Input:
				return L"Input";
			case StorageClass::Uniform:
				return L"Uniform";
			case StorageClass::Output:
				return L"Output";
			case StorageClass::Workgroup:
				return L"Workgroup";
			case StorageClass::CrossWorkGroup:
				return L"CrossWorkGroup";
			case StorageClass::Private:
				return L"Private";
			case StorageClass::Function:
				return L"Function";
			case StorageClass::Generic:
				return L"Generic";
			case StorageClass::PushConstant:
				return L"PushConstant";
			case StorageClass::AtomicCounter:
				return L"AtomicCounter";
			case StorageClass::Image:
				return L"Image";
			default:
				throw NotImplementedException(L"Unknown StorageClass: ");
			}
		}

		enum class MemoryAccess
		{
			None = 0, //0x0
			Volatile = 1, //0x1
			Aligned = 2, //0x2
			Nontemporal = 4 //0x4
		};

		String MemoryAccessToString(MemoryAccess ma)
		{
			switch (ma)
			{
			case MemoryAccess::None:
				return L"None";
			case MemoryAccess::Volatile:
				return L"Volatile";
			case MemoryAccess::Aligned:
				return L"Aligned";
			case MemoryAccess::Nontemporal:
				return L"Nontemporal";
			default:
				throw NotImplementedException(L"Unknown MemoryAccess");
			}
		}

		enum class Decoration
		{
			Invalid = 777,
			Block = 2,
			BufferBlock = 3,
			RowMajor = 4,
			ColMajor = 5,
			ArrayStride = 6,
			MatrixStride = 7,
			BuiltIn = 11,
			Flat = 14,
			Constant = 22,
			Location = 30,
			Component = 31,
			Index = 32,
			Binding = 33,
			DescriptorSet = 34,
			Offset = 35
		};

		String DecorationToString(Decoration d)
		{
			switch (d)
			{
			case Decoration::Invalid:
				return L"invalid";
			case Decoration::Block:
				return L"Block";
			case Decoration::BufferBlock:
				return L"BufferBlock";
			case Decoration::RowMajor:
				return L"RowMajor";
			case Decoration::ColMajor:
				return L"ColMajor";
			case Decoration::ArrayStride:
				return L"ArrayStride";
			case Decoration::MatrixStride:
				return L"MatrixStride";
			case Decoration::BuiltIn:
				return L"BuiltIn";
			case Decoration::Flat:
				return L"Flat";
			case Decoration::Constant:
				return L"Constant";
			case Decoration::Location:
				return L"Location";
			case Decoration::Component:
				return L"Component";
			case Decoration::Index:
				return L"Index";
			case Decoration::Binding:
				return L"Binding";
			case Decoration::DescriptorSet:
				return L"DescriptorSet";
			case Decoration::Offset:
				return L"Offset";
			default:
				throw NotImplementedException(L"unknown Decoration");
			}
		}

		enum class BuiltIn
		{
			Invalid = 777,
			Position = 0,
			PointSize = 1,
			ClipDistance = 3,
			CullDistance = 4,
			FragDepth = 22,
			WorkgroupSize = 25,
			GlobalInvocationId = 28
		};

		String BuiltinToString(BuiltIn b)
		{
			switch (b)
			{
			case BuiltIn::Invalid:
				return L"invalid";
			case BuiltIn::Position:
				return L"Position";
			case BuiltIn::PointSize:
				return L"PointSize";
			case BuiltIn::ClipDistance:
				return L"ClipDistance";
			case BuiltIn::CullDistance:
				return L"CullDistance";
			case BuiltIn::FragDepth:
				return L"FragDepth";
			case BuiltIn::WorkgroupSize:
				return L"WorkgroupSize";
			case BuiltIn::GlobalInvocationId:
				return L"GlobalInvocationId";
			default:
				throw NotImplementedException(L"unknown Builtin");
			}
		}

		enum class Dim
		{
			e1D = 0,
			e2D = 1,
			e3D = 2,
			eCube = 3,
			eRect = 4,
			eBuffer = 5,
			eSubpassData = 6
		};

		String DimToString(Dim b)
		{
			switch (b)
			{
			case Dim::e1D:
				return L"1D";
			case Dim::e2D:
				return L"2D";
			case Dim::e3D:
				return L"3D";
			case Dim::eCube:
				return L"Cube";
			case Dim::eRect:
				return L"Rect";
			case Dim::eBuffer:
				return L"Buffer";
			case Dim::eSubpassData:
				return L"SubpassData";
			default:
				throw NotImplementedException(L"unknown Builtin");
			}
		}

		enum class ImageOperands
		{
			None = 0,
			Bias = 0x1,
			Lod = 0x2,
			Grad = 0x4,
			ConstOffset = 0x8,
			Offset = 0x10,
			ConstOffsets = 0x20,
			Sample = 0x40,
			MinLod = 0x80
		};

		String ImageOperandsToString(ImageOperands io)
		{
			switch (io)
			{
			case ImageOperands::None:
				return L"None";
			case ImageOperands::Bias:
				return L"Bias";
			case ImageOperands::Lod:
				return L"Lod";
			case ImageOperands::Grad:
				return L"Grad";
			case ImageOperands::ConstOffset:
				return L"ConstOffset";
			case ImageOperands::Offset:
				return L"Offset";
			case ImageOperands::ConstOffsets:
				return L"ConstOffsets";
			case ImageOperands::Sample:
				return L"Sample";
			case ImageOperands::MinLod:
				return L"MinLod";
			default:
				throw NotImplementedException(L"unknown Image Operands");
			}
		}

		Dictionary<String, int> GenGLSLstd450InstructionSet()
			//https://www.khronos.org/registry/spir-v/specs/1.0/GLSL.std.450.html
		{
			Dictionary<String, int> ret;

			ret[L"abs"] = 4;	//fabs, actually :(
			ret[L"sign"] = 6;	//fsign, actually :(
			ret[L"floor"] = 8;
			ret[L"ceil"] = 9;
			ret[L"fract"] = 10;
			ret[L"sin"] = 13;
			ret[L"cos"] = 14;
			ret[L"tan"] = 15;
			ret[L"asin"] = 16;
			ret[L"acos"] = 17;
			ret[L"atan"] = 18;
			ret[L"atan2"] = 25;
			ret[L"pow"] = 26;
			ret[L"exp"] = 27;
			ret[L"log"] = 28;
			ret[L"exp2"] = 29;
			ret[L"log2"] = 30;

			ret[L"sqrt"] = 31;

			ret[L"min"] = 37;
			ret[L"max"] = 40;
			ret[L"clamp"] = 43;

			ret[L"mix"] = 46;

			ret[L"step"] = 48;
			ret[L"smoothstep"] = 49;

			ret["length"] = 66;

			ret[L"cross"] = 68;
			ret[L"normalize"] = 69;

			ret[L"reflect"] = 71;
			ret[L"refract"] = 72;

			return ret;
		}

		String GetFuncOriginalName(const String & name)
		{
			String originalName;
			int splitPos = name.IndexOf(L'@');
			if (splitPos == 0)
				return name;
			if (splitPos != -1)
				originalName = name.SubString(0, splitPos);
			else
				originalName = name;
			return originalName;
		}

		String SpirVFloatToString(float v)
		{
			String rs(v, L"%.12e");
			if (!rs.Contains(L'.') && !rs.Contains(L'e') && !rs.Contains(L'E'))
				rs = rs + L".0";
			return rs;
		};

		String SpirVUIntToString(unsigned int i)
		{
			String s;
			if (i >> 31)
				s = s + L"1";
			s = s + int(i & 0x7fffffff);
			return s;
		}

		RefPtr<ILType> GetTypeFromString(String s)
		{
			CoreLib::Text::Parser parser(s);
			return TypeFromString(parser);
		}

		//UniformOrBuffer - 0: none; 1: uniform; 2: buffer 
		int GetBaseAlignment(ILType* Type, int UniformOrBuffer)
		{
			auto RoundUpTo = [](int x, int r)
			{
				if (x%r)
					x += r - x%r;
				return x;
			};
			if (auto basicType = dynamic_cast<ILBasicType*>(Type))
			{
				return Type->GetAlignment();
			}
			else if (auto arrayType = dynamic_cast<ILArrayType*>(Type))
			{
				int elementAlignment = GetBaseAlignment(arrayType->BaseType.Ptr(), UniformOrBuffer);
				if (UniformOrBuffer == 1)
					elementAlignment = RoundUpTo(elementAlignment, 16);
				return elementAlignment;
			}
			else if (auto structType = dynamic_cast<ILStructType*>(Type))
			{
				int maxAlignment = -1;
				for (auto &member : structType->Members)
				{
					int memberAlignment = GetBaseAlignment(member.Type.Ptr(), UniformOrBuffer);
					maxAlignment = std::max(maxAlignment, memberAlignment);
				}
				if (UniformOrBuffer == 1)
					maxAlignment = RoundUpTo(maxAlignment, 16);
				return maxAlignment;
			}
			return -1;
		}

		int GetSize(ILType* Type, int UniformOrBuffer)
		{
			auto RoundUpTo = [](int x, int r)
			{
				if (x%r)
					x += r - x%r;
				return x;
			};

			if (auto basicType = dynamic_cast<ILBasicType*>(Type))
			{
				return Type->GetSize();
			}
			else if (auto arrayType = dynamic_cast<ILArrayType*>(Type))
			{
				return GetSize(arrayType->BaseType.Ptr(), UniformOrBuffer) * arrayType->ArrayLength;
			}
			else if (auto structType = dynamic_cast<ILStructType*>(Type))
			{
				int rs = 0;
				for (auto &member : structType->Members)
				{
					int memberAlignment = GetBaseAlignment(member.Type.Ptr(), UniformOrBuffer);
					rs = RoundUpTo(rs, memberAlignment);
					rs += GetSize(member.Type.Ptr(), UniformOrBuffer);
				}
				return rs;
			}
			return 0;
		}

		enum class IDClass
		{
			None,
			TypeofValue,
			TypeofPointer,
			Pointer,
			Value,
			Function
		};

		class IDInfo
		{
		private:
			bool available;
			IDClass idClass;
			int ID;
			String variableName; // only available for Class:Pointer
			String typeName;
			int typeID;
			int baseTypeID;
			RefPtr<ILType> typeIL;
			StorageClass store;
			CompiledFunction * func = nullptr;
			ILOperand *op;
		public:
			IDInfo()
				:available(false)
			{
			}

			//
			static IDInfo CreateIDInfoForTypeofValue(int ID, RefPtr<ILType> typeIL, int UniformOrBuffer = 0)
			{
				IDInfo ret;
				ret.available = true;
				ret.idClass = IDClass::TypeofValue;
				ret.ID = ID;
				ret.typeName = L"";
				if (typeIL) 
				{
					ret.typeName = typeIL->ToString();
					if (UniformOrBuffer)
						ret.typeName = ret.typeName + L"#" + UniformOrBuffer;
				}
				ret.typeID = ID;
				ret.typeIL = typeIL;
				return ret;
			}

			static IDInfo CreateIDInfoForValue(int ID, RefPtr<ILType> typeIL, ILOperand *op, int typeID)
			{
				IDInfo ret;
				ret.available = true;
				ret.idClass = IDClass::Value;
				ret.ID = ID;
				if (op)
					ret.variableName = op->Name;
				else
					ret.variableName = L"";
				ret.op = op;
				ret.typeName = typeIL->ToString();
				ret.typeID = typeID;
				ret.typeIL = typeIL;
				return ret;
			}

			static IDInfo CreateIDInfoForPointer(int ID, ILOperand *op, int typeID, RefPtr<ILType> basetypeIL, int basetypeID, StorageClass store)
			{
				IDInfo ret;
				ret.available = true;
				ret.idClass = IDClass::Pointer;
				ret.ID = ID;
				ret.op = op;
				if (op)
					ret.variableName = op->Name;
				else
					ret.variableName = L"";
				ret.typeName = basetypeIL->ToString();
				ret.typeID = typeID;
				ret.baseTypeID = basetypeID;
				ret.typeIL = basetypeIL;
				ret.store = store;
				return ret;
			}

			static IDInfo CreateIDInfoForTypeofPointer(int ID, RefPtr<ILType> baseTypeIL, int baseTypeID, StorageClass store)
			{
				IDInfo ret;
				ret.available = true;
				ret.idClass = IDClass::TypeofPointer;
				ret.ID = ID;
				ret.typeName = baseTypeIL->ToString();
				ret.typeID = ID;
				ret.baseTypeID = baseTypeID;
				ret.typeIL = baseTypeIL;
				ret.store = store;
				return ret;
			}

			static IDInfo CreateIDInfoForFunction(int ID, CompiledFunction * func)
			{
				IDInfo ret;
				ret.available = true;
				ret.idClass = IDClass::Function;
				ret.ID = ID;
				ret.func = func;
				return ret;
			}

			bool IsAvailable()
			{
				return available;
			}
			int GetID()
			{
				if (!available) return -1;
				return ID;
			}
			IDClass GetClass()
			{
				if (!available) return IDClass::None;
				return idClass;
			}
			bool IsTypeofValue()
			{
				if (!available) return false;
				return idClass == IDClass::TypeofValue;
			}
			bool IsValue()
			{
				if (!available) return false;
				return idClass == IDClass::Value;
			}
			bool IsPointer()
			{
				if (!available) return false;
				return idClass == IDClass::Pointer;
			}
			bool IsTypeofPointer()
			{
				if (!available) return false;
				return idClass == IDClass::TypeofPointer;
			}
			bool IsFunction()
			{
				if (!available) return false;
				return idClass == IDClass::Function;
			}
			String GetVariableName()
			{
				if (!available) return L"";
				return variableName;
			}
			String GetTypeName()
			{
				if (!available) return L"";
				return typeName;
			}
			int GetTypeID()
			{
				if (!available) return -1;
				return typeID;
			}
			int GetBaseTypeID()
			{
				if (!available) return -1;
				return baseTypeID;
			}
			RefPtr<ILType> GetILType()
			{
				if (!available) return nullptr;
				return typeIL;
			}
			StorageClass GetStorageClass()
			{
				if (!available) return StorageClass::Invalid;
				return store;
			}
			CompiledFunction * GetFunc()
			{
				if (!available || idClass != IDClass::Function)
					return nullptr;
				return func;
			}
			ILOperand* GetOp()
			{
				if (!available)
					return nullptr;
				return op;
			}
		};

		class SpirVCodeBuilder
		{
			List<unsigned int> streamHeader;
			List<unsigned int> streamDebug;
			List<unsigned int> streamAnnotation;
			List<unsigned int> streamTypeDefinition;
			List<unsigned int> streamFunctionHeader;
			List<unsigned int> streamFunctionVariable;
			List<unsigned int> streamFunctionBody;
			List<unsigned int> streamProcessedFunctions;
			StringBuilder sbTextHeader;
			//OpCapability, OpExtension, OpExtInstImport, OpMemoryModel, OpEntryPoint, OpExecutionMode
			StringBuilder sbDebug;
			//OpName, OpMemberName
			StringBuilder sbTextAnnotation;
			//OpDecorate, OpMemberDecorate, OpGroupDecorate, OpGroupMemberDecorate, OpDecoration Group
			StringBuilder sbTextTypeDefinition;
			//OpTypeXXXX, OpConstant, global variable declarations(all OpVariable instructions whose storage class is not Function)
			StringBuilder sbTextFunctionDefinitions;
			StringBuilder sbTextFunctionHeader;
			StringBuilder sbTextFunctionVariable;
			StringBuilder sbTextFunctionBody;

		public:
			void Clear()
			{
				streamHeader.Clear();
				streamDebug.Clear();
				streamAnnotation.Clear();
				streamTypeDefinition.Clear();
				streamFunctionHeader.Clear();
				streamFunctionVariable.Clear();
				streamFunctionBody.Clear();
				streamProcessedFunctions.Clear();
				
				sbTextHeader.Clear();
				sbDebug.Clear();
				sbTextAnnotation.Clear();
				sbTextTypeDefinition.Clear();
				sbTextFunctionDefinitions.Clear();
				sbTextFunctionHeader.Clear();
				sbTextFunctionVariable.Clear();
				sbTextFunctionBody.Clear();
			}
			void Initiate()
			{
				Clear();

				streamHeader.Add(0x07230203); // magic number
				streamHeader.Add(0x00010000); // version 
				streamHeader.Add(0x00080001); // register number
				streamHeader.Add(0x0000ffff); // ID bound
				streamHeader.Add(0x00000000); // reserved
			}
			void ProduceFunction()
			{
				//---------------- for binary code ----------------
				streamProcessedFunctions.AddRange(streamFunctionHeader);
				streamFunctionHeader.Clear();

				streamProcessedFunctions.AddRange(streamFunctionVariable);
				streamFunctionVariable.Clear();

				streamProcessedFunctions.AddRange(streamFunctionBody);
				streamFunctionBody.Clear();

				//---------------- for text code ----------------
				sbTextFunctionDefinitions
					<< sbTextFunctionHeader.ToString()
					<< sbTextFunctionVariable.ToString()
					<< sbTextFunctionBody.ToString();
				sbTextFunctionHeader.Clear();
				sbTextFunctionVariable.Clear();
				sbTextFunctionBody.Clear();
			}
			List<unsigned int> ProduceWordStream(int IDBound)
			{
				streamHeader[3] = IDBound + 5;
				List<unsigned int> ret;
				ret.AddRange(streamHeader);
				ret.AddRange(streamDebug);
				ret.AddRange(streamAnnotation);
				ret.AddRange(streamTypeDefinition);
				ret.AddRange(streamProcessedFunctions);
				return ret;
			}
			String ProduceTextCode()
			{
				String ret;
				ret = ret + sbTextHeader.ToString();
				ret = ret + sbDebug.ToString();
				ret = ret + sbTextAnnotation.ToString();
				ret = ret + sbTextTypeDefinition.ToString();
				ret = ret + sbTextFunctionDefinitions.ToString();
				return ret;
			}
			void ProgramHeader()
			{
				sbTextHeader << LR"(OpCapability Shader)" << EndLine;
				sbTextHeader << LR"(%1 = OpExtInstImport "GLSL.std.450")" << EndLine;
				sbTextHeader << LR"(OpMemoryModel Logical GLSL450)" << EndLine;

				streamHeader.Add(17 + (2 << 16));	//wordCount and opCode
				streamHeader.Add(1);	//Shader

										//hardcoded
				streamHeader.Add(0x0006000B);
				streamHeader.Add(0x00000001);
				streamHeader.Add(0x4c534c47);
				streamHeader.Add(0x6474732E);
				streamHeader.Add(0x3035342E);
				streamHeader.Add(0);

				streamHeader.Add(14 + (3 << 16));
				streamHeader.Add(0);
				streamHeader.Add(1);
			}
			void OpFunction(const int funcID, const int returnTypeID, const int functionTypeID)
			{

				sbTextFunctionHeader << LR"(%)" << funcID << LR"( = OpFunction )";
				sbTextFunctionHeader << LR"(%)" << returnTypeID;
				sbTextFunctionHeader << LR"( None)";
				sbTextFunctionHeader << LR"( %)" << functionTypeID;
				sbTextFunctionHeader << EndLine;

				streamFunctionHeader.Add(54 + (5 << 16));
				streamFunctionHeader.Add(returnTypeID);
				streamFunctionHeader.Add(funcID);
				streamFunctionHeader.Add(0);	// function control - 0
				streamFunctionHeader.Add(functionTypeID);
			}
			void OpFunctionParameter(const int paramID, const int typeID)
			{
				sbTextFunctionHeader << LR"(%)" << paramID << LR"( = OpFunctionParameter %)" << typeID << EndLine;

				streamFunctionHeader.Add(55 + (3 << 16));
				streamFunctionHeader.Add(typeID);
				streamFunctionHeader.Add(paramID);
			}
			void OpTypeFunction(const int functionTypeID, const int returnTypeID, const List<int> &argIDList)
			{
				sbTextTypeDefinition << LR"(%)" << functionTypeID << LR"( = OpTypeFunction %)" << returnTypeID;
				for (auto & arg : argIDList)
					sbTextTypeDefinition << LR"( %)" << arg;
				sbTextTypeDefinition << EndLine;

				streamTypeDefinition.Add(33 + ((3 + argIDList.Count()) << 16));
				streamTypeDefinition.Add(functionTypeID);
				streamTypeDefinition.Add(returnTypeID);
				for (auto & arg : argIDList)
					streamTypeDefinition.Add(arg);
			}
			void OpLabel_AtFunctionHeader(const int label)
			{
				sbTextFunctionHeader << LR"(%)" << label << LR"( = OpLabel)" << EndLine;

				streamFunctionHeader.Add(248 + (2 << 16));
				streamFunctionHeader.Add(label);
			}
			void OpLabel_AtFunctionBody(const int label)
			{
				sbTextFunctionBody << LR"(%)" << label << LR"( = OpLabel)" << EndLine;

				streamFunctionBody.Add(248 + (2 << 16));
				streamFunctionBody.Add(label);
			}
			void OpBranch(const int ID)
			{
				sbTextFunctionBody << LR"(OpBranch %)" << ID << EndLine;

				streamFunctionBody.Add(249 + (2 << 16));
				streamFunctionBody.Add(ID);
			}
			void OpBranchConditional(const int cond, const int tb, const int fb)
			{
				sbTextFunctionBody << LR"(OpBranchConditional %)" << cond << LR"( %)" << tb << LR"( %)" << fb << EndLine;

				streamFunctionBody.Add(250 + (4 << 16));
				streamFunctionBody.Add(cond);
				streamFunctionBody.Add(tb);
				streamFunctionBody.Add(fb);
			}
			void OpLoopMerge(const int merge, const int cont)
			{
				sbTextFunctionBody << LR"(OpLoopMerge %)" << merge << LR"( %)" << cont << LR"( None)" << EndLine;

				streamFunctionBody.Add(246 + (4 << 16));
				streamFunctionBody.Add(merge);
				streamFunctionBody.Add(cont);
				streamFunctionBody.Add(0);	//loop control: none
			}
			void OpSelectionMerge(const int merge)
			{
				sbTextFunctionBody << LR"(OpSelectionMerge %)" << merge << LR"( None)" << EndLine;

				streamFunctionBody.Add(247 + (3 << 16));
				streamFunctionBody.Add(merge);
				streamFunctionBody.Add(0);	//selection control: none
			}
			void OpPhi(const int ID, const int typeID, const List<int> branches)
			{
				//<branches>: (variable1, parent branch1), (variable2, parent branch2), ...
				sbTextFunctionBody << LR"(%)" << ID << LR"( = OpPhi %)" << typeID;
				for (const auto & x : branches)
					sbTextFunctionBody << LR"( %)" << x;
				sbTextFunctionBody << EndLine;

				streamFunctionBody.Add(245 + ((3 + branches.Count()) << 16));
				streamFunctionBody.Add(typeID);
				streamFunctionBody.Add(ID);
				for (const auto & x : branches)
					streamFunctionBody.Add(x);
			}
			void OpFunctionCall(const int ID, const int typeID, const int funcID, const List<int> &args)
			{
				sbTextFunctionBody << LR"(%)" << ID << LR"( = OpFunctionCall %)" << typeID << LR"( %)" << funcID;
				for (auto & arg : args)
					sbTextFunctionBody << LR"( %)" << arg;
				sbTextFunctionBody << EndLine;

				streamFunctionBody.Add(57 + ((4 + args.Count()) << 16));
				streamFunctionBody.Add(typeID);
				streamFunctionBody.Add(ID);
				streamFunctionBody.Add(funcID);
				for (auto & arg : args)
					streamFunctionBody.Add(arg);
			}
			void OpKill()
			{
				sbTextFunctionBody << LR"(OpKill)" << EndLine;
				
				streamFunctionBody.Add(252 + (1<<16));
			}
			void OpReturn()
			{
				sbTextFunctionBody << LR"(OpReturn)" << EndLine;

				streamFunctionBody.Add(253 + (1 << 16));
			}
			void OpReturnValue(const int ID)
			{
				sbTextFunctionBody << LR"(OpReturnValue %)" << ID << EndLine;

				streamFunctionBody.Add(254 + (2 << 16));
				streamFunctionBody.Add(ID);
			}
			void OpFunctionEnd()
			{
				sbTextFunctionBody << LR"(OpFunctionEnd)" << EndLine;

				streamFunctionBody.Add(56 + (1 << 16));
			}
			int EncodeString(List<unsigned int> & stream, String S)
			{
				auto encoder = CoreLib::IO::Encoding::UTF8;
				List<char> bytes;
				encoder->GetBytes(bytes, S);
				int padding = (4 - (bytes.Count() & 3)) & 3;
				for (int i = 0; i < padding; i++)
					bytes.Add(0);
				int oldSize = stream.Count();
				stream.SetSize(oldSize + (bytes.Count() >> 2));
				memcpy(stream.Buffer() + oldSize, bytes.Buffer(), bytes.Count());
				if (padding==0)
					stream.Add(0);
				return stream.Count() - oldSize;
			}
			void OpEntryPoint(const ExecutionModel currentExecutionModel, const int entryID, const List<int> &interfaceIDs)
			{
				sbTextHeader << LR"(OpEntryPoint )";
				sbTextHeader << ExecutionModelToString(currentExecutionModel) << LR"( )";
				sbTextHeader << LR"(%)" << entryID << LR"( "main" )";
				for (auto & id : interfaceIDs)
					sbTextHeader << LR"( %)" << id;
				sbTextHeader << EndLine;

				int len_i = streamHeader.Count();
				streamHeader.Add(0);
				streamHeader.Add((int)currentExecutionModel);
				streamHeader.Add(entryID);
				int NameLen = EncodeString(streamHeader, L"main");
				for (auto & id : interfaceIDs)
					streamHeader.Add(id);
				streamHeader[len_i] = (15) + ((1 + 1 + NameLen + 1 + interfaceIDs.Count()) << 16);
			}
			void OpExecutionMode(const int entryID, const ExecutionMode mode, const int op1, const int op2, const int op3)
			{
				bool LocalSize = false;
				if (mode == ExecutionMode::LocalSize)
					LocalSize = true;

				sbTextHeader << LR"(OpExecutionMode %)" << entryID << LR"( )" << ExecutionModeToString(mode);
				if (LocalSize)
					sbTextHeader << op1 << op2 << op3;
				sbTextHeader << EndLine;

				int len = 3;
				if (LocalSize)
					len += 3;
				streamHeader.Add(16 + (len << 16));
				streamHeader.Add(entryID);
				streamHeader.Add((int)mode);
				if (LocalSize) {
					streamHeader.Add(op1);
					streamHeader.Add(op2);
					streamHeader.Add(op3);
				}
			}
			int Decorate(const Decoration deco, int op1 = 0)
			{
				int len = 0;
				sbTextAnnotation << L" " << DecorationToString(deco);
				streamAnnotation.Add((int)deco);
				len++;
				if (deco == Decoration::Location ||
					deco == Decoration::Offset ||
					deco == Decoration::MatrixStride ||
					deco == Decoration::ArrayStride ||
					deco == Decoration::DescriptorSet ||
					deco == Decoration::Binding)
				{
					sbTextAnnotation << LR"( )" << op1;
					streamAnnotation.Add(op1);
					len++;
				}
				if (deco == Decoration::BuiltIn)
				{
					BuiltIn builtin = static_cast<BuiltIn>(op1);
					sbTextAnnotation << LR"( )" << BuiltinToString(builtin);
					streamAnnotation.Add(op1);
					len++;
				}
				return len;
			}
			void OpDecorate(const int ID, const Decoration deco, int op1 = 0)
			{
				sbTextAnnotation << LR"(OpDecorate %)" << ID;

				int len_i = streamAnnotation.Count();
				streamAnnotation.Add(0);
				streamAnnotation.Add(ID);
				int deco_len = Decorate(deco, op1);
				streamAnnotation[len_i] = 71 + ((2 + deco_len) << 16);

				sbTextAnnotation << EndLine;
			}
			void OpMemberDecorate(const int ID, const int memberIndex, const Decoration deco, int op1 = 0)
			{
				sbTextAnnotation << LR"(OpMemberDecorate %)" << ID << LR"( )" << memberIndex;

				int len_i = streamAnnotation.Count();
				streamAnnotation.Add(0);
				streamAnnotation.Add(ID);
				streamAnnotation.Add(memberIndex);
				int deco_len = Decorate(deco, op1);
				streamAnnotation[len_i] = 72 + ((3 + deco_len) << 16);

				sbTextAnnotation << EndLine;
			}
			void OpSNegate(const int ID, const int typeID, const int valueID)
			{
				sbTextFunctionBody << LR"(%)" << ID << LR"( = OpSNegate %)" << typeID << LR"( %)" << valueID << EndLine;

				streamFunctionBody.Add(126 + (4 << 16));
				streamFunctionBody.Add(typeID);
				streamFunctionBody.Add(ID);
				streamFunctionBody.Add(valueID);
			}
			void OpFNegate(const int ID, const int typeID, const int valueID)
			{
				sbTextFunctionBody << LR"(%)" << ID << LR"( = OpFNegate %)" << typeID << LR"( %)" << valueID << EndLine;

				streamFunctionBody.Add(127 + (4 << 16));
				streamFunctionBody.Add(typeID);
				streamFunctionBody.Add(ID);
				streamFunctionBody.Add(valueID);
			}
			void OpFAdd(const int ID, const int typeID, const int op1, const int op2)
			{
				sbTextFunctionBody << LR"(%)" << ID << LR"( = OpFAdd %)" << typeID << LR"( %)" << op1 << LR"( %)" << op2 << EndLine;

				streamFunctionBody.Add(129 + (5 << 16));
				streamFunctionBody.Add(typeID);
				streamFunctionBody.Add(ID);
				streamFunctionBody.Add(op1);
				streamFunctionBody.Add(op2);
			}
			void OpFMul(const int ID, const int typeID, const int op1, const int op2)
			{
				sbTextFunctionBody << LR"(%)" << ID << LR"( = OpFMul %)" << typeID << LR"( %)" << op1 << LR"( %)" << op2 << EndLine;

				streamFunctionBody.Add(133 + (5 << 16));
				streamFunctionBody.Add(typeID);
				streamFunctionBody.Add(ID);
				streamFunctionBody.Add(op1);
				streamFunctionBody.Add(op2);
			}
			void OpINotEqual(const int ID, const int typeID, const int id0, const int id1)
			{
				sbTextFunctionBody << LR"(%)" << ID << LR"( = OpINotEqual %)" << typeID << LR"( %)" << id0 << LR"( %)" << id1 << EndLine;

				streamFunctionBody.Add(171 + (5 << 16));
				streamFunctionBody.Add(typeID);
				streamFunctionBody.Add(ID);
				streamFunctionBody.Add(id0);
				streamFunctionBody.Add(id1);
			}
			void OpNot(const int ID, const int typeID, const int valueID)
			{
				sbTextFunctionBody << LR"(%)" << ID << LR"( = OpNot %)" << typeID << LR"( %)" << valueID << EndLine;

				streamFunctionBody.Add(200 + (4 << 16));
				streamFunctionBody.Add(typeID);
				streamFunctionBody.Add(ID);
				streamFunctionBody.Add(valueID);
			}
			void OpLogicalNot(const int ID, const int typeID, const int valueID)
			{
				sbTextFunctionBody << LR"(%)" << ID << LR"( = OpLogicalNot %)" << typeID << LR"( %)" << valueID << EndLine;

				streamFunctionBody.Add(168 + (4 << 16));
				streamFunctionBody.Add(typeID);
				streamFunctionBody.Add(ID);
				streamFunctionBody.Add(valueID);
			}
			void OpBinaryInstr(const int ID, String opStr, const int typeID, const int ID0, const int ID1)
			{
				sbTextFunctionBody << LR"(%)" << ID << LR"( = )";
				sbTextFunctionBody << opStr;
				sbTextFunctionBody << LR"( %)" << typeID << LR"( %)" << ID0 << LR"( %)" << ID1 << EndLine;

				int opCode = -1;
				String opStr_prefix = opStr.SubString(0, 2);
				opStr = opStr.SubString(2, opStr.Length() - 2);
				if (opStr == L"FMul")
					opCode = 133;
				else if (opStr == L"IMul")
					opCode = 132;
				else if (opStr == L"FAdd")
					opCode = 129;
				else if (opStr == L"IAdd")
					opCode = 128;
				else if (opStr == L"UDiv")
					opCode = 134;
				else if (opStr == L"SDiv")
					opCode = 135;
				else if (opStr == L"FDiv")
					opCode = 136;
				else if (opStr == L"FSub")
					opCode = 131;
				else if (opStr == L"ISub")
					opCode = 130;
				else if (opStr == L"UMod")
					opCode = 137;
				else if (opStr == L"SMod")
					opCode = 139;
				else if (opStr == L"FMod")
					opCode = 141;
				else if (opStr == L"ShiftLeftLogical")
					opCode = 196;
				else if (opStr == L"ShiftRightArithmetic")
					opCode = 195;
				else if (opStr == L"ShiftRightLogical")
					opCode = 194;
				else if (opStr == L"BitwiseXor")
					opCode = 198;
				else if (opStr == L"BitwiseAnd")
					opCode = 199;
				else if (opStr == L"BitwiseOr")
					opCode = 197;
				else if (opStr == L"LogicalAnd")
					opCode = 167;
				else if (opStr == L"LogicalOr")
					opCode = 166;
				else if (opStr == L"INotEqual")
					opCode = 171;
				else if (opStr == L"FOrdNotEqual")
					opCode = 182;
				else if (opStr == L"IEqual")
					opCode = 170;
				else if (opStr == L"FOrdEqual")
					opCode = 180;
				else if (opStr == L"SGreaterThanEqual")
					opCode = 175;
				else if (opStr == L"FOrdGreaterThanEqual")
					opCode = 190;
				else if (opStr == L"SGreaterThan")
					opCode = 173;
				else if (opStr == L"FOrdGreaterThan")
					opCode = 186;
				else if (opStr == L"SLessThanEqual")
					opCode = 179;
				else if (opStr == L"FOrdLessThanEqual")
					opCode = 188;
				else if (opStr == L"SLessThan")
					opCode = 177;
				else if (opStr == L"FOrdLessThan")
					opCode = 184;
				else if (opStr == L"UGreaterThan")
					opCode = 172;
				else if (opStr == L"UGreaterThanEqual")
					opCode = 174;
				else if (opStr == L"ULessThan")
					opCode = 176;
				else if (opStr == L"ULessThanEqual")
					opCode = 178;
				if (opCode == -1)
					throw InvalidOperationException(L"unrecognized op string in CodeGenerator::OpBinaryInstr(): " + opStr);

				streamFunctionBody.Add(opCode + (5 << 16));
				streamFunctionBody.Add(typeID);
				streamFunctionBody.Add(ID);
				streamFunctionBody.Add(ID0);
				streamFunctionBody.Add(ID1);
			}
			void OpMatrixTimesScalar(const int ID, const int typeID, const int ID0, const int ID1)
			{
				sbTextFunctionBody << LR"(%)" << ID << LR"( = OpMatrixTimesScalar %)" << typeID << LR"( %)" << ID0 << LR"( %)" << ID1 << EndLine;

				streamFunctionBody.Add(143 + (5 << 16));
				streamFunctionBody.Add(typeID);
				streamFunctionBody.Add(ID);
				streamFunctionBody.Add(ID0);
				streamFunctionBody.Add(ID1);
			}
			void OpVectorTimesMatrix(const int ID, const int typeID, const int ID0, const int ID1)
			{
				sbTextFunctionBody << LR"(%)" << ID << LR"( = OpVectorTimesMatrix %)" << typeID << LR"( %)" << ID0 << LR"( %)" << ID1 << EndLine;

				streamFunctionBody.Add(144 + (5 << 16));
				streamFunctionBody.Add(typeID);
				streamFunctionBody.Add(ID);
				streamFunctionBody.Add(ID0);
				streamFunctionBody.Add(ID1);
			}
			void OpMatrixTimesVector(const int ID, const int typeID, const int ID0, const int ID1)
			{
				sbTextFunctionBody << LR"(%)" << ID << LR"( = OpMatrixTimesVector %)" << typeID << LR"( %)" << ID0 << LR"( %)" << ID1 << EndLine;

				streamFunctionBody.Add(145 + (5 << 16));
				streamFunctionBody.Add(typeID);
				streamFunctionBody.Add(ID);
				streamFunctionBody.Add(ID0);
				streamFunctionBody.Add(ID1);
			}
			void OpMatrixTimesMatrix(const int ID, const int typeID, const int ID0, const int ID1)
			{
				sbTextFunctionBody << LR"(%)" << ID << LR"( = OpMatrixTimesMatrix %)" << typeID << LR"( %)" << ID0 << LR"( %)" << ID1 << EndLine;

				streamFunctionBody.Add(146 + (5 << 16));
				streamFunctionBody.Add(typeID);
				streamFunctionBody.Add(ID);
				streamFunctionBody.Add(ID0);
				streamFunctionBody.Add(ID1);
			}
			void OpConstantBool(const int typeID, const int ID, const bool b)
			{
				if (b)
				{
					sbTextTypeDefinition << LR"(%)" << ID << LR"( = OpConstantTrue%)" << EndLine;

					streamTypeDefinition.Add(41 + (3 << 16));
					streamTypeDefinition.Add(typeID);
					streamTypeDefinition.Add(ID);
				}
				else
				{
					sbTextTypeDefinition << LR"(%)" << ID << LR"( = OpConstantFalse%)" << EndLine;

					streamTypeDefinition.Add(42 + (3 << 16));
					streamTypeDefinition.Add(typeID);
					streamTypeDefinition.Add(ID);
				}
			}
			void OpConstantFloat(const int ID, const int typeID, float f)
			{
				sbTextTypeDefinition << LR"(%)" << ID << LR"( = OpConstant %)" << typeID << LR"( )" << SpirVFloatToString(f) << EndLine;

				streamTypeDefinition.Add(43 + (4 << 16));
				streamTypeDefinition.Add(typeID);
				streamTypeDefinition.Add(ID);
				streamTypeDefinition.Add(*reinterpret_cast<unsigned int*>(&f));
				//printf("%.8f -> %x\n", f, streamTypeDefinition[streamTypeDefinition.Count() - 1]);
			}
			void OpConstantInt(const int ID, const int typeID, int i)
			{
				sbTextTypeDefinition << LR"(%)" << ID << LR"( = OpConstant %)" << typeID << LR"( )" << i << EndLine;

				streamTypeDefinition.Add(43 + (4 << 16));
				streamTypeDefinition.Add(typeID);
				streamTypeDefinition.Add(ID);
				streamTypeDefinition.Add(*reinterpret_cast<unsigned int*>(&i));
			}
			void OpConstantUInt(const int ID, const int typeID, const unsigned int i)
			{
				sbTextTypeDefinition << LR"(%)" << ID << LR"( = OpConstant %)" << typeID << LR"( )";
				sbTextTypeDefinition << SpirVUIntToString(i);
				sbTextTypeDefinition << EndLine;

				streamTypeDefinition.Add(43 + (4 << 16));
				streamTypeDefinition.Add(typeID);
				streamTypeDefinition.Add(ID);
				streamTypeDefinition.Add(i);
			}
			void OpConstantComposite(const int ID, const int typeID, const List<int> &args)
			{
				sbTextTypeDefinition << LR"(%)" << ID << LR"( = OpConstantComposite %)" << typeID;
				for (auto & id : args)
					sbTextTypeDefinition << LR"( %)" << id;
				sbTextTypeDefinition << EndLine;

				streamTypeDefinition.Add(44 + ((3 + args.Count()) << 16));
				streamTypeDefinition.Add(typeID);
				streamTypeDefinition.Add(ID);
				for (auto & id : args)
					streamTypeDefinition.Add(id);
			}
			void OpCompositeConstruct(const int ID, const int typeID, const List<int> &args)
			{
				sbTextFunctionBody << LR"(%)" << ID << LR"( = OpCompositeConstruct %)" << typeID;
				for (auto & id : args)
					sbTextFunctionBody << LR"( %)" << id;
				sbTextFunctionBody << EndLine;

				streamFunctionBody.Add(80 + ((3 + args.Count()) << 16));
				streamFunctionBody.Add(typeID);
				streamFunctionBody.Add(ID);
				for (auto & id : args)
					streamFunctionBody.Add(id);
			}
			void OpCompositeExtract(const int ID, const int baseTypeID, const int compositeID, const int index)
			{
				sbTextFunctionBody << LR"(%)" << ID << LR"( = OpCompositeExtract %)" << baseTypeID << LR"( %)" << compositeID
					<< LR"( )" << index << EndLine;

				streamFunctionBody.Add(81 + (5 << 16));
				streamFunctionBody.Add(baseTypeID);
				streamFunctionBody.Add(ID);
				streamFunctionBody.Add(compositeID);
				streamFunctionBody.Add(index);
			}
			void OpCompositeInsert(const int ID, const int typeID, const int objectID, const int compositeID, const int index)
			{
				sbTextFunctionBody << LR"(%)" << ID << LR"( = OpCompositeInsert %)"
					<< typeID << LR"( %)" << objectID << LR"( %)" << compositeID << LR"( )" << index << EndLine;

				streamFunctionBody.Add(82 + (6 << 16));
				streamFunctionBody.Add(typeID);
				streamFunctionBody.Add(ID);
				streamFunctionBody.Add(objectID);
				streamFunctionBody.Add(compositeID);
				streamFunctionBody.Add(index);
			}
			void OpExtInst(const int ID, const int typeID, const int instrNumber, const List<int> &Arguments)
			{
				sbTextFunctionBody << LR"(%)" << ID << LR"( = OpExtInst %)" << typeID << LR"( %1 )";
				sbTextFunctionBody << instrNumber;
				for (auto & arg : Arguments)
					sbTextFunctionBody << LR"( %)" << arg;
				sbTextFunctionBody << EndLine;

				streamFunctionBody.Add(12 + ((5 + Arguments.Count()) << 16));
				streamFunctionBody.Add(typeID);
				streamFunctionBody.Add(ID);
				streamFunctionBody.Add(1);	//instruction set **<ID>**
				streamFunctionBody.Add(instrNumber);
				for (auto & arg : Arguments)
					streamFunctionBody.Add(arg);
			}
			void OpStore(const int op0, const int op1)
			{
				sbTextFunctionBody << LR"(OpStore %)" << op0 << LR"( %)" << op1 << EndLine;

				streamFunctionBody.Add(62 + (3 << 16));
				streamFunctionBody.Add(op0);
				streamFunctionBody.Add(op1);
			}
			void OpLoad(const int ID, const int typeID, const int variableID, const MemoryAccess ma)
			{
				sbTextFunctionBody << LR"(%)" << ID << LR"( = OpLoad %)" << typeID << LR"( %)"
					<< variableID << LR"( )" << MemoryAccessToString(ma) << EndLine;

				if (ma != MemoryAccess::None)
					throw NotImplementedException(L"not support memory access in CodeGenerator::OpLoad(): " + MemoryAccessToString(ma));

				streamFunctionBody.Add(61 + (4 << 16));
				streamFunctionBody.Add(typeID);
				streamFunctionBody.Add(ID);
				streamFunctionBody.Add(variableID);
			}
			void OpVariable(const int ID, const int typeID, StorageClass store)
			{
				StringBuilder instrBuilder;
				instrBuilder << LR"(%)" << ID << LR"( = OpVariable %)" << typeID << LR"( )" << StorageClassToString(store) << EndLine;
				if (store == StorageClass::Function)
					sbTextFunctionVariable << instrBuilder.ProduceString() << EndLine;
				else
					sbTextTypeDefinition << instrBuilder.ProduceString() << EndLine;

				if (store == StorageClass::Function)
				{
					streamFunctionVariable.Add(59 + (4 << 16));
					streamFunctionVariable.Add(typeID);
					streamFunctionVariable.Add(ID);
					streamFunctionVariable.Add((int)store);
				}
				else
				{
					streamTypeDefinition.Add(59 + (4 << 16));
					streamTypeDefinition.Add(typeID);
					streamTypeDefinition.Add(ID);
					streamTypeDefinition.Add((int)store);
				}
			}
			void OpAccessChain(const int ID, const int typeID, const int structID, const int indexID)
			{
				sbTextFunctionBody << LR"(%)" << ID << LR"( = OpAccessChain %)" << typeID
					<< LR"( %)" << structID << LR"( %)" << indexID << EndLine;

				streamFunctionBody.Add(65 + (5 << 16));
				streamFunctionBody.Add(typeID);
				streamFunctionBody.Add(ID);
				streamFunctionBody.Add(structID);
				streamFunctionBody.Add(indexID);
			}
			void OpImageSampleImplicitLod(
				const int ID, 
				const int typeID, 
				const int textureID, 
				const int coordinateID,
				const int Bias = -1)
			{
				sbTextFunctionBody << LR"(%)" << ID << LR"( = OpImageSampleImplicitLod %)"
					<< typeID << LR"( %)" << textureID << LR"( %)" << coordinateID;
				if (Bias != -1)
					sbTextFunctionBody << LR"( Bias %)" << Bias;
				sbTextFunctionBody << EndLine;

				int len = 5;
				int IO = 0;
				if (Bias != -1)
				{
					len++;
					IO |= (int)ImageOperands::Bias;
				}
				if (IO)
					len++;
				streamFunctionBody.Add(87 + (len << 16));
				streamFunctionBody.Add(typeID);
				streamFunctionBody.Add(ID);
				streamFunctionBody.Add(textureID);
				streamFunctionBody.Add(coordinateID);
				if (IO)
					streamFunctionBody.Add(IO);
				if (Bias != -1)
					streamFunctionBody.Add(Bias);
			}
			void OpImageSampleExplicitLod(
				const int ID, 
				const int typeID, 
				const int textureID, 
				const int coordinateID, 
				const int LodID,
				const int Bias = -1,
				const int GradX = -1, 
				const int GradY = -1)
			{
				sbTextFunctionBody << LR"(%)" << ID << LR"( = OpImageSampleExplicitLod %)"
					<< typeID << LR"( %)" << textureID << LR"( %)" << coordinateID;
				if (Bias != -1)
					sbTextFunctionBody << LR"( Bias %)" << Bias;
				if (GradX != -1)
					sbTextFunctionBody << LR"( Grad %)" << GradX << LR"( %)" << GradY;
				else
					sbTextFunctionBody << LR"( Lod %)" << LodID;
				sbTextFunctionBody << EndLine;

				int IO = 0;
				int len = 5;
				if (Bias != -1)
				{
					IO |= (int)ImageOperands::Bias;
					len++;
				}
				if (GradX != -1) {
					IO |= (int)ImageOperands::Grad;
					len += 2;
				}
				else
				{
					IO |= (int)ImageOperands::Lod;
					len++;
				}
				if (IO)
					len++;
				streamFunctionBody.Add(88 + (len << 16));
				streamFunctionBody.Add(typeID);
				streamFunctionBody.Add(ID);
				streamFunctionBody.Add(textureID);
				streamFunctionBody.Add(coordinateID);
				if (IO)
					streamFunctionBody.Add(IO);
				if (Bias != -1)
					streamFunctionBody.Add(Bias);
				if (GradX != -1)
				{
					streamFunctionBody.Add(GradX);
					streamFunctionBody.Add(GradY);
				}
				else
					streamFunctionBody.Add(LodID);
			}
			void OpImageSampleDrefImplicitLod(
				const int ID,
				const int typeID,
				const int textureID,
				const int coordinateID,
				const int DrefID)
			{
				sbTextFunctionBody << LR"(%)" << ID << LR"( = OpImageSampleDrefImplicitLod %)"
					<< typeID << LR"( %)" << textureID << LR"( %)" << coordinateID << LR"( %)" << DrefID;
				sbTextFunctionBody << EndLine;

				int len = 6;
				streamFunctionBody.Add(89 + (len << 16));
				streamFunctionBody.Add(typeID);
				streamFunctionBody.Add(ID);
				streamFunctionBody.Add(textureID);
				streamFunctionBody.Add(coordinateID);
				streamFunctionBody.Add(DrefID);
			}
			void OpImageSampleDrefExplicitLod(
				const int ID,
				const int typeID,
				const int textureID,
				const int coordinateID, 
				const int DrefID,
				const int LodID)
			{
				sbTextFunctionBody << LR"(%)" << ID << LR"( = OpImageSampleDrefExplicitLod %)"
					<< typeID << LR"( %)" << textureID << LR"( %)" << coordinateID << LR"( %)" << DrefID;
				sbTextFunctionBody << LR"( Lod %)" << LodID;
				sbTextFunctionBody << EndLine;

				int len = 8;
				streamFunctionBody.Add(90 + (len << 16));
				streamFunctionBody.Add(typeID);
				streamFunctionBody.Add(ID);
				streamFunctionBody.Add(textureID);
				streamFunctionBody.Add(coordinateID);
				streamFunctionBody.Add(DrefID);
				streamFunctionBody.Add((int)ImageOperands::Lod);
				streamFunctionBody.Add(LodID);
			}
			void OpImageSampleProjDrefImplicitLod(
				const int ID,
				const int typeID,
				const int textureID,
				const int coordinateID,
				const int DrefID) 
			{
				sbTextFunctionBody << LR"(%)" << ID << LR"( = OpImageSampleProjDrefImplicitLod %)"
					<< typeID << LR"( %)" << textureID << LR"( %)" << coordinateID << LR"( %)" << DrefID;
				sbTextFunctionBody << EndLine;

				int len = 6;
				streamFunctionBody.Add(93 + (len << 16));
				streamFunctionBody.Add(typeID);
				streamFunctionBody.Add(ID);
				streamFunctionBody.Add(textureID);
				streamFunctionBody.Add(coordinateID);
				streamFunctionBody.Add(DrefID);
			}
			void OpImageSampleProjDrefExplicitLod(
				const int ID,
				const int typeID,
				const int textureID,
				const int coordinateID,
				const int DrefID,
				const int LodID)
			{
				sbTextFunctionBody << LR"(%)" << ID << LR"( = OpImageSampleProjDrefExplicitLod %)"
					<< typeID << LR"( %)" << textureID << LR"( %)" << coordinateID << LR"( %)" << DrefID;
				sbTextFunctionBody << LR"( Lod %)" << LodID;
				sbTextFunctionBody << EndLine;

				int len = 8;
				streamFunctionBody.Add(94 + (len << 16));
				streamFunctionBody.Add(typeID);
				streamFunctionBody.Add(ID);
				streamFunctionBody.Add(textureID);
				streamFunctionBody.Add(coordinateID);
				streamFunctionBody.Add(DrefID);
				streamFunctionBody.Add((int)ImageOperands::Lod);
				streamFunctionBody.Add(LodID);
			}
			void OpConvertSToF(const int ID, const int typeID, const int operandID)
			{
				sbTextFunctionBody << LR"(%)" << ID << LR"( = OpConvertSToF %)" << typeID << LR"( %)" << operandID << EndLine;

				streamFunctionBody.Add(111 + (4 << 16));
				streamFunctionBody.Add(typeID);
				streamFunctionBody.Add(ID);
				streamFunctionBody.Add(operandID);
			}
			void OpConvertFToS(const int ID, const int typeID, const int operandID)
			{
				sbTextFunctionBody << LR"(%)" << ID << LR"( = OpConvertFToS %)" << typeID << LR"( %)" << operandID << EndLine;

				streamFunctionBody.Add(110 + (4 << 16));
				streamFunctionBody.Add(typeID);
				streamFunctionBody.Add(ID);
				streamFunctionBody.Add(operandID);
			}
			void OpConvertFToU(const int ID, const int typeID, const int operandID)
			{
				sbTextFunctionBody << LR"(%)" << ID << LR"( = OpConvertFToU %)" << typeID << LR"( %)" << operandID << EndLine;

				streamFunctionBody.Add(109 + (4 << 16));
				streamFunctionBody.Add(typeID);
				streamFunctionBody.Add(ID);
				streamFunctionBody.Add(operandID);
			}
			void OpConvertUToF(const int ID, const int typeID, const int operandID)
			{
				sbTextFunctionBody << LR"(%)" << ID << LR"( = OpConvertUToF %)" << typeID << LR"( %)" << operandID << EndLine;

				streamFunctionBody.Add(112 + (4 << 16));
				streamFunctionBody.Add(typeID);
				streamFunctionBody.Add(ID);
				streamFunctionBody.Add(operandID);
			}
			void OpBitCast(const int ID, const int typeID, const int operandID)
			{
				sbTextFunctionBody << LR"(%)" << ID << LR"( = OpBitcast %)" << typeID << LR"( %)" << operandID << EndLine;

				streamFunctionBody.Add(124 + (4 << 16));
				streamFunctionBody.Add(typeID);
				streamFunctionBody.Add(ID);
				streamFunctionBody.Add(operandID);
			}
			void OpTypeVoid(const int ID)
			{
				sbTextTypeDefinition << LR"(%)" << ID << LR"( = OpTypeVoid)" << EndLine;

				streamTypeDefinition.Add(19 + (2 << 16));
				streamTypeDefinition.Add(ID);
			}
			void OpTypeBool(const int ID)
			{
				sbTextTypeDefinition << LR"(%)" << ID << LR"( = OpTypeBool)" << EndLine;

				streamTypeDefinition.Add(20 + (2 << 16));
				streamTypeDefinition.Add(ID);
			}
			void OpTypeInt(const int ID, const int width, const int signedness)
			{
				sbTextTypeDefinition << LR"(%)" << ID << LR"( = OpTypeInt )" << width << LR"( )" << signedness << EndLine;

				streamTypeDefinition.Add(21 + (4 << 16));
				streamTypeDefinition.Add(ID);
				streamTypeDefinition.Add(width);
				streamTypeDefinition.Add(signedness);
			}
			void OpTypeFloat(const int ID, const int width)
			{
				sbTextTypeDefinition << LR"(%)" << ID << LR"( = OpTypeFloat )" << width << EndLine;

				streamTypeDefinition.Add(22 + (3 << 16));
				streamTypeDefinition.Add(ID);
				streamTypeDefinition.Add(width);
			}
			void OpTypeVector(const int ID, const int eleTypeID, const int vecLen)
			{
				sbTextTypeDefinition << LR"(%)" << ID << LR"( = OpTypeVector %)" << eleTypeID << LR"( )" << vecLen << EndLine;

				streamTypeDefinition.Add(23 + (4 << 16));
				streamTypeDefinition.Add(ID);
				streamTypeDefinition.Add(eleTypeID);
				streamTypeDefinition.Add(vecLen);
			}
			void OpTypeMatrix(const int ID, const int colTypeID, const int Dim)
			{
				sbTextTypeDefinition << LR"(%)" << ID << LR"( = OpTypeMatrix %)" << colTypeID << LR"( )" << Dim << EndLine;

				streamTypeDefinition.Add(24 + (4 << 16));
				streamTypeDefinition.Add(ID);
				streamTypeDefinition.Add(colTypeID);
				streamTypeDefinition.Add(Dim);
			}
			void OpTypeImage(const int ID, const int sampledTypeID, const Dim d, const int depth)
			{
				sbTextTypeDefinition << LR"(%)" << ID << LR"( = OpTypeImage %)" << sampledTypeID
					<< LR"( )" << DimToString(d) << LR"( )" << depth << LR"( 0 0 1 Unknown)" << EndLine;

				streamTypeDefinition.Add(25 + (9 << 16));
				streamTypeDefinition.Add(ID);
				streamTypeDefinition.Add(sampledTypeID);
				streamTypeDefinition.Add((int)d);			//Dim
				streamTypeDefinition.Add(depth);			//depth
				streamTypeDefinition.Add(0);				//arrayed
				streamTypeDefinition.Add(0);				//MS
				streamTypeDefinition.Add(1);				//sampled: will be used with sampler
				streamTypeDefinition.Add(0);				//image format: Unknown
			}
			void OpTypeSampledImage(const int ID, const int imageTypeID)
			{
				sbTextTypeDefinition << LR"(%)" << ID << LR"( = OpTypeSampledImage %)" << imageTypeID << EndLine;

				streamTypeDefinition.Add(27 + (3 << 16));
				streamTypeDefinition.Add(ID);
				streamTypeDefinition.Add(imageTypeID);
			}
			void OpTypePointer(const int ID, const StorageClass store, const int baseTypeID)
			{
				sbTextTypeDefinition << LR"(%)" << ID << LR"( = OpTypePointer )" << StorageClassToString(store)
					<< LR"( %)" << baseTypeID << EndLine;

				streamTypeDefinition.Add(32 + (4 << 16));
				streamTypeDefinition.Add(ID);
				streamTypeDefinition.Add((int)store);
				streamTypeDefinition.Add(baseTypeID);
			}
			void OpTypeArray(const int ID, const int elementTypeID, const int lengthID)
			{
				sbTextTypeDefinition << LR"(%)" << ID << LR"( = OpTypeArray %)" << elementTypeID << LR"( %)" << lengthID << EndLine;

				streamTypeDefinition.Add(28 + (4 << 16));
				streamTypeDefinition.Add(ID);
				streamTypeDefinition.Add(elementTypeID);
				streamTypeDefinition.Add(lengthID);
			}
			void OpTypeRuntimeArray(const int ID, const int elementTypeID)
			{
				sbTextTypeDefinition << LR"(%)" << ID << LR"( = OpTypeRuntimeArray %)" << elementTypeID << EndLine;

				streamTypeDefinition.Add(29 + (3 << 16));
				streamTypeDefinition.Add(ID);
				streamTypeDefinition.Add(elementTypeID);
			}
			void OpTypeStruct(const int ID, const List<int> & memberIDList)
			{
				sbTextTypeDefinition << LR"(%)" << ID << LR"( = OpTypeStruct)";
				for (auto & member : memberIDList)
					sbTextTypeDefinition << LR"( %)" << member;
				sbTextTypeDefinition << EndLine;

				streamTypeDefinition.Add(30 + ((2 + memberIDList.Count()) << 16));
				streamTypeDefinition.Add(ID);
				for (auto & member : memberIDList)
					streamTypeDefinition.Add(member);
			}

			void OpDot(const int ID, const int typeID, const int ID0, const int ID1)
			{
				sbTextFunctionBody << LR"(%)" << ID << LR"( = OpDot %)" << typeID << LR"( %)" << ID0 << LR"( %)" << ID1 << EndLine;

				streamFunctionBody.Add(148 + (5 << 16));
				streamFunctionBody.Add(typeID);
				streamFunctionBody.Add(ID);
				streamFunctionBody.Add(ID0);
				streamFunctionBody.Add(ID1);
			}

			void OpTranspose(const int ID, const int typeID, const int Op0)
			{
				sbTextFunctionBody << LR"(%)" << ID << LR"( = OpTranspose %)" << typeID << LR"( %)" << Op0 << EndLine;

				streamFunctionBody.Add(84 + (4 << 16));
				streamFunctionBody.Add(typeID);
				streamFunctionBody.Add(ID);
				streamFunctionBody.Add(Op0);
			}

			void OpDPdx(const int ID, const int typeID, const int Op0)
			{
				sbTextFunctionBody << LR"(%)" << ID << LR"( = OpDPdx %)" << typeID << LR"( %)" << Op0 << EndLine;

				streamFunctionBody.Add(207 + (4 << 16));
				streamFunctionBody.Add(typeID);
				streamFunctionBody.Add(ID);
				streamFunctionBody.Add(Op0);
			}

			void OpDPdy(const int ID, const int typeID, const int Op0)
			{
				sbTextFunctionBody << LR"(%)" << ID << LR"( = OpDPdy %)" << typeID << LR"( %)" << Op0 << EndLine;

				streamFunctionBody.Add(208 + (4 << 16));
				streamFunctionBody.Add(typeID);
				streamFunctionBody.Add(ID);
				streamFunctionBody.Add(Op0);
			}

			void OpFwidth(const int ID, const int typeID, const int Op0)
			{
				sbTextFunctionBody << LR"(%)" << ID << LR"( = OpFwidth %)" << typeID << LR"( %)" << Op0 << EndLine;

				streamFunctionBody.Add(209 + (4 << 16));
				streamFunctionBody.Add(typeID);
				streamFunctionBody.Add(ID);
				streamFunctionBody.Add(Op0);
			}

			void OpName(int ID, String Name)
			{
				sbDebug << LR"(OpName %)" << ID << LR"( ")" << Name << LR"(")" << EndLine;

				int len_i = streamDebug.Count();
				streamDebug.Add(0);
				streamDebug.Add(ID);
				int len = EncodeString(streamDebug, Name);
				streamDebug[len_i] = 5 + ((2 + len) << 16);
			}

			void OpMemberName(int ID, int index, String Name)
			{
				sbDebug << LR"(OpMemberName %)" << ID << LR"( )" << index << LR"( ")" << Name << LR"(")" << EndLine;

				int len_i = streamDebug.Count();
				streamDebug.Add(0);
				streamDebug.Add(ID);
				streamDebug.Add(index);
				int len = EncodeString(streamDebug, Name);
				streamDebug[len_i] = 6 + ((3 + len) << 16);
			}
		};

		class SpirVCodeGenContext
		{
		public:
			CompileResult * Result = nullptr;

			int CurrentID = 0;
			int MainFunctionID = 0;
			int MainFunctionReturnTypeID = 0;
			int MainFunctionTypeID = 0;
			int ReturnID = -1;
			Dictionary<String, int> TypeNameToID;					// 'int' - 1, 'vec4' - 2
			Dictionary<String, int> TypeStorageToTypePointerID;		// 'uint Function' - 5, 'mat3 Uniform' - 6
			Dictionary<String, int> FunctionNameToFunctionTypeID;
			Dictionary<String, int> FunctionNameToFunctionID;
			Dictionary<ILOperand*, int> ParameterNameToID;

			List<Dictionary<ILOperand*, int>> StackVariableNameToStorageID;
			List<Dictionary<ILOperand*, int>> StackVariableNameToValueID;
			Dictionary<String, int> InterfaceNameToID;

			Dictionary<int, int> Dictionary_ConstantIntToID;
			Dictionary<unsigned int, int> Dictionary_ConstantUIntToID;
			Dictionary<int, int> Dictionary_ConstantBoolToID;

			Dictionary<int, IDInfo> IDInfos;

			List<int> StackMergeBlock;
			List<int> StackContinueBlock;

			SpirVCodeBuilder CodeGen;

			void Clear()
			{
				Result = nullptr;
				CurrentID = 0;
				MainFunctionID = 0;
				MainFunctionReturnTypeID = 0;
				MainFunctionTypeID = 0;
				ReturnID = -1;
				StackVariableNameToStorageID.Clear();
				StackVariableNameToValueID.Clear();
				TypeNameToID.Clear();
				TypeStorageToTypePointerID.Clear();
				FunctionNameToFunctionTypeID.Clear();
				FunctionNameToFunctionID.Clear();
				ParameterNameToID.Clear();
				Dictionary_ConstantIntToID.Clear();
				Dictionary_ConstantUIntToID.Clear();
				Dictionary_ConstantBoolToID.Clear();
				IDInfos.Clear();
				StackMergeBlock.Clear();
				StackContinueBlock.Clear();
				CodeGen.Clear();
				InterfaceNameToID.Clear();
			}

			void ClearBuffer()
			{
				StackVariableNameToStorageID.Clear();
				StackVariableNameToValueID.Clear();
				ParameterNameToID.Clear();
				ReturnID = -1;
			}

			void PushScope()
			{
				StackVariableNameToStorageID.Add(Dictionary<ILOperand*, int>());
				StackVariableNameToValueID.Add(Dictionary<ILOperand*, int>());
			}

			void PopScope()
			{
				StackVariableNameToStorageID.RemoveAt(StackVariableNameToStorageID.Count() - 1);
				StackVariableNameToValueID.RemoveAt(StackVariableNameToValueID.Count() - 1); 
			}

			void UpdateVariable(ILOperand* op, int id)
			{
				if (op == nullptr)
					return;
				StackVariableNameToStorageID.Last()[op] = id;
			}

			int FindVariableID(ILOperand* op)
			{
				auto it = StackVariableNameToStorageID.end();
				while (it != StackVariableNameToStorageID.begin())
				{
					it--;
					if (it->ContainsKey(op))
						return (*it)[op];
				}
				return -1;
			}

			// ***NOTICE***: 
			//   There is no relation between VariableNameToStorageID and ValueIDToVariableNames.

			void UpdateValue(ILOperand *op, int id)
			{
				if (op == nullptr)
					return;
				StackVariableNameToValueID.Last()[op] = id;
			}

			int FindValueID(ILOperand *op)
			{
				auto it = StackVariableNameToValueID.end();
				while (it != StackVariableNameToValueID.begin())
				{
					it--;
					if (it->ContainsKey(op))
						return (*it)[op];
				}
				return -1;
			}

			void InvalidateValue(ILOperand *op)
			{
				if (StackVariableNameToValueID.Last().ContainsKey(op))
					StackVariableNameToValueID.Last()[op] = -1;
			}

			int DefineBasicType(RefPtr<ILType> Type)
			{
				String typeName = Type->ToString();
				if (TypeNameToID.ContainsKey(typeName))
					return TypeNameToID[typeName];
				TypeNameToID[typeName] = -1; //marked as visited

				if (typeName == L"int" || typeName.StartsWith(L"ivec"))
				{
					DefineBasicType(new ILBasicType(ILBaseType::Int));

					if (typeName == L"int")
					{
						++CurrentID;
						CodeGen.OpTypeInt(CurrentID, 32, 1);
						TypeNameToID[typeName] = CurrentID;
					}

					if (typeName.StartsWith(L"ivec"))
					{
						++CurrentID;
						CodeGen.OpTypeVector(CurrentID, TypeNameToID[L"int"](), StringToInt(typeName[4]));
						TypeNameToID[typeName] = CurrentID;
					}
				}

				if (typeName == L"uint" || typeName.StartsWith(L"uvec"))
				{
					DefineBasicType(new ILBasicType(ILBaseType::UInt));

					if (typeName == L"uint") {
						++CurrentID;
						CodeGen.OpTypeInt(CurrentID, 32, 0);
						TypeNameToID[typeName] = CurrentID;
					}

					if (typeName.StartsWith(L"uvec"))
					{
						++CurrentID;
						CodeGen.OpTypeVector(CurrentID, TypeNameToID[L"uint"](), StringToInt(typeName[4]));
						TypeNameToID[typeName] = CurrentID;
					}
				}

				if (typeName == L"float" || typeName.StartsWith(L"vec") || typeName.StartsWith(L"mat"))
				{
					DefineBasicType(new ILBasicType(ILBaseType::Float));

					if (typeName == L"float")
					{
						++CurrentID;
						CodeGen.OpTypeFloat(CurrentID, 32);
						TypeNameToID[typeName] = CurrentID;
					}

					if (typeName.StartsWith(L"vec"))
					{
						++CurrentID;
						CodeGen.OpTypeVector(CurrentID, TypeNameToID[L"float"](), StringToInt(typeName[3]));
						TypeNameToID[typeName] = CurrentID;
					}

					if (typeName == L"mat3")
					{
						DefineBasicType(new ILBasicType(ILBaseType::Float3));
						++CurrentID;
						CodeGen.OpTypeMatrix(CurrentID, TypeNameToID[L"vec3"](), 3);
						TypeNameToID[typeName] = CurrentID;
					}

					if (typeName == L"mat4")
					{
						DefineBasicType(new ILBasicType(ILBaseType::Float4));
						++CurrentID;
						CodeGen.OpTypeMatrix(CurrentID, TypeNameToID[L"vec4"](), 4);
						TypeNameToID[typeName] = CurrentID;
					}
				}

				if (typeName == L"sampler2D")
				{
					//according to vulkan specification
					//	Resource Descriptors, Descriptor Types, Sampled Image
					DefineBasicType(new ILBasicType(ILBaseType::Float));

					++CurrentID;
					CodeGen.OpTypeImage(CurrentID, TypeNameToID[L"float"](), Dim::e2D, 0);
					int tmp = CurrentID;

					++CurrentID;
					CodeGen.OpTypeSampledImage(CurrentID, tmp);
					TypeNameToID[typeName] = CurrentID;
				}

				if (typeName == L"samplerCube")
				{
					DefineBasicType(new ILBasicType(ILBaseType::Float));

					++CurrentID;
					CodeGen.OpTypeImage(CurrentID, TypeNameToID[L"float"](), Dim::eCube, 0);
					int tmp = CurrentID;

					++CurrentID;
					CodeGen.OpTypeSampledImage(CurrentID, tmp);
					TypeNameToID[typeName] = CurrentID;
				}

				if (typeName == L"samplerCubeShadow")
				{
					DefineBasicType(new ILBasicType(ILBaseType::Float));

					++CurrentID;
					CodeGen.OpTypeImage(CurrentID, TypeNameToID[L"float"](), Dim::eCube, 1);
					int tmp = CurrentID;

					++CurrentID;
					CodeGen.OpTypeSampledImage(CurrentID, tmp);
					TypeNameToID[typeName] = CurrentID;
				}

				if (typeName == L"sampler2DShadow")
				{
					DefineBasicType(new ILBasicType(ILBaseType::Float));

					++CurrentID;
					CodeGen.OpTypeImage(CurrentID, TypeNameToID[L"float"](), Dim::e2D, 1);
					int tmp = CurrentID;

					++CurrentID;
					CodeGen.OpTypeSampledImage(CurrentID, tmp);
					TypeNameToID[typeName] = CurrentID;
				}

				if (typeName == L"bool")
				{
					++CurrentID;
					CodeGen.OpTypeBool(CurrentID);
					TypeNameToID[typeName] = CurrentID;
				}

				if (TypeNameToID[typeName] == -1)
				{
					throw InvalidProgramException(L"fail to generate type definition for: " + typeName);
				}

				int id = TypeNameToID[typeName];
				IDInfos[id] = IDInfo::CreateIDInfoForTypeofValue(id, Type);

				return id;
			}

			//UniformOrBuffer - 0: none; 1: uniform; 2: buffer 
			int DefineType(RefPtr<ILType> Type, int UniformOrBuffer = 0)
			{
				if (!Type)
				{
					if (TypeNameToID.ContainsKey(L"void"))
						return TypeNameToID[L"void"];
					++CurrentID;
					//TypeDefinition << LR"(%)" <<  << LR"( = OpTypeVoid)" << EndLine;
					CodeGen.OpTypeVoid(CurrentID);
					TypeNameToID[L"void"] = CurrentID;
					IDInfos[CurrentID] = IDInfo::CreateIDInfoForTypeofValue(CurrentID, nullptr);
					return CurrentID;
				}
				int RetID = -1;
				if (auto ArrayType = dynamic_cast<ILArrayType*>(Type.Ptr()))
				{
					String IndexName = Type->ToString();
					if (UniformOrBuffer != 0)
						IndexName = IndexName + L"#" + UniformOrBuffer;
					if (TypeNameToID.ContainsKey(IndexName))
						return TypeNameToID[IndexName];

					if (ArrayType->ArrayLength != 0)
					{
						//normal constant-length array
						int lengthID = AddInstrConstantInt(ArrayType->ArrayLength);

						int elementTypeID = DefineType(ArrayType->BaseType, UniformOrBuffer);
						++CurrentID;
						CodeGen.OpTypeArray(CurrentID, elementTypeID, lengthID);
						TypeNameToID[IndexName] = CurrentID;
						IDInfos[CurrentID] = IDInfo::CreateIDInfoForTypeofValue(CurrentID, Type, UniformOrBuffer);
						RetID = CurrentID;
					}
					else
					{
						//dynamic array
						int elementTypeID = DefineType(ArrayType->BaseType, UniformOrBuffer);
						++CurrentID;
						CodeGen.OpTypeRuntimeArray(CurrentID, elementTypeID);
						TypeNameToID[IndexName] = CurrentID;
						IDInfos[CurrentID] = IDInfo::CreateIDInfoForTypeofValue(CurrentID, Type, UniformOrBuffer);
						RetID = CurrentID;
					}

					if (UniformOrBuffer != 0)
					{
						int Stride = GetSize(ArrayType->BaseType.Ptr(), UniformOrBuffer);
						CodeGen.OpDecorate(RetID, Decoration::ArrayStride, Stride);
					}
				}
				if (auto StructType = dynamic_cast<ILStructType*>(Type.Ptr()))
				{
					String IndexName = Type->ToString();
					if (UniformOrBuffer != 0)
						IndexName = IndexName + L"#" + UniformOrBuffer;
					if (TypeNameToID.ContainsKey(IndexName))
						return TypeNameToID[IndexName];

					List<int> memberIDList;
					for (auto & member : StructType->Members)
						memberIDList.Add(DefineType(member.Type, UniformOrBuffer));
					++CurrentID;
					CodeGen.OpTypeStruct(CurrentID, memberIDList);
					TypeNameToID[IndexName] = CurrentID;
					IDInfos[CurrentID] = IDInfo::CreateIDInfoForTypeofValue(CurrentID, Type, UniformOrBuffer);
					RetID = CurrentID;

					//generate decoration for struct layout
					if (UniformOrBuffer != 0)
					{
						int Offset = 0;
						int Index = 0;
						for (auto & MemberTypeID : memberIDList)
						{
							RefPtr<ILType> MemberType = IDInfos[MemberTypeID]().GetILType();

							int BaseAlignment = GetBaseAlignment(MemberType.Ptr(), UniformOrBuffer);

							//round up to baseAlignment
							if (Offset % BaseAlignment)
								Offset += BaseAlignment - Offset % BaseAlignment;

							AddInstrMemberDecorate(RetID, Index, Decoration::Offset, Offset);

							if (MemberType->IsFloatMatrix())
							{
								AddInstrMemberDecorate(RetID, Index, Decoration::ColMajor);
								AddInstrMemberDecorate(RetID, Index, Decoration::MatrixStride, 16);
							}

							Offset += GetSize(MemberType.Ptr(), UniformOrBuffer);
							Index++;
						}
					}

					//generate debug information
					CodeGen.OpName(RetID, Type->ToString());
					int index = 0;
					for (auto &member : StructType->Members)
					{
						CodeGen.OpMemberName(RetID, index, member.FieldName);
						index++;
					}
				}
				if (auto BasicType = dynamic_cast<ILBasicType*>(Type.Ptr()))
				{
					if (TypeNameToID.ContainsKey(Type->ToString()))
						return TypeNameToID[Type->ToString()];
					RetID = DefineBasicType(Type);
				}
				return RetID;
			}

			int DefineTypePointer(RefPtr<ILType> Type, StorageClass store, int UniformOrBuffer = 0)
			{
				String PointerName = Type->ToString() + L"$" + StorageClassToString(store) + L"#" + UniformOrBuffer;
				if (TypeStorageToTypePointerID.ContainsKey(PointerName))
					return TypeStorageToTypePointerID[PointerName]();

				int basetypeID = DefineType(Type, UniformOrBuffer);
				++CurrentID;
				CodeGen.OpTypePointer(CurrentID, store, basetypeID);
				TypeStorageToTypePointerID[PointerName] = CurrentID;
				IDInfos[CurrentID] = IDInfo::CreateIDInfoForTypeofPointer(CurrentID, Type, basetypeID, store);
				return CurrentID;
			}

			int AddInstrTypeFunction(CompiledFunction * func, const List<RefPtr<ILType>> & argTypes, RefPtr<ILType> returnType)
			{
				int returnTypeID = DefineType(returnType);
				for (auto & arg : argTypes)
					DefineTypePointer(arg, StorageClass::Function);
				int functionTypeID = ++CurrentID;
				/*
				TypeDefinition << LR"(%)" << functionTypeID << LR"( = OpTypeFunction %)" << returnTypeID;
				for (auto & arg : argTypes)
				TypeDefinition << LR"( %)" << DefineTypePointer(arg, StorageClass::Function);
				TypeDefinition << EndLine;
				*/
				List<int> argIDList;
				for (auto & arg : argTypes)
					argIDList.Add(DefineTypePointer(arg, StorageClass::Function));
				CodeGen.OpTypeFunction(functionTypeID, returnTypeID, argIDList);
				IDInfos[functionTypeID] = IDInfo::CreateIDInfoForFunction(functionTypeID, func);
				if (func)
					FunctionNameToFunctionTypeID[func->Name] = functionTypeID;
				else
					FunctionNameToFunctionTypeID[L"main"] = functionTypeID;
				return functionTypeID;
			}

			int AddInstrConstantBool(int value)
			{
				if (Dictionary_ConstantBoolToID.ContainsKey(value != 0))
					return Dictionary_ConstantBoolToID[value != 0].GetValue();

				auto Type = GetTypeFromString(L"bool");
				int typeID = DefineType(Type);
				++CurrentID;
				/*
				if (value != 0)
				TypeDefinition << LR"(%)" << CurrentID << LR"( = OpConstantTrue%)" << EndLine;
				else
				TypeDefinition << LR"(%)" << CurrentID << LR"( = OpConstantFalse%)" << EndLine;
				*/
				CodeGen.OpConstantBool(typeID, CurrentID, value != 0);
				IDInfos[CurrentID] = IDInfo::CreateIDInfoForValue(CurrentID, Type, 0, typeID);
				Dictionary_ConstantBoolToID[value != 0] = CurrentID;
				return CurrentID;
			}

			int AddInstrConstantFloat(float f)
			{
				auto Type = GetTypeFromString(L"float");
				int typeID = DefineType(Type);
				++CurrentID;
				CodeGen.OpConstantFloat(CurrentID, typeID, f);
				IDInfos[CurrentID] = IDInfo::CreateIDInfoForValue(CurrentID, Type, 0, typeID);
				return CurrentID;
			}

			int AddInstrConstantInt(int i)
			{
				auto Type = GetTypeFromString(L"int");
				if (Dictionary_ConstantIntToID.ContainsKey(i))
					return Dictionary_ConstantIntToID[i].GetValue();

				int typeID = DefineType(Type);
				++CurrentID;
				CodeGen.OpConstantInt(CurrentID, typeID, i);
				IDInfos[CurrentID] = IDInfo::CreateIDInfoForValue(CurrentID, Type, 0, typeID);
				Dictionary_ConstantIntToID[i] = CurrentID;
				return CurrentID;
			}

			int AddInstrConstantUInt(unsigned int i)
			{
				auto Type = GetTypeFromString(L"uint");
				if (Dictionary_ConstantUIntToID.ContainsKey(i))
					return Dictionary_ConstantUIntToID[i].GetValue();

				int typeID = DefineType(Type);
				++CurrentID;
				CodeGen.OpConstantUInt(CurrentID, typeID, i);
				IDInfos[CurrentID] = IDInfo::CreateIDInfoForValue(CurrentID, Type, 0, typeID);
				Dictionary_ConstantUIntToID[i] = CurrentID;
				return CurrentID;
			}

			int AddInstrConstantCompositeFloat(float *f, int len)
			{
				RefPtr<ILType> Type;
				if (len == 2)
					Type = GetTypeFromString(L"vec2");
				else if (len == 3)
					Type = GetTypeFromString(L"vec3");
				else if (len == 4)
					Type = GetTypeFromString(L"vec4");
				else
					throw InvalidOperationException(L"Invalid type in AddInstrConstantCompositeFloat(): vec"+len);
				int typeID = DefineType(Type);

				List<int> elementIDs;
				for (int i = 0; i < len; i++)
					elementIDs.Add(AddInstrConstantFloat(f[i]));

				++CurrentID;
				CodeGen.OpConstantComposite(CurrentID, typeID, elementIDs);

				IDInfos[CurrentID] = IDInfo::CreateIDInfoForValue(CurrentID, Type, 0, typeID);
				return CurrentID;
			}

			int AddInstrConstantCompositeInt(int *v, int len)
			{
				RefPtr<ILType> Type;
				if (len == 2)
					Type = GetTypeFromString(L"ivec2");
				else if (len == 3)
					Type = GetTypeFromString(L"ivec3");
				else if (len == 4)
					Type = GetTypeFromString(L"ivec4");
				else
					throw InvalidOperationException(L"Invalid type in AddInstrConstantCompositeInt(): ivec" + len);
				int typeID = DefineType(Type);

				List<int> elementIDs;
				for (int i = 0; i < len; i++)
					elementIDs.Add(AddInstrConstantInt(v[i]));

				++CurrentID;
				CodeGen.OpConstantComposite(CurrentID, typeID, elementIDs);

				IDInfos[CurrentID] = IDInfo::CreateIDInfoForValue(CurrentID, Type, 0, typeID);
				return CurrentID;
			}

			int AddInstrConstantCompositeUInt(unsigned int *v, int len)
			{
				RefPtr<ILType> Type;
				if (len == 2)
					Type = GetTypeFromString(L"uvec2");
				else if (len == 3)
					Type = GetTypeFromString(L"uvec3");
				else if (len == 4)
					Type = GetTypeFromString(L"uvec4");
				else
					throw InvalidOperationException(L"Invalid type in AddInstrConstantCompositeUInt(): uvec" + len);
				int typeID = DefineType(Type);

				List<int> elementIDs;
				for (int i = 0; i < len; i++)
					elementIDs.Add(AddInstrConstantUInt(*(v + i)));

				++CurrentID;
				CodeGen.OpConstantComposite(CurrentID, typeID, elementIDs);

				IDInfos[CurrentID] = IDInfo::CreateIDInfoForValue(CurrentID, Type, 0, typeID);
				return CurrentID;
			}

			int AddInstrConstantMatrix(float *f, int n)
			{
				RefPtr<ILType> Type;
				if (n == 3)
					Type = GetTypeFromString(L"mat3");
				else if (n == 4)
					Type = GetTypeFromString(L"mat4");
				else
					throw InvalidOperationException(L"Invalid type in AddInstrConstantMatrix(): mat" + n);
				int typeID = DefineType(Type);

				List<int> vectorIDs;
				for (int i = 0; i < n; i++)
					vectorIDs.Add(AddInstrConstantCompositeFloat(f + (i * n), n));

				++CurrentID;
				CodeGen.OpConstantComposite(CurrentID, typeID, vectorIDs);

				IDInfos[CurrentID] = IDInfo::CreateIDInfoForValue(CurrentID, Type, 0, typeID);
				return CurrentID;
			}

			int AddInstrCompositeConstruct(ILOperand* op, RefPtr<ILType> Type, List<int> Arguments)
				// return ID of this instruction
			{
				int typeID = DefineType(Type);
				++CurrentID;
				CodeGen.OpCompositeConstruct(CurrentID, typeID, Arguments);
				IDInfos[CurrentID] = IDInfo::CreateIDInfoForValue(CurrentID, Type, op, typeID);
				UpdateValue(op, CurrentID);
				return CurrentID;
			}

			int AddInstrCompositeExtract(int ID, RefPtr<ILType> baseType, int index)
			{
				int baseTypeID = DefineType(baseType);
				++CurrentID;
				CodeGen.OpCompositeExtract(CurrentID, baseTypeID, ID, index);
				IDInfos[CurrentID] = IDInfo::CreateIDInfoForValue(CurrentID, baseType, 0, baseTypeID);
				return CurrentID;
			}

			int AddInstrCompositeInsert(RefPtr<ILType> Type, int ID, int index, int op)
			{
				//ID[index] = op
				int typeID = DefineType(Type);
				++CurrentID;
				CodeGen.OpCompositeInsert(CurrentID, typeID, op, ID, index);
				IDInfos[CurrentID] = IDInfo::CreateIDInfoForValue(CurrentID, Type, 0, typeID);
				return CurrentID;
			}

			int AddInstrExtInst(ILOperand* op, RefPtr<ILType> Type, int instrNumber, List<int> Arguments)
			{
				int typeID = DefineType(Type);
				++CurrentID;
				CodeGen.OpExtInst(CurrentID, typeID, instrNumber, Arguments);
				IDInfos[CurrentID] = IDInfo::CreateIDInfoForValue(CurrentID, Type, op, typeID);
				UpdateValue(op, CurrentID);
				return CurrentID;
			}

			void AddInstrStore(ILOperand *op, int op0, int op1) {
				CodeGen.OpStore(op0, op1);
				UpdateValue(op, op1);
				return;
			}

			int AddInstrVariableDeclaration(ILOperand *op, RefPtr<ILType> typeIL, StorageClass store, String DebugName = L"", int UniformOrBuffer = 0)
			{
				int typeID = DefineTypePointer(typeIL, store, UniformOrBuffer);
				++CurrentID;
				CodeGen.OpVariable(CurrentID, typeID, store);
				UpdateVariable(op, CurrentID);
				IDInfos[CurrentID] =
					IDInfo::CreateIDInfoForPointer(CurrentID, op, typeID, typeIL, IDInfos[typeID]().GetBaseTypeID(), store);
				//Debug Information
				CodeGen.OpName(CurrentID, DebugName!=L""? DebugName : (op?op->Name:L""));
				return CurrentID;
			}

			int AddInstrAccessChain_VectorMember(ILOperand *op, int ID, int indexID, int index)
			{
				String variableName = L"";
				if (index == -1 && indexID == -1)
					throw InvalidOperationException(L"indexID=-1 && index=-1 in AddInstrAccessChain_VectorMember()");

				if (indexID == -1) {
					//indexID == -1 && index != -1
					indexID = AddInstrConstantInt(index);
				}

				if (index != -1)
				{
					variableName = IDInfos[ID]().GetVariableName() + L"[" + index + L"]";
				}

				RefPtr<ILType> TypeIL = IDInfos[ID]().GetILType();
				RefPtr<ILType> memberTypeIL = nullptr;
				if (TypeIL->IsFloatMatrix())
				{
					if (TypeIL->ToString() == "mat3")
						memberTypeIL = GetTypeFromString(L"vec3");
					else if (TypeIL->ToString() == "mat4")
						memberTypeIL = GetTypeFromString(L"vec4");
				}
				else if (TypeIL->IsFloatVector())
				{
					memberTypeIL = GetTypeFromString(L"float");
				}
				else if (TypeIL->IsIntVector())
				{
					memberTypeIL = GetTypeFromString(L"int");
				}
				else if (TypeIL->IsUIntVector())
				{
					memberTypeIL = GetTypeFromString(L"uint");
				}
				else
					throw InvalidOperationException(L"invalid operand type for access chain: " + TypeIL->ToString());

				int memberTypeID = DefineTypePointer(memberTypeIL, IDInfos[ID]().GetStorageClass());

				++CurrentID;
				/*FunctionBody << LR"(%)" << CurrentID << LR"( = OpAccessChain %)" << memberTypeID
				<< LR"( %)" << ID << LR"( %)" << indexID << EndLine;*/
				CodeGen.OpAccessChain(CurrentID, memberTypeID, ID, indexID);
				IDInfos[CurrentID] =
					IDInfo::CreateIDInfoForPointer(
						CurrentID,
						op,
						memberTypeID,
						memberTypeIL,
						IDInfos[memberTypeID]().GetBaseTypeID(),
						IDInfos[ID]().GetStorageClass()
					);
				UpdateVariable(op, CurrentID);
				return CurrentID;
			}

			int AddInstrAccessChain_StructMember(ILOperand *op, int ID, int indexID, int index)
			{
				if (indexID == -1)
					indexID = AddInstrConstantInt(index);
				RefPtr<ILType> Type = IDInfos[ID]().GetILType();
				ILStructType * structType = dynamic_cast<ILStructType*>(Type.Ptr());
				RefPtr<ILType> memberBasetypeIL = structType->Members[index].Type;
				int memberTypeID = DefineTypePointer(memberBasetypeIL, IDInfos[ID]().GetStorageClass());

				++CurrentID;
				/*
				FunctionBody << LR"(%)" << CurrentID << LR"( = OpAccessChain %)"
				<< memberTypeID
				<< LR"( %)" << ID << LR"( %)" << indexID << EndLine;
				*/
				CodeGen.OpAccessChain(CurrentID, memberTypeID, ID, indexID);

				UpdateVariable(op, CurrentID);
				IDInfos[CurrentID] =
					IDInfo::CreateIDInfoForPointer(
						CurrentID,
						op,
						memberTypeID,
						memberBasetypeIL,
						IDInfos[memberTypeID]().GetBaseTypeID(),
						IDInfos[ID]().GetStorageClass()
					);
				return CurrentID;
			}

			int AddInstrAccessChain_StructMember(ILOperand *op, String memberName)
			{
				int structID = FindVariableID(op);
				ILStructType* structIL = dynamic_cast<ILStructType*>(IDInfos[structID]().GetILType().Ptr());
				if (!structIL)
					throw InvalidProgramException(L"can not convert to ILStruct in AddInstrAccessChain_StructMember()");
				int index = structIL->Members.FindFirst([&](ILStructType::ILStructField member)
				{
					return member.FieldName == memberName;
				});
				int indexID = AddInstrConstantInt(index);
				return AddInstrAccessChain_StructMember(op, structID, indexID, index);
			}

			int AddInstrAccessChain_StructMember(ILOperand *op, int structID, String memberName)
			{
				ILStructType* structIL = dynamic_cast<ILStructType*>(IDInfos[structID]().GetILType().Ptr());
				if (!structIL)
					throw InvalidProgramException(L"can not convert to ILStruct in AddInstrAccessChain_StructMember()");
				int index = structIL->Members.FindFirst([&](ILStructType::ILStructField member)
				{
					return member.FieldName == memberName;
				});
				int indexID = AddInstrConstantInt(index);
				return AddInstrAccessChain_StructMember(op, structID, indexID, index);
			}

			int AddInstrAccessChain_ArrayMember(ILOperand *op, RefPtr<ILType> Type, int ID, int indexID)
			{
				if (!Type)
					throw InvalidProgramException(L"empty type in AddInstrAccessChain_ArrayMember()");
				auto arrayType = dynamic_cast<ILArrayType*>(Type.Ptr());
				int baseTypeID = DefineTypePointer(arrayType->BaseType, IDInfos[ID]().GetStorageClass()); //it's a pointer

				++CurrentID;
				CodeGen.OpAccessChain(CurrentID, baseTypeID, ID, indexID);
				IDInfos[CurrentID] =
					IDInfo::CreateIDInfoForPointer(
						CurrentID,
						op,
						baseTypeID,
						arrayType->BaseType,
						IDInfos[baseTypeID]().GetBaseTypeID(),
						IDInfos[ID]().GetStorageClass()
					);
				UpdateVariable(op, CurrentID);

				return CurrentID;
			}

			int AddInstrLoad(int variableID, MemoryAccess ma)
			{
				++CurrentID;
				RefPtr<ILType> Type = IDInfos[variableID]().GetILType();
				int TypeID = IDInfos[variableID]().GetBaseTypeID();
				CodeGen.OpLoad(CurrentID, TypeID, variableID, ma);
				IDInfos[CurrentID]
					= IDInfo::CreateIDInfoForValue(
						CurrentID,
						Type,
						0,
						TypeID);
				return CurrentID;
			}

			int AddInstrLoad(ILOperand *op, ILOperand *targetOp, MemoryAccess ma)
			{
				int targetID = FindVariableID(targetOp);
				if (targetID == -1)
					return -1;
				int typeID = IDInfos[targetID]().GetBaseTypeID();
				++CurrentID;
				CodeGen.OpLoad(CurrentID, typeID, targetID, ma);
				IDInfos[CurrentID]
					= IDInfo::CreateIDInfoForValue(
						CurrentID,
						IDInfos[targetID]().GetILType(),
						op,
						typeID);
				UpdateValue(op, CurrentID);
				return CurrentID;
			}

			int AddInstrINotEqual(int id0, int id1)
			{
				RefPtr<ILType> typeIL = GetTypeFromString(L"bool");
				int typeID = DefineType(typeIL);
				++CurrentID;
				CodeGen.OpINotEqual(CurrentID, typeID, id0, id1);
				IDInfos[CurrentID]
					= IDInfo::CreateIDInfoForValue(
						CurrentID,
						typeIL,
						0,
						typeID
					);
				return CurrentID;
			}

			int AddInstrTexture(
				ILOperand *op, 
				int textureID, 
				int coordinateID, 
				ExecutionModel currentExecutionModel,
				int Bias = -1,
				int GradX = -1,
				int GradY = -1)
			{
				RefPtr<ILType> typeIL = GetTypeFromString(L"vec4");
				int typeID = DefineType(typeIL);

				++CurrentID;
				if (currentExecutionModel == ExecutionModel::Fragment && GradX == -1)
				{
					//implicit LOD
					CodeGen.OpImageSampleImplicitLod(CurrentID, typeID, textureID, coordinateID, Bias);
				}
				else
				{
					//explicit LOD
					int zeroID = AddInstrConstantInt(0);
					CodeGen.OpImageSampleExplicitLod(CurrentID, typeID, textureID, coordinateID, zeroID, Bias, GradX, GradY);
				}
				IDInfos[CurrentID] = IDInfo::CreateIDInfoForValue(
					CurrentID,
					typeIL,
					op,
					typeID
				);
				UpdateValue(op, CurrentID);

				return CurrentID;
			}

			int AddInstrTextureShadow(
				ILOperand *op, 
				int textureID, 
				int coordinateID, 
				ExecutionModel currentExecutionModel) 
			{
				RefPtr<ILType> typeIL = GetTypeFromString(L"vec4");
				int typeID = DefineType(typeIL);

				int veclen = IDInfos[coordinateID]().GetILType()->GetVectorSize();
				int DrefID = AddInstrCompositeExtract(coordinateID, GetTypeFromString(L"float"), veclen-1);

				++CurrentID;
				if (currentExecutionModel == ExecutionModel::Fragment)
				{
					//implicit LOD
					CodeGen.OpImageSampleDrefImplicitLod(CurrentID, typeID, textureID, coordinateID, DrefID);
				}
				else
				{
					//explicit LOD
					int zeroID = AddInstrConstantInt(0);
					CodeGen.OpImageSampleDrefExplicitLod(CurrentID, typeID, textureID, coordinateID, DrefID, zeroID);
				}
				IDInfos[CurrentID] = IDInfo::CreateIDInfoForValue(
					CurrentID,
					typeIL,
					op,
					typeID
				);
				UpdateValue(op, CurrentID);

				return CurrentID;
			}

			int AddInstrTexture2DShadowProj(
				ILOperand *op,
				int textureID,
				int coordinateID,	////coordinateID: u, v, depth, q
				ExecutionModel currentExecutionModel)
			{
				RefPtr<ILType> typeIL = GetTypeFromString(L"vec4");
				int typeID = DefineType(typeIL);

				int DrefID = AddInstrCompositeExtract(coordinateID, GetTypeFromString(L"float"), 2);
				int qID = AddInstrCompositeExtract(coordinateID, GetTypeFromString(L"float"), 3);
				int NewCoordinateID = AddInstrCompositeInsert(IDInfos[coordinateID]().GetILType(), coordinateID, 2, qID);

				++CurrentID;
				if (currentExecutionModel == ExecutionModel::Fragment)
				{
					//implicit LOD
					CodeGen.OpImageSampleProjDrefImplicitLod(CurrentID, typeID, textureID, NewCoordinateID, DrefID);
				}
				else
				{
					//explicit LOD
					int zeroID = AddInstrConstantInt(0);
					CodeGen.OpImageSampleProjDrefExplicitLod(CurrentID, typeID, textureID, NewCoordinateID, DrefID, zeroID);
				}
				IDInfos[CurrentID] = IDInfo::CreateIDInfoForValue(
					CurrentID,
					typeIL,
					op,
					typeID
				);
				UpdateValue(op, CurrentID);

				return CurrentID;
			}

			int AddInstrConvertSToF(int destTypeID, int operandID)
			{
				++CurrentID;
				CodeGen.OpConvertSToF(CurrentID, destTypeID, operandID);
				IDInfos[CurrentID] = IDInfo::CreateIDInfoForValue(
					CurrentID,
					IDInfos[destTypeID]().GetILType(),
					0,
					destTypeID
				);
				return CurrentID;
			}

			int AddInstrConvertFToS(int destTypeID, int operandID)
			{
				++CurrentID;
				CodeGen.OpConvertFToS(CurrentID, destTypeID, operandID);
				IDInfos[CurrentID] = IDInfo::CreateIDInfoForValue(
					CurrentID,
					IDInfos[destTypeID]().GetILType(),
					0,
					destTypeID
				);
				return CurrentID;
			}

			int AddInstrConvertUToF(int destTypeID, int operandID)
			{
				++CurrentID;
				CodeGen.OpConvertUToF(CurrentID, destTypeID, operandID);
				IDInfos[CurrentID] = IDInfo::CreateIDInfoForValue(
					CurrentID,
					IDInfos[destTypeID]().GetILType(),
					0,
					destTypeID
				);
				return CurrentID;
			}

			int AddInstrConvertFToU(int destTypeID, int operandID)
			{
				++CurrentID;
				CodeGen.OpConvertFToU(CurrentID, destTypeID, operandID);
				IDInfos[CurrentID] = IDInfo::CreateIDInfoForValue(
					CurrentID,
					IDInfos[destTypeID]().GetILType(),
					0,
					destTypeID
				);
				return CurrentID;
			}

			int AddInstrConvertSToU(int destTypeID, int operandID)
			{
				++CurrentID;
				CodeGen.OpBitCast(CurrentID, destTypeID, operandID);
				IDInfos[CurrentID] = IDInfo::CreateIDInfoForValue(
					CurrentID,
					IDInfos[destTypeID]().GetILType(),
					0,
					destTypeID
				);
				return CurrentID;
			}

			int AddInstrConvertUToS(int destTypeID, int operandID) 
			{
				++CurrentID;
				CodeGen.OpBitCast(CurrentID, destTypeID, operandID);
				IDInfos[CurrentID] = IDInfo::CreateIDInfoForValue(
					CurrentID,
					IDInfos[destTypeID]().GetILType(),
					0,
					destTypeID
				);
				return CurrentID;
			}

			int AddInstrBitcast(int destTypeID, int operandID)
			{
				++CurrentID;
				CodeGen.OpBitCast(CurrentID, destTypeID, operandID);
				IDInfos[CurrentID] = IDInfo::CreateIDInfoForValue(
					CurrentID,
					IDInfos[destTypeID]().GetILType(),
					0,
					destTypeID
				);
				return CurrentID;
			}

			int AddInstrFunctionCall(ILOperand *op, int typeID, int funcID, List<int> &args)
			{
				++CurrentID;
				CodeGen.OpFunctionCall(CurrentID, typeID, funcID, args);
				IDInfos[CurrentID] = IDInfo::CreateIDInfoForValue(
					CurrentID,
					IDInfos[typeID]().GetILType(),
					op,
					typeID
				);
				UpdateValue(op, CurrentID);
				return CurrentID;
			}

			int AddInstrFnegate(ILOperand *op, int typeID, int valueID)
			{
				++CurrentID;
				CodeGen.OpFNegate(CurrentID, typeID, valueID);
				IDInfos[CurrentID] = IDInfo::CreateIDInfoForValue(
					CurrentID,
					IDInfos[typeID]().GetILType(),
					op, 
					typeID
				);
				UpdateValue(op, CurrentID);
				return CurrentID;
			}

			int AddInstrSnegate(ILOperand *op, int typeID, int valueID)
			{
				++CurrentID;
				CodeGen.OpSNegate(CurrentID, typeID, valueID);
				IDInfos[CurrentID] = IDInfo::CreateIDInfoForValue(
					CurrentID,
					IDInfos[typeID]().GetILType(),
					op,
					typeID
				);
				UpdateValue(op, CurrentID);
				return CurrentID;
			}

			int AddInstrNot(ILOperand *op, int typeID, int valueID)
			{
				++CurrentID;
				CodeGen.OpNot(CurrentID, typeID, valueID);
				IDInfos[CurrentID] = IDInfo::CreateIDInfoForValue(
					CurrentID,
					IDInfos[typeID]().GetILType(),
					op,
					typeID
				);
				UpdateValue(op, CurrentID);
				return CurrentID;
			}

			int AddInstrLogicalNot(ILOperand *op, int typeID, int valueID)
			{
				++CurrentID;
				CodeGen.OpLogicalNot(CurrentID, typeID, valueID);
				IDInfos[CurrentID] = IDInfo::CreateIDInfoForValue(
					CurrentID,
					IDInfos[typeID]().GetILType(),
					op,
					typeID
				);
				UpdateValue(op, CurrentID);
				return CurrentID;
			}

			int AddInstrMatrixTimesScalar(ILOperand *op, int ID0, int ID1)
			{
				++CurrentID;
				CodeGen.OpMatrixTimesScalar(CurrentID, IDInfos[ID0]().GetTypeID(), ID0, ID1);
				IDInfos[CurrentID] = IDInfo::CreateIDInfoForValue(
					CurrentID,
					IDInfos[ID0]().GetILType(),
					op,
					IDInfos[ID0]().GetTypeID()
				);
				UpdateValue(op, CurrentID);
				return CurrentID;
			}

			int AddInstrVectorTimesMatrix(ILOperand *op, int ID0, int ID1)
			{
				++CurrentID;
				CodeGen.OpVectorTimesMatrix(CurrentID, IDInfos[ID0]().GetTypeID(), ID0, ID1);
				IDInfos[CurrentID] = IDInfo::CreateIDInfoForValue(
					CurrentID,
					IDInfos[ID0]().GetILType(),
					op,
					IDInfos[ID0]().GetTypeID()
				);
				UpdateValue(op, CurrentID);
				return CurrentID;
			}

			int AddInstrMatrixTimesVector(ILOperand *op, int ID0, int ID1)
			{
				++CurrentID;
				CodeGen.OpMatrixTimesVector(CurrentID, IDInfos[ID1]().GetTypeID(), ID0, ID1);
				IDInfos[CurrentID] = IDInfo::CreateIDInfoForValue(
					CurrentID,
					IDInfos[ID1]().GetILType(),
					op,
					IDInfos[ID1]().GetTypeID()
				);
				UpdateValue(op, CurrentID);
				return CurrentID;
			}

			int AddInstrMatrixTimesMatrix(ILOperand *op, int ID0, int ID1)
			{
				++CurrentID;
				CodeGen.OpMatrixTimesMatrix(CurrentID, IDInfos[ID0]().GetTypeID(), ID0, ID1);
				IDInfos[CurrentID] = IDInfo::CreateIDInfoForValue(
					CurrentID,
					IDInfos[ID0]().GetILType(),
					op,
					IDInfos[ID0]().GetTypeID()
				);
				UpdateValue(op, CurrentID);
				return CurrentID;
			}

			int AddInstrBinaryInstr(ILOperand *op, RefPtr<ILType> instrType, const String &opStr, int ID0, int ID1)
			{
				int instrTypeID = DefineType(instrType);
				CurrentID++;
				CodeGen.OpBinaryInstr(CurrentID, opStr, instrTypeID, ID0, ID1);
				IDInfos[CurrentID] = IDInfo::CreateIDInfoForValue(CurrentID, instrType, op, instrTypeID);
				UpdateValue(op, CurrentID);
				return CurrentID;
			}

			int AddInstrMulAdd(int operandID, float mul, float add)
			{
				//return 0.5*op+0.5
				int typeID = IDInfos[operandID]().GetTypeID();  //shoudl be float 
				RefPtr<ILType> typeIL = IDInfos[operandID]().GetILType();

				int mul_ID = AddInstrConstantFloat(mul);
				mul_ID = ConvertBasicType(mul_ID, IDInfos[mul_ID]().GetILType(), IDInfos[operandID]().GetILType());

				int add_ID = AddInstrConstantFloat(add);
				add_ID = ConvertBasicType(add_ID, IDInfos[add_ID]().GetILType(), IDInfos[operandID]().GetILType());

				++CurrentID;
				//ctx.FunctionBody << LR"(%)" << ctx.CurrentID << LR"( = OpFMul %)" << typeID << LR"( %)" << operandID << LR"( %)" << mul_ID << EndLine;
				CodeGen.OpFMul(CurrentID, typeID, operandID, mul_ID);
				IDInfos[CurrentID] = IDInfo::CreateIDInfoForValue(CurrentID, typeIL, 0, typeID);
				++CurrentID;
				//ctx.FunctionBody << LR"(%)" << ctx.CurrentID << LR"( = OpFAdd %)" << typeID << LR"( %)" << ctx.CurrentID-1 << LR"( %)" << add_ID << EndLine;
				CodeGen.OpFAdd(CurrentID, typeID, CurrentID - 1, add_ID);
				IDInfos[CurrentID] = IDInfo::CreateIDInfoForValue(CurrentID, typeIL, 0, typeID);
				return CurrentID;
			}

			int ConvertBasicType(int operandID, RefPtr<ILType> srcType, RefPtr<ILType> dstType)
			{
				String srcStr = srcType->ToString();
				String dstStr = dstType->ToString();
				if (srcStr == dstStr)
					return operandID;

				if (dstType->IsBool())
				{
					if (srcType->IsInt())
						return AddInstrINotEqual(operandID, AddInstrConstantInt(0));
					if (srcType->IsUInt())
						return AddInstrINotEqual(operandID, AddInstrConstantUInt(0));
					throw NotImplementedException(L"only convert int to bool in ConvertBasicType(): " + srcType->ToString());
				}

				//from column vector to column vector
				bool srcIsColumnVector = (srcType->IsFloat() || srcType->IsFloatVector() || srcType->IsIntegral()) && !srcType->IsFloatMatrix();
				bool dstIsColumnVector = (dstType->IsFloat() || dstType->IsFloatVector() || dstType->IsIntegral()) && !dstType->IsFloatMatrix();
				if (srcIsColumnVector && dstIsColumnVector && srcType->GetVectorSize() != dstType->GetVectorSize())
				{
					//make src ID have length equal to destType

					RefPtr<ILType> elementType;
					if (srcType->IsInt() || srcType->IsUInt())
						elementType = new ILBasicType(ILBaseType::Int);
					else if (srcType->IsUInt() || srcType->IsUIntVector())
						elementType = new ILBasicType(ILBaseType::UInt);
					else
						elementType = new ILBasicType(ILBaseType::Float);
					List<int> arguments;
					int extraID = -1;

					if (srcType->GetVectorSize() == 1)
					{
						for (int i = 0; i < dstType->GetVectorSize(); i++)
						{
							arguments.Add(operandID);
						}
					}
					else {
						for (int i = 0; i < dstType->GetVectorSize(); i++)
						{
							if (i >= srcType->GetVectorSize())
							{
								if (i == srcType->GetVectorSize())
								{
									if (srcType->IsInt() || srcType->IsIntVector())
										extraID = AddInstrConstantInt(0);
									else if (srcType->IsUInt() || srcType->IsUIntVector())
										extraID = AddInstrConstantUInt(0);
									else
										extraID = AddInstrConstantFloat(0.0);
								}
								arguments.Add(extraID);
							}
							else
							{
								if (srcType->GetVectorSize() == 1)
									arguments.Add(operandID);
								else
									arguments.Add(AddInstrCompositeExtract(operandID, elementType, i));
							}
						}
					}

					int BaseType = (dynamic_cast<ILBasicType*>(srcType.Ptr()))->Type;
					int newBaseType = BaseType & ~15; // int or float
					newBaseType += dstType->GetVectorSize() - 1;
					RefPtr<ILType> newSrcType = new ILBasicType(ILBaseType(newBaseType));

					operandID = AddInstrCompositeConstruct(0, newSrcType, arguments);
					srcType = newSrcType;
				}

				srcStr = srcType->ToString();
				dstStr = dstType->ToString();
				if (srcStr == dstStr)
					return operandID;

				//from scalar to matrix
				if ((srcStr == L"float" || srcStr == L"int" || srcStr == L"uint") && dstType->IsFloatMatrix())
				{
					throw NotImplementedException(L"scalar to matrix conversion is not supported yet.");
				}

				//from matrix to matrix
				if (srcType->IsFloatMatrix() && dstType->IsFloatMatrix())
				{
					throw NotImplementedException(L"matrix to matrix conversion is not supported yet.");
				}

				if (srcType->GetVectorSize() != dstType->GetVectorSize())
				{
					throw NotImplementedException(L"can not convert " + srcType->ToString() + L" to " + dstType->ToString());
				}

				//component-wise conversion

				bool srcFloat = srcType->IsFloat() || srcType->IsFloatVector();
				bool srcInt = srcType->IsInt() || srcType->IsIntVector();
				bool srcUint = srcType->IsUInt() || srcType->IsUIntVector();
				bool dstFloat = dstType->IsFloat() || dstType->IsFloatVector();
				bool dstInt = dstType->IsInt() || dstType->IsIntVector();
				bool dstUint = dstType->IsUInt() || dstType->IsUIntVector();

				int destTypeID = DefineType(dstType);
				if (srcInt && dstFloat)
					return AddInstrConvertSToF(destTypeID, operandID);
				else if (srcFloat && dstInt)
					return AddInstrConvertFToS(destTypeID, operandID);
				else if (srcUint && dstFloat)
					return AddInstrConvertUToF(destTypeID, operandID);
				else if (srcFloat && dstUint)
					return AddInstrConvertFToU(destTypeID, operandID);
				else if (srcInt && dstUint)
					return AddInstrConvertSToU(destTypeID, operandID);
				else if (srcUint && dstInt)
					return AddInstrConvertUToS(destTypeID, operandID);
				else
					throw NotImplementedException(L"can not convert " + srcType->ToString() + L" to " + dstType->ToString());
			}

			void AddInstrSelectionMerge(int MergeLabel) {
				CodeGen.OpSelectionMerge(MergeLabel);
			}

			void AddInstrBranchConditional(int ID, int TrueLabel, int FalseLabel)
			{
				CodeGen.OpBranchConditional(ID, TrueLabel, FalseLabel);
			}

			void AddInstrLabel_AtFunctionBody(int Label) {
				CodeGen.OpLabel_AtFunctionBody(Label);
			}

			void AddInstrLabel_AtFunctionHeader(int Label)
			{
				CodeGen.OpLabel_AtFunctionHeader(Label);
			}

			void AddInstrBranch(int Target)
			{
				CodeGen.OpBranch(Target);;
			}

			int AddInstrPhi(ILOperand *op, int ID1, int Label1, int ID2, int Label2)
			{
				List<int> branches;
				branches.Add(ID1); branches.Add(Label1);
				branches.Add(ID2); branches.Add(Label2);

				++CurrentID;
				CodeGen.OpPhi(CurrentID, IDInfos[ID1]().GetTypeID(), branches);

				IDInfos[CurrentID] =
					IDInfo::CreateIDInfoForValue(
						CurrentID,
						IDInfos[ID1]().GetILType(),
						op,
						IDInfos[ID1]().GetTypeID()
					);
				UpdateValue(op, CurrentID);
				return CurrentID;
			}

			void AddInstrLoopMerge(int MergeLabel, int ContinueLabel)
			{
				CodeGen.OpLoopMerge(MergeLabel, ContinueLabel);
			}

			void AddInstrReturnValue(int operandID) 
			{
				CodeGen.OpReturnValue(operandID);
			}

			void AddInstrKill() 
			{
				CodeGen.OpKill();
			}

			void AddInstrDecorate(int ID, Decoration deco, int ID1 = 0)
			{
				CodeGen.OpDecorate(ID, deco, ID1);
			}

			void AddInstrMemberDecorate(int ID, int index, Decoration deco, int ID1 = 0)
			{
				CodeGen.OpMemberDecorate(ID, index, deco, ID1);
			}

			void AddInstrFunction(int funcID, int returnTypeID, int funcTypeID, String funcName) 
			{
				CodeGen.OpName(funcID, funcName);
				CodeGen.OpFunction(funcID, returnTypeID, funcTypeID);
			}

			void AddInstrFunctionParameter(ILOperand *op, int typeID, String DebugName)
			{
				int paramID = ++CurrentID;
				CodeGen.OpName(paramID, DebugName);
				CodeGen.OpFunctionParameter(paramID, typeID);
				IDInfos[paramID] = IDInfo::CreateIDInfoForPointer(
					paramID,
					op,
					typeID,
					IDInfos[typeID]().GetILType(),
					IDInfos[typeID]().GetBaseTypeID(),
					StorageClass::Function
				);
				ParameterNameToID[op] = paramID;
				UpdateVariable(op, paramID);
			}

			void AddInstrReturn()
			{
				CodeGen.OpReturn();
			}

			void AddInstrFunctionEnd()
			{
				CodeGen.OpFunctionEnd();
			}

			void AddInstrEntryPoint(ExecutionModel EM, int entryID, const List<int>& interfaceIDs)
			{
				CodeGen.OpEntryPoint(EM, entryID, interfaceIDs);
			}

			void AddInstrExecutionMode(int ID, ExecutionMode mode, int op1 = -1, int op2 = -1, int op3 = -1) 
			{
				CodeGen.OpExecutionMode(ID, mode, op1, op2, op3);
			}

			int AddInstrDot(ILOperand *op, RefPtr<ILType> typeIL, int ID0, int ID1)
			{
				int typeID = DefineType(typeIL);
				++CurrentID;
				CodeGen.OpDot(CurrentID, typeID, ID0, ID1);
				IDInfos[CurrentID] = IDInfo::CreateIDInfoForValue(
					CurrentID,
					typeIL,
					op,
					typeID
				);
				UpdateValue(op, CurrentID);
				return CurrentID;
			}

			int AddInstrTranspose(ILOperand *op, RefPtr<ILType> typeIL, int ID)
			{
				int typeID = DefineType(typeIL);
				++CurrentID;
				CodeGen.OpTranspose(CurrentID, typeID, ID);
				IDInfos[CurrentID] = IDInfo::CreateIDInfoForValue(
					CurrentID,
					typeIL,
					op,
					typeID
				);
				UpdateValue(op, CurrentID);
				return CurrentID;
			}

			int AddInstrDFdx(ILOperand *op, RefPtr<ILType> typeIL, int ID)
			{
				int typeID = DefineType(typeIL);
				++CurrentID;
				CodeGen.OpDPdx(CurrentID, typeID, ID);
				IDInfos[CurrentID] = IDInfo::CreateIDInfoForValue(
					CurrentID,
					typeIL,
					op,
					typeID
				);
				UpdateValue(op, CurrentID);
				return CurrentID;
			}

			int AddInstrDFdy(ILOperand *op, RefPtr<ILType> typeIL, int ID)
			{
				int typeID = DefineType(typeIL);
				++CurrentID;
				CodeGen.OpDPdy(CurrentID, typeID, ID);
				IDInfos[CurrentID] = IDInfo::CreateIDInfoForValue(
					CurrentID,
					typeIL,
					op,
					typeID
				);
				UpdateValue(op, CurrentID);
				return CurrentID;
			}

			int AddInstrFwidth(ILOperand *op, RefPtr<ILType> typeIL, int ID)
			{
				int typeID = DefineType(typeIL);
				++CurrentID;
				CodeGen.OpFwidth(CurrentID, typeID, ID);
				IDInfos[CurrentID] = IDInfo::CreateIDInfoForValue(
					CurrentID,
					typeIL,
					op,
					typeID
				);
				UpdateValue(op, CurrentID);
				return CurrentID;
			}

			void ProduceFunction()
			{
				CodeGen.ProduceFunction();
			}

			List<unsigned int> ProduceWordStream()
			{
				return CodeGen.ProduceWordStream(CurrentID);
			}

			String ProduceTextCode() 
			{
				return CodeGen.ProduceTextCode();
			}
		};



		class SpirvModule
		{
		private:
			SpirVCodeGenContext ctx;
			ExecutionModel currentExecutionModel;
			List<int> interfaceIDs;
			bool DepthReplacing;
			bool LocalSize;
			bool BufferImportOrExport;
			CompiledWorld * currentWorld;

			int GetOperandValue(ILOperand * op)
			{
				int id = -1;
				if (auto c = dynamic_cast<ILConstOperand*>(op))
				{
					auto type = c->Type.Ptr();
					if (type->IsFloat())
					{
						id = ctx.AddInstrConstantFloat(c->FloatValues[0]);
					}
					else if (type->IsInt())
					{
						id = ctx.AddInstrConstantInt(c->IntValues[0]);
					}
					else if (type->IsUInt())
					{
						id = ctx.AddInstrConstantUInt(*((unsigned int*)(&c->IntValues[0])));
					}
					else if (auto baseType = dynamic_cast<ILBasicType*>(type))
					{
						if (baseType->Type == ILBaseType::Float2)
						{
							id = ctx.AddInstrConstantCompositeFloat(c->FloatValues, 2);
						}
						else if (baseType->Type == ILBaseType::Float3)
						{
							id = ctx.AddInstrConstantCompositeFloat(c->FloatValues, 3);
						}
						else if (baseType->Type == ILBaseType::Float4)
						{
							id = ctx.AddInstrConstantCompositeFloat(c->FloatValues, 4);
						}
						else if (baseType->Type == ILBaseType::Float3x3)
						{
							id = ctx.AddInstrConstantMatrix(c->FloatValues, 3);
						}
						else if (baseType->Type == ILBaseType::Float4x4)
						{
							id = ctx.AddInstrConstantMatrix(c->FloatValues, 4);
						}
						else if (baseType->Type == ILBaseType::Int2)
						{
							id = ctx.AddInstrConstantCompositeInt(c->IntValues, 2);
						}
						else if (baseType->Type == ILBaseType::Int3)
						{
							id = ctx.AddInstrConstantCompositeInt(c->IntValues, 3);
						}
						else if (baseType->Type == ILBaseType::Int4)
						{
							id = ctx.AddInstrConstantCompositeInt(c->IntValues, 4);
						}
						else if (baseType->Type == ILBaseType::UInt2)
						{
							id = ctx.AddInstrConstantCompositeUInt((unsigned int*)c->IntValues, 2);
						}
						else if (baseType->Type == ILBaseType::UInt3)
						{
							id = ctx.AddInstrConstantCompositeUInt((unsigned int*)c->IntValues, 3);
						}
						else if (baseType->Type == ILBaseType::UInt4)
						{
							id = ctx.AddInstrConstantCompositeUInt((unsigned int*)c->IntValues, 4);
						}
						else if (baseType->Type == ILBaseType::Bool)
						{
							id = ctx.AddInstrConstantBool(c->IntValues[0]);
						}
					}
					else
						throw InvalidOperationException(L"Illegal constant.");
				}
				else if (auto instr = dynamic_cast<ILInstruction*>(op))
				{
					id = ctx.FindValueID(op);
					if (id == -1)
					{
						//need to load it from storage
						id = ctx.AddInstrLoad(op, op, MemoryAccess::None);
					}
				}
				else
					throw InvalidOperationException(L"Unsupported operand type.");

				return id;
			}

			int GetOperandPointer(ILOperand * op)
			{
				int id = -1;
				//RefPtr<ILType> result_type;
				if (auto c = dynamic_cast<ILConstOperand*>(op))
				{
					int valueID = GetOperandValue(op);
					id = ctx.AddInstrVariableDeclaration(op, op->Type, StorageClass::Function);
					ctx.AddInstrStore(op, id, valueID);
				}
				else if (auto instr = dynamic_cast<ILInstruction*>(op))
				{
					id = ctx.FindVariableID(op);
					if (id == -1)
					{
						int valueID = ctx.FindValueID(op);
						if (valueID == -1)
							throw InvalidOperationException(L"can not find variable ID in Get OperandPointer(): " + op->ToString());
						id = ctx.AddInstrVariableDeclaration(op, instr->Type, StorageClass::Function);
						ctx.AddInstrStore(op, id, valueID);
					}
				}
				else
					throw InvalidOperationException(L"Unsupported operand type.");

				return id;
			}

			void PrintAllocVarInstr(AllocVarInstruction * instr, StorageClass store)
			{
				if (dynamic_cast<ILConstOperand*>(instr->Size.Ptr()))
				{
					ctx.AddInstrVariableDeclaration((ILOperand*)instr, instr->Type, store);
				}
				else
					throw InvalidProgramException(L"size operand of allocVar instr is not an intermediate.");
			}

			Dictionary<String, int> GLSLstd450InstructionSet = GenGLSLstd450InstructionSet();

			void PrintCallInstr(CallInstruction * instr)
				// return ID of this instruction
			{
				String callName = GetFuncOriginalName(instr->Function);

				//------------------------- texture instructions -------------------------
				if (callName == L"texture")
				{
					if (instr->Arguments[0]->Type->IsNonShadowTexture())
					{
						if (instr->Arguments[0]->Type->ToString() == L"sampler2D")
						{
							//*** no bias!!!
							//__intrinsic vec4 texture(sampler2D tex, vec2 coord);
							ctx.AddInstrTexture(
								(ILOperand*)instr,
								GetOperandValue(instr->Arguments[0].Ptr()),
								GetOperandValue(instr->Arguments[1].Ptr()),
								currentExecutionModel
							);
							return;
						}
						else if (instr->Arguments[0]->Type->ToString() == L"samplerCube")
						{
							if (instr->Arguments.Count() == 2)
							{
								//__intrinsic vec4 texture(samplerCube tex, vec3 coord);
								ctx.AddInstrTexture(
									(ILOperand*)instr,
									GetOperandValue(instr->Arguments[0].Ptr()),
									GetOperandValue(instr->Arguments[1].Ptr()),
									currentExecutionModel
								);
								return;
							}
							else
							{
								//__intrinsic vec4 texture(samplerCube tex, vec3 coord, float bias);
								ctx.AddInstrTexture(
									(ILOperand*)instr,
									GetOperandValue(instr->Arguments[0].Ptr()),
									GetOperandValue(instr->Arguments[1].Ptr()),
									currentExecutionModel,
									GetOperandValue(instr->Arguments[2].Ptr())
								);
								return;
							}
						}
					}
					else
					{
						//instr->Arguments[0]->Type->IsShadowTexture

						//__intrinsic float texture(sampler2DShadow tex, vec3 coord);
						//__intrinsic float texture(samplerCubeShadow tex, vec4 coord);
						ctx.AddInstrTextureShadow(
							(ILOperand*)instr,
							GetOperandValue(instr->Arguments[0].Ptr()),
							GetOperandValue(instr->Arguments[1].Ptr()),
							currentExecutionModel
						);
						return;
					}
				}

				if (callName == L"textureGrad")
				{
					//__intrinsic vec4 textureGrad(sampler2D tex, vec2 coord, vec2 dPdx, vec2 dPdy);
					//__intrinsic vec4 textureGrad(samplerCube tex, vec3 coord, vec3 dPdx, vec3 dPdy);
					ctx.AddInstrTexture(
						(ILOperand*)instr,
						GetOperandValue(instr->Arguments[0].Ptr()),
						GetOperandValue(instr->Arguments[1].Ptr()),
						currentExecutionModel,
						-1,	//Bias
						GetOperandValue(instr->Arguments[2].Ptr()),
						GetOperandValue(instr->Arguments[3].Ptr())
					);
					return;
				}

				if (callName == L"textureProj")
				{
					if (instr->Arguments[0]->Type->ToString() == L"sampler2DShadow")
					{
						//__intrinsic float textureProj(sampler2DShadow tex, vec4 coord);
						ctx.AddInstrTexture2DShadowProj(
							(ILOperand*)instr,
							GetOperandValue(instr->Arguments[0].Ptr()),
							GetOperandValue(instr->Arguments[1].Ptr()),
							currentExecutionModel
						);
						return;
					}
				}

				//------------------------- Dot Instruction ------------------------------
				if (callName == L"dot"
					&& instr->Arguments.Count() == 2
					&& instr->Arguments[0]->Type->ToString() == instr->Arguments[1]->Type->ToString()
					&& instr->Arguments[0]->Type->IsFloatVector()
					&& !instr->Arguments[0]->Type->IsFloatMatrix())
				{
					ctx.AddInstrDot(
						(ILOperand*)instr,
						instr->Type,
						GetOperandValue(instr->Arguments[0].Ptr()),
						GetOperandValue(instr->Arguments[1].Ptr())
					);
					return;
				}

				//------------------------- Transpose Instruction ------------------------------
				if (callName == L"transpose" && instr->Arguments.Count() == 1 && instr->Arguments[0]->Type->IsFloatMatrix())
				{
					ctx.AddInstrTranspose((ILOperand*)instr, instr->Type, GetOperandValue(instr->Arguments[0].Ptr()));
					return;
				}

				//------------------------- Derivative Instruction -----------------------------
				if (callName == L"dFdx")
				{
					ctx.AddInstrDFdx((ILOperand*)instr, instr->Type, GetOperandValue(instr->Arguments[0].Ptr()));
					return;
				}
				else if (callName == L"dFdy")
				{
					ctx.AddInstrDFdy((ILOperand*)instr, instr->Type, GetOperandValue(instr->Arguments[0].Ptr()));
					return;
				}
				else if (callName == L"fwidth")
				{
					ctx.AddInstrFwidth((ILOperand*)instr, instr->Type, GetOperandValue(instr->Arguments[0].Ptr()));
					return;
				}

				//------------------------- user-defined  instructions -------------------------
				int funcID;
				if (ctx.FunctionNameToFunctionID.TryGetValue(instr->Function, funcID))
				{
					RefPtr<ILType> returnType = ctx.IDInfos[
						ctx.FunctionNameToFunctionTypeID[instr->Function]()
					]().GetFunc()->ReturnType;
						int typeID = ctx.DefineType(returnType);
						List<int> args;
						for (auto & arg : instr->Arguments) {
							int valueID = GetOperandValue(arg.Ptr());
							int paramID = ctx.AddInstrVariableDeclaration(0, arg->Type, StorageClass::Function, L"param");
							// the name of the parameter must be empty; or may conflict with non-param variables
							ctx.AddInstrStore(0, paramID, valueID);
							args.Add(paramID);
						}
						ctx.AddInstrFunctionCall((ILOperand*)instr, typeID, funcID, args);
						return;
				}

				//------------------------- ext-import  instructions -----------------------------
				List<int> Arguments;

				for (auto & arg : instr->Arguments) {
					int valueID = GetOperandValue(arg.Ptr());
					if (callName == L"mix") {
						//the mix instruction in spirv only accept mix(vec_, vec_, vec_);
						//however, front end of SPIRE can accept mix(vec_, vec_, float);
						valueID = ctx.ConvertBasicType(valueID, arg->Type, instr->Type);
					}
					Arguments.Add(valueID);
				}

				if (GLSLstd450InstructionSet.ContainsKey(callName))
				{
					ctx.AddInstrExtInst((ILOperand*)instr, instr->Type, GLSLstd450InstructionSet[callName](), Arguments);
					return;
				}


				//------------------------- built-in constructors -----------------------------

				RefPtr<ILType> dstType = GetTypeFromString(callName);
				if (dstType == nullptr)
					throw InvalidOperationException(L"can not call: " + callName);
				RefPtr<ILBasicType> dstBasicType = dstType;

				if (instr->Arguments.Count() > 1)
				{
					//composite
					for (auto & ID : Arguments)
					{
						auto argBasicType = dynamic_cast<ILBasicType*>((ctx.IDInfos[ID]().GetILType()).Ptr());
						if (argBasicType)
							if (argBasicType->IsIntegral() != dstType->IsIntegral())
							{
								RefPtr<ILType> argDstType = new ILBasicType(ILBaseType((dstBasicType->Type & ~15) + (argBasicType->Type & 15)));
								ID = ctx.ConvertBasicType(ID, ctx.IDInfos[ID]().GetILType(), argDstType);
							}
					}

					if (instr->Type->IsFloatMatrix() &&
						(Arguments.Count() == 0 || (Arguments.Count() > 0 && ctx.IDInfos[Arguments[0]]().GetILType()->IsScalar())))
					{
						//need to arrange scalars into vectors
						int n = (int)sqrt((float)instr->Type->GetVectorSize() + 1e-6);
						int diff = n * n - Arguments.Count();
						if (diff > 0)
							for (int i = 0; i < diff; i++)
								Arguments.Add(ctx.AddInstrConstantFloat(0.0));
						List<int> newArguments;
						RefPtr<ILType> vectorType = new ILBasicType(ILBaseType(ILBaseType::Float + n - 1));
						for (int i = 0; i < n; i++)
						{
							List<int> subArguments;
							for (int j = 0; j < n; j++)
								subArguments.Add(Arguments[i*n + j]);
							newArguments.Add(ctx.AddInstrCompositeConstruct(0, vectorType, subArguments));
						}
						Arguments = newArguments;
					}

					ctx.AddInstrCompositeConstruct((ILOperand*)instr, instr->Type, Arguments);
					return;
				}
				else
				{
					//need conversion
					int ID = Arguments[0];
					ID = ctx.ConvertBasicType(ID, ctx.IDInfos[ID]().GetILType(), dstType);
					ctx.UpdateValue((ILOperand*)instr, ID);
					return;
				}

			}

			void PrintUnaryInstr(UnaryInstruction * instr)
			{
				auto op0 = instr->Operand.Ptr();
				if (instr->Is<LoadInstruction>())
				{
					ctx.AddInstrLoad((ILOperand*)instr, op0, MemoryAccess::None);
					return;
				}

				if (instr->Is<NotInstruction>())
					instr->Type = GetTypeFromString(L"bool");

				int op0ValueID = GetOperandValue(op0);
				op0ValueID = ctx.ConvertBasicType(op0ValueID, ctx.IDInfos[op0ValueID]().GetILType(), instr->Type);
				RefPtr<ILType> op0ILType = ctx.IDInfos[op0ValueID]().GetILType();

				if (instr->Is<Float2IntInstruction>() || instr->Is<Int2FloatInstruction>() || instr->Is<CopyInstruction>())
				{
					ctx.UpdateValue((ILOperand*)instr, op0ValueID);
					return;
				}

				int instrTypeID = ctx.DefineType(instr->Type);

				if (instr->Is<NegInstruction>())
				{
					if (op0ILType->IsFloat() || op0ILType->IsFloatVector())
						ctx.AddInstrFnegate((ILOperand*)instr, instrTypeID, op0ValueID);
					else if (op0ILType->IsInt() || op0ILType->IsIntVector())
						ctx.AddInstrSnegate((ILOperand*)instr, instrTypeID, op0ValueID);
					else if (op0ILType->IsUInt() || op0ILType->IsUIntVector())
						throw InvalidOperationException(L"trying to negate a uint in PrintUnaryInstruction(): " + instr->ToString());
				}
				else if (instr->Is<BitNotInstruction>())
					ctx.AddInstrNot((ILOperand*)instr, instrTypeID, op0ValueID);
				else if (instr->Is<NotInstruction>())
					ctx.AddInstrLogicalNot((ILOperand*)instr, instrTypeID, op0ValueID);
				else
					throw InvalidProgramException(L"unsupported unary instruction.");
			}

			void PrintBinaryInstr(BinaryInstruction * instr)
			{
				auto op0 = instr->Operands[0].Ptr();
				auto op1 = instr->Operands[1].Ptr();

				//-------------------------------------Store Instruction------------------------------------------
				if (instr->Is<StoreInstruction>())
				{
					if (auto structType = dynamic_cast<ILStructType*>(op0->Type.Ptr()))
					{
						int op0ID = ctx.FindVariableID(op0);
						int op1ID = ctx.FindVariableID(op1);
						int index = 0;
						for (int i = 0; i < structType->Members.Count(); i++)
						{
							int indexID = ctx.AddInstrConstantInt(index);
							int dest = ctx.AddInstrAccessChain_StructMember(0, op0ID, indexID, index);
							int pSrc = ctx.AddInstrAccessChain_StructMember(0, op1ID, indexID, index);
							int vSrc = ctx.AddInstrLoad(pSrc, MemoryAccess::None);
							ctx.AddInstrStore(0, dest, vSrc);
							index++;
						}
						return;
					}

					int op0ID = ctx.FindVariableID(op0); // should be a pointer 
					int op1ID = GetOperandValue(op1);
					op1ID = ctx.ConvertBasicType(op1ID, ctx.IDInfos[op1ID]().GetILType(), ctx.IDInfos[op0ID]().GetILType());
					ctx.AddInstrStore(instr, op0ID, op1ID); //TO FIX
					return;
				}

				//----------------------------------Member Load Instruction---------------------------------------
				if (instr->Is<MemberLoadInstruction>())
				{
					int fatherID = GetOperandPointer(op0);
					if (op0->Type->IsVector())
					{
						if (auto c = dynamic_cast<ILConstOperand*>(op1))
						{
							//if op1 is constant, take that as index of vector 
							int memberID = ctx.AddInstrAccessChain_VectorMember((ILOperand*)instr, fatherID, -1, c->IntValues[0]);
							int retID = ctx.AddInstrLoad(memberID, MemoryAccess::None);
							ctx.UpdateValue((ILOperand*)instr, retID);
							return;
						}
						else
						{
							//if op1 is not constant, compute it
							int memberID = ctx.AddInstrAccessChain_VectorMember((ILOperand*)instr, fatherID, GetOperandValue(op1), -1);
							int retID = ctx.AddInstrLoad(memberID, MemoryAccess::None);
							ctx.UpdateValue((ILOperand*)instr, retID);
							return;
						}
					}
					else if (auto structType = dynamic_cast<ILStructType*>(op0->Type.Ptr()))
					{
						if (auto c = dynamic_cast<ILConstOperand*>(op1))
						{
							//index of struct must be constant
							int indexID = GetOperandValue(c);
							int memberID = ctx.AddInstrAccessChain_StructMember((ILOperand*)instr, fatherID, indexID, c->IntValues[0]);
							int retID = ctx.AddInstrLoad(memberID, MemoryAccess::None);
							ctx.UpdateValue((ILOperand*)instr, retID);
							return;
						}
						else
							throw InvalidOperationException(L"wrong: " + instr->ToString());
					}
					else if (auto arrayType = dynamic_cast<ILArrayType*>(op0->Type.Ptr()))
					{
						int memberID = ctx.AddInstrAccessChain_ArrayMember((ILOperand*)instr, op0->Type, fatherID, GetOperandValue(op1));
						int retID = ctx.AddInstrLoad(memberID, MemoryAccess::None);
						ctx.UpdateValue((ILOperand*)instr, retID);
						return;
					}
					else
						throw InvalidOperationException(L"wrong op0 type for MemberLoadInstruction(): " + op0->Type->ToString());
				}

				int ID0 = GetOperandValue(op0);
				int ID1 = GetOperandValue(op1);
				RefPtr<ILType> ID0Type = ctx.IDInfos[ID0]().GetILType();
				RefPtr<ILType> ID1Type = ctx.IDInfos[ID1]().GetILType();

				//----------------------------------Vec/Mat Multiplication---------------------------------------
				if (instr->Is<MulInstruction>())
				{
					//scalar X matrix or matrix X scalar
					if (ID0Type->IsScalar() && ID1Type->IsFloatMatrix() ||
						ID1Type->IsScalar() && ID0Type->IsFloatMatrix())
					{
						if (ID1Type->IsFloatMatrix())
							Swap(ID0, ID1);
						//now ID0 is matrix, ID1 is scalar, 
						ID1 = ctx.ConvertBasicType(ID1, ctx.IDInfos[ID1]().GetILType(), GetTypeFromString(L"float"));
						ctx.AddInstrMatrixTimesScalar((ILOperand*)instr, ID0, ID1);
						return;
					}

					//vector X matrix
					if (ID0Type->IsFloatVector() && !ID0Type->IsFloatMatrix() && ID1Type->IsFloatMatrix())
					{
						ctx.AddInstrVectorTimesMatrix((ILOperand*)instr, ID0, ID1);
						return;
					}

					//matrix X vector
					if (ID1Type->IsFloatVector() && !ID1Type->IsFloatMatrix() && ID0Type->IsFloatMatrix())
					{
						ctx.AddInstrMatrixTimesVector((ILOperand*)instr, ID0, ID1);
						return;
					}

					//matrix X matrix
					if (ID0Type->IsFloatMatrix() && ID1Type->IsFloatMatrix())
					{
						ctx.AddInstrMatrixTimesMatrix((ILOperand*)instr, ID0, ID1);
						return;
					}
				}

				//---------------------------------Boolean-Related Instruction---------------------------------------
				bool ResultIsLogical =
					instr->Is<OrInstruction>() || instr->Is<AndInstruction>() ||
					instr->Is<CmpeqlInstruction>() || instr->Is<CmpgeInstruction>() || instr->Is<CmpgtInstruction>() ||
					instr->Is<CmpleInstruction>() || instr->Is<CmpltInstruction>() || instr->Is<CmpneqInstruction>();

				if (dynamic_cast<ILBasicType*>(instr->Type.Ptr())->Type == 0)
				{
					instr->Type = ID0Type;
				}

				if (ResultIsLogical)
				{
					RefPtr<ILType> OperandType = nullptr;
					if (instr->Is<OrInstruction>() || instr->Is<AndInstruction>())
					{
						OperandType = GetTypeFromString(L"bool");
					}
					else
					{
						if (ID0Type->IsFloat() || ID1Type->IsFloat())
							OperandType = GetTypeFromString(L"float");
						else if (ID0Type->IsUInt() || ID1Type->IsUInt())
							OperandType = GetTypeFromString(L"uint");
						else if (ID0Type->IsInt() || ID1Type->IsInt())
							OperandType = GetTypeFromString(L"int");
					}

					ID0 = ctx.ConvertBasicType(ID0, ID0Type, OperandType);
					ID1 = ctx.ConvertBasicType(ID1, ID1Type, OperandType);

					instr->Type = GetTypeFromString(L"bool");
					ID0Type = ctx.IDInfos[ID0]().GetILType();
					ID1Type = ctx.IDInfos[ID1]().GetILType();
				}
				else
				{
					ID0 = ctx.ConvertBasicType(ID0, ID0Type, instr->Type);
					ID1 = ctx.ConvertBasicType(ID1, ID1Type, instr->Type);

					ID0Type = ctx.IDInfos[ID0]().GetILType();
					ID1Type = ctx.IDInfos[ID1]().GetILType();
				}

				//--------------------------------------Get Binary Operator String---------------------------------------
				String opStr;
				bool needPrefix = false;
				bool Signed = false;
				if (instr->Is<MulInstruction>())
				{
					opStr = L"Mul";
					needPrefix = true;
				}
				else if (instr->Is<AddInstruction>())
				{
					opStr = L"Add";
					needPrefix = true;
				}
				else if (instr->Is<DivInstruction>())
				{
					opStr = L"Div";
					needPrefix = true;
					Signed = true;
				}
				else if (instr->Is<SubInstruction>())
				{
					opStr = L"Sub";
					needPrefix = true;
				}
				else if (instr->Is<ModInstruction>())
				{
					opStr = L"Mod";
					needPrefix = true;
					Signed = true;
				}
				else if (instr->Is<ShlInstruction>())
				{
					opStr = L"ShiftLeftLogical";
				}
				else if (instr->Is<ShrInstruction>())
				{
					if (ID0Type->IsUInt() || ID0Type->IsUIntVector())
						opStr = L"ShiftRightLogical";
					else
						opStr = L"ShiftRightArithmetic";
				}
				else if (instr->Is<BitXorInstruction>())
				{
					opStr = L"BitwiseXor";
				}
				else if (instr->Is<BitAndInstruction>())
				{
					opStr = L"BitwiseAnd";
				}
				else if (instr->Is<BitOrInstruction>())
				{
					opStr = L"BitwiseOr";
				}
				else if (instr->Is<AndInstruction>())
				{
					opStr = L"LogicalAnd";
				}
				else if (instr->Is<OrInstruction>())
				{
					opStr = L"LogicalOr";
				}
				else if (instr->Is<CmpneqInstruction>())
				{
					if (ID0Type->IsIntegral())
						opStr = L"INotEqual";
					else
						opStr = L"FOrdNotEqual";
				}
				else if (instr->Is<CmpeqlInstruction>())
				{
					if (ID0Type->IsIntegral())
						opStr = L"IEqual";
					else
						opStr = L"FOrdEqual";
				}
				else if (instr->Is<CmpgeInstruction>())
				{
					if (ID0Type->IsIntegral())
					{
						if (ID0Type->IsUInt() || ID0Type->IsUIntVector())
							opStr = L"UGreaterThanEqual";
						else
							opStr = L"SGreaterThanEqual";
					}
					else
						opStr = L"FOrdGreaterThanEqual";
				}
				else if (instr->Is<CmpgtInstruction>())
				{
					if (ID0Type->IsIntegral())
					{
						if (ID0Type->IsUInt() || ID0Type->IsUIntVector())
							opStr = L"UGreaterThan";
						else
							opStr = L"SGreaterThan";
					}
					else
						opStr = L"FOrdGreaterThan";
				}
				else if (instr->Is<CmpleInstruction>())
				{
					if (ID0Type->IsIntegral())
					{
						if (ID0Type->IsUInt() || ID0Type->IsUIntVector())
							opStr = L"ULessThanEqual";
						else
							opStr = L"SLessThanEqual";
					}
					else
						opStr = L"FOrdLessThanEqual";
				}
				else if (instr->Is<CmpltInstruction>())
				{
					if (ID0Type->IsIntegral())
					{
						if (ID0Type->IsUInt() || ID0Type->IsUIntVector())
							opStr = L"ULessThan";
						else
							opStr = L"SLessThan";
					}
					else
						opStr = L"FOrdLessThan";
				}
				else
					throw InvalidProgramException(L"unsupported binary instruction: " + instr->ToString());

				//---------------------------------------Generate Instrction---------------------------------------

				String finalOpStr = LR"(Op)";
				if (needPrefix)
				{
					if (ID0Type->IsFloat() || ID0Type->IsFloatVector())
						finalOpStr = finalOpStr + LR"(F)";
					else if (ID0Type->IsIntegral())
					{
						if (Signed)
							finalOpStr = finalOpStr + LR"(S)";
						else
							finalOpStr = finalOpStr + LR"(I)";
					}
				}
				finalOpStr = finalOpStr + opStr;

				ctx.AddInstrBinaryInstr((ILOperand*)instr, instr->Type, finalOpStr, ID0, ID1);
			}

			void PrintUpdateInstr(MemberUpdateInstruction * instr)
			{
				int variableID = ctx.AddInstrVariableDeclaration((ILOperand*)instr, instr->Operands[0]->Type, StorageClass::Function);
				ctx.AddInstrStore((ILOperand*)instr, variableID, GetOperandValue(instr->Operands[0].Ptr()));

				auto typeIL = ctx.IDInfos[variableID]().GetILType().Ptr();
				int memberID = -1;
				int indexID = GetOperandValue(instr->Operands[1].Ptr());

				if (indexID == -1)
					throw InvalidOperationException(L"bad index in PrintUpdateInstr(): " + instr->Operands[1]->ToString());

				if (auto structType = dynamic_cast<ILStructType*>(typeIL))
				{
					auto c = dynamic_cast<ILConstOperand*>(instr->Operands[1].Ptr());
					if (c)
						memberID = ctx.AddInstrAccessChain_StructMember(0, variableID, indexID, c->IntValues[0]);
					else
						throw InvalidOperationException(L"index of struct must be const in PrintUpdateInstr(): " + instr->Operands[1]->ToString());
				}
				else if (auto arrayType = dynamic_cast<ILArrayType*>(typeIL))
				{
					memberID = ctx.AddInstrAccessChain_ArrayMember(0, typeIL, variableID, indexID);
				}
				else if (auto vecType = dynamic_cast<ILBasicType*>(typeIL))
				{
					if (!typeIL->IsVector())
						throw InvalidOperationException(L"unable to update members of type: " + typeIL->ToString());
					memberID = ctx.AddInstrAccessChain_VectorMember(0, variableID, indexID, -1);
				}
				else
					throw InvalidOperationException(L"not supported type in PrintUpdateInstr(): " + typeIL->ToString());

				ctx.AddInstrStore(
					0,
					memberID,
					GetOperandValue(instr->Operands[2].Ptr())
				);
				ctx.InvalidateValue((ILOperand*)instr);
			}

			void PrintSelectInstr(SelectInstruction * instr)
			{
				int ID0 = GetOperandValue(instr->Operands[0].Ptr());
				ID0 = ctx.ConvertBasicType(
					ID0,
					ctx.IDInfos[ID0]().GetILType(),
					GetTypeFromString(L"bool"));

				int TrueLabel = ++ctx.CurrentID;
				int FalseLabel = ++ctx.CurrentID;
				int MergeLabel = ++ctx.CurrentID;

				ctx.AddInstrSelectionMerge(MergeLabel);
				ctx.AddInstrBranchConditional(ID0, TrueLabel, FalseLabel);

				ctx.AddInstrLabel_AtFunctionBody(TrueLabel);
				int ID1 = GetOperandValue(instr->Operands[1].Ptr());
				ID1 = ctx.ConvertBasicType(ID1, ctx.IDInfos[ID1]().GetILType(), instr->Type);
				ctx.AddInstrBranch(MergeLabel);

				ctx.AddInstrLabel_AtFunctionBody(FalseLabel);
				int ID2 = GetOperandValue(instr->Operands[2].Ptr());
				ID2 = ctx.ConvertBasicType(ID2, ctx.IDInfos[ID2]().GetILType(), instr->Type);
				ctx.AddInstrBranch(MergeLabel);

				ctx.AddInstrLabel_AtFunctionBody(MergeLabel);

				ctx.AddInstrPhi((ILOperand*)instr, ID1, TrueLabel, ID2, FalseLabel);
			}

			void PrintFetchArgInstr(FetchArgInstruction * instr)
			{
				if (instr->ArgId == 0)
				{
					ctx.ReturnID = ctx.AddInstrVariableDeclaration((ILOperand*)instr, instr->Type, StorageClass::Function);
				}
			}

			void PrintExportInstr(ExportInstruction * instr)
			{
				String exportOpName = instr->ExportOperator;

				if (exportOpName == L"fragmentExport")
				{
					CompiledComponent ccomp;
					bool isNormal = false;
					bool isDepthOutput = false;
					if (currentWorld->LocalComponents.TryGetValue(instr->ComponentName, ccomp))
					{
						if (ccomp.Attributes.ContainsKey(L"Normal"))
							isNormal = true;
						if (ccomp.Attributes.ContainsKey(L"DepthOutput"))
							isDepthOutput = true;
					}
					String exportName;
					if (isDepthOutput)
						exportName = L"gl_FragDepth";
					else
						exportName = instr->ComponentName;

					int exportID = ctx.InterfaceNameToID[exportName];
					if (exportID == -1)
						throw InvalidOperationException(L"can not find component for export instruction for fragmentExport in PrintExportInstr(): " + exportName);

					int operandID = GetOperandValue(instr->Operand.Ptr());
					if (isNormal)
						operandID = ctx.AddInstrMulAdd(operandID, 0.5, 0.5);

					ctx.AddInstrStore((ILOperand*)instr, exportID, operandID);
				}

				else if (exportOpName == L"standardExport")
				{
					int storeID = ctx.AddInstrAccessChain_StructMember(0, ctx.InterfaceNameToID[L"blk" + currentWorld->WorldOutput->Name], instr->ComponentName);
					ctx.AddInstrStore((ILOperand*)instr, storeID, GetOperandValue(instr->Operand.Ptr()));
				}

				else if (exportOpName == L"bufferExport")
				{
					auto & comp = currentWorld->WorldOutput->Entries[instr->ComponentName]();

					auto UIntType = GetTypeFromString(L"uint");
					auto FloatType = GetTypeFromString(L"float");
					int GIIDx = ctx.AddInstrLoad(
						ctx.AddInstrAccessChain_VectorMember(0, ctx.InterfaceNameToID[L"gl_GlobalInvocationID"], -1, 0),
						MemoryAccess::None
					);	//GlobalInvocationID.x
					int baseIndex = ctx.AddInstrBinaryInstr(
						0,
						UIntType,
						L"OpIMul",
						GIIDx,
						ctx.AddInstrConstantUInt(currentWorld->WorldOutput->Size / 4)
					);
					baseIndex = ctx.AddInstrBinaryInstr(
						0,
						UIntType,
						L"OpIAdd",
						baseIndex,
						ctx.AddInstrConstantUInt(comp.Offset / 4)
					);

					RefPtr<ILType> compElementType =
						(!comp.Type->IsIntegral())
						? FloatType
						: ((comp.Type->IsUInt() || comp.Type->IsUIntVector()) ? UIntType : GetTypeFromString(L"int"));

					for (int i = 0; i < comp.Type->GetVectorSize(); i++)
					{
						int index = ctx.AddInstrBinaryInstr(
							0,
							UIntType,
							L"OpIAdd",
							baseIndex,
							ctx.AddInstrConstantUInt(i)
						);

						int blockID = ctx.InterfaceNameToID[L"blk" + currentWorld->WorldOutput->Name];
						int arrayID = ctx.AddInstrAccessChain_StructMember(0, blockID, -1, 0);
						int storeID = ctx.AddInstrAccessChain_ArrayMember(
							0,
							ctx.IDInfos[arrayID]().GetILType(),
							arrayID,
							index
						);

						int valueID = -1;
						if (instr->Operand->Type->GetVectorSize() > 1)
							valueID = ctx.AddInstrLoad(
								ctx.AddInstrAccessChain_VectorMember(0, GetOperandPointer(instr->Operand.Ptr()), -1, i),
								MemoryAccess::None
							);
						else
							valueID = ctx.AddInstrLoad(
								GetOperandPointer(instr->Operand.Ptr()),
								MemoryAccess::None
							);

						valueID = ctx.ConvertBasicType(valueID, ctx.IDInfos[valueID]().GetILType(), compElementType);

						if (ctx.IDInfos[valueID]().GetILType()->IsIntegral())
							valueID = ctx.AddInstrBitcast(ctx.DefineType(FloatType), valueID);

						ctx.AddInstrStore(0, storeID, valueID);
					}
				}

				else
					throw InvalidOperationException(L"not valid export operator in PrintExportInstr(): " + exportOpName);
			}

			void PrintImportInstr(ImportInstruction * instr)
			{
				auto block = instr->SourceWorld->WorldOutput;

				if (instr->ImportOperator->Name.Content == L"standardImport")
				{
					ctx.AddInstrAccessChain_StructMember(instr, ctx.InterfaceNameToID[L"blk" + block->Name], instr->ComponentName);
				}

				else if (instr->ImportOperator->Name.Content == L"vertexImport")
				{
					int componentID = ctx.InterfaceNameToID[instr->ComponentName];
					if (componentID == -1)
						throw InvalidOperationException(L"can not find import component for vertexImport in PrintImportInstr(): " + instr->ComponentName);
					ctx.UpdateVariable(instr, componentID);
				}

				else if (instr->ImportOperator->Name.Content == L"uniformImport")
				{
					if (instr->Type->IsTexture())
					{
						int pointerID = ctx.InterfaceNameToID[instr->ComponentName];
						if (pointerID == -1)
							throw InvalidOperationException(L"can not find import component for uniformImport in PrintImportInstr(): " + instr->ComponentName);
						ctx.UpdateVariable(instr, pointerID);
					}
					else
					{
						ctx.AddInstrAccessChain_StructMember(instr, ctx.InterfaceNameToID[L"blk" + block->Name], instr->ComponentName);
					}
				}

				else if (instr->ImportOperator->Name.Content == L"textureImport")
				{
					int textureStorageID = ctx.InterfaceNameToID[instr->ComponentName];
					int textureValueID = ctx.AddInstrLoad(textureStorageID, MemoryAccess::None);

					int operandID = -1;
					operandID = ctx.AddInstrTexture(
						0,
						textureValueID,
						GetOperandValue(instr->Arguments[0].Ptr()),
						currentExecutionModel
					);

					operandID = ctx.ConvertBasicType(
						operandID,
						ctx.IDInfos[operandID]().GetILType(),
						instr->Type);
					CompiledComponent ccomp;
					if (instr->SourceWorld->LocalComponents.TryGetValue(instr->ComponentName, ccomp))
					{
						if (ccomp.Attributes.ContainsKey(L"Normal"))
							operandID = ctx.AddInstrMulAdd(operandID, 2.0, -1.0);
					}

					int storeID = ctx.AddInstrVariableDeclaration((ILOperand*)instr, instr->Type, StorageClass::Function);
					ctx.AddInstrStore((ILOperand*)instr, storeID, operandID);
				}

				else if (instr->ImportOperator->Name.Content == L"bufferImport")
				{
					//instr->Name[][] = 
					//	*(int*/float*) 
					//	( block->Name + block->Entries[instr->ComponentName].GetValue().Offset / 4 + i + gl_GlobalInvocationID.x * block->Size / 4 )

					auto UIntType = GetTypeFromString(L"uint");
					auto FloatType = GetTypeFromString(L"float");
					int GIIDx = ctx.AddInstrLoad(
						ctx.AddInstrAccessChain_VectorMember(0, ctx.InterfaceNameToID[L"gl_GlobalInvocationID"], -1, 0),
						MemoryAccess::None
					);	//GlobalInvocationID.x
					int baseIndex = ctx.AddInstrBinaryInstr(
						0,
						UIntType,
						L"OpIMul",
						GIIDx,
						ctx.AddInstrConstantUInt(block->Size / 4)
					);
					baseIndex = ctx.AddInstrBinaryInstr(
						0,
						UIntType,
						L"OpIAdd",
						baseIndex,
						ctx.AddInstrConstantUInt(block->Entries[instr->ComponentName]().Offset / 4)
					);

					RefPtr<ILType> instrElementType =
						(!instr->Type->IsIntegral())
						? FloatType
						: ((instr->Type->IsUInt() || instr->Type->IsUIntVector()) ? UIntType : GetTypeFromString(L"int"));

					int vecSize = instr->Type->GetVectorSize();
					int srcIDs[16];
					for (int i = 0; i < vecSize; i++)
					{
						int index = ctx.AddInstrBinaryInstr(
							0,
							UIntType,
							L"OpIAdd",
							baseIndex,
							ctx.AddInstrConstantUInt(i)
						);
						int blockID = ctx.InterfaceNameToID[L"blk" + block->Name];
						int arrayID = ctx.AddInstrAccessChain_StructMember(0, blockID, -1, 0);
						int srcID = ctx.AddInstrLoad(
							ctx.AddInstrAccessChain_ArrayMember(0, ctx.IDInfos[arrayID]().GetILType(), arrayID, index),
							MemoryAccess::None
						);
						srcIDs[i] = ctx.AddInstrBitcast(ctx.DefineType(instrElementType), srcID);
					}

					int valueID = -1;

					if (instr->Type->IsFloatMatrix())
					{
						int n = 3;
						auto colType = GetTypeFromString(L"vec3");
						if (instr->Type->GetVectorSize() == 16)
						{
							n = 4;
							colType = GetTypeFromString(L"vec4");
						}
						int colIDs[4];
						for (int i = 0; i < n; i++)
						{
							List<int> args;
							for (int j = 0; j < n; j++)
								args.Add(srcIDs[i*n + j]);
							colIDs[i] = ctx.AddInstrCompositeConstruct(0, colType, args);
						}
						List<int> args;
						for (int i = 0; i < n; i++)
							args.Add(colIDs[i]);
						valueID = ctx.AddInstrCompositeConstruct(0, instr->Type, args);
					}
					else if (instr->Type->IsVector())
					{
						int n = 3;
						if (instr->Type->GetVectorSize() == 16)
							n = 4;
						List<int> args;
						for (int i = 0; i < n; i++)
							args.Add(srcIDs[i]);
						valueID = ctx.AddInstrCompositeConstruct(0, instr->Type, args);
					}
					else //scalar
					{
						valueID = srcIDs[0];
					}

					int storeID = ctx.AddInstrVariableDeclaration(instr, instr->Type, StorageClass::Function);
					ctx.AddInstrStore(instr, storeID, valueID);
				}

				else
					throw NotImplementedException(L"import in PrintImportInstr(): " + instr->ImportOperator->Name.Content);
			}

			void PrintInstr(ILInstruction & instr)
			{
				if (auto binInstr = instr.As<BinaryInstruction>())
					PrintBinaryInstr(binInstr);
				else if (auto allocVar = instr.As<AllocVarInstruction>())
					PrintAllocVarInstr(allocVar, StorageClass::Function);
				else if (auto call = instr.As<CallInstruction>())
					PrintCallInstr(call);
				else if (auto exportInstr = instr.As<ExportInstruction>())
				{
					PrintExportInstr(exportInstr);
					//throw InvalidOperationException(L"export instruction not supported");

				}
				else if (auto import = instr.As<ImportInstruction>())
				{
					PrintImportInstr(import);
					//throw InvalidOperationException(L"import instruction not supported");
				}
				else if (auto update = instr.As<MemberUpdateInstruction>())
					PrintUpdateInstr(update);
				else if (auto unaryInstr = instr.As<UnaryInstruction>())
					PrintUnaryInstr(unaryInstr);
				else if (auto select = instr.As<SelectInstruction>())
					PrintSelectInstr(select);
				else if (auto fetchArg = instr.As<FetchArgInstruction>()) //for function: return instruction
					PrintFetchArgInstr(fetchArg);
				else
					throw NotImplementedException(L"unsupported instruction in PrintInstr()" + instr.ToString());
			}

			void PrintIf(IfInstruction * instr)
			{
				int operandID = GetOperandValue(instr->Operand.Ptr());
				operandID = ctx.ConvertBasicType(
					operandID,
					ctx.IDInfos[operandID]().GetILType(),
					GetTypeFromString(L"bool"));

				int TrueLabel = ++ctx.CurrentID;
				int FalseLabel = ++ctx.CurrentID;
				int MergeLabel = ++ctx.CurrentID;

				ctx.AddInstrSelectionMerge(MergeLabel);
				ctx.AddInstrBranchConditional(operandID, TrueLabel, FalseLabel);

				ctx.PushScope();
				ctx.AddInstrLabel_AtFunctionBody(TrueLabel);
				GenerateCode(instr->TrueCode.Ptr(), TrueLabel);
				ctx.AddInstrBranch(MergeLabel);
				ctx.PopScope();

				ctx.PushScope();
				ctx.AddInstrLabel_AtFunctionBody(FalseLabel);
				if (instr->FalseCode)
					GenerateCode(instr->FalseCode.Ptr(), FalseLabel);
				ctx.AddInstrBranch(MergeLabel);
				ctx.PopScope();

				ctx.AddInstrLabel_AtFunctionBody(MergeLabel);
			}

			void PrintFor(ForInstruction * instr)
			{
				int HeaderBlockLabel = ++ctx.CurrentID;
				int ConditionBlockLabel = ++ctx.CurrentID;
				int BodyBlockLabel = ++ctx.CurrentID;
				int UpdateBlockLabel = ++ctx.CurrentID;
				int MergeBlockLabel = ++ctx.CurrentID;

				ctx.AddInstrBranch(HeaderBlockLabel);

				ctx.AddInstrLabel_AtFunctionBody(HeaderBlockLabel);
				ctx.AddInstrLoopMerge(MergeBlockLabel, UpdateBlockLabel);
				ctx.AddInstrBranch(ConditionBlockLabel);

				// condition block
				ctx.PushScope();
				ctx.AddInstrLabel_AtFunctionBody(ConditionBlockLabel);
				GenerateCode(instr->ConditionCode.Ptr(), ConditionBlockLabel);
				int conditionID = GetOperandValue(instr->ConditionCode->GetLastInstruction());
				conditionID = ctx.ConvertBasicType(
					conditionID,
					ctx.IDInfos[conditionID]().GetILType(),
					GetTypeFromString(L"bool"));
				ctx.AddInstrBranchConditional(conditionID, BodyBlockLabel, MergeBlockLabel);
				ctx.PopScope();

				// body block
				ctx.PushScope();
				ctx.AddInstrLabel_AtFunctionBody(BodyBlockLabel);
				ctx.StackMergeBlock.Add(MergeBlockLabel);
				ctx.StackContinueBlock.Add(UpdateBlockLabel);
				GenerateCode(instr->BodyCode.Ptr(), BodyBlockLabel);
				ctx.StackMergeBlock.RemoveAt(ctx.StackMergeBlock.Count() - 1);
				ctx.StackContinueBlock.RemoveAt(ctx.StackContinueBlock.Count() - 1);
				ctx.AddInstrBranch(UpdateBlockLabel);
				ctx.PopScope();

				// update block
				ctx.PushScope();
				ctx.AddInstrLabel_AtFunctionBody(UpdateBlockLabel);
				GenerateCode(instr->SideEffectCode.Ptr(), UpdateBlockLabel);
				ctx.AddInstrBranch(HeaderBlockLabel);
				ctx.PopScope();

				// merge block
				ctx.AddInstrLabel_AtFunctionBody(MergeBlockLabel);
			}

			void PrintWhileDo(WhileInstruction * instr)
			{
				int HeaderBlockLabel = ++ctx.CurrentID;
				int ConditionBlockLabel = ++ctx.CurrentID;
				int BodyBlockLabel = ++ctx.CurrentID;
				int UpdateBlockLabel = ++ctx.CurrentID;
				int MergeBlockLabel = ++ctx.CurrentID;

				ctx.AddInstrBranch(HeaderBlockLabel);

				// header block
				ctx.AddInstrLabel_AtFunctionBody(HeaderBlockLabel);
				ctx.AddInstrLoopMerge(MergeBlockLabel, UpdateBlockLabel);
				ctx.AddInstrBranch(ConditionBlockLabel);

				// condition block
				ctx.PushScope();
				ctx.AddInstrLabel_AtFunctionBody(ConditionBlockLabel);
				GenerateCode(instr->ConditionCode.Ptr(), ConditionBlockLabel, true);
				int conditionID = GetOperandValue(instr->ConditionCode->GetLastInstruction()->As<ReturnInstruction>()->Operand.Ptr());
				conditionID = ctx.ConvertBasicType(
					conditionID,
					ctx.IDInfos[conditionID]().GetILType(),
					GetTypeFromString(L"bool")
				);
				ctx.AddInstrBranchConditional(conditionID, BodyBlockLabel, MergeBlockLabel);
				ctx.PopScope();

				// body block
				ctx.PushScope();
				ctx.AddInstrLabel_AtFunctionBody(BodyBlockLabel);
				ctx.StackMergeBlock.Add(MergeBlockLabel);
				ctx.StackContinueBlock.Add(UpdateBlockLabel);
				GenerateCode(instr->BodyCode.Ptr(), BodyBlockLabel);
				ctx.StackMergeBlock.RemoveAt(ctx.StackMergeBlock.Count() - 1);
				ctx.StackContinueBlock.RemoveAt(ctx.StackContinueBlock.Count() - 1);
				ctx.AddInstrBranch(UpdateBlockLabel);
				ctx.PopScope();

				// update block (empty)
				ctx.AddInstrLabel_AtFunctionBody(UpdateBlockLabel);
				ctx.AddInstrBranch(HeaderBlockLabel);

				// merge block
				ctx.AddInstrLabel_AtFunctionBody(MergeBlockLabel);
			}

			void PrintDoWhile(DoInstruction * instr)
			{
				int HeaderBlockLabel = ++ctx.CurrentID;
				int BodyBlockLabel = ++ctx.CurrentID;
				int ConditionBlockLabel = ++ctx.CurrentID;
				int MergeBlockLabel = ++ctx.CurrentID;

				//ctx.FunctionBody << LR"(OpBranch %)" << HeaderBlockLabel << EndLine;
				ctx.AddInstrBranch(HeaderBlockLabel);

				// header block
				ctx.AddInstrLabel_AtFunctionBody(HeaderBlockLabel);
				ctx.AddInstrLoopMerge(MergeBlockLabel, ConditionBlockLabel);
				ctx.AddInstrBranch(BodyBlockLabel);

				// body block
				ctx.PushScope();
				ctx.AddInstrLabel_AtFunctionBody(BodyBlockLabel);
				ctx.StackMergeBlock.Add(MergeBlockLabel);
				ctx.StackContinueBlock.Add(ConditionBlockLabel);
				GenerateCode(instr->BodyCode.Ptr(), BodyBlockLabel);
				ctx.StackMergeBlock.RemoveAt(ctx.StackMergeBlock.Count() - 1);
				ctx.StackContinueBlock.RemoveAt(ctx.StackContinueBlock.Count() - 1);
				ctx.AddInstrBranch(ConditionBlockLabel);
				ctx.PopScope();

				// condition block
				ctx.PushScope();
				ctx.AddInstrLabel_AtFunctionBody(ConditionBlockLabel);
				GenerateCode(instr->ConditionCode.Ptr(), ConditionBlockLabel, true);
				int conditionID = GetOperandValue(instr->ConditionCode->GetLastInstruction()->As<ReturnInstruction>()->Operand.Ptr());
				conditionID = ctx.ConvertBasicType(
					conditionID,
					ctx.IDInfos[conditionID]().GetILType(),
					GetTypeFromString(L"bool")
				);
				ctx.AddInstrBranchConditional(conditionID, HeaderBlockLabel, MergeBlockLabel);
				ctx.PopScope();

				// merge block
				ctx.AddInstrLabel_AtFunctionBody(MergeBlockLabel);
			}

			void GenerateCode(CFGNode * code, int givenLabel = -1, bool LoopReturn = false)
			{
				if (givenLabel == -1)
				{
					++ctx.CurrentID; //label ID
					ctx.AddInstrLabel_AtFunctionBody(ctx.CurrentID);
				}

				List<int> usedID;
				for (auto & instr : *code)
				{

					if (auto ifInstr = instr.As<IfInstruction>())
					{
						PrintIf(ifInstr);
					}
					else if (auto forInstr = instr.As<ForInstruction>())
					{
						PrintFor(forInstr);
					}
					else if (auto doInstr = instr.As<DoInstruction>())
					{
						PrintDoWhile(doInstr);
					}
					else if (auto whileInstr = instr.As<WhileInstruction>())
					{
						PrintWhileDo(whileInstr);
					}
					else if (auto ret = instr.As<ReturnInstruction>())
					{
						if (!LoopReturn)
						{
							if (ret->Operand)
								ctx.AddInstrReturnValue(GetOperandValue(ret->Operand.Ptr()));
							else
								ctx.AddInstrReturn();
							ctx.AddInstrLabel_AtFunctionBody(++ctx.CurrentID);
						}
					}
					else if (instr.Is<BreakInstruction>())
					{
						ctx.AddInstrBranch(ctx.StackMergeBlock.Last());
						ctx.AddInstrLabel_AtFunctionBody(++ctx.CurrentID);
					}
					else if (instr.Is<ContinueInstruction>())
					{
						ctx.AddInstrBranch(ctx.StackContinueBlock.Last());
						ctx.AddInstrLabel_AtFunctionBody(++ctx.CurrentID);
					}
					else if (instr.Is<DiscardInstruction>())
					{
						ctx.AddInstrKill();
						ctx.AddInstrLabel_AtFunctionBody(++ctx.CurrentID);
					}
					else
					{
						PrintInstr(instr);
					}
				}
			}

		public:

			bool BufferPreProcessed;

			void Initiate(ExecutionModel model, CompiledWorld * shaderWorld)
			{
				ctx.Clear();
				ctx.CodeGen.Initiate();
				ctx.CurrentID = 1; // reserved for extinst
				ctx.CodeGen.ProgramHeader();
				ctx.PushScope();
				interfaceIDs.Clear();
				DepthReplacing = false;
				LocalSize = false;
				BufferImportOrExport = false;
				BufferPreProcessed = false;
				currentWorld = shaderWorld;
				currentExecutionModel = model;
			}

			int GenerateFunctionDeclaration(CompiledFunction *func)
				//return the ID of the Function Type
			{
				List<RefPtr<ILType>> args;
				for (auto & instr : *func->Code)
					if (auto arg = instr.As<FetchArgInstruction>())
						if (arg->ArgId != 0)
						{
							args.Add(arg->Type);
						}
				int funcTypeID = ctx.AddInstrTypeFunction(func, args, func->ReturnType);
				ctx.FunctionNameToFunctionID[func->Name] = ++ctx.CurrentID;
				return funcTypeID;
			}

			int GenerateFunctionDefinition(CompiledFunction *func, ILOperand *vertexOutput = nullptr)
				//return the ID of the Function
			{
				ctx.ClearBuffer();

				ctx.PushScope();

				int funcID = ctx.FunctionNameToFunctionID[func->Name]();
				int funcTypeID = ctx.FunctionNameToFunctionTypeID[func->Name]();

				ctx.AddInstrFunction(funcID, ctx.DefineType(func->ReturnType), funcTypeID, GetFuncOriginalName(func->Name));

				for (auto & instr : *func->Code)
					if (auto arg = instr.As<FetchArgInstruction>())
						if (arg->ArgId != 0)
						{
							if (!ctx.ParameterNameToID.ContainsKey((ILOperand*)&instr))
							{
								ctx.DefineType(arg->Type);
								int typeID = ctx.DefineTypePointer(arg->Type, StorageClass::Function);
								ctx.AddInstrFunctionParameter((ILOperand*)&instr, typeID, arg->Name);
							}
						}

				++ctx.CurrentID;
				ctx.AddInstrLabel_AtFunctionHeader(ctx.CurrentID);

				func->Code->NameAllInstructions();
				GenerateCode(func->Code.Ptr(), ctx.CurrentID);

				if (vertexOutput)
				{
					int valueID = ctx.AddInstrLoad(nullptr, vertexOutput, MemoryAccess::None);
					int gl_PositionID = ctx.AddInstrAccessChain_StructMember(
						0,
						ctx.InterfaceNameToID[L"variable_gl_PerVertex"],
						L"gl_Position"
					);
					ctx.AddInstrStore(0, gl_PositionID, valueID);
				}

				ctx.AddInstrReturn();
				ctx.AddInstrFunctionEnd();

				ctx.ProduceFunction();

				ctx.PopScope();

				return funcID;
			}

			void Decorate(int ID, Decoration deco, int op1 = -1)
			{
				ctx.AddInstrDecorate(ID, deco, op1);
			}

			void MemberDecorate(int ID, int index, Decoration deco, int op1 = -1)
			{
				ctx.AddInstrMemberDecorate(ID, index, deco, op1);
			}

			void SetDepthReplacing()
			{
				DepthReplacing = true;
			}

			void SetLocalSize(unsigned int x)
			{
				//layout(local_size_x = <x> ) in;
				LocalSize = true;
				unsigned int workgroup[3] = { x, 1, 1 };
				ctx.AddInstrDecorate(
					ctx.AddInstrConstantCompositeUInt(workgroup, 3),
					Decoration::BuiltIn,
					(int)BuiltIn::WorkgroupSize
				);
			}

			void GenerateEntryPoint(int mainFunctionID)
			{
				ctx.AddInstrEntryPoint(currentExecutionModel, mainFunctionID, interfaceIDs);
				if (currentExecutionModel == ExecutionModel::Fragment)
				{
					ctx.AddInstrExecutionMode(mainFunctionID, ExecutionMode::OriginUpperLeft);
				}
				if (DepthReplacing)
				{
					ctx.AddInstrExecutionMode(mainFunctionID, ExecutionMode::DepthReplacing);
				}
				if (LocalSize)
				{
					ctx.AddInstrExecutionMode(mainFunctionID, ExecutionMode::LocalSize, 256, 1, 1);
				}
			}

			int GenerateGlGlobalInvocationID()
				//return the ID of the gl_GlobalInvocationID variable
			{
				int GlobalInvocationID = ctx.AddInstrVariableDeclaration(0, GetTypeFromString(L"uvec3"), StorageClass::Input, L"gl_GlobalInvocationID", 0);
				ctx.AddInstrDecorate(GlobalInvocationID, Decoration::BuiltIn, (int)BuiltIn::GlobalInvocationId);
				ctx.InterfaceNameToID[L"gl_GlobalInvocationID"] = GlobalInvocationID;
				return GlobalInvocationID;
			}

			int GenerateInterfaceForSingleVariable(
				String varName,
				RefPtr<ILType> varType,
				StorageClass storageClass,
				int location = -1,
				int bindIndex = -1)
				//return the ID of the variable
			{
				int entID = ctx.AddInstrVariableDeclaration(0, varType, storageClass, varName, 0);
				ctx.InterfaceNameToID[varName] = entID;
				if (location != -1)
					ctx.AddInstrDecorate(entID, Decoration::Location, location);
				if (bindIndex != -1)
				{
					ctx.AddInstrDecorate(entID, Decoration::DescriptorSet, 0);
					ctx.AddInstrDecorate(entID, Decoration::Binding, bindIndex);
				}
				if (storageClass == StorageClass::Input || storageClass == StorageClass::Output)
					interfaceIDs.Add(entID);
				return entID;
			}

			std::pair<int,int> GenerateInterfaceForStructVariable(
				String structTypeName,
				String structVariableName,
				List<RefPtr<ILType>> memberTypes,
				List<String> memberNames,
				int UniformOrBuffer,
				StorageClass storageClass,
				int location = -1,
				int bindindex = -1)
				//first  - the ID of the struct type
				//second - the ID of the variable 
			{
				RefPtr<ILStructType> structIL = new ILStructType();
				structIL->TypeName = structTypeName;
				int n = memberTypes.Count();
				for (int i = 0; i < n; i++)
				{
					ILStructType::ILStructField field;
					field.Type = memberTypes[i];
					field.FieldName = memberNames[i];
					structIL->Members.Add(field);
				}

				int structTypeID = ctx.DefineType(structIL, UniformOrBuffer);
				int structVariableID = ctx.AddInstrVariableDeclaration(0, structIL, storageClass, structVariableName, UniformOrBuffer);
				ctx.InterfaceNameToID[structVariableName] = structVariableID;

				if (UniformOrBuffer == 1)
				{
					ctx.AddInstrDecorate(structVariableID, Decoration::DescriptorSet, 0);
					ctx.AddInstrDecorate(structTypeID, Decoration::Block);
				}
				else if (UniformOrBuffer == 2)
				{
					ctx.AddInstrDecorate(structVariableID, Decoration::DescriptorSet, 0);
					ctx.AddInstrDecorate(structTypeID, Decoration::BufferBlock);
				}

				if (location != -1)
				{
					ctx.AddInstrDecorate(structVariableID, Decoration::Location, location);
				}

				if (bindindex != -1)
				{
					ctx.AddInstrDecorate(structVariableID, Decoration::Binding, bindindex);
				}

				if (storageClass == StorageClass::Input || storageClass == StorageClass::Output)
				{
					for (int i = 0; i < n; i++)
						if (memberTypes[i]->IsIntegral())
							ctx.AddInstrMemberDecorate(structTypeID, i, Decoration::Flat);
					interfaceIDs.Add(structVariableID);
				}

				return std::make_pair(structTypeID, structVariableID);
			}

			CompiledShaderSource GenerateShaderWorld()
			{
				CompiledShaderSource rs;

				auto binaryForm = ctx.ProduceWordStream();
				rs.BinaryCode.SetSize(binaryForm.Count() * sizeof(unsigned int));
				memcpy(rs.BinaryCode.Buffer(), binaryForm.Buffer(), rs.BinaryCode.Count());

				rs.MainCode = ctx.ProduceTextCode();

				return rs;
			}
		};

		class SpirVCodeGen : public CodeGenBackend
		{
			String vertexOutputName;
			EnumerableDictionary<String, String> backendArguments;

		public:

			ExecutionModel currentExecutionModel = ExecutionModel::Invalid;

			void ProcessBufferImportOrExportInterfaces(SpirvModule & spvModule, String blkName, int index)
			{
				if (!spvModule.BufferPreProcessed)
				{
					spvModule.BufferPreProcessed = true;
					spvModule.SetLocalSize(256);
					spvModule.GenerateGlGlobalInvocationID();

					List<RefPtr<ILType>> memberTypes;
					List<String> memberNames;
					memberTypes.Add(GetTypeFromString(L"uint"));
					memberNames.Add(L"sys_thread_count");
					spvModule.GenerateInterfaceForStructVariable(
						L"SystemBlock",
						L"blkSystemBlock",
						memberTypes,
						memberNames,
						1,
						StorageClass::Uniform,
						-1,
						0
					);
				}

				List<RefPtr<ILType>> memberTypes;
				List<String> memberNames;
				memberTypes.Add(GetTypeFromString(L"float[0]"));
				memberNames.Add(L"a");
				spvModule.GenerateInterfaceForStructVariable(
					blkName,
					L"blk" + blkName,
					memberTypes,
					memberNames,
					2,
					StorageClass::Uniform,
					-1,
					index
				);
			}

			virtual CompiledShaderSource GenerateShaderWorld(CompileResult & result, SymbolTable * /*symbols*/, CompiledWorld * shaderWorld, Dictionary<String, ImportOperatorHandler*>& opHandlers, Dictionary<String, ExportOperatorHandler*>& exportHandlers) override
			{
				
				currentExecutionModel = ExecutionModel::Invalid;
				if (shaderWorld->ExportOperator.Content == L"fragmentExport")
					currentExecutionModel = ExecutionModel::Fragment;
				else if (shaderWorld->BackendParameters.ContainsKey(L"vertex"))
					currentExecutionModel = ExecutionModel::Vertex;
				else if (shaderWorld->ExportOperator.Content == L"bufferExport")
					currentExecutionModel = ExecutionModel::GLCompute;

				CompiledFunction mainFunction;
				mainFunction.Name = L"main";
				mainFunction.ReturnType = nullptr;
				mainFunction.Code = shaderWorld->Code;

				SpirvModule spvModule;
				spvModule.Initiate(currentExecutionModel, shaderWorld);
				spvModule.GenerateFunctionDeclaration(&mainFunction);

				for (auto funcName : shaderWorld->ReferencedFunctions)
					for(auto & func : result.Program->Functions)
						if (funcName == func->Name)
							spvModule.GenerateFunctionDeclaration(func.Ptr());

				for (auto funcName : shaderWorld->ReferencedFunctions)
					for (auto & func : result.Program->Functions)
						if (funcName == func->Name)
							spvModule.GenerateFunctionDefinition(func.Ptr());

				for (auto & inputBlock : shaderWorld->WorldInputs)
				{
					auto block = inputBlock.Value.Block;
					if (!block->UserWorlds.Contains(shaderWorld->WorldName))
						continue;
					String impOpName = inputBlock.Value.ImportOperator.Name.Content;

					if (impOpName == L"standardImport")
					{
						List<RefPtr<ILType>> memberTypes;
						List<String> memberNames;
						for (auto & ent : block->Entries)
						{
							memberTypes.Add(ent.Value.Type);
							memberNames.Add(ent.Value.Name);
						}
						spvModule.GenerateInterfaceForStructVariable(
							block->Name,
							L"blk"+block->Name,
							memberTypes,
							memberNames,
							0,
							StorageClass::Input,
							0
						);
					}

					else if (impOpName == L"vertexImport")
					{
						int location = 0;
						for (auto & ent : block->Entries)
						{
							spvModule.GenerateInterfaceForSingleVariable(
								ent.Key,
								ent.Value.Type,
								StorageClass::Input,
								location
							);
							location++;
						}
					}

					else if (impOpName == L"uniformImport")
					{
						int nonTextureCount = 0;
						for (auto & ent : block->Entries)
							if (!ent.Value.Type->IsTexture())
								nonTextureCount++;

						int TypeOfStruct = 1; //1: uniform buffer; 2: shader storage buffer; 0: not a buffer
						if (block->Attributes.ContainsKey(L"ShaderStorageBlock"))
							TypeOfStruct = 2;

						if (nonTextureCount)
						{
							List<RefPtr<ILType>> memberTypes;
							List<String> memberNames;
							for (auto & ent : block->Entries)
								if (!ent.Value.Type->IsTexture())
								{
									memberTypes.Add(ent.Value.Type);
									memberNames.Add(ent.Value.Name);
								}
							String strIndex;
							int index = -1;
							if (block->Attributes.TryGetValue(L"Index", strIndex))
								index = StringToInt(strIndex);
							spvModule.GenerateInterfaceForStructVariable(
								block->Name,
								L"blk" + block->Name,
								memberTypes,
								memberNames,
								TypeOfStruct,
								StorageClass::Uniform,
								-1,
								index
							);
						}
						
						int bindPoint = 0;
						String bindingStart;
						if (backendArguments.TryGetValue(L"TextureBindingStart", bindingStart))
							bindPoint = StringToInt(bindingStart);

						for(auto & ent : block->Entries)
							if (ent.Value.Type->IsTexture())
							{
								spvModule.GenerateInterfaceForSingleVariable(
									ent.Key,
									ent.Value.Type,
									StorageClass::UniformConstant,
									-1,
									bindPoint
								);
								bindPoint++;
							}
					}

					else if (impOpName == L"textureImport")
					{
						int bindPoint = 0;
						String strIndex;
						if (block->Attributes.TryGetValue(L"Index", strIndex))
							bindPoint = StringToInt(strIndex);
						for (auto & ent : block->Entries)
						{
							spvModule.GenerateInterfaceForSingleVariable(
								ent.Key,
								ent.Value.Type,
								StorageClass::UniformConstant,
								-1,
								bindPoint
							);
							bindPoint++;
						}
					}

					else if (impOpName == L"bufferImport")
					{
						String strIdx;
						int index = 0;
						if (block->Attributes.TryGetValue(L"Index", strIdx))
							index = StringToInt(strIdx);
						ProcessBufferImportOrExportInterfaces(spvModule, block->Name, index);
					}

					else 
						throw NotImplementedException(L"not implemented input interface: " + impOpName);
				}

				if (shaderWorld->ExportOperator.Content == L"fragmentExport")
				{
					int location = 0;
					for (auto & ent : shaderWorld->WorldOutput->Entries)
						if (!ent.Value.LayoutAttribs.ContainsKey(L"DepthOutput"))
						{
							spvModule.GenerateInterfaceForSingleVariable(
								ent.Key,
								ent.Value.Type,
								StorageClass::Output,
								location
							);
							location++;
						}
						else
						{
							int entID = spvModule.GenerateInterfaceForSingleVariable(
								L"gl_FragDepth",
								ent.Value.Type,
								StorageClass::Output,
								location
							);
							spvModule.SetDepthReplacing();
							spvModule.Decorate(entID, Decoration::BuiltIn, (int)BuiltIn::FragDepth);
						}
				}

				else if (shaderWorld->ExportOperator.Content == L"standardExport")
				{
					List<RefPtr<ILType>> memberTypes;
					List<String> memberNames;
					for (auto & ent : shaderWorld->WorldOutput->Entries)
					{
						memberTypes.Add(ent.Value.Type);
						memberNames.Add(ent.Value.Name);
					}
					spvModule.GenerateInterfaceForStructVariable(
						shaderWorld->WorldOutput->Name,
						L"blk" + shaderWorld->WorldOutput->Name,
						memberTypes,
						memberNames,
						0,
						StorageClass::Output,
						0
					);
				}

				else if (shaderWorld->ExportOperator.Content == L"bufferExport")
				{
					String strIdx;
					int index = 0;
					if (shaderWorld->WorldOutput->Attributes.TryGetValue(L"Index", strIdx))
						index = StringToInt(strIdx);
					ProcessBufferImportOrExportInterfaces(spvModule, shaderWorld->WorldOutput->Name, index);
				}

				else
					throw NotImplementedException(L"not implemented output interface: " + shaderWorld->ExportOperator.Content);

				if (vertexOutputName.Length())
				{
					CompiledComponent ccomp;
					if (shaderWorld->LocalComponents.TryGetValue(vertexOutputName, ccomp))
					{
						List<RefPtr<ILType>> memberTypes;
						List<String> memberNames;
						memberTypes.Add(GetTypeFromString(L"vec4"));
						memberNames.Add(L"gl_Position");
						memberTypes.Add(GetTypeFromString(L"float"));
						memberNames.Add(L"gl_PointSize");
						memberTypes.Add(GetTypeFromString(L"float[1]"));
						memberNames.Add(L"gl_ClipDistance");
						memberTypes.Add(GetTypeFromString(L"float[1]"));
						memberNames.Add(L"gl_CullDistance");

						int typeID = spvModule.GenerateInterfaceForStructVariable(
							L"gl_PerVertex",
							L"variable_gl_PerVertex",
							memberTypes,
							memberNames,
							0,
							StorageClass::Output,
							-1,
							-1
						).first;

						spvModule.Decorate(typeID, Decoration::Block);
						spvModule.MemberDecorate(typeID, 0, Decoration::BuiltIn, (int)BuiltIn::Position);
						spvModule.MemberDecorate(typeID, 1, Decoration::BuiltIn, (int)BuiltIn::PointSize);
						spvModule.MemberDecorate(typeID, 2, Decoration::BuiltIn, (int)BuiltIn::ClipDistance);
						spvModule.MemberDecorate(typeID, 3, Decoration::BuiltIn, (int)BuiltIn::CullDistance);
					}
				}

				ILOperand *vertexOutput = nullptr;
				if (vertexOutputName.Length())
				{
					CompiledComponent ccomp;
					if (shaderWorld->LocalComponents.TryGetValue(vertexOutputName, ccomp))
					{
						vertexOutput = ccomp.CodeOperand;
					}
					else
						throw InvalidOperationException(L"can not find vertexOutputName");
				}

				int mainFunctionID = spvModule.GenerateFunctionDefinition(&mainFunction, vertexOutput);

				spvModule.GenerateEntryPoint(mainFunctionID);

				return spvModule.GenerateShaderWorld();
				
				/*
				ctx.Clear();

				currentWorld = shaderWorld;
				CompiledShaderSource rs;
				ctx.Result = &result;

				currentExecutionModel = ExecutionModel::Invalid;
				if (currentWorld->ExportOperator.Content == L"fragmentExport")
					currentExecutionModel = ExecutionModel::Fragment;
				else if (currentWorld->BackendParameters.ContainsKey(L"vertex"))
					currentExecutionModel = ExecutionModel::Vertex;
				else if (currentWorld->ExportOperator.Content == L"bufferExport")
					currentExecutionModel = ExecutionModel::GLCompute;

				if (ExecutionModel::Invalid == currentExecutionModel)
					throw InvalidOperationException(L"invalid execution model for shader world: " + currentWorld->WorldName);

				ctx.CurrentID = 1;

				ctx.CodeGen.Initiate();
				ctx.CodeGen.ProgramHeader();

				//add all functions type definition
				for (auto funcName : shaderWorld->ReferencedFunctions)
				{
					for (auto &func : result.Program->Functions)
					{
						if (func->Name == funcName)
						{
							List<RefPtr<ILType>> args;
							for (auto & instr : *func->Code)
								if (auto arg = instr.As<FetchArgInstruction>())
									if (arg->ArgId != 0)
									{
										args.Add(arg->Type);
									}
							ctx.AddInstrTypeFunction(func.Ptr(), args, func->ReturnType);
							ctx.FunctionNameToFunctionID[func->Name] = ++ctx.CurrentID; 
							//this is reserverd for the result ID of the OpFunction instruction! 
						}
					}
				}

				//add all functions definition
				for (auto funcName : shaderWorld->ReferencedFunctions)
				{
					for (auto &func : result.Program->Functions)
					{
						if (func->Name == funcName)
						{

							ctx.ClearBuffer();

							ctx.PushScope();

							int funcID = ctx.FunctionNameToFunctionID[func->Name]();
							int funcTypeID = ctx.FunctionNameToFunctionTypeID[func->Name]();

							ctx.AddInstrFunction(funcID, ctx.DefineType(func->ReturnType), funcTypeID, GetFuncOriginalName(funcName));

							for (auto & instr : *func->Code)
								if (auto arg = instr.As<FetchArgInstruction>())
									if (arg->ArgId != 0)
									{
										if (!ctx.ParameterNameToID.ContainsKey((ILOperand*)&instr))
										{
											ctx.DefineType(arg->Type);
											int typeID = ctx.DefineTypePointer(arg->Type, StorageClass::Function);
											ctx.AddInstrFunctionParameter((ILOperand*)&instr, typeID, arg->Name);
										}
									}

							++ctx.CurrentID;
							ctx.AddInstrLabel_AtFunctionHeader(ctx.CurrentID);

							func->Code->NameAllInstructions();
							GenerateCode(func->Code.Ptr(), ctx.CurrentID);

							ctx.AddInstrReturn();
							ctx.AddInstrFunctionEnd();

							ctx.ProduceFunction();

							ctx.PopScope();
						}
					}
				}

				ctx.ClearBuffer();

				ctx.PushScope();

				List<int> interfaceIDs;
				bool DepthReplacing = false;
				bool LocalSize = false;
				bool BufferImportOrExport = false;
				ProcessInterfaces(interfaceIDs, shaderWorld, opHandlers, DepthReplacing, LocalSize, BufferImportOrExport);

				//for gl_Position
				if (vertexOutputName.Length())
				{
					CompiledComponent ccomp;
					if (currentWorld->LocalComponents.TryGetValue(vertexOutputName, ccomp))
					{
						RefPtr<ILStructType> structIL = new ILStructType();
						structIL->TypeName = L"gl_PerVertex";

						ILStructType::ILStructField f1;
						f1.Type = GetTypeFromString(L"vec4");
						f1.FieldName = L"gl_Position";
						structIL->Members.Add(f1);
						ILStructType::ILStructField f2;
						f2.Type = GetTypeFromString(L"float");
						f2.FieldName = L"gl_PointSize";
						structIL->Members.Add(f2);
						ILStructType::ILStructField f3;
						f3.Type = GetTypeFromString(L"float[1]");
						f3.FieldName = L"gl_ClipDistance";
						structIL->Members.Add(f3);
						ILStructType::ILStructField f4;
						f4.Type = GetTypeFromString(L"float[1]");
						f4.FieldName = L"gl_CullDistance";
						structIL->Members.Add(f4);

						int structTypeID = ctx.DefineType(structIL);
						int structVariableID = ctx.AddInstrVariableDeclaration(0, structIL, StorageClass::Output, L"gl_PerVertex");
						ctx.InterfaceNameToID[L"gl_PerVertex"] = structVariableID;

						ctx.AddInstrDecorate(structTypeID, Decoration::Block);
						ctx.AddInstrMemberDecorate(structTypeID, 0, Decoration::BuiltIn, (int)BuiltIn::Position);
						ctx.AddInstrMemberDecorate(structTypeID, 1, Decoration::BuiltIn, (int)BuiltIn::PointSize);
						ctx.AddInstrMemberDecorate(structTypeID, 2, Decoration::BuiltIn, (int)BuiltIn::ClipDistance);
						ctx.AddInstrMemberDecorate(structTypeID, 3, Decoration::BuiltIn, (int)BuiltIn::CullDistance);

						interfaceIDs.Add(structVariableID);
					}
					else
						throw InvalidOperationException(L"can not find vertexOutputName");
				}

				//add Main function type definition
				ctx.MainFunctionTypeID = ctx.AddInstrTypeFunction(nullptr, List<RefPtr<ILType>>(), nullptr);
				ctx.MainFunctionID = ++ctx.CurrentID;

				//Entry Point
				ctx.AddInstrEntryPoint(currentExecutionModel, ctx.MainFunctionID, interfaceIDs);

				//execution mode
				if (currentExecutionModel == ExecutionModel::Fragment)
				{
					//CodeGen.OpExecutionMode(ctx.MainFunctionID, ExecutionMode::OriginUpperLeft);
					ctx.AddInstrExecutionMode(ctx.MainFunctionID, ExecutionMode::OriginUpperLeft);
				}
				if (DepthReplacing)
				{
					//CodeGen.OpExecutionMode(ctx.MainFunctionID, ExecutionMode::DepthReplacing);
					ctx.AddInstrExecutionMode(ctx.MainFunctionID, ExecutionMode::DepthReplacing);
				}
				if (LocalSize)
				{
					ctx.AddInstrExecutionMode(ctx.MainFunctionID, ExecutionMode::LocalSize, 256, 1, 1);
				}

				//MainFunction
				ctx.AddInstrFunction(ctx.MainFunctionID, ctx.TypeNameToID[L"void"](), ctx.MainFunctionTypeID, L"main");

				++ctx.CurrentID;
				ctx.AddInstrLabel_AtFunctionHeader(ctx.CurrentID);

				if (BufferImportOrExport)
				{
					int GIIDx = ctx.AddInstrLoad(
						ctx.AddInstrAccessChain_VectorMember(0, ctx.InterfaceNameToID[L"gl_GlobalInvocationID"], -1, 0),
						MemoryAccess::None
					);	//GlobalInvocationID.x
					int SysThreadCountID = ctx.AddInstrLoad(
						ctx.AddInstrAccessChain_StructMember(0, ctx.InterfaceNameToID[L"SystemBlock"], L"sys_thread_count"),
						MemoryAccess::None
					);
					int conditionID = ctx.AddInstrBinaryInstr(
						0, GetTypeFromString(L"bool"), L"OpUGreaterThanEqual", GIIDx, SysThreadCountID
					);
					int MergeLabel = ++ctx.CurrentID;
					int TrueLabel = ++ctx.CurrentID;
					ctx.AddInstrSelectionMerge(MergeLabel);
					ctx.AddInstrBranchConditional(conditionID, TrueLabel, MergeLabel);
					ctx.AddInstrLabel_AtFunctionBody(TrueLabel);
					ctx.AddInstrReturn();
					ctx.AddInstrLabel_AtFunctionBody(MergeLabel);
				}

				shaderWorld->Code->NameAllInstructions();
				GenerateCode(shaderWorld->Code.Ptr(), ctx.CurrentID);

				if (vertexOutputName.Length())
				{
					CompiledComponent ccomp;
					if (currentWorld->LocalComponents.TryGetValue(vertexOutputName, ccomp))
					{
						int valueID = ctx.AddInstrLoad(nullptr, ccomp.CodeOperand, MemoryAccess::None);
						int gl_PositionID = ctx.AddInstrAccessChain_StructMember(
							0,
							ctx.InterfaceNameToID[L"gl_PerVertex"],
							L"gl_Position"
						);
						ctx.AddInstrStore(0, gl_PositionID, valueID);
					}
					else
						throw InvalidOperationException(L"can not find vertexOutputName");
				}

				//MainFunction End
				ctx.AddInstrReturn();
				ctx.AddInstrFunctionEnd();

				ctx.ProduceFunction();

				ctx.PopScope();

				auto binaryForm = ctx.ProduceWordStream();
				rs.BinaryCode.SetSize(binaryForm.Count() * sizeof(unsigned int));
				memcpy(rs.BinaryCode.Buffer(), binaryForm.Buffer(), rs.BinaryCode.Count());

				rs.MainCode = ctx.ProduceTextCode();

				rs.OutputDeclarations = L"spirv";

				//print IL 
				{
					auto compiledProgram = result.Program.Ptr();
					StringBuilder sb;

					//function part
					sb << L"function" << EndLine;
					sb << L"{" << EndLine;
					for (auto &pfunc : compiledProgram->Functions) {
						sb << pfunc->ReturnType->ToString() << L" " << pfunc->Name << L"(";
						bool first = true;
						for (auto &name2param : pfunc->Parameters) {
							if (!first)
								sb << L", ";
							sb << name2param.Value->ToString() << L" " << name2param.Key;
							first = false;
						}
						sb << L")" << EndLine;
						sb << L"{" << EndLine;
						pfunc->Code->NameAllInstructions();
						sb << pfunc->Code->ToString() << EndLine;
						sb << L"}" << EndLine;
					}
					sb << L"}" << EndLine;

					//shader part
					for (auto &pshader : compiledProgram->Shaders) {
						sb << L"Shader " << pshader->MetaData.ShaderName << EndLine;
						sb << L"{" << EndLine;
						for (auto &pworld : pshader->Worlds) {
							sb << L"World " << pworld.Key << EndLine;
							sb << L"{" << EndLine;
							pworld.Value.Ptr()->Code->NameAllInstructions();
							sb << pworld.Value.Ptr()->Code->ToString() << EndLine;
							sb << L"}" << EndLine;
						}
						sb << L"}" << EndLine;
					}

					StringBuilder sb_indent;
					IndentString(sb_indent, sb.ToSt\`ring());
					CoreLib::IO::StreamWriter sw(L"IL-" + currentWorld->ShaderName + L"-" + currentWorld->WorldOutput->Name + String(L".out"));
					sw.Write(sb_indent.ToString());
				}

				currentWorld = nullptr;

				return rs;
				*/
			}

			virtual void SetParameters(const EnumerableDictionary<String, String>& arguments) override
			{
				backendArguments = arguments;
				if (!arguments.TryGetValue(L"vertex", vertexOutputName))
					vertexOutputName = L"";
			}
		};

		CodeGenBackend * CreateSpirVCodeGen()
		{
			return new SpirVCodeGen();
		}
	}
}

/***********************************************************************
CORE\STDINCLUDE.CPP
***********************************************************************/

const wchar_t * VertexShaderIncludeString = LR"(
__builtin out vec4 gl_Position;
)";

const char * LibIncludeString = R"(
__intrinsic float dFdx(float v);
__intrinsic float dFdy(float v);
__intrinsic float fwidth(float v);
__intrinsic vec2 dFdx(vec2 v);
__intrinsic vec2 dFdy(vec2 v);
__intrinsic vec2 fwidth(vec2 v);
__intrinsic vec3 dFdx(vec3 v);
__intrinsic vec3 dFdy(vec3 v);
__intrinsic vec3 fwidth(vec3 v);
__intrinsic vec4 dFdx(vec4 v);
__intrinsic vec4 dFdy(vec4 v);
__intrinsic vec4 fwidth(vec4 v);

__intrinsic vec3 normalize(vec3 v);
__intrinsic float dot(vec2 v0, vec2 v1);
__intrinsic float dot(vec3 v0, vec3 v1);
__intrinsic float dot(vec4 v0, vec4 v1);
__intrinsic float sin(float v);
__intrinsic float cos(float v);
__intrinsic float tan(float v);
__intrinsic float sqrt(float v);
__intrinsic vec2 sin(vec2 v);
__intrinsic vec2 cos(vec2 v);
__intrinsic vec2 tan(vec2 v);
__intrinsic vec2 sqrt(vec2 v);
__intrinsic vec3 sin(vec3 v);
__intrinsic vec3 cos(vec3 v);
__intrinsic vec3 tan(vec3 v);
__intrinsic vec3 sqrt(vec3 v);
__intrinsic vec4 sin(vec4 v);
__intrinsic vec4 cos(vec4 v);
__intrinsic vec4 tan(vec4 v);
__intrinsic vec4 sqrt(vec4 v);
__intrinsic float abs(float v);
__intrinsic vec2 abs(vec2 v);
__intrinsic vec3 abs(vec3 v);
__intrinsic vec4 abs(vec4 v);

__intrinsic float exp(float v);
__intrinsic vec2 exp(vec2 v);
__intrinsic vec3 exp(vec3 v);
__intrinsic vec4 exp(vec4 v);

__intrinsic float log(float v);
__intrinsic vec2 log(vec2 v);
__intrinsic vec3 log(vec3 v);
__intrinsic vec4 log(vec4 v);

__intrinsic float exp2(float v);
__intrinsic vec2 exp2(vec2 v);
__intrinsic vec3 exp2(vec3 v);
__intrinsic vec4 exp2(vec4 v);

__intrinsic float log2(float v);
__intrinsic vec2 log2(vec2 v);
__intrinsic vec3 log2(vec3 v);
__intrinsic vec4 log2(vec4 v);

__intrinsic float asin(float v);
__intrinsic vec2 asin(vec2 v);
__intrinsic vec3 asin(vec3 v);
__intrinsic vec4 asin(vec4 v);

__intrinsic float acos(float v);
__intrinsic vec2 acos(vec2 v);
__intrinsic vec3 acos(vec3 v);
__intrinsic vec4 acos(vec4 v);

__intrinsic float atan(float v);
__intrinsic vec2 atan(vec2 v);
__intrinsic vec3 atan(vec3 v);
__intrinsic vec4 atan(vec4 v);

__intrinsic float sign(float x);
__intrinsic vec2 sign(vec2 x);
__intrinsic vec3 sign(vec3 x);
__intrinsic vec4 sign(vec4 x);

__intrinsic float pow(float base, float e);
__intrinsic vec2 pow(vec2 base, vec2 e);
__intrinsic vec3 pow(vec3 base, vec3 e);
__intrinsic vec4 pow(vec4 base, vec4 e);
__intrinsic float atan2(float x, float y);
__intrinsic float floor(float v);
__intrinsic vec2 floor(vec2 v);
__intrinsic vec3 floor(vec3 v);
__intrinsic vec4 floor(vec4 v);
__intrinsic float fract(float v);
__intrinsic vec2 fract(vec2 v);
__intrinsic vec3 fract(vec3 v);
__intrinsic vec4 fract(vec4 v);
__intrinsic float ceil(float v);
__intrinsic vec2 ceil(vec2 v);
__intrinsic vec3 ceil(vec3 v);
__intrinsic vec4 ceil(vec4 v);
__intrinsic float step(float v, float y);
__intrinsic vec2 step(vec2 v, vec2 v1);
__intrinsic vec3 step(vec3 v, vec3 v1);
__intrinsic vec4 step(vec4 v, vec4 v1);
__intrinsic float smoothstep(float e0, float e1, float v);
__intrinsic vec2 smoothstep(vec2 e0, vec2 e1, vec2 v);
__intrinsic vec3 smoothstep(vec3 e0, vec3 e1, vec3 v);
__intrinsic vec4 smoothstep(vec4 e0, vec4 e1, vec4 v);
__intrinsic vec4 texture(sampler2D tex, vec2 coord);
__intrinsic vec4 texture(samplerCube tex, vec3 coord);
__intrinsic vec4 textureGrad(sampler2D tex, vec2 coord, vec2 dPdx, vec2 dPdy);
__intrinsic vec4 textureGrad(samplerCube tex, vec3 coord, vec3 dPdx, vec3 dPdy);
__intrinsic vec4 texture(samplerCube tex, vec3 coord, float bias);
__intrinsic float texture(sampler2DShadow tex, vec3 coord);
__intrinsic float texture(samplerCubeShadow tex, vec4 coord);
__intrinsic float textureProj(sampler2DShadow tex, vec4 coord);
__intrinsic float textureProj(samplerCubeShadow tex, vec4 coord);
__intrinsic float diff(float v);
__intrinsic float mod(float x, float y);
__intrinsic float max(float v);
__intrinsic float min(float v);
__intrinsic float max(float v, float v1);
__intrinsic float min(float v, float v1);
__intrinsic vec2 max(vec2 v, vec2 v1);
__intrinsic vec2 min(vec2 v, vec2 v1);
__intrinsic vec3 max(vec3 v, vec3 v1);
__intrinsic vec3 min(vec3 v, vec3 v1);
__intrinsic vec4 max(vec4 v, vec4 v1);
__intrinsic vec4 min(vec4 v, vec4 v1);
__intrinsic float clamp(float v, float v1, float v2);
__intrinsic vec2 clamp(vec2 v, vec2 v1, vec2 v2);
__intrinsic vec3 clamp(vec3 v, vec3 v1, vec3 v2);
__intrinsic vec4 clamp(vec4 v, vec4 v1, vec4 v2);

__intrinsic vec3 reflect(vec3 I, vec3 N);
__intrinsic vec3 refract(vec3 I, vec3 N, float eta);

__intrinsic float length(vec2 v);
__intrinsic float length(vec3 v);
__intrinsic float length(vec4 v);

__intrinsic void alphaTest(float alpha, float threshold);
__intrinsic vec3 mix(vec3 v0, vec3 v1, float t);
__intrinsic vec4 mix(vec4 v0, vec4 v1, float t);
__intrinsic vec2 mix(vec2 v0, vec2 v1, float t);
__intrinsic float mix(float v0, float v1, float t);
__intrinsic vec3 mix(vec3 v0, vec3 v1, vec3 t);
__intrinsic vec4 mix(vec4 v0, vec4 v1, vec4 t);
__intrinsic vec2 mix(vec2 v0, vec2 v1, vec2 t);
__intrinsic mat3 mat3(vec3 a, vec3 b, vec3 c);
__intrinsic mat3 mat3(float a0, float a1, float a2, float a3, float a4, float a5, float a6, float a7, float a8);
__intrinsic mat4 mat4(vec4 a, vec4 b, vec4 c, vec4 d);
__intrinsic mat4 mat4(float a0, float a1, float a2, float a3, float a4, float a5, float a6, float a7, float a8, float a9, float a10, float a11, float a12, float a13, float a14, float a15);
__intrinsic vec3 cross(vec3 v1, vec3 v2);
__intrinsic vec2 vec2(float v);
__intrinsic vec3 vec3(float v);
__intrinsic vec4 vec4(float v);
__intrinsic vec2 vec2(float x, float y);
__intrinsic vec3 vec3(float x, float y, float z);
__intrinsic vec3 vec3(vec2 v, float z);
__intrinsic vec4 vec4(float x, float y, float z, float w);
__intrinsic vec4 vec4(vec3 v, float w);
__intrinsic vec4 vec4(vec2 v, float z, float w);
__intrinsic vec4 vec4(vec2 v, vec2 w);
__intrinsic ivec2 ivec2(int x, int y);
__intrinsic ivec3 ivec3(int x, int y, int z);
__intrinsic ivec3 ivec3(ivec2 v, int z);
__intrinsic ivec4 ivec4(int x, int y, int z, int w);
__intrinsic ivec4 ivec4(ivec3 v, int w);
__intrinsic ivec4 ivec4(ivec2 v, int z, int w);
__intrinsic ivec4 ivec4(ivec2 v, ivec2 w);

__intrinsic uvec2 uvec2(uint x, uint y);
__intrinsic uvec3 uvec3(uint x, uint y, uint z);
__intrinsic uvec3 uvec3(uvec2 v, uint z);
__intrinsic uvec4 uvec4(uint x, uint y, uint z, uint w);
__intrinsic uvec4 uvec4(uvec3 v, uint w);
__intrinsic uvec4 uvec4(uvec2 v, uint z, uint w);
__intrinsic uvec4 uvec4(uvec2 v, uvec2 w);

__intrinsic int int(uint val);
__intrinsic int int(float val);
__intrinsic ivec2 ivec2(uvec2 val);
__intrinsic ivec2 ivec2(vec2 val);
__intrinsic ivec3 ivec3(uvec3 val);
__intrinsic ivec3 ivec3(vec3 val);
__intrinsic ivec4 ivec4(uvec4 val);
__intrinsic ivec4 ivec4(vec4 val);

__intrinsic uint uint(int val);
__intrinsic uint uint(float val);
__intrinsic uvec2 uvec2(ivec2 val);
__intrinsic uvec2 uvec2(vec2 val);
__intrinsic uvec3 uvec3(ivec3 val);
__intrinsic uvec3 uvec3(vec3 val);
__intrinsic uvec4 uvec4(ivec4 val);
__intrinsic uvec4 uvec4(vec4 val);

__intrinsic float float(int val);
__intrinsic float float(uint val);
__intrinsic vec2 vec2(ivec2 val);
__intrinsic vec2 vec2(uvec2 val);
__intrinsic vec3 vec3(ivec3 val);
__intrinsic vec3 vec3(uvec3 val);
__intrinsic vec4 vec4(ivec4 val);
__intrinsic vec4 vec4(uvec4 val);

__intrinsic mat3 transpose(mat3 in);
__intrinsic mat4 transpose(mat4 in);

#line_reset#
)";

/***********************************************************************
CORE\SYMBOLTABLE.CPP
***********************************************************************/

namespace Spire
{
	namespace Compiler
	{
		bool SymbolTable::SortShaders()
		{
			HashSet<ShaderSymbol*> shaderSet;
			ShaderDependenceOrder.Clear();
			List<ShaderSymbol *> nextShaders, currentShaders;
			// sort shaders in dependency order
			for (auto & shader : Shaders)
			{
				if (shader.Value->DependentShaders.Count() == 0)
				{
					ShaderDependenceOrder.Add(shader.Value.Ptr());
					shaderSet.Add(shader.Value.Ptr());
				}
				else
					currentShaders.Add(shader.Value.Ptr());
			}
			while (currentShaders.Count())
			{
				nextShaders.Clear();
				for (auto & shader : currentShaders)
				{
					bool pass = true;
					for (auto & dshader : shader->DependentShaders)
						if (!shaderSet.Contains(dshader))
						{
							pass = false;
							break;
						}
					if (pass)
					{
						ShaderDependenceOrder.Add(shader);
						shaderSet.Add(shader);
					}
					else
						nextShaders.Add(shader);
				}
				currentShaders.SwapWith(nextShaders);
			}
			return (ShaderDependenceOrder.Count() == Shaders.Count());
		}
		void SymbolTable::EvalFunctionReferenceClosure()
		{
			for (auto & func : Functions)
			{
				List<String> funcList;
				EnumerableHashSet<String> funcSet;
				for (auto & ref : func.Value->ReferencedFunctions)
				{
					funcList.Add(ref);
					funcSet.Add(ref);
				}
				for (int i = 0; i < funcList.Count(); i++)
				{
					RefPtr<FunctionSymbol> funcSym;
					if (Functions.TryGetValue(funcList[i], funcSym))
					{
						for (auto rfunc : funcSym->ReferencedFunctions)
						{
							if (funcSet.Add(rfunc))
								funcList.Add(rfunc);
						}
					}
				}
				func.Value->ReferencedFunctions = _Move(funcSet);
			}
		}

		bool PipelineSymbol::IsAbstractWorld(String world)
		{
			WorldSymbol ws;
			if (Worlds.TryGetValue(world, ws))
				return ws.IsAbstract;
			return false;
		}

		bool PipelineSymbol::IsWorldReachable(String src, String targetWorld)
		{
			if (src == targetWorld)
				return true;
			if (ReachableWorlds.ContainsKey(src))
				if (ReachableWorlds[src]().Contains(targetWorld))
					return true;
			return false;
		}

		bool PipelineSymbol::IsWorldImplicitlyReachable(String src, String targetWorld)
		{
			if (src == targetWorld)
				return true;
			if (ImplicitlyReachableWorlds.ContainsKey(src))
				if (ImplicitlyReachableWorlds[src]().Contains(targetWorld))
					return true;
			return false;
		}

		bool PipelineSymbol::IsWorldImplicitlyReachable(EnumerableHashSet<String>& src, String targetWorld)
		{
			for (auto srcW : src)
			{
				if (srcW == targetWorld)
					return true;
				if (ImplicitlyReachableWorlds.ContainsKey(srcW))
					if (ImplicitlyReachableWorlds[srcW]().Contains(targetWorld))
						return true;
			}
			return false;
		}

		List<String>& PipelineSymbol::GetWorldTopologyOrder()
		{
			if (WorldTopologyOrder.Count() != 0)
				return WorldTopologyOrder;
			List<String> rs;
			HashSet<String> rsSet;
			bool changed = true;
			while (changed)
			{
				changed = false;
				for (auto & w : WorldDependency)
				{
					if (!rsSet.Contains(w.Key))
					{
						bool canAdd = true;
						for (auto & dw : w.Value)
							if (!rsSet.Contains(dw))
							{
								canAdd = false;
								break;
							}
						if (canAdd)
						{
							rsSet.Add(w.Key);
							rs.Add(w.Key);
							changed = true;
						}
					}
				}
			}
			WorldTopologyOrder = _Move(rs);
			return WorldTopologyOrder;
		}
		
		bool PipelineSymbol::IsWorldReachable(EnumerableHashSet<String>& src, String targetWorld)
		{
			for (auto srcW : src)
			{
				if (srcW == targetWorld)
					return true;
				if (ReachableWorlds.ContainsKey(srcW))
					if (ReachableWorlds[srcW]().Contains(targetWorld))
						return true;
			}
			return false;
		}
		
		List<ImportPath> PipelineSymbol::FindImplicitImportOperatorChain(String worldSrc, String worldDest)
		{
			List<ImportPath> resultPathes;
			if (worldSrc == worldDest)
				return resultPathes;
			List<ImportPath> pathes, pathes2;
			pathes.Add(ImportPath());
			pathes[0].Nodes.Add(ImportPath::Node(worldSrc, nullptr));
			while (pathes.Count())
			{
				pathes2.Clear();
				for (auto & p : pathes)
				{
					String world0 = p.Nodes.Last().TargetWorld;
					for (auto op : SyntaxNode->ImportOperators)
					{
						if (op->SourceWorld.Content == world0 && op->Parameters.Count() == 0)
						{
							ImportPath np = p;
							np.Nodes.Add(ImportPath::Node(op->DestWorld.Content, op.Ptr()));
							if (op->DestWorld.Content == worldDest)
								resultPathes.Add(np);
							else
								pathes2.Add(np);
						}
					}
				}
				pathes.SwapWith(pathes2);
			}
			return resultPathes;
		}
		List<ImportOperatorDefSyntaxNode*> PipelineSymbol::GetImportOperatorsFromSourceWorld(String worldSrc)
		{
			List<ImportOperatorDefSyntaxNode*> rs;
			for (auto & op : this->SyntaxNode->ImportOperators)
			{
				if (op->SourceWorld.Content == worldSrc)
					rs.Add(op.Ptr());
			}
			return rs;
		}
		List<ShaderComponentSymbol*> ShaderSymbol::GetComponentDependencyOrder()
		{
			List<ShaderComponentSymbol*> components;

			for (auto & comp : Components)
			{
				components.Add(comp.Value.Ptr());
			}
			SortComponents(components);
			return components;
		}
		void ShaderSymbol::SortComponents(List<ShaderComponentSymbol*>& comps)
		{
			comps.Sort([&](ShaderComponentSymbol*c0, ShaderComponentSymbol*c1)
			{
				return c0->Implementations.First()->SyntaxNode->Position < c1->Implementations.First()->SyntaxNode->Position;
			});
			HashSet<ShaderComponentSymbol*> allSymbols, addedSymbols;
			for (auto & comp : comps)
				allSymbols.Add(comp);
			List<ShaderComponentSymbol*> sorted;
			bool changed = true;
			while (changed)
			{
				changed = false;
				for (auto & comp : comps)
				{
					if (!addedSymbols.Contains(comp))
					{
						bool isFirst = true;
						for (auto & impl : comp->Implementations)
							for (auto & dep : impl->DependentComponents)
								if (allSymbols.Contains(dep.Key) && !addedSymbols.Contains(dep.Key))
								{
									isFirst = false;
									goto loopEnd;
								}
					loopEnd:;
						if (isFirst)
						{
							addedSymbols.Add(comp);
							sorted.Add(comp);
							changed = true;
						}
					}
				}
			}
			comps = _Move(sorted);
		}

		ShaderSymbol::ComponentReference ShaderSymbol::ResolveComponentReference(String compName, bool topLevel)
		{
			ComponentReference result;
			result.IsAccessible = true;
			RefPtr<ShaderComponentSymbol> refComp, privateRefComp;
			if (Components.TryGetValue(compName, refComp))
			{
				result.Component = refComp.Ptr();
				return result;
			}
			for (auto & shaderUsing : ShaderUsings)
			{
				if (shaderUsing.Shader->Components.TryGetValue(compName, refComp))
				{
					if (refComp->Implementations.First()->SyntaxNode->IsPublic)
					{
						result.Component = refComp.Ptr();
						result.IsAccessible = true;
						return result;
					}
					else
					{
						result.Component = refComp.Ptr();
						result.IsAccessible = false;
					}
				}
				else if (shaderUsing.IsPublic || topLevel)
				{
					auto rresult = shaderUsing.Shader->ResolveComponentReference(compName, false);
					if (rresult.IsAccessible)
						return rresult;
					else
						result = rresult;
				}
			}
			if (Pipeline->Components.TryGetValue(compName, refComp))
			{
				if (!refComp->IsParam())
				{
					result.Component = refComp.Ptr();
					return result;
				}
			}
			result.IsAccessible = false;
			return result;
		}

		bool SymbolTable::CheckComponentImplementationConsistency(ErrorWriter * err, ShaderComponentSymbol * comp, ShaderComponentImplSymbol * impl)
		{
			bool rs = true;
			if (impl->SyntaxNode->Rate)
			{
				for (auto & cimpl : comp->Implementations)
				{
					for (auto & w : cimpl->Worlds)
						if (impl->Worlds.Contains(w) && impl->AlternateName == cimpl->AlternateName)
						{
							err->Error(33020, L"\'" + comp->Name + L"\' is already defined at '" + w + L"\'.", impl->SyntaxNode->Position);
							rs = false;
						}
				}
			}
			else
			{
				for (auto & cimpl : comp->Implementations)
				{
					if (cimpl->Worlds.Count() == 0 && impl->Worlds.Count() == 0 && impl->AlternateName == cimpl->AlternateName)
					{
						err->Error(33020, L"\'" + comp->Name + L"\' is already defined.", impl->SyntaxNode->Position);
						rs = false;
					}
				}
			}
			for (auto & cimpl : comp->Implementations)
			{
				if (impl->SyntaxNode->IsOutput != cimpl->SyntaxNode->IsOutput)
				{
					err->Error(33021, L"\'" + comp->Name + L"\': inconsistent signature.\nsee previous definition at " + cimpl->SyntaxNode->Position.ToString(), impl->SyntaxNode->Position);
					rs = false;
					break;
				}
				if (impl->SyntaxNode->IsParam != cimpl->SyntaxNode->IsParam)
				{
					err->Error(33021, L"\'" + comp->Name + L"\': inconsistent signature.\nsee previous definition at " + cimpl->SyntaxNode->Position.ToString(), impl->SyntaxNode->Position);
					rs = false;
					break;
				}
				if (impl->SyntaxNode->IsPublic != cimpl->SyntaxNode->IsPublic)
				{
					err->Error(33021, L"\'" + comp->Name + L"\': inconsistent signature.\nsee previous definition at " + cimpl->SyntaxNode->Position.ToString(), impl->SyntaxNode->Position);
					rs = false;
					break;
				}
				if (!impl->SyntaxNode->Type->Equals(cimpl->SyntaxNode->Type.Ptr()))
				{
					err->Error(33021, L"\'" + comp->Name + L"\': inconsistent signature.\nsee previous definition at " + cimpl->SyntaxNode->Position.ToString(), impl->SyntaxNode->Position);
					rs = false;
					break;
				}
			}
			if (impl->SyntaxNode->IsParam && comp->Implementations.Count() != 0)
			{
				err->Error(33022, L"\'" + comp->Name + L"\': parameter name conflicts with existing definition.", impl->SyntaxNode->Position);
				rs = false;
			}
			return rs;
		}

		int GUID::currentGUID = 0;
		void GUID::Clear()
		{
			currentGUID = 0;
		}
		int GUID::Next()
		{
			return currentGUID++;
		}
		RefPtr<ShaderComponentSymbol> ShaderClosure::FindComponent(String name, bool findInPrivate, bool includeParams)
		{
			RefPtr<ShaderComponentSymbol> rs;
			if (RefMap.TryGetValue(name, rs))
			{
				if (includeParams || !rs->IsParam())
					return rs;
				else
					return nullptr;
			}
			if (Components.TryGetValue(name, rs))
			{
				if (includeParams || !rs->IsParam())
					return rs;
				else
					return nullptr;
			}
			for (auto & subClosure : SubClosures)
			{
				if (subClosure.Value->IsInPlace)
				{
					rs = subClosure.Value->FindComponent(name, findInPrivate, includeParams);
					if (rs && (findInPrivate || rs->Implementations.First()->SyntaxNode->IsPublic))
						return rs;
					else
						rs = nullptr;
				}
			}
			ShaderClosure * root = this;
			while (root->Parent != nullptr)
				root = root->Parent;
			if (root != this)
			{
				// find global components in root (pipeline-defined components)
				if (root->Components.TryGetValue(name, rs))
					return rs;
			}
			return rs;
		}
		RefPtr<ShaderClosure> ShaderClosure::FindClosure(String name)
		{
			RefPtr<ShaderClosure> rs;
			if (SubClosures.TryGetValue(name, rs))
				return rs;
			for (auto & subClosure : SubClosures)
			{
				if (subClosure.Value->IsInPlace)
				{
					rs = subClosure.Value->FindClosure(name);
					if (rs && rs->IsPublic)
						return rs;
					else
						rs = nullptr;
				}
			}
			return rs;
		}
		List<ShaderComponentSymbol*> ShaderClosure::GetDependencyOrder()
		{
			List<ShaderComponentSymbol*> comps;
			for (auto & comp : AllComponents)
				comps.Add(comp.Value);
			comps.Sort([&](ShaderComponentSymbol*c0, ShaderComponentSymbol*c1)
			{
				return c0->Implementations.First()->SyntaxNode->Position < c1->Implementations.First()->SyntaxNode->Position;
			});
			HashSet<ShaderComponentSymbol*> allSymbols, addedSymbols;
			for (auto & comp : comps)
				allSymbols.Add(comp);
			List<ShaderComponentSymbol*> sorted;
			bool changed = true;
			while (changed)
			{
				changed = false;
				for (auto & comp : comps)
				{
					if (!addedSymbols.Contains(comp))
					{
						bool isFirst = true;
						for (auto & impl : comp->Implementations)
							for (auto & dep : impl->DependentComponents)
								if (allSymbols.Contains(dep.Key) && !addedSymbols.Contains(dep.Key))
								{
									isFirst = false;
									goto loopEnd;
								}
					loopEnd:;
						if (isFirst)
						{
							addedSymbols.Add(comp);
							sorted.Add(comp);
							changed = true;
						}
					}
				}
			}
			return sorted;
		}
	}
}

/***********************************************************************
CORE\SYNTAX.CPP
***********************************************************************/

namespace Spire
{
	namespace Compiler
	{
		bool Scope::FindVariable(const String & name, VariableEntry & variable)
		{
			if (Variables.TryGetValue(name, variable))
				return true;
			if (Parent)
				return Parent->FindVariable(name, variable);
			return false;
		}

		int BasicExpressionType::GetSize() const
		{
			int baseSize = GetVectorSize(BaseType);
			if (BaseType == Compiler::BaseType::Texture2D || BaseType == Compiler::BaseType::TextureCube ||
				BaseType == Compiler::BaseType::TextureCubeShadow || BaseType == Compiler::BaseType::TextureShadow)
				baseSize = sizeof(void*) / sizeof(int);
			else if (BaseType == Compiler::BaseType::Struct)
				baseSize = Struct->Type->GetSize();
			return baseSize;
		}

		bool BasicExpressionType::Equals(const ExpressionType * type) const
		{
			auto basicType = dynamic_cast<const BasicExpressionType*>(type);
			if (basicType == nullptr)
				return false;
			return (basicType->BaseType == BaseType &&
				basicType->Func == Func &&
				basicType->Shader == Shader &&
				basicType->Struct == Struct);
		}

		bool BasicExpressionType::IsVectorType() const
		{
			return IsVector(BaseType);
		}

		bool BasicExpressionType::IsArray() const
		{
			return false;
		}

		CoreLib::Basic::String BasicExpressionType::ToString() const
		{
			CoreLib::Basic::StringBuilder res;

			switch (BaseType)
			{
			case Compiler::BaseType::Int:
				res.Append(L"int");
				break;
			case Compiler::BaseType::UInt:
				res.Append(L"uint");
				break;
			case Compiler::BaseType::Bool:
				res.Append(L"bool");
				break;
			case Compiler::BaseType::Float:
				res.Append(L"float");
				break;
			case Compiler::BaseType::Int2:
				res.Append(L"ivec2");
				break;
			case Compiler::BaseType::Float2:
				res.Append(L"vec2");
				break;
			case Compiler::BaseType::Int3:
				res.Append(L"ivec3");
				break;
			case Compiler::BaseType::Float3:
				res.Append(L"vec3");
				break;
			case Compiler::BaseType::Int4:
				res.Append(L"ivec4");
				break;
			case Compiler::BaseType::Float4:
				res.Append(L"vec4");
				break;
			case Compiler::BaseType::Float3x3:
				res.Append(L"mat3");
				break;
			case Compiler::BaseType::Float4x4:
				res.Append(L"mat4");
				break;
			case Compiler::BaseType::Texture2D:
				res.Append(L"sampler2D");
				break;
			case Compiler::BaseType::TextureCube:
				res.Append(L"samplerCube");
				break;
			case Compiler::BaseType::TextureShadow:
				res.Append(L"samplerShadow");
				break;
			case Compiler::BaseType::TextureCubeShadow:
				res.Append(L"samplerCubeShadow");
				break;
			case Compiler::BaseType::Function:
				res.Append(Func->InternalName);
				break;
			case Compiler::BaseType::Shader:
				res.Append(Shader->SyntaxNode->Name.Content);
				break;
			case Compiler::BaseType::Void:
				res.Append("void");
				break;
			case Compiler::BaseType::Record:
				res.Append(RecordTypeName);
				break;
			case Compiler::BaseType::Error:
				res.Append(L"<errtype>");
				break;
			default:
				break;
			}
			return res.ToString();
		}

		ExpressionType * BasicExpressionType::Clone()
		{
			BasicExpressionType * rs = new BasicExpressionType(*this);
			return rs;
		}


		RefPtr<SyntaxNode> ProgramSyntaxNode::Accept(SyntaxVisitor * visitor)
		{
			return visitor->VisitProgram(this);
		}
		ProgramSyntaxNode * ProgramSyntaxNode::Clone(CloneContext & ctx)
		{
			auto rs = CloneSyntaxNodeFields(new ProgramSyntaxNode(*this), ctx);
			rs->Structs.Clear();
			for (auto & x : Structs)
				rs->Structs.Add(x->Clone(ctx));
			rs->Functions.Clear();
			for (auto & x : Functions)
				rs->Functions.Add(x->Clone(ctx));
			rs->Pipelines.Clear();
			for (auto & x : Pipelines)
				rs->Pipelines.Add(x->Clone(ctx));
			rs->Shaders.Clear();
			for (auto & x : Shaders)
				rs->Shaders.Add(x->Clone(ctx));
			return rs;
		}
		RefPtr<SyntaxNode> FunctionSyntaxNode::Accept(SyntaxVisitor * visitor)
		{
			return visitor->VisitFunction(this);
		}
		FunctionSyntaxNode * FunctionSyntaxNode::Clone(CloneContext & ctx)
		{
			auto rs = CloneSyntaxNodeFields(new FunctionSyntaxNode(*this), ctx);
			rs->Parameters.Clear();
			for (auto & param : Parameters)
			{
				rs->Parameters.Add(param->Clone(ctx));
			}
			rs->ReturnTypeNode = ReturnTypeNode->Clone(ctx);
			rs->Body = Body->Clone(ctx);
			return rs;
		}
		RefPtr<SyntaxNode> BlockStatementSyntaxNode::Accept(SyntaxVisitor * visitor)
		{
			return visitor->VisitBlockStatement(this);
		}
		BlockStatementSyntaxNode * BlockStatementSyntaxNode::Clone(CloneContext & ctx)
		{
			auto rs = CloneSyntaxNodeFields(new BlockStatementSyntaxNode(*this), ctx);
			rs->Statements.Clear();
			for (auto & stmt : Statements)
			{
				rs->Statements.Add(stmt->Clone(ctx));
			}
			return rs;
		}
		RefPtr<SyntaxNode> BreakStatementSyntaxNode::Accept(SyntaxVisitor * visitor)
		{
			return visitor->VisitBreakStatement(this);
		}
		BreakStatementSyntaxNode * BreakStatementSyntaxNode::Clone(CloneContext & ctx)
		{
			return CloneSyntaxNodeFields(new BreakStatementSyntaxNode(*this), ctx);
		}
		RefPtr<SyntaxNode> ContinueStatementSyntaxNode::Accept(SyntaxVisitor * visitor)
		{
			return visitor->VisitContinueStatement(this);
		}
		ContinueStatementSyntaxNode * ContinueStatementSyntaxNode::Clone(CloneContext & ctx)
		{
			return CloneSyntaxNodeFields(new ContinueStatementSyntaxNode(*this), ctx);
		}
		RefPtr<SyntaxNode> DoWhileStatementSyntaxNode::Accept(SyntaxVisitor * visitor)
		{
			return visitor->VisitDoWhileStatement(this);
		}
		DoWhileStatementSyntaxNode * DoWhileStatementSyntaxNode::Clone(CloneContext & ctx)
		{
			auto rs = CloneSyntaxNodeFields(new DoWhileStatementSyntaxNode(*this), ctx);
			if (Predicate)
				rs->Predicate = Predicate->Clone(ctx);
			if (Statement)
				rs->Statement = Statement->Clone(ctx);
			return rs;
		}
		RefPtr<SyntaxNode> EmptyStatementSyntaxNode::Accept(SyntaxVisitor * visitor)
		{
			return visitor->VisitEmptyStatement(this);
		}
		EmptyStatementSyntaxNode * EmptyStatementSyntaxNode::Clone(CloneContext & ctx)
		{
			return CloneSyntaxNodeFields(new EmptyStatementSyntaxNode(*this), ctx);
		}
		RefPtr<SyntaxNode> ForStatementSyntaxNode::Accept(SyntaxVisitor * visitor)
		{
			return visitor->VisitForStatement(this);
		}
		ForStatementSyntaxNode * ForStatementSyntaxNode::Clone(CloneContext & ctx)
		{
			auto rs = CloneSyntaxNodeFields(new ForStatementSyntaxNode(*this), ctx);
			if (InitialExpression)
				rs->InitialExpression = InitialExpression->Clone(ctx);
			if (StepExpression)
				rs->StepExpression = StepExpression->Clone(ctx);
			if (EndExpression)
				rs->EndExpression = EndExpression->Clone(ctx);
			if (Statement)
				rs->Statement = Statement->Clone(ctx);
			rs->TypeDef = TypeDef->Clone(ctx);
			return rs;
		}
		RefPtr<SyntaxNode> IfStatementSyntaxNode::Accept(SyntaxVisitor * visitor)
		{
			return visitor->VisitIfStatement(this);
		}
		IfStatementSyntaxNode * IfStatementSyntaxNode::Clone(CloneContext & ctx)
		{
			auto rs = CloneSyntaxNodeFields(new IfStatementSyntaxNode(*this), ctx);
			if (Predicate)
				rs->Predicate = Predicate->Clone(ctx);
			if (PositiveStatement)
				rs->PositiveStatement = PositiveStatement->Clone(ctx);
			if (NegativeStatement)
				rs->NegativeStatement = NegativeStatement->Clone(ctx);
			return rs;
		}
		RefPtr<SyntaxNode> ReturnStatementSyntaxNode::Accept(SyntaxVisitor * visitor)
		{
			return visitor->VisitReturnStatement(this);
		}
		ReturnStatementSyntaxNode * ReturnStatementSyntaxNode::Clone(CloneContext & ctx)
		{
			auto rs = CloneSyntaxNodeFields(new ReturnStatementSyntaxNode(*this), ctx);
			if (Expression)
				rs->Expression = Expression->Clone(ctx);
			return rs;
		}
		RefPtr<SyntaxNode> VarDeclrStatementSyntaxNode::Accept(SyntaxVisitor * visitor)
		{
			return visitor->VisitVarDeclrStatement(this);
		}
		VarDeclrStatementSyntaxNode * VarDeclrStatementSyntaxNode::Clone(CloneContext & ctx)
		{
			auto rs = CloneSyntaxNodeFields(new VarDeclrStatementSyntaxNode(*this), ctx);
			rs->TypeNode = TypeNode->Clone(ctx);
			rs->Variables.Clear();
			for (auto & var : Variables)
				rs->Variables.Add(var->Clone(ctx));
			return rs;
		}
		RefPtr<SyntaxNode> Variable::Accept(SyntaxVisitor * visitor)
		{
			return visitor->VisitDeclrVariable(this);
		}
		Variable * Variable::Clone(CloneContext & ctx)
		{
			auto rs = CloneSyntaxNodeFields(new Variable(*this), ctx);
			if (Expression)
				rs->Expression = Expression->Clone(ctx);
			return rs;
		}
		RefPtr<SyntaxNode> WhileStatementSyntaxNode::Accept(SyntaxVisitor * visitor)
		{
			return visitor->VisitWhileStatement(this);
		}
		WhileStatementSyntaxNode * WhileStatementSyntaxNode::Clone(CloneContext & ctx)
		{
			auto rs = CloneSyntaxNodeFields(new WhileStatementSyntaxNode(*this), ctx);
			if (Predicate)
				rs->Predicate = Predicate->Clone(ctx);
			if (Statement)
				rs->Statement = Statement->Clone(ctx);
			return rs;
		}
		RefPtr<SyntaxNode> ExpressionStatementSyntaxNode::Accept(SyntaxVisitor * visitor)
		{
			return visitor->VisitExpressionStatement(this);
		}
		ExpressionStatementSyntaxNode * ExpressionStatementSyntaxNode::Clone(CloneContext & ctx)
		{
			auto rs = CloneSyntaxNodeFields(new ExpressionStatementSyntaxNode(*this), ctx);
			if (Expression)
				rs->Expression = Expression->Clone(ctx);
			return rs;
		}
		RefPtr<SyntaxNode> BinaryExpressionSyntaxNode::Accept(SyntaxVisitor * visitor)
		{
			return visitor->VisitBinaryExpression(this);
		}
		BinaryExpressionSyntaxNode * BinaryExpressionSyntaxNode::Clone(CloneContext & ctx)
		{
			auto rs = CloneSyntaxNodeFields(new BinaryExpressionSyntaxNode(*this), ctx);
			rs->LeftExpression = LeftExpression->Clone(ctx);
			rs->RightExpression = RightExpression->Clone(ctx);
			return rs;
		}
		RefPtr<SyntaxNode> ConstantExpressionSyntaxNode::Accept(SyntaxVisitor * visitor)
		{
			return visitor->VisitConstantExpression(this);
		}
		ConstantExpressionSyntaxNode * ConstantExpressionSyntaxNode::Clone(CloneContext & ctx)
		{
			return CloneSyntaxNodeFields(new ConstantExpressionSyntaxNode(*this), ctx);
		}
		IndexExpressionSyntaxNode * IndexExpressionSyntaxNode::Clone(CloneContext & ctx)
		{
			auto rs = CloneSyntaxNodeFields(new IndexExpressionSyntaxNode(*this), ctx);
			rs->BaseExpression = BaseExpression->Clone(ctx);
			rs->IndexExpression = IndexExpression->Clone(ctx);
			return rs;
		}
		RefPtr<SyntaxNode> IndexExpressionSyntaxNode::Accept(SyntaxVisitor * visitor)
		{
			return visitor->VisitIndexExpression(this);
		}
		RefPtr<SyntaxNode> MemberExpressionSyntaxNode::Accept(SyntaxVisitor * visitor)
		{
			return visitor->VisitMemberExpression(this);
		}
		MemberExpressionSyntaxNode * MemberExpressionSyntaxNode::Clone(CloneContext & ctx)
		{
			auto rs = CloneSyntaxNodeFields(new MemberExpressionSyntaxNode(*this), ctx);
			rs->BaseExpression = BaseExpression->Clone(ctx);
			return rs;
		}
		RefPtr<SyntaxNode> InvokeExpressionSyntaxNode::Accept(SyntaxVisitor * visitor)
		{
			return visitor->VisitInvokeExpression(this);
		}
		InvokeExpressionSyntaxNode * InvokeExpressionSyntaxNode::Clone(CloneContext & ctx)
		{
			auto rs = CloneSyntaxNodeFields(new InvokeExpressionSyntaxNode(*this), ctx);
			rs->FunctionExpr = FunctionExpr->Clone(ctx);
			rs->Arguments.Clear();
			for (auto & arg : Arguments)
			{
				rs->Arguments.Add(arg->Clone(ctx));
			}
			return rs;
		}
		RefPtr<SyntaxNode> TypeCastExpressionSyntaxNode::Accept(SyntaxVisitor * visitor)
		{
			return visitor->VisitTypeCastExpression(this);
		}
		TypeCastExpressionSyntaxNode * TypeCastExpressionSyntaxNode::Clone(CloneContext & ctx)
		{
			auto rs = CloneSyntaxNodeFields(new TypeCastExpressionSyntaxNode(*this), ctx);
			rs->TargetType = TargetType->Clone(ctx);
			rs->Expression = Expression->Clone(ctx);
			return rs;
		}
		RefPtr<SyntaxNode> SelectExpressionSyntaxNode::Accept(SyntaxVisitor * visitor)
		{
			return visitor->VisitSelectExpression(this);
		}
		SelectExpressionSyntaxNode * SelectExpressionSyntaxNode::Clone(CloneContext & ctx)
		{
			auto rs = CloneSyntaxNodeFields(new SelectExpressionSyntaxNode(*this), ctx);
			rs->SelectorExpr = SelectorExpr->Clone(ctx);
			rs->Expr0 = Expr0->Clone(ctx);
			rs->Expr1 = Expr1->Clone(ctx);
			return rs;
		}
		RefPtr<SyntaxNode> UnaryExpressionSyntaxNode::Accept(SyntaxVisitor * visitor)
		{
			return visitor->VisitUnaryExpression(this);
		}
		UnaryExpressionSyntaxNode * UnaryExpressionSyntaxNode::Clone(CloneContext & ctx)
		{
			auto rs = CloneSyntaxNodeFields(new UnaryExpressionSyntaxNode(*this), ctx);
			rs->Expression = Expression->Clone(ctx);
			return rs;
		}
		RefPtr<SyntaxNode> VarExpressionSyntaxNode::Accept(SyntaxVisitor * visitor)
		{
			return visitor->VisitVarExpression(this);
		}
		VarExpressionSyntaxNode * VarExpressionSyntaxNode::Clone(CloneContext & ctx)
		{
			return CloneSyntaxNodeFields(new VarExpressionSyntaxNode(*this), ctx);
		}
		RefPtr<SyntaxNode> ParameterSyntaxNode::Accept(SyntaxVisitor * visitor)
		{
			return visitor->VisitParameter(this);
		}
		ParameterSyntaxNode * ParameterSyntaxNode::Clone(CloneContext & ctx)
		{
			auto rs = CloneSyntaxNodeFields(new ParameterSyntaxNode(*this), ctx);
			rs->TypeNode = TypeNode->Clone(ctx);
			rs->Expr = Expr->Clone(ctx);
			return rs;
		}
		RefPtr<SyntaxNode> BasicTypeSyntaxNode::Accept(SyntaxVisitor * visitor)
		{
			return visitor->VisitBasicType(this);
		}
		RefPtr<TypeSyntaxNode> TypeSyntaxNode::FromExpressionType(ExpressionType * type)
		{
			if (auto basicType = dynamic_cast<BasicExpressionType*>(type))
			{
				RefPtr<BasicTypeSyntaxNode> rs = new BasicTypeSyntaxNode();
				auto & t = *basicType;
				if (basicType->BaseType == BaseType::Int)
					rs->TypeName = L"int";
				else if (t.BaseType == BaseType::Float)
					rs->TypeName = L"float";
				else if (t.BaseType == BaseType::Bool)
					rs->TypeName = L"bool";
				else if (t.BaseType == BaseType::Int2)
					rs->TypeName = L"ivec2";
				else if (t.BaseType == BaseType::Int3)
					rs->TypeName = L"ivec3";
				else if (t.BaseType == BaseType::Int4)
					rs->TypeName = L"ivec4";
				else if (t.BaseType == BaseType::UInt)
					rs->TypeName = L"uint";
				else if (t.BaseType == BaseType::UInt2)
					rs->TypeName = L"uint2";
				else if (t.BaseType == BaseType::UInt3)
					rs->TypeName = L"uint3";
				else if (t.BaseType == BaseType::UInt4)
					rs->TypeName = L"uint4";
				else if (t.BaseType == BaseType::Float2)
					rs->TypeName = L"vec2";
				else if (t.BaseType == BaseType::Float3)
					rs->TypeName = L"vec3";
				else if (t.BaseType == BaseType::Float4)
					rs->TypeName = L"vec4";
				else if (t.BaseType == BaseType::Float3x3)
					rs->TypeName = L"mat3";
				else if (t.BaseType == BaseType::Float4x4)
					rs->TypeName = L"mat4";
				else if (t.BaseType == BaseType::Texture2D)
					rs->TypeName = L"sampler2D";
				else if (t.BaseType == BaseType::TextureCube)
					rs->TypeName = L"samplerCube";
				else if (t.BaseType == BaseType::TextureShadow)
					rs->TypeName = L"samplerShadow";
				else if (t.BaseType == BaseType::TextureCubeShadow)
					rs->TypeName = L"samplerCubeShadow";
				return rs;
			}
			else if (auto arrayType = dynamic_cast<ArrayExpressionType*>(type))
			{
				RefPtr<ArrayTypeSyntaxNode> rs = new ArrayTypeSyntaxNode();
				rs->ArrayLength = arrayType->ArrayLength;
				rs->BaseType = FromExpressionType(arrayType->BaseType.Ptr());
				return rs;
			}
			throw NotImplementedException();
		}
		RefPtr<SyntaxNode> ComponentSyntaxNode::Accept(SyntaxVisitor * visitor)
		{
			return visitor->VisitComponent(this);
		}
		ComponentSyntaxNode * ComponentSyntaxNode::Clone(CloneContext & ctx)
		{
			auto rs = CloneSyntaxNodeFields(new ComponentSyntaxNode(*this), ctx);
			rs->TypeNode = TypeNode->Clone(ctx);
			if (Rate)
				rs->Rate = Rate->Clone(ctx);
			if (BlockStatement)
				rs->BlockStatement = BlockStatement->Clone(ctx);
			if (Expression)
				rs->Expression = Expression->Clone(ctx);
			return rs;
		}
		RefPtr<SyntaxNode> ShaderSyntaxNode::Accept(SyntaxVisitor * visitor)
		{
			return visitor->VisitShader(this);
		}
		ShaderSyntaxNode * ShaderSyntaxNode::Clone(CloneContext & ctx)
		{
			auto rs = CloneSyntaxNodeFields(new ShaderSyntaxNode(*this), ctx);
			rs->Members.Clear();
			for (auto & comp : Members)
				rs->Members.Add(comp->Clone(ctx));
			return rs;
		}
		RateSyntaxNode * RateSyntaxNode::Clone(CloneContext & ctx)
		{
			return CloneSyntaxNodeFields(new RateSyntaxNode(*this), ctx);
		}
		WorldSyntaxNode * WorldSyntaxNode::Clone(CloneContext & ctx)
		{
			return CloneSyntaxNodeFields(new WorldSyntaxNode(*this), ctx);
		}
		RefPtr<SyntaxNode> ImportOperatorDefSyntaxNode::Accept(SyntaxVisitor * visitor)
		{
			return visitor->VisitImportOperatorDef(this); 
		}
		ImportOperatorDefSyntaxNode * ImportOperatorDefSyntaxNode::Clone(CloneContext & ctx)
		{
			return CloneSyntaxNodeFields(new ImportOperatorDefSyntaxNode(*this), ctx);
		}
		PipelineSyntaxNode * PipelineSyntaxNode::Clone(CloneContext & ctx)
		{
			auto rs = CloneSyntaxNodeFields(new PipelineSyntaxNode(*this), ctx);
			rs->Worlds.Clear();
			for (auto & w : Worlds)
				rs->Worlds.Add(w->Clone(ctx));
			rs->ImportOperators.Clear();
			for (auto & imp : ImportOperators)
				rs->ImportOperators.Add(imp->Clone(ctx));
			rs->AbstractComponents.Clear();
			for (auto & comp : AbstractComponents)
				rs->AbstractComponents.Add(comp->Clone(ctx));
			return rs;
		}
		ChoiceValueSyntaxNode * ChoiceValueSyntaxNode::Clone(CloneContext & ctx)
		{
			return CloneSyntaxNodeFields(new ChoiceValueSyntaxNode(*this), ctx);
		}
		RefPtr<SyntaxNode> ImportSyntaxNode::Accept(SyntaxVisitor * v)
		{
			return v->VisitImport(this);
		}
		ImportSyntaxNode * ImportSyntaxNode::Clone(CloneContext & ctx)
		{
			auto rs = CloneSyntaxNodeFields(new ImportSyntaxNode(*this), ctx);
			rs->Arguments.Clear();
			for (auto & arg : Arguments)
				rs->Arguments.Add(arg->Clone(ctx));
			return rs;
		}
		RefPtr<SyntaxNode> ImportArgumentSyntaxNode::Accept(SyntaxVisitor * visitor)
		{
			return visitor->VisitImportArgument(this);
		}
		ImportArgumentSyntaxNode * ImportArgumentSyntaxNode::Clone(CloneContext & ctx)
		{
			auto rs = CloneSyntaxNodeFields(new ImportArgumentSyntaxNode(*this), ctx);
			rs->Expression = Expression->Clone(ctx);
			return rs;
		}
		RefPtr<SyntaxNode> ImportStatementSyntaxNode::Accept(SyntaxVisitor * visitor)
		{
			return visitor->VisitImportStatement(this);
		}
		ImportStatementSyntaxNode * ImportStatementSyntaxNode::Clone(CloneContext & ctx)
		{
			auto rs = CloneSyntaxNodeFields(new ImportStatementSyntaxNode(*this), ctx);
			rs->Import = Import->Clone(ctx);
			return rs;
		}
		RefPtr<SyntaxNode> StructField::Accept(SyntaxVisitor * visitor)
		{
			return visitor->VisitStructField(this);
		}
		RefPtr<SyntaxNode> StructSyntaxNode::Accept(SyntaxVisitor * visitor)
		{
			return visitor->VisitStruct(this);
		}
		RefPtr<SyntaxNode> DiscardStatementSyntaxNode::Accept(SyntaxVisitor * visitor)
		{
			return visitor->VisitDiscardStatement(this);
		}
		DiscardStatementSyntaxNode * DiscardStatementSyntaxNode::Clone(CloneContext & ctx)
		{
			auto rs = CloneSyntaxNodeFields(new DiscardStatementSyntaxNode(*this), ctx);
			return rs;
		}
		bool BasicExpressionType::IsIntegral() const
		{
			return (BaseType == Compiler::BaseType::Int || BaseType == Compiler::BaseType::UInt || BaseType == Compiler::BaseType::Bool);
		}
		bool ExpressionType::IsTexture() const
		{
			auto basicType = AsBasicType();
			if (basicType)
				return basicType->BaseType == BaseType::Texture2D ||
					basicType->BaseType == BaseType::TextureCube ||
					basicType->BaseType == BaseType::TextureCubeShadow ||
					basicType->BaseType == BaseType::TextureShadow;
			return false;
		}
		bool ExpressionType::IsStruct() const
		{
			auto basicType = AsBasicType();
			if (basicType)
				return basicType->Struct != nullptr;
			return false;
		}
		bool ExpressionType::IsShader() const
		{
			auto basicType = AsBasicType();
			if (basicType)
				return basicType->Shader != nullptr;
			return false;
		}

		RefPtr<ExpressionType> ExpressionType::Bool;
		RefPtr<ExpressionType> ExpressionType::UInt;
		RefPtr<ExpressionType> ExpressionType::UInt2;
		RefPtr<ExpressionType> ExpressionType::UInt3;
		RefPtr<ExpressionType> ExpressionType::UInt4;
		RefPtr<ExpressionType> ExpressionType::Int;
		RefPtr<ExpressionType> ExpressionType::Int2;
		RefPtr<ExpressionType> ExpressionType::Int3;
		RefPtr<ExpressionType> ExpressionType::Int4;
		RefPtr<ExpressionType> ExpressionType::Float;
		RefPtr<ExpressionType> ExpressionType::Float2;
		RefPtr<ExpressionType> ExpressionType::Float3;
		RefPtr<ExpressionType> ExpressionType::Float4;
		RefPtr<ExpressionType> ExpressionType::Void;
		RefPtr<ExpressionType> ExpressionType::Error;

		void ExpressionType::Init()
		{
			Bool = new BasicExpressionType(BaseType::Bool);
			UInt = new BasicExpressionType(BaseType::UInt);
			UInt2 = new BasicExpressionType(BaseType::UInt2);
			UInt3 = new BasicExpressionType(BaseType::UInt3);
			UInt4 = new BasicExpressionType(BaseType::UInt4);
			Int = new BasicExpressionType(BaseType::Int);
			Int2 = new BasicExpressionType(BaseType::Int2);
			Int3 = new BasicExpressionType(BaseType::Int3);
			Int4 = new BasicExpressionType(BaseType::Int4);
			Float = new BasicExpressionType(BaseType::Float);
			Float2 = new BasicExpressionType(BaseType::Float2);
			Float3 = new BasicExpressionType(BaseType::Float3);
			Float4 = new BasicExpressionType(BaseType::Float4);
			Void = new BasicExpressionType(BaseType::Void);
			Error = new BasicExpressionType(BaseType::Error);
		}
		void ExpressionType::Finalize()
		{
			Bool = nullptr;
			UInt = nullptr;
			UInt2 = nullptr;
			UInt3 = nullptr;
			UInt4 = nullptr;
			Int = nullptr;
			Int2 = nullptr;
			Int3 = nullptr;
			Int4 = nullptr;
			Float = nullptr;
			Float2 = nullptr;
			Float3 = nullptr;
			Float4 = nullptr;
			Void = nullptr;
			Error = nullptr;
		}
		bool ArrayExpressionType::IsIntegral() const
		{
			return false;
		}
		bool ArrayExpressionType::IsArray() const
		{
			return true;
		}
		int ArrayExpressionType::GetSize() const
		{
			return ArrayLength * BaseType->GetSize();
		}
		bool ArrayExpressionType::Equals(const ExpressionType * type) const
		{
			auto arrType = dynamic_cast<const ArrayExpressionType*>(type);
			if (!arrType)
				return false;
			return (ArrayLength == arrType->ArrayLength && BaseType->Equals(arrType->BaseType.Ptr()));
		}
		bool ArrayExpressionType::IsVectorType() const
		{
			return false;
		}
		CoreLib::Basic::String ArrayExpressionType::ToString() const
		{
			if (ArrayLength > 0)
				return BaseType->ToString() + L"[" + String(ArrayLength) + L"]";
			else
				return BaseType->ToString() + L"[]";
		}
		ExpressionType * ArrayExpressionType::Clone()
		{
			auto rs = new ArrayExpressionType(*this);
			rs->BaseType = BaseType->Clone();
			return rs;
		}
		RefPtr<SyntaxNode> ArrayTypeSyntaxNode::Accept(SyntaxVisitor * visitor)
		{
			return visitor->VisitArrayType(this);
		}
		RefPtr<SyntaxNode> GenericTypeSyntaxNode::Accept(SyntaxVisitor * visitor)
		{
			return visitor->VisitGenericType(this);
		}
		bool GenericExpressionType::IsIntegral() const
		{
			return false;
		}
		int GenericExpressionType::GetSize() const
		{
			return 0;
		}
		bool GenericExpressionType::IsArray() const
		{
			return false;
		}
		bool GenericExpressionType::Equals(const ExpressionType * type) const
		{
			if (auto gtype = dynamic_cast<const GenericExpressionType*>(type))
				return GenericTypeName == gtype->GenericTypeName && gtype->BaseType->Equals(BaseType.Ptr());
			
			return false;
		}
		bool GenericExpressionType::IsVectorType() const
		{
			return false;
		}
		CoreLib::Basic::String GenericExpressionType::ToString() const
		{
			return GenericTypeName + L"<" + BaseType->ToString() + L">";
		}
		ExpressionType * GenericExpressionType::Clone()
		{
			auto rs = new GenericExpressionType(*this);
			rs->BaseType = BaseType->Clone();
			return rs;
		}
		RefPtr<SyntaxNode> ImportExpressionSyntaxNode::Accept(SyntaxVisitor * visitor)
		{
			return visitor->VisitImportExpression(this);
		}
		ImportExpressionSyntaxNode * ImportExpressionSyntaxNode::Clone(CloneContext & ctx)
		{
			ImportExpressionSyntaxNode * result = new ImportExpressionSyntaxNode(*this);
			CloneSyntaxNodeFields(result, ctx);
			result->Component = Component->Clone(ctx);
			result->Arguments.Clear();
			for (auto & arg : Arguments)
				result->Arguments.Add(arg->Clone(ctx));
			return result;
		}
		StageSyntaxNode * StageSyntaxNode::Clone(CloneContext &)
		{
			return new StageSyntaxNode(*this);
		}
		RefPtr<ComponentSyntaxNode> SyntaxVisitor::VisitComponent(ComponentSyntaxNode * comp)
		{
			if (comp->TypeNode)
				comp->TypeNode = comp->TypeNode->Accept(this).As<TypeSyntaxNode>();
			if (comp->Expression)
				comp->Expression = comp->Expression->Accept(this).As<ExpressionSyntaxNode>();
			if (comp->BlockStatement)
				comp->BlockStatement = comp->BlockStatement->Accept(this).As<BlockStatementSyntaxNode>();
			return comp;
		}
}
}

/***********************************************************************
CORE\VARIANTIR.CPP
***********************************************************************/

namespace Spire
{
	namespace Compiler
	{
		class ComponentDependency
		{
		public:
			String ReferencedComponent;
			ImportOperatorDefSyntaxNode * ImportOperator = nullptr;
			ComponentDependency() = default;
			ComponentDependency(String compName, ImportOperatorDefSyntaxNode * impOp)
				: ReferencedComponent(compName), ImportOperator(impOp)
			{}
			int GetHashCode()
			{
				return ReferencedComponent.GetHashCode() ^ (int)(CoreLib::PtrInt)(void*)(ImportOperator);
			}
			bool operator == (const ComponentDependency & other)
			{
				return ReferencedComponent == other.ReferencedComponent && ImportOperator == other.ImportOperator;
			}
		};
		class GetDependencyVisitor : public SyntaxVisitor
		{
		public:
			EnumerableHashSet<ComponentDependency> Result;
			GetDependencyVisitor()
				: SyntaxVisitor(nullptr)
			{}

			RefPtr<ExpressionSyntaxNode> VisitVarExpression(VarExpressionSyntaxNode * var) override
			{
				RefPtr<Object> refCompObj;
				if (var->Tags.TryGetValue(L"ComponentReference", refCompObj))
				{
					auto refComp = refCompObj.As<StringObject>().Ptr();
					Result.Add(ComponentDependency(refComp->Content, nullptr));
				}
				return var;
			}

			RefPtr<ExpressionSyntaxNode> VisitMemberExpression(MemberExpressionSyntaxNode * member) override
			{
				RefPtr<Object> refCompObj;
				if (member->Tags.TryGetValue(L"ComponentReference", refCompObj))
				{
					auto refComp = refCompObj.As<StringObject>().Ptr();
					Result.Add(ComponentDependency(refComp->Content, nullptr));
				}
				else
					member->BaseExpression->Accept(this);
				return member;
			}

			RefPtr<ExpressionSyntaxNode> VisitImportExpression(ImportExpressionSyntaxNode * syntax) override
			{
				for (auto & comp : syntax->ImportOperatorDef->Usings)
					Result.Add(ComponentDependency(comp, nullptr));
				Result.Add(ComponentDependency(syntax->ComponentUniqueName, syntax->ImportOperatorDef.Ptr()));
				return SyntaxVisitor::VisitImportExpression(syntax);
			}
		};

		EnumerableHashSet<ComponentDependency> GetDependentComponents(SyntaxNode * tree)
		{
			GetDependencyVisitor visitor;
			tree->Accept(&visitor);
			return visitor.Result;
		}

		void ShaderIR::EliminateDeadCode()
		{
			// mark entry points
			auto MarkUsing = [&](String compName, String userWorld)
			{
				if (auto defs = DefinitionsByComponent.TryGetValue(compName))
				{
					if (auto def = defs->TryGetValue(userWorld))
						(*def)->IsEntryPoint = true;
					else
					{
						for (auto & world : Shader->Pipeline->WorldDependency[userWorld]())
						{
							if (auto def2 = defs->TryGetValue(world))
							{
								(*def2)->IsEntryPoint = true;
								break;
							}
						}
					}
				}
			};
			for (auto & impOp : Shader->Pipeline->SyntaxNode->ImportOperators)
				for (auto & ref : impOp->Usings)
					MarkUsing(ref, impOp->DestWorld.Content);
			for (auto & req : Shader->Pipeline->Components)
				if (req.Value->IsParam())
				{
					for (auto & impl : req.Value->Implementations)
						for (auto & world : impl->Worlds)
							MarkUsing(req.Key, world);
				}
			List<ComponentDefinitionIR*> workList;
			HashSet<ComponentDefinitionIR*> referencedDefs;
			for (auto & def : Definitions)
			{
				if (def->IsEntryPoint)
				{
					if (referencedDefs.Add(def.Ptr()))
						workList.Add(def.Ptr());
				}
			}
			for (int i = 0; i < workList.Count(); i++)
			{
				auto def = workList[i];
				for (auto & dep : def->Dependency)
				{
					if (referencedDefs.Add(dep))
						workList.Add(dep);
				}
			}
			List<RefPtr<ComponentDefinitionIR>> newDefinitions;
			for (auto & def : Definitions)
			{
				if (referencedDefs.Contains(def.Ptr()))
				{
					newDefinitions.Add(def);
					EnumerableHashSet<ComponentDefinitionIR*> newSet;
					for (auto & comp : def->Users)
						if (referencedDefs.Contains(comp))
						{
							newSet.Add(comp);
						}
					def->Users = newSet;
					newSet.Clear();
					for (auto & comp : def->Dependency)
						if (referencedDefs.Contains(comp))
						{
							newSet.Add(comp);
						}
					def->Dependency = newSet;
				}
			}
			Definitions = _Move(newDefinitions);
			for (auto & kv : DefinitionsByComponent)
			{
				for (auto & def : kv.Value)
					if (!referencedDefs.Contains(def.Value))
						kv.Value.Remove(def.Key);
			}
		}

		class ReferenceWorkItem
		{
		public:
			ComponentDependency Dependency;
			String SourceWorld;
			int GetHashCode()
			{
				return Dependency.GetHashCode();
			}
			bool operator == (const ReferenceWorkItem & other)
			{
				return Dependency == other.Dependency && SourceWorld == other.SourceWorld;
			}
		};

		void ShaderIR::ResolveComponentReference()
		{
			// build bidirectional dependency map of component definitions
			for (auto & comp : Definitions)
			{
				comp->Dependency.Clear();
				comp->Users.Clear();
			}
			for (auto & comp : Definitions)
			{
				List<ReferenceWorkItem> workList;
				for (auto & dep : GetDependentComponents(comp->SyntaxNode.Ptr()))
				{
					ReferenceWorkItem item;
					item.Dependency = dep;
					item.SourceWorld = dep.ImportOperator ? dep.ImportOperator->SourceWorld.Content : comp->World;
					workList.Add(item);
				}
				HashSet<ReferenceWorkItem> proceseedDefCompss;
				for (int i = 0; i < workList.Count(); i++)
				{
					auto dep = workList[i];
					if (!proceseedDefCompss.Add(dep))
						continue;
					auto & depDefs = DefinitionsByComponent[dep.Dependency.ReferencedComponent]();
					// select the best overload according to import operator ordering,
					// prefer user-pinned definitions (as provided in the choice file)
					List<String> depWorlds;
					depWorlds.Add(dep.SourceWorld);
					for (auto & w : Shader->Pipeline->WorldDependency[dep.SourceWorld]())
						depWorlds.Add(w);
					for (int pass = 0; pass < 2; pass++)
					{
						// in the first pass, examine the pinned definitions only
						// in the second pass, examine all the rest definitions
						for (auto & depWorld : depWorlds)
						{
							bool isPinned = Shader->AllComponents[dep.Dependency.ReferencedComponent]()->Type->PinnedWorlds.Contains(depWorld);
							if ((pass == 0 && !isPinned) || (pass == 1 && isPinned)) continue;
							ComponentDefinitionIR * depDef;
							if (depDefs.TryGetValue(depWorld, depDef))
							{
								comp->Dependency.Add(depDef);
								depDef->Users.Add(comp.Ptr());
								// add additional dependencies due to import operators
								auto processImportOperatorUsings = [&](ImportOperatorDefSyntaxNode * importOp)
								{
									for (auto & importUsing : importOp->Usings)
									{
										ShaderComponentSymbol* refComp;
										if (!Shader->AllComponents.TryGetValue(importUsing, refComp))
											throw InvalidProgramException(L"import operator dependency not exists.");
										ReferenceWorkItem workItem;
										workItem.Dependency = ComponentDependency(refComp->UniqueName, nullptr);
										workItem.SourceWorld = importOp->SourceWorld.Content;
										workList.Add(workItem);
									}
								};
								if (dep.Dependency.ImportOperator)
								{
									processImportOperatorUsings(dep.Dependency.ImportOperator);
								}
								if (depWorld != dep.SourceWorld)
								{
									auto importPath = Shader->Pipeline->FindImplicitImportOperatorChain(depWorld, dep.SourceWorld);
									if (importPath.Count() == 0)
										throw InvalidProgramException(L"no import path found.");
									processImportOperatorUsings(importPath.First().Nodes.Last().ImportOperator);
								}
								goto selectionEnd; // first preferred overload is found, terminate searching
							}
						}
					}
				selectionEnd:;
				}
			}
		}
		List<String> ShaderIR::GetComponentDependencyOrder()
		{
			List<String> result, workList;
			HashSet<String> set;
			for (auto & comp : DefinitionsByComponent)
			{
				bool emptyDependency = true;
				for (auto & def : comp.Value)
					if (def.Value->Dependency.Count())
					{
						emptyDependency = false;
						break;
					}
				if (emptyDependency)
				{
					workList.Add(comp.Key);
				}
			}
			for (int i = 0; i < workList.Count(); i++)
			{
				auto comp = workList[i];
				if (!set.Contains(comp))
				{
					bool insertable = true;
					for (auto & def : DefinitionsByComponent[comp]())
					{
						for (auto & dep : def.Value->Dependency)
							if (!set.Contains(dep->UniqueName))
							{
								insertable = false;
								goto breakLoc;
							}
					}
				breakLoc:;
					if (insertable)
					{
						if (set.Add(comp))
						{
							result.Add(comp);
							for (auto & def : DefinitionsByComponent[comp]())
								for (auto & user : def.Value->Users)
									workList.Add(user->UniqueName);
						}
					}
				}
			}
			return result;
		}
	}
}

/***********************************************************************
LIB\SPIRELIB.CPP
***********************************************************************/

using namespace CoreLib::Basic;
using namespace CoreLib::IO;
using namespace CoreLib::Text;
using namespace Spire::Compiler;

namespace SpireLib
{
	void ReadSource(EnumerableDictionary<String, StageSource> & sources, CoreLib::Text::Parser & parser, String src)
	{
		auto getShaderSource = [&]()
		{
			auto token = parser.ReadToken();
			int endPos = token.Position + 1;
			int brace = 0;
			while (endPos < src.Length() && !(src[endPos] == L'}' && brace == 0))
			{
				if (src[endPos] == L'{')
					brace++;
				else if (src[endPos] == L'}')
					brace--;
				endPos++;
			}
			while (!parser.IsEnd() && parser.NextToken().Position != endPos)
				parser.ReadToken();
			parser.ReadToken();
			return src.SubString(token.Position + 1, endPos - token.Position - 1);
		};
		while (!parser.IsEnd() && !parser.LookAhead(L"}"))
		{
			auto worldName = parser.ReadWord();
			StageSource compiledSrc;
			if (parser.LookAhead(L"binary"))
			{
				parser.ReadToken();
				parser.Read(L"{");
				while (!parser.LookAhead(L"}") && !parser.IsEnd())
				{
					auto val = parser.ReadUInt();
					compiledSrc.BinaryCode.AddRange((unsigned char*)&val, sizeof(unsigned int));
					if (parser.LookAhead(L","))
						parser.ReadToken();
				}
				parser.Read(L"}");
			}
			if (parser.LookAhead(L"text"))
			{
				parser.ReadToken();
				compiledSrc.MainCode = getShaderSource();
			}
			sources[worldName] = compiledSrc;
		}
	}
	StageSource ShaderLib::GetStageSource(String stage)
	{
		StageSource rs;
		Sources.TryGetValue(stage, rs);
		return rs;
	}
	ShaderLib::ShaderLib(CoreLib::Basic::String fileName)
	{
		Reload(fileName);
	}
	void ShaderLib::Reload(CoreLib::Basic::String fileName)
	{
		Load(fileName);
	}
	bool ShaderLib::CompileFrom(String symbolName, String sourceFileName, String schedule)
	{
		CompileResult result;
		CompileOptions options;
		options.ScheduleSource = schedule;
		options.SymbolToCompile = symbolName;
		options.Mode = CompilerMode::ProduceShader;
		auto shaderLibs = CompileShaderSourceFromFile(result, sourceFileName, options);
		if (result.Success)
		{
			for (auto & lib : shaderLibs)
			{
				if (lib.MetaData.ShaderName == symbolName)
				{
					FromString(shaderLibs[0].ToString());
					return true;
				}
			}
		}
		result.PrintError(true);
		return false;
	}

	List<ShaderLibFile> CompileUnits(Spire::Compiler::CompileResult & compileResult,
		ShaderCompiler * compiler, List<CompileUnit> & units,
		Spire::Compiler::CompileOptions & options)
	{
		List<ShaderLibFile> resultFiles;
		compiler->Compile(compileResult, units, options);
		if (compileResult.Success)
		{
			if (options.Mode == CompilerMode::ProduceShader)
			{
				EnumerableDictionary<String, ShaderLibFile> shaderLibs;
				for (auto file : compileResult.CompiledSource)
				{
					ShaderLibFile libFile;
					libFile.MetaData = file.Value.MetaData;
					libFile.Sources = file.Value.Stages;
					resultFiles.Add(libFile);
				}
			}
		}
		return resultFiles;
	}

	List<ShaderLibFile> CompileShaderSource(Spire::Compiler::CompileResult & compileResult,
		const CoreLib::String & src, const CoreLib::String & fileName, Spire::Compiler::CompileOptions & options)
	{
		Spire::Compiler::NamingCounter = 0;
		RefPtr<ShaderCompiler> compiler = CreateShaderCompiler();
		List<CompileUnit> units;
		HashSet<String> processedUnits;
		List<String> unitsToInclude;
		unitsToInclude.Add(fileName);
		processedUnits.Add(fileName);
		auto predefUnit = compiler->Parse(compileResult, LibIncludeString, L"stdlib");
		for (int i = 0; i < unitsToInclude.Count(); i++)
		{
			auto inputFileName = unitsToInclude[i];
			try
			{
				String source = src;
				if (i > 0)
					source = File::ReadAllText(inputFileName);
				auto unit = compiler->Parse(compileResult, source, inputFileName);
				units.Add(unit);
				if (unit.SyntaxNode)
				{
					for (auto inc : unit.SyntaxNode->Usings)
					{
						String includeFile = Path::Combine(Path::GetDirectoryName(inputFileName), inc.Content);
						if (processedUnits.Add(includeFile))
						{
							unitsToInclude.Add(includeFile);
						}
					}
				}
			}
			catch (IOException)
			{
				compileResult.GetErrorWriter()->Error(1, L"cannot open file '" + inputFileName + L"'.", CodePosition(0, 0, L""));
			}
		}
		units.Add(predefUnit);
		if (compileResult.ErrorList.Count() == 0)
			return CompileUnits(compileResult, compiler.Ptr(), units, options);
		else
			return List<ShaderLibFile>();
	}

	List<ShaderLibFile> CompileShaderSourceFromFile(Spire::Compiler::CompileResult & compileResult, 
		CoreLib::Basic::String sourceFileName,
		Spire::Compiler::CompileOptions & options)
	{
		try
		{
			return CompileShaderSource(compileResult, File::ReadAllText(sourceFileName), sourceFileName, options);
		}
		catch (IOException)
		{
			compileResult.GetErrorWriter()->Error(1, L"cannot open file '" + Path::GetFileName(sourceFileName) + L"'.", CodePosition(0, 0, L""));
		}
		return List<ShaderLibFile>();
	}
	void ShaderLibFile::AddSource(CoreLib::Basic::String source, CoreLib::Text::Parser & parser)
	{
		ReadSource(Sources, parser, source);
	}

	CoreLib::String ShaderLibFile::ToString()
	{
		StringBuilder writer;
		writer << L"name " << MetaData.ShaderName << EndLine;
		for (auto & stage : MetaData.Stages)
		{
			writer << L"stage " << stage.Key << EndLine << L"{" << EndLine;
			writer << L"target " << stage.Value.TargetName << EndLine;
			for (auto & blk : stage.Value.InputBlocks)
			{
				writer << L"in " << blk << L";\n";
			}
			writer << L"out " << stage.Value.OutputBlock << L";\n";
			for (auto & comp : stage.Value.Components)
				writer << L"comp " << comp << L";\n";
			writer << L"}" << EndLine;
		}
		for (auto & ublock : MetaData.InterfaceBlocks)
		{
			writer << L"interface " << ublock.Key << L" size " << ublock.Value.Size << L"\n{\n";
			for (auto & entry : ublock.Value.Entries)
			{
				writer << entry.Type->ToString() << L" " << entry.Name << L" : " << entry.Offset << L"," << entry.Size;
				if (entry.Attributes.Count())
				{
					writer << L"\n{\n";
					for (auto & attrib : entry.Attributes)
					{
						writer << attrib.Key << L" : " << CoreLib::Text::Parser::EscapeStringLiteral(attrib.Value) << L";\n";
					}
					writer << L"}";
				}
				writer << L";\n";
			}
			writer << L"}\n";
		}
		writer << L"source" << EndLine << L"{" << EndLine;
		for (auto & src : Sources)
		{
			writer << src.Key << EndLine;
			if (src.Value.BinaryCode.Count())
			{
				writer << L"binary" << EndLine << L"{" << EndLine;
				auto binaryBuffer = (unsigned int*)src.Value.BinaryCode.Buffer();
				for (int i = 0; i < src.Value.BinaryCode.Count() / 4; i++)
				{
					writer << String((long long)binaryBuffer[i]) << L",";
					if ((i+1) % 10)
						writer << EndLine;
				}
				writer << EndLine << L"}" << EndLine;
			}
			writer << L"text" << EndLine << L"{" << EndLine;
			writer << src.Value.MainCode << EndLine;

			writer << L"}" << EndLine;
		}
		writer << L"}" << EndLine;
		StringBuilder formatSB;
		IndentString(formatSB, writer.ProduceString());
		return formatSB.ProduceString();
	}
	
	void ShaderLibFile::Clear()
	{
		Sources.Clear();
		MetaData.Stages.Clear();
		Sources.Clear();
	}

	void ShaderLibFile::SaveToFile(CoreLib::Basic::String fileName)
	{
		StreamWriter fwriter(fileName);
		fwriter.Write(ToString());
	}

	void ShaderLibFile::FromString(const String & src)
	{
		Clear();
		CoreLib::Text::Parser parser(src);
		while (!parser.IsEnd())
		{
			auto fieldName = parser.ReadWord();
			if (fieldName == L"name")
			{
				MetaData.ShaderName = parser.ReadWord();
			}
			else if (fieldName == L"source")
			{
				parser.Read(L"{");
				ReadSource(Sources, parser, src);
				parser.Read(L"}");
			}
			
			else if (fieldName == L"stage")
			{
				StageMetaData stage;
				stage.Name = parser.ReadWord();
				parser.Read(L"{");
				while (!parser.LookAhead(L"}"))
				{
					auto subFieldName = parser.ReadWord();
					if (subFieldName == L"target")
						stage.TargetName = parser.ReadWord();
					else if (subFieldName == L"in")
					{
						stage.InputBlocks.Add(parser.ReadWord());
						parser.Read(L";");
					}
					else if (subFieldName == L"out")
					{
						stage.OutputBlock = parser.ReadWord();
						parser.Read(L";");
					}
					else if (subFieldName == L"comp")
					{
						auto compName = parser.ReadWord();
						parser.Read(L";");
						stage.Components.Add(compName);
					}
				}
				parser.Read(L"}");
				MetaData.Stages[stage.Name] = stage;
			}
			else if (fieldName == L"interface")
			{
				InterfaceBlockMetaData block;
				if (!parser.LookAhead(L"{") && !parser.LookAhead(L"size"))
					block.Name = parser.ReadWord();
				if (parser.LookAhead(L"size"))
				{
					parser.ReadWord();
					block.Size = parser.ReadInt();
				}
				parser.Read(L"{");
				while (!parser.LookAhead(L"}") && !parser.IsEnd())
				{
					InterfaceBlockEntry entry;
					entry.Type = TypeFromString(parser);
					entry.Name = parser.ReadWord();
					parser.Read(L":");
					entry.Offset = parser.ReadInt();
					parser.Read(L",");
					entry.Size = parser.ReadInt();
					if (parser.LookAhead(L"{"))
					{
						parser.Read(L"{");
						while (!parser.LookAhead(L"}") && !parser.IsEnd())
						{
							auto attribName = parser.ReadWord();
							parser.Read(L":");
							auto attribValue = parser.ReadStringLiteral();
							parser.Read(L";");
							entry.Attributes[attribName] = attribValue;
						}
						parser.Read(L"}");
					}
					parser.Read(L";");
					block.Entries.Add(entry);
				}
				parser.Read(L"}");
				MetaData.InterfaceBlocks[block.Name] = block;
			}
		}
	}

	void ShaderLibFile::Load(String fileName)
	{
		String src = File::ReadAllText(fileName);
		FromString(src);
	}
}
