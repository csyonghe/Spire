/***********************************************************************

Spire - The MIT License (MIT)
Copyright (c) 2016, Carnegie Mellon University

Permission is hereby granted, free of charge, to any person obtaining a 
copy of this software and associated documentation files (the "Software"), 
to deal in the Software without restriction, including without limitation 
the rights to use, copy, modify, merge, publish, distribute, sublicense, 
and/or sell copies of the Software, and to permit persons to whom the 
Software is furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in 
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR 
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, 
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL 
THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER 
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING 
FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER 
DEALINGS IN THE SOFTWARE.


========================================================================
WARNING: THIS FILE IS AUTOMATICALLY GENERATED. DO NOT MODIFY
***********************************************************************/
#include "Spire.h"

/***********************************************************************
CORE\CLOSURE.CPP
***********************************************************************/

namespace Spire
{
	namespace Compiler
	{
		void CheckComponentRedefinition(ErrorWriter * err, ShaderClosure * parent, ShaderClosure * child)
		{
			for (auto & comp : child->Components)
			{
				RefPtr<ShaderComponentSymbol> ccomp;
				RefPtr<ShaderClosure> su;
				if ((comp.Value->Implementations.First()->SyntaxNode->IsPublic ||
					comp.Value->Implementations.First()->SyntaxNode->IsOutput))
				{
					if (parent->Components.TryGetValue(comp.Key, ccomp))
						err->Error(33022, L"\'" + comp.Key + L"\' is already defined in current scope.\nsee previous definition at " + ccomp->Implementations.First()->SyntaxNode->Position.ToString(),
							comp.Value->Implementations.First()->SyntaxNode->Position);
					else if (parent->SubClosures.TryGetValue(comp.Key, su))
						err->Error(33022, L"\'" + comp.Key + L"\' is already defined in current scope.\nsee previous definition at " + su->UsingPosition.ToString(),
							comp.Value->Implementations.First()->SyntaxNode->Position);
				}
			}
			for (auto & c : child->SubClosures)
			{
				if (c.Value->IsInPlace)
				{
					RefPtr<ShaderComponentSymbol> ccomp;
					RefPtr<ShaderClosure> su;
					if (parent->Components.TryGetValue(c.Key, ccomp))
						err->Error(33022, L"\'" + c.Key + L"\' is already defined in current scope.\nsee previous definition at " + ccomp->Implementations.First()->SyntaxNode->Position.ToString(),
							c.Value->UsingPosition);
					else if (parent->SubClosures.TryGetValue(c.Key, su))
						err->Error(33022, L"\'" + c.Key + L"\' is already defined in current scope.\nsee previous definition at " + su->UsingPosition.ToString(),
							c.Value->UsingPosition);
					for (auto & sc : c.Value->SubClosures)
						if (sc.Value->IsInPlace)
							CheckComponentRedefinition(err, parent, sc.Value.Ptr());
				}
			}
		}
		RefPtr<ShaderClosure> CreateShaderClosure(ErrorWriter * err, SymbolTable * symTable, ShaderSymbol * shader, CodePosition usingPos, const Dictionary<String, RefPtr<ShaderComponentSymbol>>& pRefMap)
		{
			RefPtr<ShaderClosure> rs = new ShaderClosure();
			rs->Name = shader->SyntaxNode->Name.Content;
			rs->RefMap = pRefMap;
			rs->Pipeline = shader->Pipeline;
			rs->UsingPosition = usingPos;
			rs->Position = shader->SyntaxNode->Position;
			for (auto & mbr : shader->SyntaxNode->Members)
			{
				if (auto import = dynamic_cast<ImportSyntaxNode*>(mbr.Ptr()))
				{
					// create component for each argument
					Dictionary<String, RefPtr<ShaderComponentSymbol>> refMap;
					for (auto & arg : import->Arguments)
					{
						RefPtr<ShaderComponentSymbol> ccomp = new ShaderComponentSymbol();
						auto compName = L"arg" + String(rs->Components.Count()) + L"_" + 
							(import->ObjectName.Content.Length()==0?import->ShaderName.Content:import->ObjectName.Content) + arg->ArgumentName.Content;
						auto impl = new ShaderComponentImplSymbol();
						auto compSyntax = new ComponentSyntaxNode();
						compSyntax->Position = arg->Expression->Position;
						compSyntax->Name.Content = compName;
						CloneContext cloneCtx;
						compSyntax->Expression = arg->Expression->Clone(cloneCtx);
						compSyntax->Type = TypeSyntaxNode::FromExpressionType(arg->Expression->Type);
						compSyntax->Type->Position = compSyntax->Position;
						impl->SyntaxNode = compSyntax;
						ccomp->Name = compName;
						ccomp->Type = new Type();
						ccomp->Type->DataType = arg->Expression->Type;
						ccomp->Implementations.Add(impl);
						rs->Components[compName] = ccomp;
						refMap[arg->ArgumentName.Content] = ccomp;
					}
					RefPtr<ShaderSymbol> shaderSym;
					if (symTable->Shaders.TryGetValue(import->ShaderName.Content, shaderSym))
					{
						// fill in automatic arguments
						for (auto & param : shaderSym->Components)
						{
							if (param.Value->IsParam() && !refMap.ContainsKey(param.Key))
							{
								auto arg = rs->FindComponent(param.Key);
								if (arg && arg->Type->DataType == param.Value->Type->DataType)
								{
									refMap[param.Key] = arg;
								}
							}
						}
						auto refClosure = CreateShaderClosure(err, symTable, shaderSym.Ptr(), import->Position, refMap);
						refClosure->IsPublic = import->IsPublic;
						refClosure->Parent = rs.Ptr();
						if (import->IsInplace)
						{
							refClosure->IsInPlace = true;
							CheckComponentRedefinition(err, rs.Ptr(), refClosure.Ptr());
							rs->SubClosures[L"annonymousObj" + String(GUID::Next())] = refClosure;
						}
						else
						{
							rs->SubClosures[import->ObjectName.Content] = refClosure;
						}
					}
				}
				else if (auto compt = dynamic_cast<ComponentSyntaxNode*>(mbr.Ptr()))
				{
					RefPtr<ShaderComponentSymbol> comp;
					if (shader->Components.TryGetValue(compt->Name.Content, comp) &&
						!rs->Components.ContainsKey(compt->Name.Content))
					{
						RefPtr<ShaderComponentSymbol> ccomp = new ShaderComponentSymbol(*comp);
						rs->Components.Add(comp->Name, ccomp);
					}
				}
			}
			// check for unassigned arguments
			for (auto & comp : shader->Components)
			{
				if (comp.Value->Implementations.First()->SyntaxNode->IsParam &&
					!pRefMap.ContainsKey(comp.Key))
				{
					StringBuilder errMsg;
					errMsg << L"argument '" + comp.Key + L"' is unassigned.";
					// try to provide more info on why it is unassigned
					if (auto arg = rs->FindComponent(comp.Key, true))
						errMsg << L" automatic argument filling failed because the component of the same name is not accessible from '" << shader->SyntaxNode->Name.Content << L"'.";
					else
						errMsg << L" automatic argument filling failed because shader '" << shader->SyntaxNode->Name.Content << L"' does not define component '" + comp.Key + L"'.";
					err->Error(33023,errMsg.ProduceString(), rs->UsingPosition);
				}
			}
			return rs;
		}

		RefPtr<ShaderClosure> CreateShaderClosure(ErrorWriter * err, SymbolTable * symTable, ShaderSymbol * shader)
		{
			return CreateShaderClosure(err, symTable, shader, shader->SyntaxNode->Position, Dictionary<String, RefPtr<ShaderComponentSymbol>>());
		}


		class ResolveDependencyVisitor : public SyntaxVisitor
		{
		private:
			ShaderClosure * shaderClosure = nullptr;
			ShaderComponentSymbol * currentComponent = nullptr;
			void AddReference(ShaderComponentSymbol * referee, CodePosition pos)
			{
				referee->UserComponents.Add(currentComponent);
				currentComponent->DependentComponents.Add(referee);
				currentImpl->DependentComponents.Add(referee);
				currentImpl->ComponentReferencePositions[referee] = pos;
			}
		public:
			ShaderComponentImplSymbol * currentImpl = nullptr;
			ResolveDependencyVisitor(ErrorWriter * err, ShaderClosure * closure, ShaderComponentSymbol * comp)
				: SyntaxVisitor(err), shaderClosure(closure), currentComponent(comp)
			{}

			void VisitVarExpression(VarExpressionSyntaxNode * var) override
			{
				VariableEntry varEntry;
				if (!var->Scope->FindVariable(var->Variable, varEntry))
				{
					if (auto comp = shaderClosure->FindComponent(var->Variable))
					{
						if (comp->Implementations.First()->SyntaxNode->IsParam)
							shaderClosure->RefMap.TryGetValue(var->Variable, comp);
						var->Tags[L"ComponentReference"] = comp;
						AddReference(comp.Ptr(), var->Position);
					}
					else if (auto closure = shaderClosure->FindClosure(var->Variable))
					{
						var->Type.ShaderClosure = closure.Ptr();
					}
				}
			}

			void VisitMemberExpression(MemberExpressionSyntaxNode * member) override
			{
				member->BaseExpression->Accept(this);
				if (member->BaseExpression->Type.ShaderClosure)
				{
					if (auto comp = member->BaseExpression->Type.ShaderClosure->FindComponent(member->MemberName))
					{
						member->Tags[L"ComponentReference"] = comp;
						AddReference(comp.Ptr(), member->Position);
					}
					else if (auto shader = member->BaseExpression->Type.ShaderClosure->FindClosure(member->MemberName))
						member->Type.ShaderClosure = shader.Ptr();
				}
			}
		};

		void ResolveReference(ErrorWriter * err, ShaderClosure* shader)
		{
			for (auto & comp : shader->Components)
			{
				ResolveDependencyVisitor depVisitor(err, shader, comp.Value.Ptr());
				for (auto & impl : comp.Value->Implementations)
				{
					depVisitor.currentImpl = impl.Ptr();
					impl->SyntaxNode->Accept(&depVisitor);
				}
			}
			for (auto & subClosure : shader->SubClosures)
				ResolveReference(err, subClosure.Value.Ptr());
		}

		String GetUniqueCodeName(String name)
		{
			StringBuilder sb;
			for (auto ch : name)
			{
				if (ch == L'.')
					sb << L"I_I";
				else
					sb << ch;
			}
			return sb.ProduceString();
		}

		bool IsInAbstractWorld(PipelineSymbol * pipeline, ShaderComponentSymbol* comp)
		{
			return comp->Implementations.First()->Worlds.Count() &&
				pipeline->IsAbstractWorld(comp->Implementations.First()->Worlds.First());
		}

		void AssignUniqueNames(ShaderClosure * shader, String namePrefix, String publicNamePrefix)
		{
			for (auto & comp : shader->Components)
			{
				if (IsInAbstractWorld(shader->Pipeline, comp.Value.Ptr()))
				{
					comp.Value->UniqueName = comp.Value->Name;
				}
				else
				{
					String uniqueChoiceName;
					if (comp.Value->Implementations.First()->SyntaxNode->IsPublic)
						uniqueChoiceName = publicNamePrefix + comp.Key;
					else
						uniqueChoiceName = namePrefix + comp.Key;
					comp.Value->ChoiceNames.Add(uniqueChoiceName);
					comp.Value->UniqueKey = uniqueChoiceName;
					comp.Value->UniqueName = GetUniqueCodeName(uniqueChoiceName);
				}
			}
			for (auto & subClosure : shader->SubClosures)
			{
				if (subClosure.Value->IsInPlace)
					AssignUniqueNames(subClosure.Value.Ptr(), namePrefix + subClosure.Value->Name + L".", publicNamePrefix);
				else
					AssignUniqueNames(subClosure.Value.Ptr(), namePrefix + subClosure.Key + L".", publicNamePrefix + subClosure.Key + L".");
			}
		}

		bool IsConsistentGlobalComponentDefinition(ShaderComponentSymbol * comp0, ShaderComponentSymbol * comp1)
		{
			if (comp0->Type->DataType != comp1->Type->DataType)
				return false;
			if (comp0->Implementations.First()->Worlds.Count() != comp1->Implementations.First()->Worlds.Count())
				return false;
			for (auto w : comp0->Implementations.First()->Worlds)
				if (!comp1->Implementations.First()->Worlds.Contains(w))
					return false;
			return true;
		}

		void GatherComponents(ErrorWriter * err, ShaderClosure * closure, ShaderClosure * subClosure)
		{
			for (auto & comp : subClosure->Components)
			{
				ShaderComponentSymbol* existingComp = nullptr;
				if (closure->AllComponents.TryGetValue(comp.Value->UniqueName, existingComp))
				{
					if (IsInAbstractWorld(closure->Pipeline, comp.Value.Ptr()) &&
						IsInAbstractWorld(closure->Pipeline, existingComp))
					{
						// silently ignore consistently defined global components (components in abstract worlds)
						if (!IsConsistentGlobalComponentDefinition(comp.Value.Ptr(), existingComp))
						{
							err->Error(34025, L"'" + existingComp->Name + L"': global component conflicts with previous declaration.\nsee previous declaration at " + existingComp->Implementations.First()->SyntaxNode->Position.ToString(),
								comp.Value->Implementations.First()->SyntaxNode->Position);
						}
						else
						{
							for (auto & user : existingComp->UserComponents)
							{
								user->DependentComponents.Remove(existingComp);
								user->DependentComponents.Add(comp.Value.Ptr());
								for (auto & impl : user->Implementations)
									if (impl->DependentComponents.Contains(existingComp))
									{
										impl->DependentComponents.Remove(existingComp);
										impl->DependentComponents.Add(comp.Value.Ptr());
									}
							}
							err->Warning(34026, L"'" + existingComp->Name + L"': component is already defined when compiling shader '" + closure->Name + L"'. use 'require' to declare it as a parameter. \nsee previous declaration at " + existingComp->Implementations.First()->SyntaxNode->Position.ToString(),
								comp.Value->Implementations.First()->SyntaxNode->Position);
						}
					}
					else
					{
						StringBuilder errBuilder;
						errBuilder << L"component named '" << comp.Value->UniqueKey << L"\' is already defined when compiling '" << closure->Name << L"'.";
						auto currentClosure = subClosure;
						while (currentClosure != nullptr && currentClosure != closure)
						{
							errBuilder << L"\nsee inclusion of '" << currentClosure->Name << L"' at " << currentClosure->UsingPosition.ToString() << L".";
							currentClosure = currentClosure->Parent;
						}
						err->Error(34024, errBuilder.ProduceString(), comp.Value->Implementations.First()->SyntaxNode->Position);
					}
				}
				closure->AllComponents[comp.Value->UniqueName] = comp.Value.Ptr();
			}
			for (auto & sc : subClosure->SubClosures)
				GatherComponents(err, closure, sc.Value.Ptr());
		}

		bool IsWorldFeasible(PipelineSymbol * pipeline, ShaderComponentImplSymbol * impl, String world, ShaderComponentSymbol*& unaccessibleComp)
		{
			bool isWFeasible = true;
			for (auto & dcomp : impl->DependentComponents)
			{
				bool reachable = false;
				for (auto & dw : dcomp->Type->FeasibleWorlds)
				{
					if (pipeline->IsWorldReachable(dw, world))
					{
						reachable = true;
						break;
					}
				}
				if (!reachable)
				{
					unaccessibleComp = dcomp;
					isWFeasible = false;
					break;
				}
			}
			return isWFeasible;
		}

		void SolveWorldConstraints(ErrorWriter * err, ShaderClosure * shader)
		{
			EnumerableHashSet<String> allWorlds;
			for (auto w : shader->Pipeline->Worlds)
				if (!shader->Pipeline->IsAbstractWorld(w.Key))
					allWorlds.Add(w.Key);
			auto depOrder = shader->GetDependencyOrder();
			for (auto & comp : depOrder)
			{
				Dictionary<String, EnumerableHashSet<String>> autoWorlds;
				comp->Type->FeasibleWorlds.Clear();
				for (auto & impl : comp->Implementations)
				{
					if (!autoWorlds.ContainsKey(impl->AlternateName))
						autoWorlds[impl->AlternateName] = allWorlds;
					auto & autoWorld = autoWorlds[impl->AlternateName]();
					for (auto & w : impl->Worlds)
					{
						ShaderComponentSymbol* unaccessibleComp = nullptr;
						if (!IsWorldFeasible(shader->Pipeline, impl.Ptr(), w, unaccessibleComp))
						{
							err->Error(33100, L"'" + comp->Name + L"' cannot be computed at '" + w + L"' because the dependent component '" + unaccessibleComp->Name + L"' is not accessible.\nsee definition of '"
								+ unaccessibleComp->Name + L"' at " + unaccessibleComp->Implementations.First()->SyntaxNode->Position.ToString(),
								impl->ComponentReferencePositions[unaccessibleComp]());
						}
						autoWorld.Remove(w);
					}
				}
				for (auto & impl : comp->Implementations)
				{
					if (impl->Worlds.Count() == 0)
					{
						EnumerableHashSet<String> deducedWorlds = autoWorlds[impl->AlternateName]();
						EnumerableHashSet<String> feasibleWorlds;
						for (auto & w : deducedWorlds)
						{
							ShaderComponentSymbol* unaccessibleComp = nullptr;
							bool isWFeasible = IsWorldFeasible(shader->Pipeline, impl.Ptr(), w, unaccessibleComp);
							if (isWFeasible)
								feasibleWorlds.Add(w);
						}
						impl->Worlds = feasibleWorlds;
					}
					for (auto & w : impl->Worlds)
						comp->Type->FeasibleWorlds.Add(w);
				}
			}
			for (auto & comp : depOrder)
			{
				comp->Type->ConstrainedWorlds = comp->Type->FeasibleWorlds;
			}
			auto useInWorld = [&](String comp, String world)
			{
				// comp is used in world, restrict comp.ContainedWorlds to guarantee
				// all candidate definitions can reach world
				RefPtr<ShaderComponentSymbol> compSym;
				if (shader->Components.TryGetValue(comp, compSym))
				{
					EnumerableHashSet<String> newWorlds;
					for (auto & w : compSym->Type->ConstrainedWorlds)
						if (shader->Pipeline->IsWorldReachable(w, world))
							newWorlds.Add(w);
					compSym->Type->ConstrainedWorlds = _Move(newWorlds);
				}
			};
			for (auto impOp : shader->Pipeline->SyntaxNode->ImportOperators)
			{
				for (auto comp : impOp->Usings)
				{
					useInWorld(comp.Content, impOp->DestWorld.Content);
				}
			}
			for (auto & userWorld : shader->Pipeline->Worlds)
			{
				for (auto comp : userWorld.Value.SyntaxNode->Usings)
				{
					useInWorld(comp.Content, userWorld.Key);
				}
			}
		}

		bool CheckCircularReference(ErrorWriter * err, ShaderClosure * shader)
		{
			bool rs = false;
			for (auto & comp : shader->Components)
			{
				for (auto & impl : comp.Value->Implementations)
				{
					// check circular references
					HashSet<ShaderComponentSymbol*> set;
					List<ShaderComponentSymbol*> referredComponents;
					referredComponents.Add(comp.Value.Ptr());
					for (int i = 0; i < referredComponents.Count(); i++)
					{
						auto xcomp = referredComponents[i];
						for (auto & xcompImpl : xcomp->Implementations)
						{
							for (auto & rcomp : xcompImpl->DependentComponents)
							{
								if (set.Add(rcomp))
								{
									referredComponents.Add(rcomp);
								}
								if (rcomp == comp.Value.Ptr())
								{
									err->Error(32013, L"circular reference is not allowed.", impl->SyntaxNode->Position);
									rs = true;
								}
							}
						}
					}
				}
			}
			return rs;
		}

		void PropagateArgumentConstraints(ShaderComponentSymbol * requirement, ShaderComponentSymbol * arg)
		{
			for (auto w : requirement->Implementations.First()->ExportWorlds)
			{
				for (auto impl : arg->Implementations)
				{
					if (impl->Worlds.Contains(w))
						impl->ExportWorlds.Add(w);
				}
			}
			for (auto w : requirement->Implementations.First()->SrcPinnedWorlds)
			{
				for (auto impl : arg->Implementations)
				{
					if (impl->Worlds.Contains(w))
						impl->SrcPinnedWorlds.Add(w);
				}
			}
		}

		void VerifyAndPropagateArgumentConstraints(ErrorWriter * err, ShaderClosure * shader)
		{
			for (auto & map : shader->RefMap)
			{
				auto & arg = map.Value;
				RefPtr<ShaderComponentSymbol> requirement;
				if (shader->Components.TryGetValue(map.Key, requirement) && requirement->IsParam())
				{
					if (requirement->Implementations.First()->SyntaxNode->Rate)
					{
						for (auto w : requirement->Implementations.First()->Worlds)
						{
							if (!shader->Pipeline->IsWorldReachable(arg->Type->FeasibleWorlds, w))
							{
								err->Error(32015, L"argument '" + arg->Name + L"' is not available in world '" + w + L"' as required by '" + shader->Name
									+ L"'.\nsee requirement declaration at " +
									requirement->Implementations.First()->SyntaxNode->Position.ToString(), arg->Implementations.First()->SyntaxNode->Position);
							}
						}
						PropagateArgumentConstraints(requirement.Ptr(), arg.Ptr());
					}
				}
			}
			for (auto & subClosure : shader->SubClosures)
				VerifyAndPropagateArgumentConstraints(err, subClosure.Value.Ptr());
		}

		void FlattenShaderClosure(ErrorWriter * err, ShaderClosure * shader)
		{
			ResolveReference(err, shader);
			// assign choice names
			AssignUniqueNames(shader, L"", L"");
			// traverse closures to get component list
			GatherComponents(err, shader, shader);
			// propagate world constraints
			if (CheckCircularReference(err, shader))
				return;
			SolveWorldConstraints(err, shader);
			// check pipeline constraints
			for (auto & requirement : shader->Pipeline->Components)
			{
				auto comp = shader->FindComponent(requirement.Key);
				if (!comp)
				{
					err->Error(32014, L"shader '" + shader->Name + L"' does not provide '" + requirement.Key + L"' as required by '" + shader->Pipeline->SyntaxNode->Name.Content
						+ L"'.\nsee requirement declaration at " +
						requirement.Value->Implementations.First()->SyntaxNode->Position.ToString(), shader->Position);
				}
				else
				{
					for (auto & impl : requirement.Value->Implementations)
					{
						for (auto w : impl->Worlds)
						{
							if (!shader->Pipeline->IsWorldReachable(comp->Type->FeasibleWorlds, w))
							{
								err->Error(32015, L"component '" + comp->Name + L"' is not available in world '" + w + L"' as required by '" + shader->Pipeline->SyntaxNode->Name.Content
									+ L"'.\nsee requirement declaration at " +
									requirement.Value->Implementations.First()->SyntaxNode->Position.ToString(), comp->Implementations.First()->SyntaxNode->Position);
							}
						}
					}
					PropagateArgumentConstraints(requirement.Value.Ptr(), comp.Ptr());
				}
			}
			// check argument constraints
			VerifyAndPropagateArgumentConstraints(err, shader);
		}
	}
}

/***********************************************************************
CORE\CODEGENERATOR.CPP
***********************************************************************/
#include <assert.h>

namespace Spire
{
	namespace Compiler
	{
		RefPtr<ILType> TranslateExpressionType(const ExpressionType & type)
		{
			RefPtr<ILType> resultType = 0;
			if (type.BaseType == BaseType::Struct)
			{
				resultType = type.Struct->Type;
			}
			else
			{
				auto base = new ILBasicType();
				base->Type = (ILBaseType)type.BaseType;
				if (type.BaseType == BaseType::Bool)
				{
					base->Type = ILBaseType::Int;
				}
				resultType = base;
			}
			if (type.IsArray)
			{
				auto nArrType = new ILArrayType();
				nArrType->BaseType = resultType;
				nArrType->ArrayLength = type.ArrayLength;
				resultType = nArrType;
			}
			return resultType;
		}

		class CodeGenerator : public ICodeGenerator
		{
		private:
			SymbolTable * symTable;
			CompiledWorld * currentWorld = nullptr;
			ShaderComponentSymbol * currentComponent = nullptr;
			ShaderComponentImplSymbol * currentComponentImpl = nullptr;
			ShaderClosure * currentShader = nullptr;
			CompileResult & result;
			List<ILOperand*> exprStack;
			CodeWriter codeWriter;
			ScopeDictionary<String, ILOperand*> variables;
			
			void PushStack(ILOperand * op)
			{
				exprStack.Add(op);
			}
			ILOperand * PopStack()
			{
				auto rs = exprStack.Last();
				exprStack.SetSize(exprStack.Count() - 1);
				return rs;
			}
			AllocVarInstruction * AllocVar(const ExpressionType & etype)
			{
				AllocVarInstruction * varOp = 0;
				RefPtr<ILType> type = TranslateExpressionType(etype);
				auto arrType = dynamic_cast<ILArrayType*>(type.Ptr());

				if (arrType)
				{
					varOp = codeWriter.AllocVar(arrType->BaseType, result.Program->ConstantPool->CreateConstant(arrType->ArrayLength));
				}
				else
				{
					assert(type);
					varOp = codeWriter.AllocVar(type, result.Program->ConstantPool->CreateConstant(0));
				}
				return varOp;
			}
			FetchArgInstruction * FetchArg(const ExpressionType & etype, int argId)
			{
				auto type = TranslateExpressionType(etype);
				auto arrType = dynamic_cast<ILArrayType*>(type.Ptr());
				FetchArgInstruction * varOp = 0;
				if (arrType)
				{
					auto baseType = arrType->BaseType.Release();
					varOp = codeWriter.FetchArg(baseType, argId);
				}
				else
				{
					varOp = codeWriter.FetchArg(type, argId);
				}
				return varOp;
			}
			void SortInterfaceBlock(InterfaceBlock * block)
			{
				List<KeyValuePair<String, ComponentDefinition>> entries;
				for (auto & kv : block->Entries)
					entries.Add(kv);
				entries.Sort([](const auto & v0, const auto & v1) {return v0.Value.OrderingStr < v1.Value.OrderingStr; });
				block->Entries.Clear();
				for (auto & kv : entries)
					block->Entries.Add(kv.Key, kv.Value);
			}
		public:
			virtual void VisitProgram(ProgramSyntaxNode *) override
			{
			}
			virtual void VisitStruct(StructSyntaxNode * st) override
			{
				result.Program->Structs.Add(symTable->Structs[st->Name.Content]()->Type);
			}
			virtual void ProcessFunction(FunctionSyntaxNode * func) override
			{
				VisitFunction(func);
			}
			virtual void ProcessStruct(StructSyntaxNode * st) override
			{
				VisitStruct(st);
			}
			virtual void ProcessShader(ShaderClosure * shader) override
			{
				currentShader = shader;
				RefPtr<CompiledShader> compiledShader = new CompiledShader();
				compiledShader->MetaData.ShaderName = shader->Name;
				result.Program->Shaders.Add(compiledShader);
				for (auto & world : shader->Pipeline->Worlds)
				{
					auto w = new CompiledWorld();
					w->ExportOperator = world.Value.SyntaxNode->ExportOperator;
					auto outputBlock = new InterfaceBlock();
					outputBlock->Name = world.Key;
					for (auto & attrib : world.Value.SyntaxNode->LayoutAttributes)
						outputBlock->Attributes[attrib.Key] = attrib.Value;
					world.Value.SyntaxNode->LayoutAttributes.TryGetValue(L"InterfaceBlock", outputBlock->Name);
					if (outputBlock->Name.Contains(L":"))
					{
						CoreLib::Text::Parser parser(outputBlock->Name);
						auto blockName = parser.ReadWord();
						parser.Read(L":");
						auto indx = parser.ReadInt();
						outputBlock->Name = blockName;
						outputBlock->Attributes[L"Index"] = String(indx);
					}
					String strIdx;
					if (world.Value.SyntaxNode->LayoutAttributes.TryGetValue(L"InterfaceBlockIndex", strIdx))
						outputBlock->Attributes[L"Index"] = strIdx;
					if (world.Value.SyntaxNode->LayoutAttributes.ContainsKey(L"Packed"))
						outputBlock->Attributes[L"Packed"] = L"1";
					
					w->WorldOutput = outputBlock;
					compiledShader->InterfaceBlocks[outputBlock->Name] = outputBlock;
					w->Attributes = world.Value.SyntaxNode->LayoutAttributes;
					w->Shader = compiledShader.Ptr();
					w->ShaderName = shader->Name;
					w->WorldName = world.Key;
					w->IsAbstract = world.Value.IsAbstract;
					auto impOps = shader->Pipeline->GetImportOperatorsFromSourceWorld(world.Key);

					w->TargetMachine = world.Value.SyntaxNode->TargetMachine;
					CoreLib::Text::Parser parser(w->TargetMachine);
					try
					{
						if (!parser.IsEnd())
						{
							w->TargetMachine = parser.ReadWord();
							if (parser.LookAhead(L"("))
							{
								parser.Read(L"(");
								while (!parser.LookAhead(L")"))
								{
									auto param = parser.ReadWord();
									if (parser.LookAhead(L":"))
									{
										parser.Read(L":");
										auto value = parser.ReadWord();
										w->BackendParameters[param] = value;
									}
									else
										w->BackendParameters[param] = L"";
									if (parser.LookAhead(L";"))
									{
										parser.Read(L";");
									}
									else
										break;
								}
								parser.Read(L")");
							}
						}
					}
					catch (const CoreLib::Text::TextFormatException & ex)
					{
						result.GetErrorWriter()->Error(34031, L"invalid target machine syntax. \n" + ex.Message, world.Value.SyntaxNode->Position);
					}
					w->WorldDefPosition = world.Value.SyntaxNode->Position;
					compiledShader->Worlds[world.Key] = w;
				}

				Dictionary<String, List<ComponentDefinitionIR*>> worldComps;
				struct ThroughVar
				{
					bool Export = false;
					String InputName, OutputName;
					String InputWorldName;
					ImportOperatorDefSyntaxNode * ImportOperator;
					ComponentDefinitionIR * Component;
					int GetHashCode()
					{
						return PointerHash<1>().GetHashCode(Component);
					}
					bool operator == (const ThroughVar & other)
					{
						return Component == other.Component;
					}
				};
				Dictionary<String, EnumerableHashSet<ThroughVar>> worldThroughVars;
				for (auto & world : shader->Pipeline->Worlds)
				{
					List<ComponentDefinitionIR*> components;
					for (auto & compDef : shader->IR->Definitions)
						if (compDef->World == world.Key)
							components.Add(compDef.Ptr());

					auto & compiledWorld = compiledShader->Worlds[world.Key].GetValue();
					DependencySort(components, [](ComponentDefinitionIR * def)
					{
						return def->Dependency;
					});
					worldComps[world.Key] = components;
					worldThroughVars[world.Key] = EnumerableHashSet<ThroughVar>();

					if (world.Value.SyntaxNode->LayoutAttributes.ContainsKey(L"Pinned"))
					{
						for (auto & comp : components)
						{
							ComponentDefinition compDef;
							compDef.LayoutAttribs = comp->Implementation->SyntaxNode->LayoutAttributes;
							compDef.Name = comp->Component->UniqueName;
							compDef.Type = TranslateExpressionType(comp->Component->Type->DataType);
							compDef.OrderingStr = comp->Implementation->SyntaxNode->Position.FileName +
								String(comp->Implementation->SyntaxNode->Position.Line).PadLeft(L' ', 8) + compDef.Name;
							compiledWorld->WorldOutput->Entries.AddIfNotExists(compDef.Name, compDef);
						}
					}
				}
				for (auto & world : shader->Pipeline->Worlds)
				{
					auto compiledWorld = compiledShader->Worlds[world.Key].GetValue();
					for (auto & impOp : shader->Pipeline->SyntaxNode->ImportOperators)
					{
						if (impOp->DestWorld.Content == world.Key)
						{
							InputInterface input;
							input.Block = compiledShader->Worlds[impOp->SourceWorld.Content].GetValue()->WorldOutput;
							input.ImportOperator = *impOp;
							compiledWorld->WorldInputs[impOp->SourceWorld.Content] = input;
						}
					}
					auto & components = worldComps[world.Key].GetValue();
					
					for (auto & comp : components)
					{
						auto srcWorld = world.Key;
						EnumerableHashSet<String> outputWorlds;
						if (comp->Implementation->ExportWorlds.Contains(srcWorld))
							outputWorlds.Add(srcWorld);
						struct ImportTechnique
						{
							String SourceWorld;
							ImportOperatorDefSyntaxNode * ImportOperator;
						};
						EnumerableDictionary<String, ImportTechnique> inputSourceWorlds;
						auto useInWorld = [&](String userWorld)
						{
							if (userWorld == srcWorld)
								return;
							auto path = currentShader->Pipeline->FindImportOperatorChain(srcWorld, userWorld);
							if (path.Count() == 0)
								throw InvalidProgramException(L"no import exists, this should have been checked by semantics analyzer.");
							for (int i = 0; i < path[0].Nodes.Count(); i++)
							{
								auto & node = path[0].Nodes[i];
								if (node.TargetWorld != userWorld)
								{
									// should define output in node.TargetWorld
									outputWorlds.Add(node.TargetWorld);
								}
								if (node.TargetWorld != srcWorld)
								{
									// should define input in node.TargetWorld
									ImportTechnique tech;
									tech.SourceWorld = path[0].Nodes[i - 1].TargetWorld;
									tech.ImportOperator = path[0].Nodes[i].ImportOperator;
									inputSourceWorlds[node.TargetWorld] = tech;
								}
							}
						};
						for (auto user : comp->Users)
						{
							if (user->World != srcWorld)
							{
								useInWorld(user->World);
							}
						}

						ShaderComponentImplSymbol * compImpl = comp->Implementation;
						
						// define outputs in all involved worlds
						for (auto & outputWorld : outputWorlds)
						{
							auto & w = compiledShader->Worlds[outputWorld].GetValue();
							
							ComponentDefinition compDef;
							compDef.Name = comp->Component->UniqueName;
							compDef.OrderingStr = compImpl->SyntaxNode->Position.FileName +
								String(compImpl->SyntaxNode->Position.Line).PadLeft(L' ', 8) + compDef.Name;
							compDef.Type = TranslateExpressionType(comp->Component->Type->DataType);
							compDef.LayoutAttribs = compImpl->SyntaxNode->LayoutAttributes;
							w->WorldOutput->Entries.AddIfNotExists(compDef.Name, compDef);
							// if an input is also defined in this world (i.e. this is a through world), insert assignment
							ImportTechnique importTech;
							if (inputSourceWorlds.TryGetValue(outputWorld, importTech))
							{
								ThroughVar tvar;
								tvar.ImportOperator = importTech.ImportOperator;
								tvar.Export = true;
								tvar.InputName = comp->Component->UniqueName;
								tvar.Component = comp;
								tvar.OutputName = w->WorldOutput->Name + L"." + comp->Component->UniqueName;
								tvar.InputWorldName = importTech.SourceWorld;
								worldThroughVars[outputWorld].GetValue().Add(tvar);
							}
						}
						// define inputs
						for (auto & input : inputSourceWorlds)
						{
							ThroughVar tvar;
							tvar.ImportOperator = input.Value.ImportOperator;
							tvar.Export = false;
							tvar.InputName = comp->Component->UniqueName;
							tvar.Component = comp;
							tvar.InputWorldName = input.Value.SourceWorld;
							worldThroughVars[input.Key].GetValue().Add(tvar);
						}
					}
				}
				for (auto & world : shader->Pipeline->Worlds)
				{
					if (world.Value.IsAbstract)
						continue;
					NamingCounter = 0;

					auto & components = worldComps[world.Key].GetValue();
					auto compiledWorld = compiledShader->Worlds[world.Key].GetValue().Ptr();
					currentWorld = compiledWorld;
					codeWriter.PushNode();
					variables.PushScope();
					HashSet<String> localComponents;
					for (auto & comp : components)
						localComponents.Add(comp->Component->UniqueName);

					DependencySort(components, [](ComponentDefinitionIR * def)
					{
						return def->Dependency;
					});

					auto generateImportInstr = [&](ComponentDefinitionIR * comp, ComponentDefinitionIR * user)
					{
						ImportInstruction * instr = nullptr;
						if (!compiledWorld->ImportInstructions.TryGetValue(comp->Component->UniqueName, instr))
						{
							auto path = shader->Pipeline->FindImportOperatorChain(comp->World, world.Key);
							auto importOp = path[0].Nodes.Last().ImportOperator;
							auto sourceWorld = compiledShader->Worlds[path[0].Nodes[path[0].Nodes.Count() - 2].TargetWorld].GetValue().Ptr();
							instr = new ImportInstruction(importOp->Usings.Count(), comp->Component->UniqueName, importOp,
								sourceWorld, TranslateExpressionType(comp->Component->Type->DataType));
							for (int i = 0; i < importOp->Usings.Count(); i++)
							{
								// resolve import operator arguments
								ILOperand * val = nullptr;
								if (!variables.TryGetValue(importOp->Usings[i].Content, val))
								{
									ImportInstruction * impInstr = nullptr;
									compiledWorld->ImportInstructions.TryGetValue(importOp->Usings[i].Content, impInstr);
									val = impInstr;
								}
								String userCompName;
								if (user)
									userCompName = user->Component->Name;
								else
									userCompName = comp->Component->Name;
								if (!val)
									result.GetErrorWriter()->Error(50010, L"\'" + importOp->Usings[i].Content + L"\': implicit import operator argument is not accessible when attempting to import \'"
										+ comp->Component->Name + L"\' from world \'" + sourceWorld->WorldName + L"\' when compiling \'" + userCompName + L"\' for world \'" + compiledWorld->WorldName + L"\'.\nsee import operator declaration at " +
										importOp->Position.ToString() + L".", comp->Implementation->SyntaxNode->Position);
								else
									instr->Arguments[i] = val;
							}
							sourceWorld->WorldOutput->UserWorlds.Add(world.Key);
							instr->Name = L"_vout" + comp->Component->UniqueName;
							codeWriter.Insert(instr);
							compiledWorld->ImportInstructions[comp->Component->UniqueName] = instr;
							CompiledComponent ccomp;
							ccomp.CodeOperand = instr;
							ccomp.Attributes = comp->Implementation->SyntaxNode->LayoutAttributes;
							compiledWorld->LocalComponents[comp->Component->UniqueName] = ccomp;
						}
						return instr;
					};
					HashSet<String> thisWorldComponents;
					for (auto & comp : components)
					{
						thisWorldComponents.Add(comp->Component->UniqueName);
					}
					auto & throughVars = worldThroughVars[world.Key].GetValue();
					auto genInputVar = [&]()
					{
						for (auto & throughVar : throughVars)
						{
							bool shouldSkip = false;
							for (auto & depComp : throughVar.ImportOperator->Usings)
							{
								if (thisWorldComponents.Contains(depComp.Content))
								{
									shouldSkip = true;
									break;
								}
							}
							if (shouldSkip)
								continue;
							auto srcInstr = generateImportInstr(throughVar.Component, nullptr);
							if (throughVar.Export)
							{
								auto exp = new ExportInstruction(throughVar.Component->Component->UniqueName, compiledWorld->ExportOperator.Content, compiledWorld, srcInstr);
								codeWriter.Insert(exp);
								throughVars.Remove(throughVar);
							}
						}
					};
					genInputVar();
					for (auto & comp : components)
					{
						genInputVar();
						for (auto & dep : comp->Dependency)
						{
							if (dep->World != world.Key)
							{
								generateImportInstr(dep, comp);
							}
						}
						thisWorldComponents.Remove(comp->Component->UniqueName);
						VisitComponent(comp);
					}
					
					variables.PopScope();
					compiledWorld->Code = codeWriter.PopNode();
					EvalReferencedFunctionClosure(compiledWorld);
					currentWorld = nullptr;

					// fill in meta data
					WorldMetaData wdata;
					for (auto & comp : components)
						wdata.Components.Add(comp->Component->UniqueName);
					wdata.Name = compiledWorld->WorldName;
					wdata.TargetName = compiledWorld->TargetMachine;
					wdata.OutputBlock = compiledWorld->WorldOutput->Name;
					for (auto & inputBlock : compiledWorld->WorldInputs)
						wdata.InputBlocks.Add(inputBlock.Value.Block->Name);
					compiledWorld->Shader->MetaData.Worlds.Add(wdata.Name, wdata);
				}
				for (auto & block : compiledShader->InterfaceBlocks)
				{
					SortInterfaceBlock(block.Value.Ptr());
					InterfaceBlockMetaData blockMeta;
					blockMeta.Name = block.Value->Name;
					blockMeta.Attributes = block.Value->Attributes;
					int offset = 0;
					bool pack = block.Value->Attributes.ContainsKey(L"Packed");
					for (auto & entry : block.Value->Entries)
					{
						InterfaceBlockEntry ment;
						ment.Type = entry.Value.Type;
						ment.Name = entry.Key;
						ment.Attributes = entry.Value.LayoutAttribs;
						if (!pack)
							offset = RoundToAlignment(offset, ment.Type->GetAlignment());
						ment.Offset = offset;
						entry.Value.Offset = offset;
						ment.Size = ment.Type->GetSize();
						offset += ment.Size;
						blockMeta.Entries.Add(ment);
					}
					block.Value->Size = offset;
					if (!pack && block.Value->Entries.Count() > 0)
						block.Value->Size = RoundToAlignment(offset, (*(block.Value->Entries.begin())).Value.Type->GetAlignment());
					blockMeta.Size = block.Value->Size;
					compiledShader->MetaData.InterfaceBlocks[blockMeta.Name] = blockMeta;
				}
				currentShader = nullptr;
			}
			void EvalReferencedFunctionClosure(CompiledWorld * world)
			{
				List<String> workList;
				for (auto & rfunc : world->ReferencedFunctions)
					workList.Add(rfunc);
				for (int i = 0; i < workList.Count(); i++)
				{
					auto rfunc = workList[i];
					RefPtr<FunctionSymbol> funcSym;
					if (symTable->Functions.TryGetValue(rfunc, funcSym))
					{
						for (auto & rrfunc : funcSym->ReferencedFunctions)
						{
							world->ReferencedFunctions.Add(rrfunc);
							workList.Add(rrfunc);
						}
					}
				}
			}
			virtual void VisitComponent(ComponentSyntaxNode *) override
			{
				throw NotImplementedException();
			}
			void VisitComponent(ComponentDefinitionIR * comp)
			{
				currentComponent = comp->Component;
				currentComponentImpl = comp->Implementation;
				String varName = L"_vcmp" + currentComponent->UniqueName;

				RefPtr<ILType> type = TranslateExpressionType(currentComponent->Type->DataType);
				auto allocVar = codeWriter.AllocVar(type, result.Program->ConstantPool->CreateConstant(1));
				allocVar->Name = varName;
				variables.Add(currentComponent->UniqueName, allocVar);
				CompiledComponent ccomp;
				ccomp.CodeOperand = allocVar;
				ccomp.Attributes = comp->Implementation->SyntaxNode->LayoutAttributes;
				currentWorld->LocalComponents[currentComponent->UniqueName] = ccomp;
				if (currentComponentImpl->SyntaxNode->Expression)
				{
					currentComponentImpl->SyntaxNode->Expression->Accept(this);
					Assign(currentComponentImpl->SyntaxNode->Type->ToExpressionType(symTable, nullptr), allocVar, exprStack.Last());
					if (currentWorld->WorldOutput->Entries.ContainsKey(currentComponent->UniqueName))
					{
						auto exp = new ExportInstruction(currentComponent->UniqueName, currentWorld->ExportOperator.Content, currentWorld,
							allocVar);
						codeWriter.Insert(exp);
					}
					exprStack.Clear();
				}
				else if (currentComponentImpl->SyntaxNode->BlockStatement)
				{
					currentComponentImpl->SyntaxNode->BlockStatement->Accept(this);
				}
				currentComponentImpl = nullptr;
				currentComponent = nullptr;
			}
			virtual void VisitFunction(FunctionSyntaxNode* function) override
			{
				if (function->IsExtern)
					return;
				RefPtr<CompiledFunction> func = new CompiledFunction();
				result.Program->Functions.Add(func);
				func->Name = function->InternalName;
				func->ReturnType = TranslateExpressionType(function->ReturnType->ToExpressionType(symTable, nullptr));
				variables.PushScope();
				codeWriter.PushNode();
				int id = 0;
				for (auto &param : function->Parameters)
				{
					func->Parameters.Add(param->Name, TranslateExpressionType(param->Type->ToExpressionType(symTable, nullptr)));
					auto op = FetchArg(param->Type->ToExpressionType(symTable, nullptr), ++id);
					op->Name = String(L"p_") + param->Name;
					variables.Add(param->Name, op);
				}
				function->Body->Accept(this);
				func->Code = codeWriter.PopNode();
				variables.PopScope();
			}
			virtual void VisitBlockStatement(BlockStatementSyntaxNode* stmt) override
			{
				variables.PushScope();
				for (auto & subStmt : stmt->Statements)
					subStmt->Accept(this);
				variables.PopScope();
			}
			virtual void VisitEmptyStatement(EmptyStatementSyntaxNode*) override {}
			virtual void VisitWhileStatement(WhileStatementSyntaxNode* stmt) override
			{
				RefPtr<WhileInstruction> instr = new WhileInstruction();
				variables.PushScope();
				codeWriter.PushNode();
				stmt->Predicate->Accept(this);
				codeWriter.Insert(new ReturnInstruction(PopStack()));
				instr->ConditionCode = codeWriter.PopNode();
				codeWriter.PushNode();
				stmt->Statement->Accept(this);
				instr->BodyCode = codeWriter.PopNode();
				codeWriter.Insert(instr.Release());
				variables.PopScope();
			}
			virtual void VisitDoWhileStatement(DoWhileStatementSyntaxNode* stmt) override
			{
				RefPtr<DoInstruction> instr = new DoInstruction();
				variables.PushScope();
				codeWriter.PushNode();
				stmt->Predicate->Accept(this);
				codeWriter.Insert(new ReturnInstruction(PopStack()));
				instr->ConditionCode = codeWriter.PopNode();
				codeWriter.PushNode();
				stmt->Statement->Accept(this);
				instr->BodyCode = codeWriter.PopNode();
				codeWriter.Insert(instr.Release());
				variables.PopScope();
			}
			virtual void VisitForStatement(ForStatementSyntaxNode* stmt) override
			{
				RefPtr<ForInstruction> instr = new ForInstruction();
				variables.PushScope();
				if (stmt->TypeDef)
				{
					AllocVarInstruction * varOp = AllocVar(stmt->TypeDef->ToExpressionType(symTable));
					varOp->Name = L"v_" + String(NamingCounter++) + stmt->IterationVariable.Content;
					variables.Add(stmt->IterationVariable.Content, varOp);
				}
				ILOperand * iterVar = nullptr;
				if (!variables.TryGetValue(stmt->IterationVariable.Content, iterVar))
					throw InvalidProgramException(L"Iteration variable not found in variables dictionary. This should have been checked by semantics analyzer.");
				stmt->InitialExpression->Accept(this);
				Assign(stmt->TypeDef->ToExpressionType(symTable), iterVar, PopStack());

				codeWriter.PushNode();
				stmt->EndExpression->Accept(this);
				auto val = PopStack();
				codeWriter.Insert(new CmpleInstruction(codeWriter.Load(iterVar), val));
				instr->ConditionCode = codeWriter.PopNode();

				codeWriter.PushNode();
				ILOperand * stepVal = nullptr;
				if (stmt->StepExpression)
				{
					stmt->StepExpression->Accept(this);
					stepVal = PopStack();
				}
				else
				{
					if (iterVar->Type->IsFloat())
						stepVal = result.Program->ConstantPool->CreateConstant(1.0f);
					else
						stepVal = result.Program->ConstantPool->CreateConstant(1);
				}
				auto afterVal = new AddInstruction(codeWriter.Load(iterVar), stepVal);
				codeWriter.Insert(afterVal);
				Assign(stmt->TypeDef->ToExpressionType(symTable), iterVar, afterVal);
				instr->SideEffectCode = codeWriter.PopNode();

				codeWriter.PushNode();
				stmt->Statement->Accept(this);
				instr->BodyCode = codeWriter.PopNode();
				codeWriter.Insert(instr.Release());
				variables.PopScope();
			}
			virtual void VisitIfStatement(IfStatementSyntaxNode* stmt) override
			{
				RefPtr<IfInstruction> instr = new IfInstruction();
				variables.PushScope();
				stmt->Predicate->Accept(this);
				instr->Operand = PopStack();
				codeWriter.PushNode();
				stmt->PositiveStatement->Accept(this);
				instr->TrueCode = codeWriter.PopNode();
				if (stmt->NegativeStatement)
				{
					codeWriter.PushNode();
					stmt->NegativeStatement->Accept(this);
					instr->FalseCode = codeWriter.PopNode();
				}
				codeWriter.Insert(instr.Release());
				variables.PopScope();
			}
			virtual void VisitReturnStatement(ReturnStatementSyntaxNode* stmt) override
			{
				if (currentComponentImpl != nullptr)
				{
					if (stmt->Expression)
					{
						stmt->Expression->Accept(this);
						ILOperand *op = nullptr;
						variables.TryGetValue(currentComponent->UniqueName, op);
						auto val = PopStack();
						codeWriter.Store(op, val);
						if (currentWorld->WorldOutput->Entries.ContainsKey(currentComponent->UniqueName))
						{
							auto exp = new ExportInstruction(currentComponent->UniqueName, currentWorld->ExportOperator.Content, currentWorld, op);
							codeWriter.Insert(exp);
						}
					}
				}
				else
				{
					if (stmt->Expression)
						stmt->Expression->Accept(this);
					codeWriter.Insert(new ReturnInstruction(PopStack()));
				}
			}
			virtual void VisitBreakStatement(BreakStatementSyntaxNode*) override
			{
				codeWriter.Insert(new BreakInstruction());
			}
			virtual void VisitContinueStatement(ContinueStatementSyntaxNode*) override
			{
				codeWriter.Insert(new ContinueInstruction());
			}
			virtual void VisitSelectExpression(SelectExpressionSyntaxNode * expr) override
			{
				expr->SelectorExpr->Accept(this);
				auto predOp = PopStack();
				expr->Expr0->Accept(this);
				auto v0 = PopStack();
				expr->Expr1->Accept(this);
				auto v1 = PopStack();
				PushStack(codeWriter.Select(predOp, v0, v1));
			}
			ILOperand * EnsureBoolType(ILOperand * op, ExpressionType type)
			{
				if (type != ExpressionType::Bool)
				{
					auto cmpeq = new CmpneqInstruction();
					cmpeq->Operands[0] = op;
					cmpeq->Operands[1] = result.Program->ConstantPool->CreateConstant(0);
					cmpeq->Type = new ILBasicType(ILBaseType::Int);
					codeWriter.Insert(cmpeq);
					return cmpeq;
				}
				else
					return op;
			}
			
			virtual void VisitVarDeclrStatement(VarDeclrStatementSyntaxNode* stmt) override
			{
				for (auto & v : stmt->Variables)
				{
					AllocVarInstruction * varOp = AllocVar(stmt->Type->ToExpressionType(symTable));
					varOp->Name = L"v" + String(NamingCounter++) + L"_" + v->Name;
					variables.Add(v->Name, varOp);
					if (v->Expression)
					{
						v->Expression->Accept(this);
						Assign(stmt->Type->ToExpressionType(symTable), varOp, PopStack());
					}
				}
			}
			virtual void VisitExpressionStatement(ExpressionStatementSyntaxNode* stmt) override
			{
				stmt->Expression->Accept(this);
				PopStack();
			}
			void Assign(const ExpressionType & /*type*/, ILOperand * left, ILOperand * right)
			{
				if (auto add = dynamic_cast<AddInstruction*>(left))
				{
					auto baseOp = add->Operands[0].Ptr();
					codeWriter.Store(add->Operands[0].Ptr(), codeWriter.Update(codeWriter.Load(baseOp), add->Operands[1].Ptr(), right));
					add->Erase();
				}
				else
					codeWriter.Store(left, right);
			}
			virtual void VisitBinaryExpression(BinaryExpressionSyntaxNode* expr) override
			{
				expr->RightExpression->Accept(this);
				auto right = PopStack();
				if (expr->Operator == Operator::Assign)
				{
					expr->LeftExpression->Access = ExpressionAccess::Write;
					expr->LeftExpression->Accept(this);
					auto left = PopStack();
					Assign(expr->LeftExpression->Type, left, right);
					PushStack(left);
				}
				else
				{
					expr->LeftExpression->Access = ExpressionAccess::Read;
					expr->LeftExpression->Accept(this);
					auto left = PopStack();
					BinaryInstruction * rs = 0;
					switch (expr->Operator)
					{
					case Operator::Add:
					case Operator::AddAssign:
						rs = new AddInstruction();
						break;
					case Operator::Sub:
					case Operator::SubAssign:
						rs = new SubInstruction();
						break;
					case Operator::Mul:
					case Operator::MulAssign:
						rs = new MulInstruction();
						break;
					case Operator::Mod:
					case Operator::ModAssign:
						rs = new ModInstruction();
						break;
					case Operator::Div:
					case Operator::DivAssign:
						rs = new DivInstruction();
						break;
					case Operator::And:
						rs = new AndInstruction();
						break;
					case Operator::Or:
						rs = new OrInstruction();
						break;
					case Operator::BitAnd:
						rs = new BitAndInstruction();
						break;
					case Operator::BitOr:
						rs = new BitOrInstruction();
						break;
					case Operator::BitXor:
						rs = new BitXorInstruction();
						break;
					case Operator::Lsh:
						rs = new ShlInstruction();
						break;
					case Operator::Rsh:
						rs = new ShrInstruction();
						break;
					case Operator::Eql:
						rs = new CmpeqlInstruction();
						break;
					case Operator::Neq:
						rs = new CmpneqInstruction();
						break;
					case Operator::Greater:
						rs = new CmpgtInstruction();
						break;
					case Operator::Geq:
						rs = new CmpgeInstruction();
						break;
					case Operator::Leq:
						rs = new CmpleInstruction();
						break;
					case Operator::Less:
						rs = new CmpltInstruction();
						break;
					default:
						throw NotImplementedException(L"Code gen not implemented for this operator.");
					}
					rs->Operands.SetSize(2);
					rs->Operands[0] = left;
					rs->Operands[1] = right;
					rs->Type = TranslateExpressionType(expr->Type);
					codeWriter.Insert(rs);
					switch (expr->Operator)
					{
					case Operator::AddAssign:
					case Operator::SubAssign:
					case Operator::MulAssign:
					case Operator::DivAssign:
					case Operator::ModAssign:
					{
						expr->LeftExpression->Access = ExpressionAccess::Write;
						expr->LeftExpression->Accept(this);
						auto target = PopStack();
						Assign(expr->Type, target, rs);
						break;
					}
					default:
						break;
					}
					PushStack(rs);
				}
			}
			virtual void VisitConstantExpression(ConstantExpressionSyntaxNode* expr) override
			{
				ILConstOperand * op;
				if (expr->ConstType == ConstantExpressionSyntaxNode::ConstantType::Float)
				{
					op = result.Program->ConstantPool->CreateConstant(expr->FloatValue);
				}
				else
				{
					op = result.Program->ConstantPool->CreateConstant(expr->IntValue);
				}
				PushStack(op);
			}
			void GenerateIndexExpression(ILOperand * base, ILOperand * idx, bool read)
			{
				if (read)
				{
					auto ldInstr = codeWriter.Retrieve(base, idx);
					ldInstr->Attribute = base->Attribute;
					PushStack(ldInstr);
				}
				else
				{
					PushStack(codeWriter.Add(base, idx));
				}
			}
			virtual void VisitIndexExpression(IndexExpressionSyntaxNode* expr) override
			{
				expr->BaseExpression->Access = expr->Access;
				expr->BaseExpression->Accept(this);
				auto base = PopStack();
				expr->IndexExpression->Access = ExpressionAccess::Read;
				expr->IndexExpression->Accept(this);
				auto idx = PopStack();
				GenerateIndexExpression(base, idx,
					expr->Access == ExpressionAccess::Read);
			}
			virtual void VisitMemberExpression(MemberExpressionSyntaxNode * expr) override
			{
				RefPtr<Object> refObj;
				if (expr->Tags.TryGetValue(L"ComponentReference", refObj))
				{
					if (auto refComp = dynamic_cast<ShaderComponentSymbol*>(refObj.Ptr()))
					{
						ILOperand * op;
						if (variables.TryGetValue(refComp->UniqueName, op))
							PushStack(op);
						else
							PushStack(currentWorld->ImportInstructions[refComp->UniqueName]());
					}
				}
				else
				{
					expr->BaseExpression->Access = expr->Access;
					expr->BaseExpression->Accept(this);
					auto base = PopStack();
					auto generateSingleMember = [&](wchar_t memberName)
					{
						int idx = 0;
						if (memberName == L'y' || memberName == L'g')
							idx = 1;
						else if (memberName == L'z' || memberName == L'b')
							idx = 2;
						else if (memberName == L'w' || memberName == L'a')
							idx = 3;

						GenerateIndexExpression(base, result.Program->ConstantPool->CreateConstant(idx),
							expr->Access == ExpressionAccess::Read);
					};
					if (expr->BaseExpression->Type.IsVectorType())
					{
						if (expr->MemberName.Length() == 1)
						{
							generateSingleMember(expr->MemberName[0]);
						}
						else
						{
							if (expr->Access != ExpressionAccess::Read)
								throw InvalidOperationException(L"temporary vector (vec.xyz) is read-only.");
							String funcName = BaseTypeToString(expr->Type.BaseType);
							auto rs = AllocVar(expr->Type);
							ILOperand* tmp = codeWriter.Load(rs);
							for (int i = 0; i < expr->MemberName.Length(); i++)
							{
								generateSingleMember(expr->MemberName[i]);
								tmp = codeWriter.Update(tmp, result.Program->ConstantPool->CreateConstant(i), PopStack());
							}
							codeWriter.Store(rs, tmp);
							PushStack(codeWriter.Load(rs));
						}
					}
					else if (expr->BaseExpression->Type.BaseType == BaseType::Struct)
					{
						if (expr->Access == ExpressionAccess::Read)
						{
							int id = expr->BaseExpression->Type.Struct->SyntaxNode->FindField(expr->MemberName);
							GenerateIndexExpression(base, result.Program->ConstantPool->CreateConstant(id),
								expr->Access == ExpressionAccess::Read);
						}
						else
						{
						}
					}
					else
						throw NotImplementedException(L"member expression codegen");
				}
			}
			virtual void VisitInvokeExpression(InvokeExpressionSyntaxNode* expr) override
			{
				List<ILOperand*> args;
				if (currentWorld)
					currentWorld->ReferencedFunctions.Add(expr->FunctionExpr->Variable);
				for (auto arg : expr->Arguments)
				{
					arg->Accept(this);
					args.Add(PopStack());
				}
				auto instr = new CallInstruction(args.Count());
				instr->Function = expr->FunctionExpr->Variable;
				for (int i = 0; i < args.Count(); i++)
					instr->Arguments[i] = args[i];
				instr->Type = TranslateExpressionType(expr->Type);
				codeWriter.Insert(instr);
				PushStack(instr);
			}
			virtual void VisitTypeCastExpression(TypeCastExpressionSyntaxNode * expr) override
			{
				expr->Expression->Accept(this);
				auto base = PopStack();
				if (expr->Expression->Type == expr->Type)
				{
					PushStack(base);
				}
				else if (expr->Expression->Type == ExpressionType::Float &&
					expr->Type == ExpressionType::Int)
				{
					auto instr = new Float2IntInstruction(base);
					codeWriter.Insert(instr);
					PushStack(instr);
				}
				else if (expr->Expression->Type == ExpressionType::Int &&
					expr->Type == ExpressionType::Float)
				{
					auto instr = new Int2FloatInstruction(base);
					codeWriter.Insert(instr);
					PushStack(instr);
				}
				else
				{
					Error(40001, L"Invalid type cast: \"" + expr->Expression->Type.ToString() + L"\" to \"" +
						expr->Type.ToString() + L"\"", expr);
				}
			}
			virtual void VisitUnaryExpression(UnaryExpressionSyntaxNode* expr) override
			{
				if (expr->Operator == Operator::PostDec || expr->Operator == Operator::PostInc
					|| expr->Operator == Operator::PreDec || expr->Operator == Operator::PreInc)
				{
					expr->Expression->Access = ExpressionAccess::Read;
					expr->Expression->Accept(this);
					auto base = PopStack();
					BinaryInstruction * instr;
					if (expr->Operator == Operator::PostDec)
						instr = new SubInstruction();
					else
						instr = new AddInstruction();
					instr->Operands.SetSize(2);
					instr->Operands[0] = base;
					if (expr->Type == ExpressionType::Float)
						instr->Operands[1] = result.Program->ConstantPool->CreateConstant(1.0f);
					else
						instr->Operands[1] = result.Program->ConstantPool->CreateConstant(1);
					instr->Type = TranslateExpressionType(expr->Type);
					codeWriter.Insert(instr);

					expr->Expression->Access = ExpressionAccess::Write;
					expr->Expression->Accept(this);
					auto dest = PopStack();
					auto store = new StoreInstruction(dest, instr);
					codeWriter.Insert(store);
					PushStack(base);
				}
				else if (expr->Operator == Operator::PreDec || expr->Operator == Operator::PreInc)
				{
					expr->Expression->Access = ExpressionAccess::Read;
					expr->Expression->Accept(this);
					auto base = PopStack();
					BinaryInstruction * instr;
					if (expr->Operator == Operator::PostDec)
						instr = new SubInstruction();
					else
						instr = new AddInstruction();
					instr->Operands.SetSize(2);
					instr->Operands[0] = base;
					if (expr->Type == ExpressionType::Float)
						instr->Operands[1] = result.Program->ConstantPool->CreateConstant(1.0f);
					else
						instr->Operands[1] = result.Program->ConstantPool->CreateConstant(1);
					instr->Type = TranslateExpressionType(expr->Type);
					codeWriter.Insert(instr);

					expr->Expression->Access = ExpressionAccess::Write;
					expr->Expression->Accept(this);
					auto dest = PopStack();
					auto store = new StoreInstruction(dest, instr);
					codeWriter.Insert(store);
					PushStack(instr);
				}
				else
				{
					expr->Expression->Accept(this);
					auto base = PopStack();
					auto genUnaryInstr = [&](ILOperand * input)
					{
						UnaryInstruction * rs = 0;
						switch (expr->Operator)
						{
						case Operator::Not:
							input = EnsureBoolType(input, expr->Expression->Type);
							rs = new NotInstruction();
							break;
						case Operator::Neg:
							rs = new NegInstruction();
							break;
						case Operator::BitNot:
							rs = new BitNotInstruction();
							break;
						default:
							throw NotImplementedException(L"Code gen is not implemented for this operator.");
						}
						rs->Operand = input;
						rs->Type = input->Type;
						codeWriter.Insert(rs);
						return rs;
					};
					PushStack(genUnaryInstr(base));
				}
			}
			bool GenerateVarRef(String name, ExpressionType & type, ExpressionAccess access)
			{
				ILOperand * var = 0;
				String srcName = name;
				if (!variables.TryGetValue(srcName, var))
				{
					return false;
				}
				if (access == ExpressionAccess::Read)
				{
					auto instr = new LoadInstruction();
					instr->Name = L"local_" + name;
					instr->Operand = var;
					instr->Type = TranslateExpressionType(type);
					codeWriter.Insert(instr);
					instr->Attribute = var->Attribute;
					if (!Is<LeaInstruction>(var))
						throw L"error";
					PushStack(instr);
				}
				else
				{
					PushStack(var);
				}
				return true;
			}
			virtual void VisitVarExpression(VarExpressionSyntaxNode* expr) override
			{
				RefPtr<Object> refObj;
				if (expr->Tags.TryGetValue(L"ComponentReference", refObj))
				{
					if (auto refComp = dynamic_cast<ShaderComponentSymbol*>(refObj.Ptr()))
					{
						ILOperand * op;
						if (variables.TryGetValue(refComp->UniqueName, op))
							PushStack(op);
						else
							PushStack(currentWorld->ImportInstructions[refComp->UniqueName]());
					}
				}
				else if (!GenerateVarRef(expr->Variable, expr->Type, expr->Access))
				{
						throw InvalidProgramException(L"identifier is neither a variable nor a regnoized component.");
				}
			}
			virtual void VisitParameter(ParameterSyntaxNode*) override {}
			virtual void VisitType(TypeSyntaxNode*) override {}
			virtual void VisitDeclrVariable(Variable*) override {}
		private:
			CodeGenerator & operator = (const CodeGenerator & other) = delete;
		public:
			CodeGenerator(SymbolTable * symbols, ErrorWriter * pErr, CompileResult & _result)
				: ICodeGenerator(pErr), symTable(symbols), result(_result)
			{
				result.Program = new CompiledProgram();
				codeWriter.SetConstantPool(result.Program->ConstantPool.Ptr());
			}
		};

		ICodeGenerator * CreateCodeGenerator(SymbolTable * symbols, CompileResult & result)
		{
			return new CodeGenerator(symbols, result.GetErrorWriter(), result);
		}
	}
}

/***********************************************************************
CORE\COMPILEDPROGRAM.CPP
***********************************************************************/
namespace Spire
{
	namespace Compiler
	{
		void CompiledShaderSource::PrintAdditionalCode(StringBuilder & sb, String userCode)
		{
			auto lines = CoreLib::Text::Parser::SplitString(userCode, L'\n');
			for (auto & line : lines)
			{
				CoreLib::Text::Parser parser(line);
				while (!parser.IsEnd())
				{
					auto word = parser.ReadToken().Str;
					if (word == L"$")
					{
						auto compName = parser.ReadToken().Str;
						String accessName;
						if (ComponentAccessNames.TryGetValue(compName, accessName))
						{
							sb << accessName;
						}
						else
							throw InvalidOperationException(L"cannot resolve symbol \'" + compName + L"\'.");
					}
					else
					{
						sb << word;
						if (word != L"#")
							sb << L" ";
					}
				}
				sb << EndLine;
			}
		}
		String CompiledShaderSource::GetAllCodeGLSL(String additionalHeader, String additionalGlobalDeclaration, String preambleCode, String epilogCode)
		{
			StringBuilder sb;
			sb << GlobalHeader << EndLine;
			sb << additionalHeader << EndLine;
			for (auto & compAccess : ComponentAccessNames)
			{
				sb << L"//$" << compAccess.Key << L"$" << compAccess.Value << EndLine;
			}
			for (auto &input : InputDeclarations)
			{
				sb << L"//! input from " << input.Key << EndLine;
				sb << input.Value;
			}
			sb << EndLine << L"//! output declarations" << EndLine << OutputDeclarations;
			sb << EndLine << L"//! global declarations" << EndLine;
			sb << GlobalDefinitions << EndLine;
			sb << additionalGlobalDeclaration;
			sb << EndLine << L"//! end declarations";
			sb << EndLine << L"void main()\n{";
			sb << EndLine << L"//! local declarations" << EndLine;
			sb << LocalDeclarations; 
			sb << EndLine << L"//! main code" << EndLine;
			PrintAdditionalCode(sb, preambleCode);
			sb << EndLine << MainCode << EndLine;
			PrintAdditionalCode(sb, epilogCode);
			sb << EndLine << L"//! end code" << EndLine;
			sb << L"}\n";
			StringBuilder sbIndent;
			IndentString(sbIndent, sb.ProduceString());
			return sbIndent.ProduceString();
		}

		void CompiledShaderSource::ParseFromGLSL(String code)
		{
			List<String> lines = CoreLib::Text::Parser::SplitString(code, L'\n');
			List<String> chunks;
			List<String> headers;
			StringBuilder currentBuilder;
			for (auto & line : lines)
			{
				auto trimLine = line.TrimStart();
				if (trimLine.StartsWith(L"//!"))
				{
					chunks.Add(currentBuilder.ToString());
					headers.Add(trimLine);
					currentBuilder.Clear();
				}
				else if (trimLine.StartsWith(L"//$"))
				{
					auto words = CoreLib::Text::Parser::SplitString(trimLine.SubString(3, trimLine.Length() - 3), L'$');
					if (words.Count() == 2)
						ComponentAccessNames[words[0]] = words[1];
				}
				else if (trimLine.Length() > 0)
					currentBuilder << trimLine << L'\n';
			}
			chunks.Add(currentBuilder.ToString());
			if (chunks.Count() == headers.Count() + 1 && chunks.Count() != 0)
			{
				GlobalHeader = chunks[0];
				for (int i = 0; i < headers.Count(); i++)
				{
					auto & header = headers[i];
					auto & chunk = chunks[i + 1];
					if (header.StartsWith(L"//! input from "))
					{
						String world = header.SubString(15, header.Length() - 15);
						InputDeclarations[world] = chunk;
					}
					else if (header.StartsWith(L"//! output declarations"))
						OutputDeclarations = chunk;
					else if (header.StartsWith(L"//! global declarations"))
						GlobalDefinitions = chunk;
					else if (header.StartsWith(L"//! local declarations"))
						LocalDeclarations = chunk;
					else if (header.StartsWith(L"//! main code"))
						MainCode = chunk;
				}
			}
		}

		void IndentString(StringBuilder & sb, String src)
		{
			int indent = 0;
			bool beginTrim = true;
			for (int c = 0; c < src.Length(); c++)
			{
				auto ch = src[c];
				if (ch == L'\n')
				{
					sb << L"\n";

					beginTrim = true;
				}
				else
				{
					if (beginTrim)
					{
						while (c < src.Length() - 1 && (src[c] == L'\t' || src[c] == L'\n' || src[c] == L'\r' || src[c] == L' '))
						{
							c++;
							ch = src[c];
						}
						for (int i = 0; i < indent - 1; i++)
							sb << L'\t';
						if (ch != '}' && indent > 0)
							sb << L'\t';
						beginTrim = false;
					}

					if (ch == L'{')
						indent++;
					else if (ch == L'}')
						indent--;
					if (indent < 0)
						indent = 0;

					sb << ch;
				}
			}
		}
		ShaderChoiceValue ShaderChoiceValue::Parse(String str)
		{
			ShaderChoiceValue result;
			int idx = str.IndexOf(L':');
			if (idx == -1)
				return ShaderChoiceValue(str, L"");
			return ShaderChoiceValue(str.SubString(0, idx), str.SubString(idx + 1, str.Length() - idx - 1));
		}
	}
}

/***********************************************************************
CORE\CONSTANTPOOL.CPP
***********************************************************************/
#ifndef CONSTANT_POOL_H
#define CONSTANT_POOL_H


namespace Spire
{
	namespace Compiler
	{
		class ConstantPoolImpl
		{
		private:
			ILUndefinedOperand undefOperand;
			Dictionary<ConstKey<int>, ILConstOperand*> intConsts;
			Dictionary<ConstKey<float>, ILConstOperand*> floatConsts;
			List<RefPtr<ILConstOperand>> constants;
		public:
			ILUndefinedOperand * GetUndefinedOperand()
			{
				return &undefOperand;
			}
			ILOperand * CreateDefaultValue(ILType * type)
			{
				ILOperand * value = 0;
				if (type->IsFloat())
					value = CreateConstant(0.0f);
				else if (type->IsInt())
					value = CreateConstant(0);
				else if (auto baseType = dynamic_cast<ILBasicType*>(type))
				{
					if (baseType->Type == ILBaseType::Int2)
					{
						value = CreateConstant(0, 2);
					}
					else if (baseType->Type == ILBaseType::Int3)
					{
						value = CreateConstant(0, 3);
					}
					else if (baseType->Type == ILBaseType::Int4)
					{
						value = CreateConstant(0, 4);
					}
					else if (baseType->Type == ILBaseType::Float2)
					{
						value = CreateConstant(0.0f, 2);
					}
					else if (baseType->Type == ILBaseType::Float3)
					{
						value = CreateConstant(0.0f, 3);
					}
					else if (baseType->Type == ILBaseType::Float4)
					{
						value = CreateConstant(0.0f, 4);
					}
					else if (baseType->Type == ILBaseType::Float3x3)
					{
						value = CreateConstant(0.0f, 9);
					}
					else if (baseType->Type == ILBaseType::Float4x4)
					{
						value = CreateConstant(0.0f, 16);
					}
					else
						throw NotImplementedException(L"default value for this type is not implemented.");
				}
				else
					throw NotImplementedException(L"default value for this type is not implemented.");
				return value;
			}
			ILConstOperand * CreateConstantIntVec(int val, int val2)
			{
				ILConstOperand * rs = 0;
				auto key = ConstKey<int>::FromValues(val, val2);
				if (intConsts.TryGetValue(key, rs))
					return rs;
				rs = new ILConstOperand();
				rs->Type = new ILBasicType(ILBaseType::Int2);
				rs->IntValues[0] = val;
				rs->IntValues[1] = val2;
				intConsts[key] = rs;
				rs->Name = rs->ToString();
				constants.Add(rs);
				return rs;
			}

			ILConstOperand * CreateConstantIntVec(int val, int val2, int val3)
			{
				ILConstOperand * rs = 0;
				auto key = ConstKey<int>::FromValues(val, val2, val3);
				if (intConsts.TryGetValue(key, rs))
					return rs;
				rs = new ILConstOperand();
				rs->Type = new ILBasicType(ILBaseType::Int3);
				rs->IntValues[0] = val;
				rs->IntValues[1] = val2;
				rs->IntValues[2] = val3;

				intConsts[key] = rs;
				rs->Name = rs->ToString();
				constants.Add(rs);

				return rs;
			}
			ILConstOperand * CreateConstantIntVec(int val, int val2, int val3, int val4)
			{
				ILConstOperand * rs = 0;
				auto key = ConstKey<int>::FromValues(val, val2, val3, val4);
				if (intConsts.TryGetValue(key, rs))
					return rs;
				rs = new ILConstOperand();
				rs->Type = new ILBasicType(ILBaseType::Int4);
				rs->IntValues[0] = val;
				rs->IntValues[1] = val2;
				rs->IntValues[2] = val3;
				rs->IntValues[3] = val4;
				intConsts[key] = rs;
				rs->Name = rs->ToString();
				constants.Add(rs);

				return rs;
			}

			ILConstOperand * CreateConstant(ILConstOperand * c)
			{
				auto baseType = dynamic_cast<ILBasicType*>(c->Type.Ptr())->Type;
				switch (baseType)
				{
				case ILBaseType::Float:
					return CreateConstant(c->FloatValues[0]);
				case ILBaseType::Float2:
					return CreateConstant(c->FloatValues[0], c->FloatValues[1]);
				case ILBaseType::Float3:
					return CreateConstant(c->FloatValues[0], c->FloatValues[1], c->FloatValues[2]);
				case ILBaseType::Float4:
					return CreateConstant(c->FloatValues[0], c->FloatValues[1], c->FloatValues[2], c->FloatValues[3]);
				case ILBaseType::Int:
					return CreateConstant(c->IntValues[0]);
				case ILBaseType::Int2:
					return CreateConstantIntVec(c->IntValues[0], c->IntValues[1]);
				case ILBaseType::Int3:
					return CreateConstantIntVec(c->IntValues[0], c->IntValues[1], c->IntValues[2]);
				case ILBaseType::Int4:
					return CreateConstantIntVec(c->IntValues[0], c->IntValues[1], c->IntValues[2], c->IntValues[3]);
				default:
					if (constants.IndexOf(c) != -1)
						return c;
					else
					{
						auto rs = new ILConstOperand(*c);
						constants.Add(rs);
						return rs;
					}
				}
			}

			ILConstOperand * CreateConstant(int val, int size = 0)
			{
				ILConstOperand * rs = 0;
				if (intConsts.TryGetValue(ConstKey<int>(val, size), rs))
					return rs;
				rs = new ILConstOperand();
				ILBaseType baseType;
				switch (size)
				{
				case 0:
				case 1:
					baseType = ILBaseType::Int;
					break;
				case 2:
					baseType = ILBaseType::Int2;
					break;
				case 3:
					baseType = ILBaseType::Int3;
					break;
				case 4:
					baseType = ILBaseType::Int4;
					break;
				default:
					throw InvalidOperationException(L"Invalid vector size.");
				}
				rs->Type = new ILBasicType(baseType);
				rs->IntValues[0] = val;
				intConsts[ConstKey<int>(val, size)] = rs;
				rs->Name = rs->ToString();
				constants.Add(rs);

				return rs;
			}

			ILConstOperand * CreateConstant(float val, int size = 0)
			{
				ILConstOperand * rs = 0;
				if (floatConsts.TryGetValue(ConstKey<float>(val, size), rs))
					return rs;
				if (Math::IsNaN(val) || Math::IsInf(val))
				{
					throw InvalidOperationException(L"Attempting to create NAN constant.");
				}
				rs = new ILConstOperand();
				ILBaseType baseType;
				switch (size)
				{
				case 0:
				case 1:
					baseType = ILBaseType::Float;
					break;
				case 2:
					baseType = ILBaseType::Float2;
					break;
				case 3:
					baseType = ILBaseType::Float3;
					break;
				case 4:
					baseType = ILBaseType::Float4;
					break;
				case 9:
					baseType = ILBaseType::Float3x3;
					break;
				case 16:
					baseType = ILBaseType::Float4x4;
					break;
				default:
					throw InvalidOperationException(L"Invalid vector size.");
				}
				rs->Type = new ILBasicType(baseType);
				for (int i = 0; i < 16; i++)
					rs->FloatValues[i] = val;
				floatConsts[ConstKey<float>(val, size)] = rs;
				rs->Name = rs->ToString();
				constants.Add(rs);

				return rs;
			}

			ILConstOperand * CreateConstant(float val, float val2)
			{
				ILConstOperand * rs = 0;
				if (Math::IsNaN(val) || Math::IsInf(val) || Math::IsNaN(val2) || Math::IsInf(val2))
				{
					throw InvalidOperationException(L"Attempting to create NAN constant.");
				}
				auto key = ConstKey<float>::FromValues(val, val2);
				if (floatConsts.TryGetValue(key, rs))
					return rs;
				rs = new ILConstOperand();
				rs->Type = new ILBasicType(ILBaseType::Float2);
				rs->FloatValues[0] = val;
				rs->FloatValues[1] = val2;
				floatConsts[key] = rs;
				rs->Name = rs->ToString();
				constants.Add(rs);

				return rs;
			}

			ILConstOperand * CreateConstant(float val, float val2, float val3)
			{
				ILConstOperand * rs = 0;
				if (Math::IsNaN(val) || Math::IsInf(val) || Math::IsNaN(val2) || Math::IsInf(val2) || Math::IsNaN(val3) || Math::IsInf(val3))
				{
					throw InvalidOperationException(L"Attempting to create NAN constant.");
				}
				auto key = ConstKey<float>::FromValues(val, val2, val3);
				if (floatConsts.TryGetValue(key, rs))
					return rs;
				rs = new ILConstOperand();
				rs->Type = new ILBasicType(ILBaseType::Float3);
				rs->FloatValues[0] = val;
				rs->FloatValues[1] = val2;
				rs->FloatValues[2] = val3;

				floatConsts[key] = rs;
				rs->Name = rs->ToString();
				constants.Add(rs);

				return rs;
			}

			ILConstOperand * CreateConstant(float val, float val2, float val3, float val4)
			{
				if (Math::IsNaN(val) || Math::IsInf(val) || Math::IsNaN(val2) || Math::IsInf(val2) || Math::IsNaN(val3) || Math::IsInf(val3) || Math::IsNaN(val4) || Math::IsInf(val4))
				{
					throw InvalidOperationException(L"Attempting to create NAN constant.");
				}
				ILConstOperand * rs = 0;
				auto key = ConstKey<float>::FromValues(val, val2, val3, val4);
				if (floatConsts.TryGetValue(key, rs))
					return rs;
				rs = new ILConstOperand();
				rs->Type = new ILBasicType(ILBaseType::Float4);
				rs->FloatValues[0] = val;
				rs->FloatValues[1] = val2;
				rs->FloatValues[2] = val3;
				rs->FloatValues[3] = val4;

				floatConsts[key] = rs;
				rs->Name = rs->ToString();
				constants.Add(rs);

				return rs;
			}
		};

		ConstantPool::ConstantPool()
		{
			impl = new ConstantPoolImpl();
		}
		ConstantPool::~ConstantPool()
		{
			delete impl;
		}
		ILUndefinedOperand * ConstantPool::GetUndefinedOperand()
		{
			return impl->GetUndefinedOperand();
		}
		ILConstOperand * ConstantPool::CreateConstant(ILConstOperand * c)
		{
			return impl->CreateConstant(c);
		}
		ILConstOperand * ConstantPool::CreateConstantIntVec(int val0, int val1)
		{
			return impl->CreateConstantIntVec(val0, val1);

		}
		ILConstOperand * ConstantPool::CreateConstantIntVec(int val0, int val1, int val2)
		{
			return impl->CreateConstantIntVec(val0, val1, val2);
		}
		ILConstOperand * ConstantPool::CreateConstantIntVec(int val0, int val1, int val3, int val4)
		{
			return impl->CreateConstantIntVec(val0, val1, val3, val4);
		}
		ILConstOperand * ConstantPool::CreateConstant(int val, int vectorSize)
		{
			return impl->CreateConstant(val, vectorSize);
		}
		ILConstOperand * ConstantPool::CreateConstant(float val, int vectorSize)
		{
			return impl->CreateConstant(val, vectorSize);
		}
		ILConstOperand * ConstantPool::CreateConstant(float val, float val1)
		{
			return impl->CreateConstant(val, val1);
		}
		ILConstOperand * ConstantPool::CreateConstant(float val, float val1, float val2)
		{
			return impl->CreateConstant(val, val1, val2);
		}
		ILConstOperand * ConstantPool::CreateConstant(float val, float val1, float val2, float val3)
		{
			return impl->CreateConstant(val, val1, val2, val3);
		}
		ILOperand * ConstantPool::CreateDefaultValue(ILType * type)
		{
			return impl->CreateDefaultValue(type);
		}
	}
}

#endif

/***********************************************************************
CORE\GLSLCODEGEN.CPP
***********************************************************************/

using namespace CoreLib::Basic;

namespace Spire
{
	namespace Compiler
	{
		void PrintType(StringBuilder & sbCode, ILType* type)
		{
			sbCode << type->ToString();
		}

		void PrintDef(StringBuilder & sbCode, ILType* type, const String & name)
		{
			PrintType(sbCode, type);
			sbCode << L" ";
			sbCode << name;
		}

		class CodeGenContext
		{
		public:
			HashSet<String> GeneratedDefinitions;
			Dictionary<String, String> SubstituteNames;
			Dictionary<ILOperand*, String> VarName;
			Dictionary<String, ImportOperatorHandler *> ImportOperatorHandlers;
			Dictionary<String, ExportOperatorHandler *> ExportOperatorHandlers;

			CompileResult * Result = nullptr;
			HashSet<String> UsedVarNames;
			StringBuilder Body, Header, GlobalHeader;
			List<ILType*> Arguments;
			String ReturnVarName;
			String GenerateCodeName(String name, String prefix)
			{
				StringBuilder nameBuilder;
				int startPos = 0;
				if (name.StartsWith(L"_sys_"))
					startPos = name.IndexOf(L'_', 5) + 1;
				nameBuilder << prefix;
				for (int i = startPos; i < name.Length(); i++)
				{
					if ((name[i] >= L'a' && name[i] <= L'z') || 
						(name[i] >= L'A' && name[i] <= L'Z') ||
						name[i] == L'_' || 
						(name[i] >= L'0' && name[i] <= L'9'))
					{
						nameBuilder << name[i];
					}
					else
						nameBuilder << L'_';
				}
				auto rs = nameBuilder.ToString();
				int i = 0;
				while (UsedVarNames.Contains(rs))
				{
					i++;
					rs = nameBuilder.ToString() + String(i);
				}
				UsedVarNames.Add(rs);

				return rs;
			}


			String DefineVariable(ILOperand * op)
			{
				String rs;
				if (op->Name == L"Tex")
					printf("break");
				if (VarName.TryGetValue(op, rs))
				{
					return rs;
				}
				else
				{
					auto name = GenerateCodeName(op->Name, L"");
					PrintDef(Header, op->Type.Ptr(), name);
					if (op->Type->IsInt())
					{
						Header << L" = 0;";
					}
					Header << L";\n";
					VarName.Add(op, name);
					op->Name = name;
					return op->Name;
				}
			}
		};

		class GLSLShaderState : public Object
		{
		public:
		};

		class GLSLCodeGen : public CodeGenBackend
		{
		private:
			String vertexOutputName;
			bool useNVCommandList = false;
			bool bindlessTexture = false;
			CompiledWorld * currentWorld = nullptr;
		private:
			String GetFunctionCallName(String name)
			{
				StringBuilder rs;
				for (int i = 0; i < name.Length(); i++)
				{
					if ((name[i] >= L'a' && name[i] <= L'z') || (name[i] >= L'A' && name[i] <= L'Z') || 
						name[i] == L'_' || (name[i] >= L'0' && name[i] <= L'9'))
					{
						rs << name[i];
					}
					else if (i != name.Length() - 1)
						rs << L'_';
				}
				return rs.ProduceString();
			}

			String GetFuncOriginalName(const String & name)
			{
				String originalName;
				int splitPos = name.IndexOf(L'@');
				if (splitPos == 0)
					return name;
				if (splitPos != -1)
					originalName = name.SubString(0, splitPos);
				else
					originalName = name;
				return originalName;
			}

			void PrintOp(CodeGenContext & ctx, ILOperand * op, bool forceExpression = false)
			{
				auto makeFloat = [](float v)
				{
					String rs(v, L"%.12e");
					if (!rs.Contains(L'.') && !rs.Contains(L'e') && !rs.Contains(L'E'))
						rs = rs + L".0";
					if (rs.StartsWith(L"-"))
						rs = L"(" + rs + L")";
					return rs;
				};
				if (auto c = dynamic_cast<ILConstOperand*>(op))
				{
					auto type = c->Type.Ptr();
					if (type->IsFloat())
						ctx.Body << makeFloat(c->FloatValues[0]);
					else if (type->IsInt())
						ctx.Body << (c->IntValues[0]);
					else if (auto baseType = dynamic_cast<ILBasicType*>(type))
					{
						if (baseType->Type == ILBaseType::Float2)
							ctx.Body << L"vec2(" << makeFloat(c->FloatValues[0]) << L", " << makeFloat(c->FloatValues[1]) << L")";
						else if (baseType->Type == ILBaseType::Float3)
							ctx.Body << L"vec3(" << makeFloat(c->FloatValues[0]) << L", " << makeFloat(c->FloatValues[1]) << L", " << makeFloat(c->FloatValues[2]) << L")";
						else if (baseType->Type == ILBaseType::Float4)
							ctx.Body << L"vec4(" << makeFloat(c->FloatValues[0]) << L", " << makeFloat(c->FloatValues[1]) << L", " << makeFloat(c->FloatValues[2]) << L", " << makeFloat(c->FloatValues[3]) << L")";
						else if (baseType->Type == ILBaseType::Float3x3)
						{
							ctx.Body << L"mat3(";
							for (int i = 0; i < 9; i++)
							{
								ctx.Body << makeFloat(c->FloatValues[i]);
								if (i != 8)
									ctx.Body << L", ";
							}
							ctx.Body << L")";
						}
						else if (baseType->Type == ILBaseType::Float4x4)
						{
							ctx.Body << L"mat4(";
							for (int i = 0; i < 16; i++)
							{
								ctx.Body << makeFloat(c->FloatValues[i]);
								if (i != 15)
									ctx.Body << L", ";
							}
							ctx.Body << L")";
						}
						else if (baseType->Type == ILBaseType::Int2)
							ctx.Body << L"ivec2(" << c->IntValues[0] << L", " << c->IntValues[1] << L")";
						else if (baseType->Type == ILBaseType::Int3)
							ctx.Body << L"ivec3(" << c->IntValues[0] << L", " << c->IntValues[1] << L", " << c->IntValues[2] << L")";
						else if (baseType->Type == ILBaseType::Int4)
							ctx.Body << L"ivec4(" << c->IntValues[0] << L", " << c->IntValues[1] << L", " << c->IntValues[2] << L", " << c->IntValues[3] << L")";
					}
					else
						throw InvalidOperationException(L"Illegal constant.");
				}
				else if (auto instr = dynamic_cast<ILInstruction*>(op))
				{
					if (AppearAsExpression(*instr, forceExpression))
					{
						PrintInstrExpr(ctx, *instr);
					}
					else
					{
						if (forceExpression)
							throw InvalidProgramException(L"cannot generate code block as an expression.");
						String substituteName;
						if (ctx.SubstituteNames.TryGetValue(instr->Name, substituteName))
							ctx.Body << substituteName;
						else
							ctx.Body << instr->Name;
					}
				}
				else
					throw InvalidOperationException(L"Unsupported operand type.");
			}

			void PrintBinaryInstrExpr(CodeGenContext & ctx, BinaryInstruction * instr)
			{
				if (instr->Is<StoreInstruction>())
				{
					auto op0 = instr->Operands[0].Ptr();
					auto op1 = instr->Operands[1].Ptr();
					ctx.Body << L"(";
					PrintOp(ctx, op0);
					ctx.Body << L" = ";
					PrintOp(ctx, op1);
					ctx.Body << L")";
					return;
				}
				auto op0 = instr->Operands[0].Ptr();
				auto op1 = instr->Operands[1].Ptr();
				if (instr->Is<StoreInstruction>())
				{
					throw InvalidOperationException(L"store instruction cannot appear as expression.");
				}
				if (instr->Is<MemberLoadInstruction>())
				{
					PrintOp(ctx, op0);
					bool printDefault = true;
					if (op0->Type->IsVector())
					{
						if (auto c = dynamic_cast<ILConstOperand*>(op1))
						{
							switch (c->IntValues[0])
							{
							case 0:
								ctx.Body << L".x";
								break;
							case 1:
								ctx.Body << L".y";
								break;
							case 2:
								ctx.Body << L".z";
								break;
							case 3:
								ctx.Body << L".w";
								break;
							default:
								throw InvalidOperationException(L"Invalid member access.");
							}
							printDefault = false;
						}
					}
					else if (auto structType = dynamic_cast<ILStructType*>(op0->Type.Ptr()))
					{
						if (auto c = dynamic_cast<ILConstOperand*>(op1))
						{
							ctx.Body << L"." << structType->Members[c->IntValues[0]].FieldName;
						}
						printDefault = false;
					}
					if (printDefault)
					{
						ctx.Body << L"[";
						PrintOp(ctx, op1);
						ctx.Body << L"]";
					}
					return;
				}
				const wchar_t * op = L"";
				if (instr->Is<AddInstruction>())
				{
					op = L"+";
				}
				else if (instr->Is<SubInstruction>())
				{
					op = L"-";
				}
				else if (instr->Is<MulInstruction>())
				{
					op = L"*";
				}
				else if (instr->Is<DivInstruction>())
				{
					op = L"/";
				}
				else if (instr->Is<ModInstruction>())
				{
					op = L"%";
				}
				else if (instr->Is<ShlInstruction>())
				{
					op = L"<<";
				}
				else if (instr->Is<ShrInstruction>())
				{
					op = L">>";
				}
				else if (instr->Is<CmpeqlInstruction>())
				{
					op = L"==";
					ctx.Body << L"int";
				}
				else if (instr->Is<CmpgeInstruction>())
				{
					op = L">=";
					ctx.Body << L"int";
				}
				else if (instr->Is<CmpgtInstruction>())
				{
					op = L">";
					ctx.Body << L"int";
				}
				else if (instr->Is<CmpleInstruction>())
				{
					op = L"<=";
					ctx.Body << L"int";
				}
				else if (instr->Is<CmpltInstruction>())
				{
					op = L"<";
					ctx.Body << L"int";
				}
				else if (instr->Is<CmpneqInstruction>())
				{
					op = L"!=";
					ctx.Body << L"int";
				}
				else if (instr->Is<AndInstruction>())
				{
					op = L"&&";
				}
				else if (instr->Is<OrInstruction>())
				{
					op = L"||";
				}
				else if (instr->Is<BitXorInstruction>())
				{
					op = L"^";
				}
				else if (instr->Is<BitAndInstruction>())
				{
					op = L"&";
				}
				else if (instr->Is<BitOrInstruction>())
				{
					op = L"|";
				}
				else
					throw InvalidProgramException(L"unsupported binary instruction.");
				ctx.Body << L"(";
				PrintOp(ctx, op0);
				ctx.Body << L" " << op << L" ";
				PrintOp(ctx, op1);
				ctx.Body << L")";
			}

			void PrintBinaryInstr(CodeGenContext & ctx, BinaryInstruction * instr)
			{
				auto op0 = instr->Operands[0].Ptr();
				auto op1 = instr->Operands[1].Ptr();
				if (instr->Is<StoreInstruction>())
				{
					PrintOp(ctx, op0);
					ctx.Body << L" = ";
					PrintOp(ctx, op1);
					ctx.Body << L";\n";
					return;
				}
				auto varName = ctx.DefineVariable(instr);
				if (instr->Is<MemberLoadInstruction>())
				{
					ctx.Body << varName << L" = ";
					PrintBinaryInstrExpr(ctx, instr);
					ctx.Body << L";\n";
					return;
				}
				ctx.Body << varName << L" = ";
				PrintBinaryInstrExpr(ctx, instr);
				ctx.Body << L";\n";
			}

			void PrintUnaryInstrExpr(CodeGenContext & ctx, UnaryInstruction * instr)
			{
				auto op0 = instr->Operand.Ptr();
				if (instr->Is<LoadInstruction>())
				{
					PrintOp(ctx, op0);
					return;
				}
				const wchar_t * op = L"";
				if (instr->Is<BitNotInstruction>())
					op = L"~";
				else if (instr->Is<Float2IntInstruction>())
					op = L"(int)";
				else if (instr->Is<Int2FloatInstruction>())
					op = L"(float)";
				else if (instr->Is<CopyInstruction>())
					op = L"";
				else if (instr->Is<NegInstruction>())
					op = L"-";
				else if (instr->Is<NotInstruction>())
					op = L"!";
				else
					throw InvalidProgramException(L"unsupported unary instruction.");
				ctx.Body << L"(" << op;
				PrintOp(ctx, op0);
				ctx.Body << L")";
			}

			void PrintUnaryInstr(CodeGenContext & ctx, UnaryInstruction * instr)
			{
				auto varName = ctx.DefineVariable(instr);
				ctx.Body << varName << L" = ";
				PrintUnaryInstrExpr(ctx, instr);
				ctx.Body << L";\n";
			}

			void PrintGleaInstrExpr(CodeGenContext & ctx, GLeaInstruction * instr)
			{
				RefPtr<CompiledGlobalVar> gvar;
				ctx.Body << instr->VariableName;
			}

			void PrintGleaInstr(CodeGenContext & /*ctx*/, GLeaInstruction * /*instr*/)
			{

			}

			void PrintAllocVarInstrExpr(CodeGenContext & ctx, AllocVarInstruction * instr)
			{
				ctx.Body << instr->Name;
			}

			void PrintAllocVarInstr(CodeGenContext & ctx, AllocVarInstruction * instr)
			{
				if (dynamic_cast<ILConstOperand*>(instr->Size.Ptr()))
				{
					PrintDef(ctx.Header, instr->Type.Ptr(), instr->Name);
					ctx.Header << L";\n";
				}
				else
					throw InvalidProgramException(L"size operand of allocVar instr is not an intermediate.");
			}

			void PrintFetchArgInstrExpr(CodeGenContext & ctx, FetchArgInstruction * instr)
			{
				ctx.Body << instr->Name;
			}

			void PrintFetchArgInstr(CodeGenContext & ctx, FetchArgInstruction * instr)
			{
				if (instr->ArgId == 0)
				{
					ctx.ReturnVarName = ctx.DefineVariable(instr);
				}
			}

			void PrintSelectInstrExpr(CodeGenContext & ctx, SelectInstruction * instr)
			{
				ctx.Body << L"(";
				PrintOp(ctx, instr->Operands[0].Ptr());
				ctx.Body << L"?";
				PrintOp(ctx, instr->Operands[1].Ptr());
				ctx.Body << L":";
				PrintOp(ctx, instr->Operands[2].Ptr());
				ctx.Body << L")";
			}

			void PrintSelectInstr(CodeGenContext & ctx, SelectInstruction * instr)
			{
				auto varName = ctx.DefineVariable(instr);
				ctx.Body << varName << L" = ";
				PrintSelectInstrExpr(ctx, instr);
				ctx.Body << L";\n";
			}

			void PrintCallInstrExpr(CodeGenContext & ctx, CallInstruction * instr)
			{
				String callName;
				callName = GetFuncOriginalName(instr->Function);
				ctx.Body << callName;
				ctx.Body << L"(";
				int id = 0;
				for (auto & arg : instr->Arguments)
				{
					PrintOp(ctx, arg.Ptr());
					if (id != instr->Arguments.Count() - 1)
						ctx.Body << L", ";
					id++;
				}
				ctx.Body << L")";
			}

			void PrintCallInstr(CodeGenContext & ctx, CallInstruction * instr)
			{
				auto varName = ctx.DefineVariable(instr);
				ctx.Body << varName;
				ctx.Body << L" = ";
				PrintCallInstrExpr(ctx, instr);
				ctx.Body << L";\n";
			}

			void PrintCastF2IInstrExpr(CodeGenContext & ctx, Float2IntInstruction * instr)
			{
				ctx.Body << L"((int)(";
				PrintOp(ctx, instr->Operand.Ptr());
				ctx.Body << L"))";
			}
			void PrintCastF2IInstr(CodeGenContext & ctx, Float2IntInstruction * instr)
			{
				auto varName = ctx.DefineVariable(instr);
				ctx.Body << varName;
				ctx.Body << L" = ";
				PrintCastF2IInstrExpr(ctx, instr);
				ctx.Body << L";\n";
			}
			void PrintCastI2FInstrExpr(CodeGenContext & ctx, Int2FloatInstruction * instr)
			{
				ctx.Body << L"((float)(";
				PrintOp(ctx, instr->Operand.Ptr());
				ctx.Body << L"))";
			}
			void PrintCastI2FInstr(CodeGenContext & ctx, Int2FloatInstruction * instr)
			{
				auto varName = ctx.DefineVariable(instr);
				ctx.Body << varName;
				ctx.Body << L" = ";
				PrintCastI2FInstrExpr(ctx, instr);
				ctx.Body << L";\n";
			}

			bool AppearAsExpression(ILInstruction & instr, bool force)
			{
				if (auto arg = instr.As<FetchArgInstruction>())
				{
					if (arg->ArgId == 0)
						return false;
				}
				for (auto &&usr : instr.Users)
				{
					if (auto update = dynamic_cast<MemberUpdateInstruction*>(usr))
					{
						if (&instr == update->Operands[0].Ptr())
							return false;
					}
					else if (dynamic_cast<ImportInstruction*>(usr))
						return false;
				}
				if (instr.Is<StoreInstruction>() && force)
					return true;
				return (instr.Users.Count() <= 1 && !instr.HasSideEffect() && !instr.Is<MemberUpdateInstruction>()
					&& !instr.Is<AllocVarInstruction>() && !instr.Is<ImportInstruction>())
					|| instr.Is<GLeaInstruction>() || instr.Is<FetchArgInstruction>() ;
			}

			void PrintImportInstr(CodeGenContext &ctx, ImportInstruction * import)
			{
				ImportOperatorHandler * handler = nullptr;
				if (ctx.ImportOperatorHandlers.TryGetValue(import->ImportOperator->Name.Content, handler))
				{
					handler->GenerateInterfaceLocalDefinition(ctx.Body, import, ImportOperatorContext(
						import->ImportOperator->Arguments, backendArguments, currentWorld, *ctx.Result,
						import->SourceWorld));
				}
			}

			void PrintExportInstr(CodeGenContext &ctx, ExportInstruction * exportInstr)
			{
				ExportOperatorHandler * handler = nullptr;
				if (ctx.ExportOperatorHandlers.TryGetValue(exportInstr->ExportOperator, handler))
				{
					handler->GenerateExport(ctx.Body, currentWorld->WorldOutput, currentWorld, exportInstr->ComponentName, exportInstr->Operand->Name);
				}
			}

			void PrintUpdateInstr(CodeGenContext & ctx, MemberUpdateInstruction * instr)
			{
				auto genCode = [&](String varName, ILType * srcType, ILOperand * op1, ILOperand * op2)
				{
					ctx.Body << varName;
					if (auto structType = dynamic_cast<ILStructType*>(srcType))
					{
						ctx.Body << L".";
						ctx.Body << structType->Members[dynamic_cast<ILConstOperand*>(op1)->IntValues[0]].FieldName;
					}
					else
					{
						ctx.Body << L"[";
						PrintOp(ctx, op1);
						ctx.Body << L"]";
					}
					ctx.Body << L" = ";
					PrintOp(ctx, op2);
					ctx.Body << L";\n";
				};
				if (auto srcInstr = dynamic_cast<ILInstruction*>(instr->Operands[0].Ptr()))
				{
					if (srcInstr->Users.Count() == 1)
					{
						auto srcName = srcInstr->Name;
						while (ctx.SubstituteNames.TryGetValue(srcName, srcName));
						genCode(srcName, srcInstr->Type.Ptr(), instr->Operands[1].Ptr(), instr->Operands[2].Ptr());
						ctx.SubstituteNames[instr->Name] = srcName;
						return;
					}
				}
				auto varName = ctx.DefineVariable(instr);
				ctx.Body << varName << L" = ";
				PrintOp(ctx, instr->Operands[0].Ptr());
				ctx.Body << L";\n";
				genCode(varName, instr->Operands[0]->Type.Ptr(), instr->Operands[1].Ptr(), instr->Operands[2].Ptr());
			}

			void PrintInstrExpr(CodeGenContext & ctx, ILInstruction & instr)
			{
				if (auto binInstr = instr.As<BinaryInstruction>())
					PrintBinaryInstrExpr(ctx, binInstr);
				else if (auto unaryInstr = instr.As<UnaryInstruction>())
					PrintUnaryInstrExpr(ctx, unaryInstr);
				else if (auto gleaInstr = instr.As<GLeaInstruction>())
					PrintGleaInstrExpr(ctx, gleaInstr);
				else if (auto allocVar = instr.As<AllocVarInstruction>())
					PrintAllocVarInstrExpr(ctx, allocVar);
				else if (auto fetchArg = instr.As<FetchArgInstruction>())
					PrintFetchArgInstrExpr(ctx, fetchArg);
				else if (auto select = instr.As<SelectInstruction>())
					PrintSelectInstrExpr(ctx, select);
				else if (auto call = instr.As<CallInstruction>())
					PrintCallInstrExpr(ctx, call);
				else if (auto castf2i = instr.As<Float2IntInstruction>())
					PrintCastF2IInstrExpr(ctx, castf2i);
				else if (auto casti2f = instr.As<Int2FloatInstruction>())
					PrintCastI2FInstrExpr(ctx, casti2f);
				else if (instr.As<MemberUpdateInstruction>())
					throw InvalidOperationException(L"member update instruction cannot appear as expression.");
			}

			void PrintInstr(CodeGenContext & ctx, ILInstruction & instr)
			{
				// ctx.Body << L"// " << instr.ToString() << L";\n";
				if (!AppearAsExpression(instr, false))
				{
					if (auto binInstr = instr.As<BinaryInstruction>())
						PrintBinaryInstr(ctx, binInstr);
					else if (auto exportInstr = instr.As<ExportInstruction>())
						PrintExportInstr(ctx, exportInstr);
					else if (auto unaryInstr = instr.As<UnaryInstruction>())
						PrintUnaryInstr(ctx, unaryInstr);
					else if (auto gleaInstr = instr.As<GLeaInstruction>())
						PrintGleaInstr(ctx, gleaInstr);
					else if (auto allocVar = instr.As<AllocVarInstruction>())
						PrintAllocVarInstr(ctx, allocVar);
					else if (auto fetchArg = instr.As<FetchArgInstruction>())
						PrintFetchArgInstr(ctx, fetchArg);
					else if (auto select = instr.As<SelectInstruction>())
						PrintSelectInstr(ctx, select);
					else if (auto call = instr.As<CallInstruction>())
						PrintCallInstr(ctx, call);
					else if (auto castf2i = instr.As<Float2IntInstruction>())
						PrintCastF2IInstr(ctx, castf2i);
					else if (auto casti2f = instr.As<Int2FloatInstruction>())
						PrintCastI2FInstr(ctx, casti2f);
					else if (auto update = instr.As<MemberUpdateInstruction>())
						PrintUpdateInstr(ctx, update);
					else if (auto import = instr.As<ImportInstruction>())
						PrintImportInstr(ctx, import);
				}
			}

			void GenerateCode(CodeGenContext & context, CFGNode * code)
			{
				for (auto & instr : *code)
				{
					if (auto ifInstr = instr.As<IfInstruction>())
					{
						context.Body << L"if (bool(";
						PrintOp(context, ifInstr->Operand.Ptr(), true);
						context.Body << L"))\n{\n";
						GenerateCode(context, ifInstr->TrueCode.Ptr());
						context.Body << L"}\n";
						if (ifInstr->FalseCode)
						{
							context.Body << L"else\n{\n";
							GenerateCode(context, ifInstr->FalseCode.Ptr());
							context.Body << L"}\n";
						}
					}
					else if (auto forInstr = instr.As<ForInstruction>())
					{
						context.Body << L"for (;bool(";
						PrintOp(context, forInstr->ConditionCode->GetLastInstruction(), true);
						context.Body << L"); ";
						PrintOp(context, forInstr->SideEffectCode->GetLastInstruction(), true);
						context.Body << L")\n{\n";
						GenerateCode(context, forInstr->BodyCode.Ptr());
						context.Body << L"}\n";
					}
					else if (auto doInstr = instr.As<DoInstruction>())
					{
						context.Body << L"do\n{\n";
						GenerateCode(context, doInstr->BodyCode.Ptr());
						context.Body << L"} while (bool(";
						PrintOp(context, doInstr->ConditionCode->GetLastInstruction()->As<ReturnInstruction>()->Operand.Ptr(), true);
						context.Body << L"));\n";
					}
					else if (auto whileInstr = instr.As<WhileInstruction>())
					{
						context.Body << L"while (bool(";
						PrintOp(context, whileInstr->ConditionCode->GetLastInstruction()->As<ReturnInstruction>()->Operand.Ptr(), true);
						context.Body << L"))\n{\n";
						GenerateCode(context, whileInstr->BodyCode.Ptr());
						context.Body << L"}\n";
					}
					else if (auto ret = instr.As<ReturnInstruction>())
					{
						context.Body << L"return ";
						PrintOp(context, ret->Operand.Ptr());
						context.Body << L";\n";
					}
					else if (instr.Is<BreakInstruction>())
					{
						context.Body << L"break;\n";
					}
					else if (instr.Is<ContinueInstruction>())
					{
						context.Body << L"continue;\n";
					}
					else
						PrintInstr(context, instr);
				}
			}
		public:
			virtual CompiledShaderSource GenerateShaderWorld(CompileResult & result, SymbolTable *, CompiledWorld * shaderWorld,
				Dictionary<String, ImportOperatorHandler *> & opHandlers,
				Dictionary<String, ExportOperatorHandler *> & exportHandlers) override
			{
				CompiledShaderSource rs;
				CodeGenContext context;
				context.Result = &result;
				context.GlobalHeader << L"#version 450\n";
				if (bindlessTexture)
					context.GlobalHeader << L"#extension GL_ARB_bindless_texture: require\n#extension GL_NV_gpu_shader5 : require\n";
				if (useNVCommandList)
					context.GlobalHeader << L"#extension GL_NV_command_list: require\n";
				context.ImportOperatorHandlers = opHandlers;
				context.ExportOperatorHandlers = exportHandlers;
				StringBuilder prologBuilder, epilogBuilder;
				for (auto & inputBlock : shaderWorld->WorldInputs)
				{
					if (!inputBlock.Value.Block->UserWorlds.Contains(shaderWorld->WorldName))
						continue;
					String impOpName = inputBlock.Value.ImportOperator.Name.Content;
					ImportOperatorHandler * handler = nullptr;
					if (!opHandlers.TryGetValue(impOpName, handler))
						result.GetErrorWriter()->Error(40003, L"import operator handler for '" + impOpName
							+ L"' is not registered.", inputBlock.Value.ImportOperator.Position);
					else
					{
						StringBuilder inputDefSB;
						ImportOperatorContext opCtx(inputBlock.Value.ImportOperator.Arguments, backendArguments, shaderWorld, result,
							shaderWorld->Shader->Worlds[inputBlock.Value.ImportOperator.SourceWorld.Content].GetValue().Ptr());
						handler->GenerateInterfaceDefinition(inputDefSB, inputBlock.Value.Block, opCtx);
						handler->GeneratePreamble(prologBuilder, inputBlock.Value.Block, opCtx);
						handler->GenerateEpilogue(epilogBuilder, inputBlock.Value.Block, opCtx);
						rs.InputDeclarations[inputBlock.Key] = inputDefSB.ProduceString();
					}
				}
				ExportOperatorHandler * expHandler = nullptr;
				if (!exportHandlers.TryGetValue(shaderWorld->ExportOperator.Content, expHandler))
				{
					result.GetErrorWriter()->Error(40004, L"export operator handler for '" + shaderWorld->ExportOperator.Content
						+ L"' is not registered.", shaderWorld->ExportOperator.Position);
				}
				else
				{
					StringBuilder outputDefSB;
					expHandler->GenerateInterfaceDefinition(outputDefSB, shaderWorld->WorldOutput);
					expHandler->GeneratePreamble(prologBuilder, shaderWorld->WorldOutput);
					expHandler->GenerateEpilogue(epilogBuilder, shaderWorld->WorldOutput);
					rs.OutputDeclarations = outputDefSB.ProduceString();
				}
				currentWorld = shaderWorld;
				NamingCounter = 0;
				shaderWorld->Code->NameAllInstructions();
				GenerateCode(context, shaderWorld->Code.Ptr());
				
				for (auto & st : result.Program->Structs)
				{
					context.GlobalHeader << L"struct " << st->TypeName << L"\n{\n";
					for (auto & f : st->Members)
					{
						context.GlobalHeader << f.Type->ToString();
						context.GlobalHeader << " " << f.FieldName << L";\n";
					}
					context.GlobalHeader << L"};\n";
				}
				
				rs.GlobalHeader = context.GlobalHeader.ProduceString();

				StringBuilder funcSB;
				for (auto funcName : shaderWorld->ReferencedFunctions)
				{
					for (auto &func : result.Program->Functions)
					{
						if (func->Name == funcName)
						{
							GenerateFunctionDeclaration(funcSB, func.Ptr());
							funcSB << L";\n";
						}
					}
				}
				for (auto funcName : shaderWorld->ReferencedFunctions)
				{
					for (auto &func : result.Program->Functions)
					{
						if (func->Name == funcName)
						{
							funcSB << GenerateFunction(func.Ptr());
						}
					}
				}
				rs.GlobalDefinitions = funcSB.ProduceString();
				rs.LocalDeclarations = prologBuilder.ProduceString() + context.Header.ProduceString();

				if (vertexOutputName.Length())
				{
					CompiledComponent ccomp;
					if (currentWorld->LocalComponents.TryGetValue(vertexOutputName, ccomp))
					{
						epilogBuilder << L"gl_Position = " << ccomp.CodeOperand->Name << L";\n";
					}
					else
					{
						result.GetErrorWriter()->Error(40005, L"cannot resolve '" + vertexOutputName
							+ L"' when generating code for world '" + currentWorld->WorldName + L"\'.", currentWorld->WorldDefPosition);
					}
				}

				for (auto & localComp : currentWorld->LocalComponents)
				{
					CodeGenContext nctx;
					PrintOp(nctx, localComp.Value.CodeOperand);
					rs.ComponentAccessNames[localComp.Key] = nctx.Body.ProduceString();
				}
				rs.MainCode = context.Body.ProduceString() + epilogBuilder.ProduceString();

				currentWorld = nullptr;
				return rs;
			}
			void GenerateFunctionDeclaration(StringBuilder & sbCode, CompiledFunction * function)
			{
				auto retType = function->ReturnType.Ptr();
				if (retType)
					PrintType(sbCode, retType);
				else
					sbCode << L"void";
				sbCode << L" " << GetFuncOriginalName(function->Name) << L"(";
				int id = 0;
				for (auto & instr : *function->Code)
				{
					if (auto arg = instr.As<FetchArgInstruction>())
					{
						if (arg->ArgId != 0)
						{
							if (id > 0)
							{
								sbCode << L", ";
							}
							PrintDef(sbCode, arg->Type.Ptr(), arg->Name);
							id++;
						}
					}
				}
				sbCode << L")";
			}
			String GenerateFunction(CompiledFunction * function)
			{
				StringBuilder sbCode;
				CodeGenContext ctx;
				ctx.UsedVarNames.Clear();
				ctx.Body.Clear();
				ctx.Header.Clear();
				ctx.Arguments.Clear();
				ctx.ReturnVarName = L"";
				ctx.VarName.Clear();
				
				function->Code->NameAllInstructions();
				GenerateFunctionDeclaration(sbCode, function);
				sbCode << L"\n{\n";
				GenerateCode(ctx, function->Code.Ptr());
				sbCode << ctx.Header.ToString() << ctx.Body.ToString();
				if (ctx.ReturnVarName.Length())
					sbCode << L"return " << ctx.ReturnVarName << L";\n";
				sbCode << L"}\n";
				return sbCode.ProduceString();
			}
			EnumerableDictionary<String, String> backendArguments;
			virtual void SetParameters(const EnumerableDictionary<String, String> & args) override
			{
				backendArguments = args;
				if (!args.TryGetValue(L"vertex", vertexOutputName))
					vertexOutputName = L"";
				useNVCommandList = args.ContainsKey(L"command_list");
				bindlessTexture = args.ContainsKey(L"bindless_texture");
			}
		};

		CodeGenBackend * CreateGLSLCodeGen()
		{
			return new GLSLCodeGen();
		}
	}
}

/***********************************************************************
CORE\IL.CPP
***********************************************************************/

namespace Spire
{
	namespace Compiler
	{
		using namespace CoreLib::IO;

		RefPtr<ILType> BaseTypeFromString(CoreLib::Text::Parser & parser)
		{
			if (parser.LookAhead(L"int"))
				return new ILBasicType(ILBaseType::Int);
			else if (parser.LookAhead(L"uint"))
				return new ILBasicType(ILBaseType::UInt);
			if (parser.LookAhead(L"float"))
				return new ILBasicType(ILBaseType::Float);
			if (parser.LookAhead(L"vec2"))
				return new ILBasicType(ILBaseType::Float2);
			if (parser.LookAhead(L"vec3"))
				return new ILBasicType(ILBaseType::Float3);
			if (parser.LookAhead(L"vec4"))
				return new ILBasicType(ILBaseType::Float4);
			if (parser.LookAhead(L"ivec2"))
				return new ILBasicType(ILBaseType::Int2);
			if (parser.LookAhead(L"mat3"))
				return new ILBasicType(ILBaseType::Float3x3);
			if (parser.LookAhead(L"mat4"))
				return new ILBasicType(ILBaseType::Float4x4);
			if (parser.LookAhead(L"ivec3"))
				return new ILBasicType(ILBaseType::Int3);
			if (parser.LookAhead(L"ivec4"))
				return new ILBasicType(ILBaseType::Int4);
			if (parser.LookAhead(L"sampler2D"))
				return new ILBasicType(ILBaseType::Texture2D);
			if (parser.LookAhead(L"sampler2DShadow"))
				return new ILBasicType(ILBaseType::TextureShadow);
			if (parser.LookAhead(L"samplerCube"))
				return new ILBasicType(ILBaseType::TextureCube);
			if (parser.LookAhead(L"samplerCubeShadow"))
				return new ILBasicType(ILBaseType::TextureCubeShadow);
			return nullptr;
		}

		RefPtr<ILType> TypeFromString(CoreLib::Text::Parser & parser)
		{
			auto result = BaseTypeFromString(parser);
			parser.ReadToken();
			while (parser.LookAhead(L"["))
			{
				parser.ReadToken();
				RefPtr<ILArrayType> newResult = new ILArrayType();
				newResult->BaseType = result;
				if (!parser.LookAhead(L"]"))
					newResult->ArrayLength = parser.ReadInt();
				result = newResult;
				parser.Read(L"]");
			}
			return result;
		}

		int RoundToAlignment(int offset, int alignment)
		{
			int remainder = offset % alignment;
			if (remainder == 0)
				return offset;
			else
				return offset + (alignment - remainder);
		}

		int SizeofBaseType(ILBaseType type)
		{
			if (type == ILBaseType::Int)
				return 4;
			if (type == ILBaseType::UInt)
				return 4;
			else if (type == ILBaseType::Int2)
				return 8;
			else if (type == ILBaseType::Int3)
				return 12;
			else if (type == ILBaseType::Int4)
				return 16;
			else if (type == ILBaseType::Float)
				return 4;
			else if (type == ILBaseType::Float2)
				return 8;
			else if (type == ILBaseType::Float3)
				return 12;
			else if (type == ILBaseType::Float4)
				return 16;
			else if (type == ILBaseType::Float3x3)
				return 48;
			else if (type == ILBaseType::Float4x4)
				return 64;
			else if (type == ILBaseType::Texture2D)
				return 8;
			else if (type == ILBaseType::TextureCube)
				return 8;
			else if (type == ILBaseType::TextureCubeShadow)
				return 8;
			else if (type == ILBaseType::TextureShadow)
				return 8;
			else
				return 0;
		}
		bool ILType::IsInt()
		{
			auto basicType = dynamic_cast<ILBasicType*>(this);
			if (basicType)
				return basicType->Type == ILBaseType::Int;
			else
				return false;
		}

		bool ILType::IsIntegral()
		{
			auto basicType = dynamic_cast<ILBasicType*>(this);
			if (basicType)
				return basicType->Type == ILBaseType::Int || basicType->Type == ILBaseType::Int2 || basicType->Type == ILBaseType::Int3 || basicType->Type == ILBaseType::Int4 || basicType->Type == ILBaseType::UInt;
			else
				return false;
		}

		bool ILType::IsFloat()
		{
			auto basicType = dynamic_cast<ILBasicType*>(this);
			if (basicType)
				return basicType->Type == ILBaseType::Float;
			else
				return false;
		}

		bool ILType::IsIntVector()
		{
			auto basicType = dynamic_cast<ILBasicType*>(this);
			if (basicType)
				return basicType->Type == ILBaseType::Int2 || basicType->Type == ILBaseType::Int3 || basicType->Type == ILBaseType::Int4;
			else
				return false;
		}

		bool ILType::IsFloatVector()
		{
			auto basicType = dynamic_cast<ILBasicType*>(this);
			if (basicType)
				return basicType->Type == ILBaseType::Float2 || basicType->Type == ILBaseType::Float3 || basicType->Type == ILBaseType::Float4 ||
					basicType->Type == ILBaseType::Float3x3 || basicType->Type == ILBaseType::Float4x4;
			else
				return false;
		}

		bool ILType::IsFloatMatrix()
		{
			auto basicType = dynamic_cast<ILBasicType*>(this);
			if (basicType)
				return basicType->Type == ILBaseType::Float3x3 || basicType->Type == ILBaseType::Float4x4;
			else
				return false;
		}

		bool ILType::IsNonShadowTexture()
		{
			auto basicType = dynamic_cast<ILBasicType*>(this);
			if (basicType)
				return basicType->Type == ILBaseType::Texture2D || basicType->Type == ILBaseType::TextureCube;
			else
				return false;
		}

		bool ILType::IsTexture()
		{
			auto basicType = dynamic_cast<ILBasicType*>(this);
			if (basicType)
				return basicType->Type == ILBaseType::Texture2D || basicType->Type == ILBaseType::TextureCube || basicType->Type == ILBaseType::TextureCubeShadow ||
				basicType->Type == ILBaseType::TextureShadow;
			else
				return false;
		}

		int ILType::GetVectorSize()
		{
			if (auto basicType = dynamic_cast<ILBasicType*>(this))
			{
				switch (basicType->Type)
				{
				case ILBaseType::Int2:
				case ILBaseType::Float2:
					return 2;
				case ILBaseType::Int3:
				case ILBaseType::Float3:
					return 3;
				case ILBaseType::Int4:
				case ILBaseType::Float4:
					return 4;
				case ILBaseType::Float3x3:
					return 9;
				case ILBaseType::Float4x4:
					return 16;
				default:
					return 1;
				}
			}
			return 1;
		}

		bool CFGNode::HasPhiInstruction()
		{
			return headInstr && headInstr->GetNext() && headInstr->GetNext()->Is<PhiInstruction>();
		}

		ILInstruction * CFGNode::GetFirstNonPhiInstruction()
		{
			for (auto & instr : *this)
			{
				if (!instr.Is<PhiInstruction>())
					return &instr;
			}
			return tailInstr;
		}

		int NamingCounter = 0;

		void CFGNode::NameAllInstructions()
		{
			// name all operands
			StringBuilder numBuilder;
			for (auto & instr : GetAllInstructions())
			{
				numBuilder.Clear();
				for (auto & c : instr.Name)
				{
					if (c >= L'0' && c <= '9')
						numBuilder.Append(c);
					else
						numBuilder.Clear();
				}
				auto num = numBuilder.ToString();
				if (num.Length())
				{
					int id = StringToInt(num);
					NamingCounter = Math::Max(NamingCounter, id + 1);
				}
			}
			for (auto & instr : GetAllInstructions())
			{
				if (instr.Name.Length() == 0)
					instr.Name = String(L"t") + String(NamingCounter++, 16);
			}
		}

		void CFGNode::DebugPrint()
		{
			printf("===========\n");
			for (auto& instr : *this)
			{
				printf("%s\n", instr.ToString().ToMultiByteString());
			}
			printf("===========\n");
		}

		LoadInstruction::LoadInstruction(ILOperand * dest)
		{
			Deterministic = false;
			Operand = dest;
			Type = dest->Type->Clone();
			if (!Spire::Compiler::Is<AllocVarInstruction>(dest) && !Spire::Compiler::Is<GLeaInstruction>(dest) && !Spire::Compiler::Is<FetchArgInstruction>(dest))
				throw L"invalid address operand";
		}
		void MemberUpdateInstruction::Accept(InstructionVisitor * visitor)
		{
			visitor->VisitMemberUpdateInstruction(this);
		}
		void SubInstruction::Accept(InstructionVisitor * visitor)
		{
			visitor->VisitSubInstruction(this);
		}
		void MulInstruction::Accept(InstructionVisitor * visitor)
		{
			visitor->VisitMulInstruction(this);
		}
		void DivInstruction::Accept(InstructionVisitor * visitor)
		{
			visitor->VisitDivInstruction(this);
		}
		void ModInstruction::Accept(InstructionVisitor * visitor)
		{
			visitor->VisitModInstruction(this);
		}
		void AndInstruction::Accept(InstructionVisitor * visitor)
		{
			visitor->VisitAndInstruction(this);
		}
		void OrInstruction::Accept(InstructionVisitor * visitor)
		{
			visitor->VisitOrInstruction(this);
		}
		void BitAndInstruction::Accept(InstructionVisitor * visitor)
		{
			visitor->VisitBitAndInstruction(this);
		}
		void BitOrInstruction::Accept(InstructionVisitor * visitor)
		{
			visitor->VisitBitOrInstruction(this);
		}
		void BitXorInstruction::Accept(InstructionVisitor * visitor)
		{
			visitor->VisitBitXorInstruction(this);
		}
		void ShlInstruction::Accept(InstructionVisitor * visitor)
		{
			visitor->VisitShlInstruction(this);
		}
		void ShrInstruction::Accept(InstructionVisitor * visitor)
		{
			visitor->VisitShrInstruction(this);
		}
		void CmpgtInstruction::Accept(InstructionVisitor * visitor)
		{
			visitor->VisitCmpgtInstruction(this);
		}
		void CmpgeInstruction::Accept(InstructionVisitor * visitor)
		{
			visitor->VisitCmpgeInstruction(this);
		}
		void CmpltInstruction::Accept(InstructionVisitor * visitor)
		{
			visitor->VisitCmpltInstruction(this);
		}
		void CmpleInstruction::Accept(InstructionVisitor * visitor)
		{
			visitor->VisitCmpleInstruction(this);
		}
		void CmpeqlInstruction::Accept(InstructionVisitor * visitor)
		{
			visitor->VisitCmpeqlInstruction(this);
		}
		void CmpneqInstruction::Accept(InstructionVisitor * visitor)
		{
			visitor->VisitCmpneqInstruction(this);
		}
		void Float2IntInstruction::Accept(InstructionVisitor * visitor)
		{
			visitor->VisitFloat2IntInstruction(this);
		}
		void Int2FloatInstruction::Accept(InstructionVisitor * visitor)
		{
			visitor->VisitInt2FloatInstruction(this);
		}
		void CopyInstruction::Accept(InstructionVisitor * visitor)
		{
			visitor->VisitCopyInstruction(this);
		}
		void LoadInstruction::Accept(InstructionVisitor * visitor)
		{
			visitor->VisitLoadInstruction(this);
		}
		void StoreInstruction::Accept(InstructionVisitor * visitor)
		{
			visitor->VisitStoreInstruction(this);
		}
		void GLeaInstruction::Accept(InstructionVisitor * visitor)
		{
			visitor->VisitGLeaInstruction(this);
		}
		void AllocVarInstruction::Accept(InstructionVisitor * visitor)
		{
			visitor->VisitAllocVarInstruction(this);
		}
		void FetchArgInstruction::Accept(InstructionVisitor * visitor)
		{
			visitor->VisitFetchArgInstruction(this);
		}
		void PhiInstruction::Accept(InstructionVisitor * visitor)
		{
			visitor->VisitPhiInstruction(this);
		}
		void SelectInstruction::Accept(InstructionVisitor * visitor)
		{
			visitor->VisitSelectInstruction(this);
		}
		void CallInstruction::Accept(InstructionVisitor * visitor)
		{
			visitor->VisitCallInstruction(this);
		}
		void SwitchInstruction::Accept(InstructionVisitor * visitor)
		{
			visitor->VisitSwitchInstruction(this);
		}
		void NotInstruction::Accept(InstructionVisitor * visitor)
		{
			visitor->VisitNotInstruction(this);
		}
		void NegInstruction::Accept(InstructionVisitor * visitor)
		{
			visitor->VisitNegInstruction(this);
		}
		void BitNotInstruction::Accept(InstructionVisitor * visitor)
		{
			visitor->VisitBitNotInstruction(this);
		}
		void AddInstruction::Accept(InstructionVisitor * visitor)
		{
			visitor->VisitAddInstruction(this);
		}
		void MemberLoadInstruction::Accept(InstructionVisitor * visitor)
		{
			visitor->VisitMemberLoadInstruction(this);
		}
		AllInstructionsIterator & AllInstructionsIterator::operator++()
		{
			bool done = false;
			do
			{
				done = true;
				if (subBlockPtr < curInstr->GetSubBlockCount())
				{
					StackItem item;
					item.instr = curInstr;
					item.subBlockPtr = subBlockPtr + 1;
					stack.Add(item);
					curInstr = curInstr->GetSubBlock(subBlockPtr)->begin().Current;
					subBlockPtr = 0;
				}
				else
					curInstr = curInstr->GetNext();
				while (curInstr->GetNext() == nullptr && stack.Count() > 0)
				{
					auto item = stack.Last();
					stack.RemoveAt(stack.Count() - 1);
					curInstr = item.instr;
					subBlockPtr = item.subBlockPtr;
					if (subBlockPtr >= curInstr->GetSubBlockCount())
					{
						subBlockPtr = 0;
						curInstr = curInstr->GetNext();
					}
					done = false;
				}
				if (curInstr->GetNext() == nullptr)
					break;
			} while (!done);

			return *this;
		}
		AllInstructionsIterator AllInstructionsCollection::begin()
		{
			return AllInstructionsIterator(node->begin().Current);
		}
		AllInstructionsIterator AllInstructionsCollection::end()
		{
			return AllInstructionsIterator(node->end().Current);
		}
		String ImportInstruction::ToString()
		{
			StringBuilder rs;
			rs << Name << L" = import<" << ImportOperator->Name.Content << ">[" << ComponentName << L"@" << SourceWorld->WorldName << L"](";
			for (auto & arg : Arguments)
			{
				rs << arg->ToString() << L", ";
			}
			rs << L")";
			return rs.ProduceString();
		}
		String ImportInstruction::GetOperatorString()
		{
			return L"import<" + ImportOperator->Name.Content + L">";
		}
		void ImportInstruction::Accept(InstructionVisitor * visitor)
		{
			visitor->VisitImportInstruction(this);
		}
		void ExportInstruction::Accept(InstructionVisitor * visitor)
		{
			visitor->VisitExportInstruction(this);
		}
		ILType * ILStructType::Clone()
		{
			auto rs = new ILStructType(*this);
			rs->Members.Clear();
			for (auto & m : Members)
			{
				ILStructField f;
				f.FieldName = m.FieldName;
				f.Type = m.Type->Clone();
				rs->Members.Add(f);
			}
			return rs;
		}
		String ILStructType::ToString()
		{
			return TypeName;
		}
		bool ILStructType::Equals(ILType * type)
		{
			auto st = dynamic_cast<ILStructType*>(type);
			if (st && st->TypeName == this->TypeName)
				return true;
			return false;
		}
		void Align(int & ptr, int alignment)
		{
			if (ptr % alignment != 0)
			{
				ptr = (ptr / alignment + 1) * alignment;
			}
		}
		int ILStructType::GetSize()
		{
			int rs = 0;
			for (auto & m : Members)
			{
				int size = m.Type->GetSize();
				int alignment = m.Type->GetAlignment();
				Align(rs, alignment);
				rs += size;
			}
			return rs;
		}
		int ILStructType::GetAlignment()
		{
			int rs = 1;
			for (auto & m : Members)
			{
				int alignment = m.Type->GetAlignment();
				rs = Math::Max(rs, alignment);
			}
			return rs;
		}
}
}

/***********************************************************************
CORE\KEYHOLEMATCHING.CPP
***********************************************************************/

namespace Spire
{
	namespace Compiler
	{
		RefPtr<KeyHoleNode> ParseInternal(CoreLib::Text::Parser & parser)
		{
			RefPtr<KeyHoleNode> result = new KeyHoleNode();
			result->NodeType = parser.ReadWord();
			if (parser.LookAhead(L"<"))
			{
				parser.ReadToken();
				result->CaptureId = parser.ReadInt();
				parser.ReadToken();
			}
			if (parser.LookAhead(L"("))
			{
				while (!parser.LookAhead(L")"))
				{
					result->Children.Add(ParseInternal(parser));
					if (parser.LookAhead(L","))
						parser.ReadToken();
					else
					{
						break;
					}
				}
				parser.Read(L")");
			}
			return result;
		}

		RefPtr<KeyHoleNode> KeyHoleNode::Parse(String format)
		{
			CoreLib::Text::Parser parser(format);
			return ParseInternal(parser);
		}

		bool KeyHoleNode::Match(List<ILOperand*> & matchResult, ILOperand * instr)
		{
			bool matches = false;
			if (NodeType == L"store")
				matches = dynamic_cast<StoreInstruction*>(instr) != nullptr;
			else if (NodeType == L"op")
				matches = true;
			else if (NodeType == L"load")
				matches = dynamic_cast<LoadInstruction*>(instr) != nullptr;
			else if (NodeType == L"glea")
				matches = dynamic_cast<GLeaInstruction*>(instr) != nullptr;
			else if (NodeType == L"add")
				matches = dynamic_cast<AddInstruction*>(instr) != nullptr;
			else if (NodeType == L"mul")
				matches = dynamic_cast<MulInstruction*>(instr) != nullptr;
			else if (NodeType == L"sub")
				matches = dynamic_cast<SubInstruction*>(instr) != nullptr;
			else if (NodeType == L"call")
				matches = dynamic_cast<CallInstruction*>(instr) != nullptr;
			else if (NodeType == L"switch")
				matches = dynamic_cast<SwitchInstruction*>(instr) != nullptr;
			if (matches)
			{
				if (Children.Count() > 0)
				{
					ILInstruction * cinstr = dynamic_cast<ILInstruction*>(instr);
					if (cinstr != nullptr)
					{
						int opId = 0;
						for (auto & op : *cinstr)
						{
							if (opId >= Children.Count())
							{
								matches = false;
								break;
							}
							matches = matches && Children[opId]->Match(matchResult, &op);
							opId++;
						}
						if (opId != Children.Count())
							matches = false;
					}
					else
						matches = false;
				}
			}
			if (matches && CaptureId != -1)
			{
				matchResult.SetSize(Math::Max(matchResult.Count(), CaptureId + 1));
				matchResult[CaptureId] = instr;
			}
			return matches;
		}
	}
}

/***********************************************************************
CORE\LEXER.CPP
***********************************************************************/

namespace Spire
{
	namespace Compiler
	{
		enum class State
		{
			Start, Identifier, Operator, Int, Fixed, Double, Char, String, MultiComment, SingleComment
		};

		bool IsLetter(wchar_t ch)
		{
			return ((ch >= L'a' && ch <= L'z') ||
				(ch >= L'A' && ch <= L'Z') || ch == L'_' || ch == L'#');
		}

		bool IsDigit(wchar_t ch)
		{
			return ch >= L'0' && ch <= L'9';
		}

		bool IsPunctuation(wchar_t ch)
		{
			return  ch == L'+' || ch == L'-' || ch == L'*' || ch == L'/' || ch == L'%' ||
					ch == L'!' || ch == L'^' || ch == L'&' || ch == L'(' || ch == L')' ||
					ch == L'=' || ch == L'{' || ch == L'}' || ch == L'[' || ch == L']' ||
					ch == L'|' || ch == L';' || ch == L',' || ch == L'.' || ch == L'<' ||
					ch == L'>' || ch == L'~' || ch == L'@' || ch == L':' || ch == L'?';
		}

		TokenType GetKeywordTokenType(const String & str)
		{
			if (str == L"return")
				return TokenType::KeywordReturn;
			else if (str == L"break")
				return TokenType::KeywordBreak;
			else if (str == L"continue")
				return TokenType::KeywordContinue;
			else if (str == L"if")
				return TokenType::KeywordIf;
			else if (str == L"else")
				return TokenType::KeywordElse;
			else if (str == L"for")
				return TokenType::KeywordFor;
			else if (str == L"while")
				return TokenType::KeywordWhile;
			else if (str == L"do")
				return TokenType::KeywordDo;
			else
				return TokenType::Identifier;
		}

		void ParseOperators(const String & str, List<Token> & tokens, int line, int col, String fileName)
		{
			int pos = 0;
			while (pos < str.Length())
			{
				wchar_t curChar = str[pos];
				wchar_t nextChar = (pos < str.Length()-1)? str[pos + 1] : L'\0';
				auto InsertToken = [&](TokenType type, const String & ct)
				{
					tokens.Add(Token(type, ct, line, col + pos, fileName));
				};
				switch(curChar)
				{
				case L'+':
					if (nextChar == L'+')
					{
						InsertToken(TokenType::OpInc, L"++");
						pos += 2;
					}
					else if (nextChar == L'=')
					{
						InsertToken(TokenType::OpAddAssign, L"+=");
						pos += 2;
					}
					else
					{
						InsertToken(TokenType::OpAdd, L"+");
						pos++;
					}
					break;
				case L'-':
					if (nextChar == L'-')
					{
						InsertToken(TokenType::OpDec, L"--");
						pos += 2;
					}
					else if (nextChar == L'=')
					{
						InsertToken(TokenType::OpSubAssign, L"-=");
						pos += 2;
					}
					else if (nextChar == L'>')
					{
						InsertToken(TokenType::RightArrow, L"->");
						pos += 2;
					}
					else
					{
						InsertToken(TokenType::OpSub, L"-");
						pos++;
					}
					break;
				case L'*':
					if (nextChar == L'=')
					{
						InsertToken(TokenType::OpMulAssign, L"*=");
						pos += 2;
					}
					else
					{
						InsertToken(TokenType::OpMul, L"*");
						pos++;
					}
					break;
				case L'/':
					if (nextChar == L'=')
					{
						InsertToken(TokenType::OpDivAssign, L"/=");
						pos += 2;
					}
					else
					{
						InsertToken(TokenType::OpDiv, L"/");
						pos++;
					}
					break;
				case L'%':
					if (nextChar == L'=')
					{
						InsertToken(TokenType::OpModAssign, L"%=");
						pos += 2;
					}
					else
					{
						InsertToken(TokenType::OpMod, L"%");
						pos++;
					}
					break;
				case L'|':
					if (nextChar == L'|')
					{
						InsertToken(TokenType::OpOr, L"||");
						pos += 2;
					}
					else
					{
						InsertToken(TokenType::OpBitOr, L"|");
						pos++;
					}
					break;
				case L'&':
					if (nextChar == L'&')
					{
						InsertToken(TokenType::OpAnd, L"&&");
						pos += 2;
					}
					else
					{
						InsertToken(TokenType::OpBitAnd, L"&");
						pos++;
					}
					break;
				case L'^':
					InsertToken(TokenType::OpBitXor, L"^");
					pos++;
					break;
				case L'>':
					if (nextChar == L'>')
					{
						InsertToken(TokenType::OpRsh, L">>");
						pos += 2;
					}
					else if (nextChar == L'=')
					{
						InsertToken(TokenType::OpGeq, L">=");
						pos += 2;
					}
					else
					{
						InsertToken(TokenType::OpGreater, L">");
						pos++;
					}
					break;
				case L'<':
					if (nextChar == L'<')
					{
						InsertToken(TokenType::OpLsh, L"<<");
						pos += 2;
					}
					else if (nextChar == L'=')
					{
						InsertToken(TokenType::OpLeq, L"<=");
						pos += 2;
					}
					else
					{
						InsertToken(TokenType::OpLess, L"<");
						pos++;
					}
					break;
				case L'=':
					if (nextChar == L'=')
					{
						InsertToken(TokenType::OpEql, L"==");
						pos += 2;
					}
					else
					{
						InsertToken(TokenType::OpAssign, L"=");
						pos++;
					}
					break;
				case L'!':
					if (nextChar == L'=')
					{
						InsertToken(TokenType::OpNeq, L"!=");
						pos += 2;
					}
					else
					{
						InsertToken(TokenType::OpNot, L"!");
						pos++;
					}
					break;
				case L'?':
					InsertToken(TokenType::QuestionMark, L"?");
					pos++;
					break;
				case L'@':
					InsertToken(TokenType::At, L"@");
					pos++;
					break;
				case L':':
					InsertToken(TokenType::Colon, L":");
					pos++;
					break;
				case L'~':
					InsertToken(TokenType::OpBitNot, L"~");
					pos++;
					break;
				case L';':
					InsertToken(TokenType::Semicolon, L";");
					pos++;
					break;
				case L',':
					InsertToken(TokenType::Comma, L","); 
					pos++;
					break;
				case L'.':
					InsertToken(TokenType::Dot, L".");
					pos++;
					break;
				case L'{':
					InsertToken(TokenType::LBrace, L"{"); 
					pos++;
					break;
				case L'}':
					InsertToken(TokenType::RBrace, L"}"); 
					pos++;
					break;
				case L'[':
					InsertToken(TokenType::LBracket, L"["); 
					pos++;
					break;
				case L']':
					InsertToken(TokenType::RBracket, L"]"); 
					pos++;
					break;
				case L'(':
					InsertToken(TokenType::LParent, L"("); 
					pos++;
					break;
				case L')':
					InsertToken(TokenType::RParent, L")"); 
					pos++;
					break;
				}
			}
		}

		List<Token> Lexer::Parse(const String & fileName, const String & str, List<CompileError> & errorList)
		{
			int lastPos = 0, pos = 0;
			int line = 1, col = 0;
			State state = State::Start;
			StringBuilder tokenBuilder;
			int tokenLine, tokenCol;
			List<Token> tokenList;
			auto InsertToken = [&](TokenType type)
			{
				tokenList.Add(Token(type, tokenBuilder.ToString(), tokenLine, tokenCol, fileName));
				tokenBuilder.Clear();
			};
			auto ProcessTransferChar = [&](wchar_t nextChar)
			{
				switch(nextChar)
				{
				case L'\\':
				case L'\"':
				case L'\'':
					tokenBuilder.Append(nextChar);
					break;
				case L't':
					tokenBuilder.Append('\t');
					break;
				case L's':
					tokenBuilder.Append(' ');
					break;
				case L'n':
					tokenBuilder.Append('\n');
					break;
				case L'r':
					tokenBuilder.Append('\r');
					break;
				case L'b':
					tokenBuilder.Append('\b');
					break;
				}
			};
			while (pos <= str.Length())
			{
				wchar_t curChar = (pos < str.Length()?str[pos]:L' ');
				wchar_t nextChar = (pos < str.Length()-1)? str[pos + 1] : L'\0';
				if (lastPos != pos)
				{
					if (curChar == L'\n')
					{
						line++;
						col = 0;
					}
					else
						col++;
					lastPos = pos;
				}

				switch (state)
				{
				case State::Start:
					if (IsLetter(curChar))
					{
						state = State::Identifier;
						tokenLine = line;
						tokenCol = col;
					}
					else if (IsDigit(curChar))
					{
						state = State::Int;
						tokenLine = line;
						tokenCol = col;
					}
					else if (curChar == L'\'')
					{
						state = State::Char;
						pos++;
						tokenLine = line;
						tokenCol = col;
					}
					else if (curChar == L'"')
					{
						state = State::String;
						pos++;
						tokenLine = line;
						tokenCol = col;
					}
					else if (curChar == L' ' || curChar == L'\t' || curChar == L'\r' || curChar == L'\n')
						pos++;
					else if (curChar == L'/' && nextChar == L'/')
					{
						state = State::SingleComment;
						pos += 2;
					}
					else if (curChar == L'/' && nextChar == L'*')
					{
						pos += 2;
						state = State::MultiComment;
					}
					else if (IsPunctuation(curChar))
					{
						state = State::Operator;
						tokenLine = line;
						tokenCol = col;
					}
					else
					{
						errorList.Add(CompileError(L"Illegal character '" + String(curChar) + L"'", 10000, CodePosition(line, col, fileName)));
						pos++;
					}
					break;
				case State::Identifier:
					if (IsLetter(curChar) || IsDigit(curChar))
					{
						tokenBuilder.Append(curChar);
						pos++;
					}
					else
					{
						auto tokenStr = tokenBuilder.ToString();
						if (tokenStr == L"#line_reset#")
						{
							line = 0;
							col = 0;
							tokenBuilder.Clear();
						}
						else
							InsertToken(GetKeywordTokenType(tokenStr));
						state = State::Start;
					}
					break;
				case State::Operator:
					if (IsPunctuation(curChar) && !((curChar == L'/' && nextChar == L'/') || (curChar == L'/' && nextChar == L'*')))
					{
						tokenBuilder.Append(curChar);
						pos++;
					}
					else
					{
						//do token analyze
						ParseOperators(tokenBuilder.ToString(), tokenList, tokenLine, tokenCol, fileName);
						tokenBuilder.Clear();
						state = State::Start;
					}
					break;
				case State::Int:
					if (IsDigit(curChar))
					{
						tokenBuilder.Append(curChar);
						pos++;
					}
					else if (curChar == L'.')
					{
						state = State::Fixed;
						tokenBuilder.Append(curChar);
						pos++;
					}
					else if (curChar == L'e' || curChar == L'E')
					{
						state = State::Double;
						tokenBuilder.Append(curChar);
						if (nextChar == L'-' || nextChar == L'+')
						{
							tokenBuilder.Append(nextChar);
							pos++;
						}
						pos++;
					}
					else
					{
						InsertToken(TokenType::IntLiterial);
						state = State::Start;
					}
					break;
				case State::Fixed:
					if (IsDigit(curChar))
					{
						tokenBuilder.Append(curChar);
						pos++;
					}
					else if (curChar == L'e' || curChar == L'E')
					{
						state = State::Double;
						tokenBuilder.Append(curChar);
						if (nextChar == L'-' || nextChar == L'+')
						{
							tokenBuilder.Append(nextChar);
							pos++;
						}
						pos++;
					}
					else
					{
						if (curChar == L'f')
							pos++;
						InsertToken(TokenType::DoubleLiterial);
						state = State::Start;
					}
					break;
				case State::Double:
					if (IsDigit(curChar))
					{
						tokenBuilder.Append(curChar);
						pos++;
					}
					else
					{
						if (curChar == L'f')
							pos++;
						InsertToken(TokenType::DoubleLiterial);
						state = State::Start;
					}
					break;
				case State::String:
					if (curChar != L'"')
					{
						if (curChar == L'\\')
						{
							ProcessTransferChar(nextChar);
							pos++;
						}
						else
							tokenBuilder.Append(curChar);
					}
					else
					{
						InsertToken(TokenType::StringLiterial);
						state = State::Start;
					}
					pos++;
					break;
				case State::Char:
					if (curChar != L'\'')
					{
						if (curChar == L'\\')
						{
							ProcessTransferChar(nextChar);
							pos++;
						}
						else
							tokenBuilder.Append(curChar);
					}
					else
					{
						if (tokenBuilder.Length() > 1)
							errorList.Add(CompileError(L"Illegal character literial.", 10001, CodePosition(line, col-tokenBuilder.Length(), fileName)));
						InsertToken(TokenType::CharLiterial);
						state = State::Start;
					}
					pos++;
					break;
				case State::SingleComment:
					if (curChar == L'\n')
						state = State::Start;
					pos++;
					break;
				case State::MultiComment:
					if (curChar == L'*' && nextChar == '/')
					{
						state = State::Start;
						pos += 2;
					}
					else
						pos++;
					break;
				}
			}
			return tokenList;
		}

		String TokenTypeToString(TokenType type)
		{
			switch (type)
			{
			case TokenType::Unkown:
				return L"UnknownToken";
			case TokenType::Identifier:
				return L"Identifier";

			case TokenType::KeywordReturn:
				return L"\"return\"";
			case TokenType::KeywordBreak:
				return L"\"break\"";
			case TokenType::KeywordContinue:
				return L"\"continue\"";
			case TokenType::KeywordIf:
				return L"\"if\"";
			case TokenType::KeywordElse:
				return L"\"else\"";
			case TokenType::KeywordFor:
				return L"\"for\"";
			case TokenType::KeywordWhile:
				return L"\"while\"";
			case TokenType::KeywordDo:
				return L"\"do\"";
			case TokenType::IntLiterial:
				return L"Int Literial";
			case TokenType::DoubleLiterial:
				return L"Double Literial";
			case TokenType::StringLiterial:
				return L"String Literial";
			case TokenType::CharLiterial:
				return L"CharLiterial";
			case TokenType::QuestionMark:
				return L"'?'";
			case TokenType::Colon:
				return L"':'";
			case TokenType::Semicolon:
				return L"';'";
			case TokenType::Comma:
				return L"','";
			case TokenType::LBrace:
				return L"'{'";
			case TokenType::RBrace:
				return L"'}'";
			case TokenType::LBracket:
				return L"'['";
			case TokenType::RBracket:
				return L"']'";
			case TokenType::LParent:
				return L"'('";
			case TokenType::RParent:
				return L"')'";
			case TokenType::At:
				return L"'@'";
			case TokenType::OpAssign:
				return L"'='";
			case TokenType::OpAdd:
				return L"'+'";
			case TokenType::OpSub:
				return L"'-'";
			case TokenType::OpMul:
				return L"'*'";
			case TokenType::OpDiv:
				return L"'/'";
			case TokenType::OpMod:
				return L"'%'";
			case TokenType::OpNot:
				return L"'!'";
			case TokenType::OpLsh:
				return L"'<<'";
			case TokenType::OpRsh:
				return L"'>>'";
			case TokenType::OpAddAssign:
				return L"'+='";
			case TokenType::OpSubAssign:
				return L"'-='";
			case TokenType::OpMulAssign:
				return L"'*='";
			case TokenType::OpDivAssign:
				return L"'/='";
			case TokenType::OpModAssign:
				return L"'%='";
			case TokenType::OpEql:
				return L"'=='";
			case TokenType::OpNeq:
				return L"'!='";
			case TokenType::OpGreater:
				return L"'>'";
			case TokenType::OpLess:
				return L"'<'";
			case TokenType::OpGeq:
				return L"'>='";
			case TokenType::OpLeq:
				return L"'<='";
			case TokenType::OpAnd:
				return L"'&&'";
			case TokenType::OpOr:
				return L"'||'";
			case TokenType::OpBitXor:
				return L"'^'";
			case TokenType::OpBitAnd:
				return L"'&'";
			case TokenType::OpBitOr:
				return L"'|'";
			case TokenType::OpInc:
				return L"'++'";
			case TokenType::OpDec:
				return L"'--'";
			default:
				return L"";
			}
		}
		
	}
}

/***********************************************************************
CORE\PARSER.CPP
***********************************************************************/

namespace Spire
{
	namespace Compiler
	{
		Token & Parser::ReadToken(const wchar_t * string)
		{
			if (pos >= tokens.Count())
			{
				errors.Add(CompileError(String(L"\"") + string + String(L"\" expected but end of file encountered."), 20001, CodePosition(0, 0, fileName)));
				throw 0;
			}
			else if (tokens[pos].Content != string)
			{
				errors.Add(CompileError(String(L"\"") + string + String(L"\" expected"), 20001, tokens[pos].Position));
				throw 20001;
			}
			return tokens[pos++];
		}

		Token & Parser::ReadToken()
		{
			if (pos >= tokens.Count())
			{
				errors.Add(CompileError(String(L" Unexpected end of file."), 20001, CodePosition(0, 0, fileName)));
				throw 0;
			}
			return tokens[pos++];
		}

		Token & Parser::ReadToken(TokenType type)
		{
			if (pos >= tokens.Count())
			{
				errors.Add(CompileError(TokenTypeToString(type) + String(L" expected but end of file encountered."), 20001, CodePosition(0, 0, fileName)));
				throw 0;
			}
			else if(tokens[pos].Type != type)
			{
				errors.Add(CompileError(TokenTypeToString(type) + String(L" expected"), 20001, tokens[pos].Position));
				throw 20001;
			}
			return tokens[pos++];
		}

		bool Parser::LookAheadToken(const wchar_t * string, int offset)
		{
			if (pos + offset >= tokens.Count())
			{
				errors.Add(CompileError(String(L"\'") + string + String(L"\' expected but end of file encountered."), 20001, CodePosition(0, 0, fileName)));
				return false;
			}
			else
			{
				if (tokens[pos + offset].Content == string)
					return true;
				else
					return false;
			}
		}

		bool Parser::LookAheadToken(TokenType type, int offset)
		{
			if (pos + offset >= tokens.Count())
			{
				errors.Add(CompileError(TokenTypeToString(type) + String(L" expected but end of file encountered."), 20001, CodePosition(0, 0, fileName)));
				return false;
			}
			else
			{
				if(tokens[pos + offset].Type == type)
					return true;
				else
					return false;
			}
		}

		Token & Parser::ReadTypeKeyword()
		{
			if (pos >= tokens.Count())
			{
				errors.Add(CompileError(String(L"type name expected but end of file encountered."), 20001, CodePosition(0, 0, fileName)));
				throw 0;
			}
			if(!IsTypeKeyword())
			{
				errors.Add(CompileError(String(L"type name expected but '" + tokens[pos].Content + L"' encountered."), 20001, tokens[pos].Position));
				throw 20001;
			}
			return tokens[pos++];
		}

		bool Parser::IsTypeKeyword()
		{
			if (pos >= tokens.Count())
			{
				errors.Add(CompileError(String(L"Unexpected end of file."), 20001, tokens[pos].Position));
				throw 0;
			}

			return typeNames.Contains(tokens[pos].Content);
		}

		RefPtr<ProgramSyntaxNode> Parser::Parse()
		{
			return ParseProgram();
		}

		EnumerableDictionary<String, String> Parser::ParseAttribute()
		{
			EnumerableDictionary<String, String> rs;
			while (LookAheadToken(TokenType::LBracket))
			{
				ReadToken(TokenType::LBracket);
				auto name = ReadToken(TokenType::Identifier).Content;
				String value;
				if (LookAheadToken(L":"))
				{
					ReadToken(L":");
					value = ReadToken(TokenType::StringLiterial).Content;
				}
				rs[name] = value;
				ReadToken(TokenType::RBracket);
			}
			return rs;
		}

		RefPtr<ProgramSyntaxNode> Parser::ParseProgram()
		{
			scopeStack.Add(new Scope());
			RefPtr<ProgramSyntaxNode> program = new ProgramSyntaxNode();
			program->Position = CodePosition(0, 0, fileName);
			program->Scope = scopeStack.Last();
			try
			{
				int lastPosBeforeError = 0;
				while (pos < tokens.Count())
				{
					try
					{
						if (LookAheadToken(L"shader") || LookAheadToken(L"module"))
							program->Shaders.Add(ParseShader());
						else if (LookAheadToken(L"pipeline"))
							program->Pipelines.Add(ParsePipeline());
						else if (LookAheadToken(L"struct"))
							program->Structs.Add(ParseStruct());
						else if (LookAheadToken(L"using"))
						{
							ReadToken(L"using");
							program->Usings.Add(ReadToken(TokenType::StringLiterial));
							ReadToken(TokenType::Semicolon);
						}
						else if (IsTypeKeyword() || LookAheadToken(L"inline") || LookAheadToken(L"extern")
							|| LookAheadToken(L"__intrinsic") || LookAheadToken(TokenType::Identifier))
							program->Functions.Add(ParseFunction());
						else if (LookAheadToken(TokenType::Semicolon))
							ReadToken(TokenType::Semicolon);
						else
						{
							if (lastPosBeforeError == 0 && pos < tokens.Count())
								errors.Add(CompileError(L"unexpected token \'" + tokens[pos].Content + L"\'.", 20003, tokens[pos].Position));
							throw 0;
						}
					}
					catch (int)
					{
						if (pos == lastPosBeforeError)
							pos++;
						lastPosBeforeError = pos;
					}
				}
			}
			catch(int)
			{}
			scopeStack.Clear();
			return program;
		}

		RefPtr<ShaderSyntaxNode> Parser::ParseShader()
		{
			RefPtr<ShaderSyntaxNode> shader = new ShaderSyntaxNode();
			if (LookAheadToken(L"module"))
			{
				shader->IsModule = true;
				ReadToken(L"module");
			}
			else
				ReadToken(L"shader");
			PushScope();
			FillPosition(shader.Ptr());
			shader->Name = ReadToken(TokenType::Identifier);
			try
			{
				if (LookAheadToken(L":"))
				{
					ReadToken(L":");
					shader->Pipeline = ReadToken(TokenType::Identifier);
				}
			}
			catch (int)
			{
			}
			
			ReadToken(TokenType::LBrace);
			int lastErrorPos = 0;
			while (!LookAheadToken(TokenType::RBrace))
			{
				try
				{
					if (LookAheadToken(L"inline") || (LookAheadToken(L"public") && !LookAheadToken(L"using", 1)) ||
						LookAheadToken(L"out") || LookAheadToken(L"@") || IsTypeKeyword()
						|| LookAheadToken(L"[") || LookAheadToken(L"require"))
						shader->Members.Add(ParseComponent());
					else if (LookAheadToken(L"using") || (LookAheadToken(L"public") && LookAheadToken(L"using", 1)))
					{
						shader->Members.Add(ParseImport());
					}
					else
					{
						if (lastErrorPos == 0 && pos < tokens.Count())
							errors.Add(CompileError(L"unexpected token \'" + tokens[pos].Content + L"\', only component definitions are allowed in a shader scope.", 
								20004, tokens[pos].Position));
						throw 0;
					}
				}
				catch (int)
				{
					if (pos == lastErrorPos)
						pos++;
					lastErrorPos = pos;
				}
			}
			ReadToken(TokenType::RBrace);
			
			PopScope();
			return shader;
		}

		RefPtr<PipelineSyntaxNode> Parser::ParsePipeline()
		{
			RefPtr<PipelineSyntaxNode> pipeline = new PipelineSyntaxNode();
			ReadToken(L"pipeline");
			FillPosition(pipeline.Ptr());
			pipeline->Name = ReadToken(TokenType::Identifier);
			ReadToken(TokenType::LBrace);
			while (!LookAheadToken(TokenType::RBrace))
			{
				auto attribs = ParseAttribute();
				if (LookAheadToken(L"input") || LookAheadToken(L"world"))
				{
					auto w = ParseWorld();
					w->LayoutAttributes = attribs;
					pipeline->Worlds.Add(w);
				}
				else if (LookAheadToken(L"import"))
				{
					auto op = ParseImportOperator();
					op->LayoutAttributes = attribs;
					pipeline->ImportOperators.Add(op);
				}
				else
				{
					auto comp = ParseComponent();
					comp->LayoutAttributes = attribs;
					pipeline->AbstractComponents.Add(comp);
				}
			}
			ReadToken(TokenType::RBrace);
			return pipeline;
		}

		RefPtr<ComponentSyntaxNode> Parser::ParseComponent()
		{
			RefPtr<ComponentSyntaxNode> component = new ComponentSyntaxNode();
			component->LayoutAttributes = ParseAttribute();
			while (LookAheadToken(L"inline") || LookAheadToken(L"out") || LookAheadToken(L"require") || LookAheadToken(L"public"))
			{
				if (LookAheadToken(L"inline"))
				{
					component->IsInline = true;
					ReadToken(L"inline");
				}
				else if (LookAheadToken(L"out"))
				{
					component->IsOutput = true;
					ReadToken(L"out");
				}
				else if (LookAheadToken(L"public"))
				{
					component->IsPublic = true;
					ReadToken(L"public");
				}
				else if (LookAheadToken(L"require"))
				{
					component->IsParam = true;
					ReadToken(L"require");
				}
				else
					break;
			}
			if (LookAheadToken(L"@"))
				component->Rate = ParseRate();
			component->Type = ParseType();
			FillPosition(component.Ptr());
			component->Name = ReadToken(TokenType::Identifier);
			if (LookAheadToken(L":"))
			{
				ReadToken(L":");
				component->AlternateName = ReadToken(TokenType::Identifier);
			}
			if (!component->IsParam && LookAheadToken(TokenType::OpAssign))
			{
				ReadToken(TokenType::OpAssign);
				component->Expression = ParseExpression();
				ReadToken(TokenType::Semicolon);
			}
			else if (!component->IsParam && LookAheadToken(TokenType::LBrace))
			{
				component->BlockStatement = ParseBlockStatement();
			}
			else
				ReadToken(TokenType::Semicolon);
			return component;
		}

		RefPtr<WorldSyntaxNode> Parser::ParseWorld()
		{
			RefPtr<WorldSyntaxNode> world = new WorldSyntaxNode();
			world->LayoutAttributes = ParseAttribute();
			world->IsAbstract = LookAheadToken(L"input");
			if (world->IsAbstract)
				ReadToken(L"input");
			ReadToken(L"world");
			FillPosition(world.Ptr());
			world->Name = ReadToken(TokenType::Identifier);
			if (LookAheadToken(TokenType::Colon))
			{
				ReadToken(TokenType::Colon);
				world->TargetMachine = ReadToken(TokenType::StringLiterial).Content;
			}
			if (LookAheadToken(L"using"))
			{
				ReadToken(L"using");
				while (LookAheadToken(TokenType::Identifier))
				{
					world->Usings.Add(ReadToken(TokenType::Identifier));
					if (LookAheadToken(TokenType::Comma))
						ReadToken(TokenType::Comma);
					else
						break;
				}
			}
			if (!world->IsAbstract)
			{
				ReadToken(L"export");
				world->ExportOperator = ReadToken(TokenType::Identifier);
			}
			ReadToken(TokenType::Semicolon);
			return world;
		}

		RefPtr<RateSyntaxNode> Parser::ParseRate()
		{
			RefPtr<RateSyntaxNode> rate = new RateSyntaxNode();
			FillPosition(rate.Ptr());
			ReadToken(TokenType::At);
			auto readWorldRate = [this]()
			{
				RateWorld rw;
				rw.World = ReadToken(TokenType::Identifier);
				if (LookAheadToken(TokenType::OpMul))
				{
					ReadToken(TokenType::OpMul);
					rw.Pinned = true;
				}
				return rw;
			};
			if (LookAheadToken(TokenType::LParent))
			{
				ReadToken(TokenType::LParent);
				while (!LookAheadToken(TokenType::RParent))
				{
					RateWorld rw = readWorldRate();
					rate->Worlds.Add(rw);
					if (LookAheadToken(TokenType::Comma))
					{
						ReadToken(TokenType::Comma);
					}
					else
						break;
				}
				ReadToken(TokenType::RParent);
			}
			else
				rate->Worlds.Add(readWorldRate());
			return rate;
		}

		RefPtr<ImportSyntaxNode> Parser::ParseImport()
		{
			RefPtr<ImportSyntaxNode> rs = new ImportSyntaxNode();
			if (LookAheadToken(L"public"))
			{
				rs->IsPublic = true;
				ReadToken(L"public");
			}
			ReadToken(L"using");
			rs->IsInplace = !LookAheadToken(TokenType::OpAssign, 1);
			if (!rs->IsInplace)
			{
				rs->ObjectName = ReadToken(TokenType::Identifier);
				ReadToken(TokenType::OpAssign);
			}
			FillPosition(rs.Ptr());
			rs->ShaderName = ReadToken(TokenType::Identifier);
			if (LookAheadToken(TokenType::Semicolon))
				ReadToken(TokenType::Semicolon);
			else
			{
				ReadToken(TokenType::LParent);
				while (!LookAheadToken(TokenType::RParent))
				{
					RefPtr<ImportArgumentSyntaxNode> arg = new ImportArgumentSyntaxNode();
					FillPosition(arg.Ptr());
					auto expr = ParseExpression();
					if (LookAheadToken(L":"))
					{
						if (auto varExpr = dynamic_cast<VarExpressionSyntaxNode*>(expr.Ptr()))
						{
							arg->ArgumentName.Content = varExpr->Variable;
							arg->ArgumentName.Position = varExpr->Position;
						}
						else
							errors.Add(CompileError(L"unexpected ':'.", 20011, pos < tokens.Count() ? tokens[pos].Position : CodePosition(0, 0, fileName)));
						ReadToken(L":");
						arg->Expression = ParseExpression();
					}
					else
						arg->Expression = expr;
					rs->Arguments.Add(arg);
					if (LookAheadToken(TokenType::Comma))
						ReadToken(TokenType::Comma);
					else
						break;
				}
				ReadToken(TokenType::RParent);
				ReadToken(TokenType::Semicolon);
			}
			return rs;
		}

		RefPtr<ImportStatementSyntaxNode> Parser::ParseImportStatement()
		{
			RefPtr<ImportStatementSyntaxNode> rs = new ImportStatementSyntaxNode();
			FillPosition(rs.Ptr());
			rs->Import = ParseImport();
			return rs;
		}

		RefPtr<ImportOperatorDefSyntaxNode> Parser::ParseImportOperator()
		{
			RefPtr<ImportOperatorDefSyntaxNode> op = new ImportOperatorDefSyntaxNode();
			ReadToken(L"import");
			FillPosition(op.Ptr());
			op->Name = ReadToken(TokenType::Identifier);
			ReadToken(TokenType::LParent);
			op->SourceWorld = ReadToken(TokenType::Identifier);
			ReadToken(TokenType::RightArrow);
			op->DestWorld = ReadToken(TokenType::Identifier);
			ReadToken(TokenType::RParent);
			if (LookAheadToken(L"using"))
			{
				ReadToken(L"using");
				do
				{
					op->Usings.Add(ReadToken(TokenType::Identifier));
					if (LookAheadToken(TokenType::Comma))
						ReadToken(TokenType::Comma);
					else
						break;
				} while (LookAheadToken(TokenType::Identifier));
			}
			if (LookAheadToken(TokenType::LBrace))
			{
				ReadToken(TokenType::LBrace);
				while (!LookAheadToken(TokenType::RBrace))
				{
					auto name = ReadToken(TokenType::Identifier);
					ReadToken(TokenType::Colon);
					auto value = ReadToken(TokenType::StringLiterial);
					ReadToken(TokenType::Semicolon);
					op->Arguments[name.Content] = value.Content;
					if (LookAheadToken(TokenType::Comma))
						ReadToken(TokenType::Comma);
					else
						break;

				}
				ReadToken(TokenType::RBrace);
				if (LookAheadToken(TokenType::Semicolon))
					ReadToken(TokenType::Semicolon);
			}
			else 
				ReadToken(TokenType::Semicolon);
			return op;
		}

		RefPtr<FunctionSyntaxNode> Parser::ParseFunction()
		{
			RefPtr<FunctionSyntaxNode> function = new FunctionSyntaxNode();
			if (LookAheadToken(L"__intrinsic"))
			{
				function->HasSideEffect = false;
				function->IsExtern = true;
				pos++;
			}
			else if (LookAheadToken(L"extern"))
			{
				function->IsExtern = true;
				pos++;
			}
			else
				function->IsExtern = false;
			function->IsInline = true;
			if (LookAheadToken(L"inline"))
			{
				function->IsInline = true;
				pos++;
			}
			
			PushScope();
			function->ReturnType = ParseType();
			try
			{
				FillPosition(function.Ptr());
				Token name = ReadToken();
				function->Name = name.Content;
				ReadToken(TokenType::LParent);
				while(pos < tokens.Count() && tokens[pos].Type != TokenType::RParent)
				{
					function->Parameters.Add(ParseParameter());
					if (LookAheadToken(TokenType::Comma))
						ReadToken(TokenType::Comma);
					else
						break;
				}
				ReadToken(TokenType::RParent);
			}
			catch(int e)
			{
				if (e == 0)
					return function;
				while (pos < tokens.Count() && tokens[pos].Type != TokenType::LBrace)
				{
					pos++;
				}
			}
			if (!function->IsExtern)
				function->Body = ParseBlockStatement();
			else
				ReadToken(TokenType::Semicolon);
			PopScope();
			return function;
		}

		RefPtr<StructSyntaxNode> Parser::ParseStruct()
		{
			RefPtr<StructSyntaxNode> rs = new StructSyntaxNode();
			FillPosition(rs.Ptr());
			ReadToken(L"struct");
			rs->Name = ReadToken(TokenType::Identifier);
			ReadToken(L"{");
			while (!LookAheadToken(L"}") && pos < tokens.Count())
			{
				RefPtr<TypeSyntaxNode> type = ParseType();
				do
				{
					RefPtr<StructField> field = new StructField();
					FillPosition(field.Ptr());
					field->Type = type;
					field->Name = ReadToken(TokenType::Identifier);
					rs->Fields.Add(field);
					if (!LookAheadToken(TokenType::Comma))
						break;
					ReadToken(TokenType::Comma);
				} while (pos < tokens.Count());
				ReadToken(TokenType::Semicolon);
			}
			ReadToken(L"}");
			return rs;
		}

		RefPtr<StatementSyntaxNode> Parser::ParseStatement()
		{
			RefPtr<StatementSyntaxNode> statement;
			if (LookAheadToken(TokenType::LBrace))
				statement = ParseBlockStatement();
			else if (IsTypeKeyword() || LookAheadToken(L"const"))
				statement = ParseVarDeclrStatement();
			else if (LookAheadToken(TokenType::KeywordIf))
				statement = ParseIfStatement();
			else if (LookAheadToken(TokenType::KeywordFor))
				statement = ParseForStatement();
			else if (LookAheadToken(TokenType::KeywordWhile))
				statement = ParseWhileStatement();
			else if (LookAheadToken(TokenType::KeywordDo))
				statement = ParseDoWhileStatement();
			else if (LookAheadToken(TokenType::KeywordBreak))
				statement = ParseBreakStatement();
			else if (LookAheadToken(TokenType::KeywordContinue))
				statement = ParseContinueStatement();
			else if (LookAheadToken(TokenType::KeywordReturn))
				statement = ParseReturnStatement();
			else if (LookAheadToken(L"using") || (LookAheadToken(L"public") && LookAheadToken(L"using", 1)))
				statement = ParseImportStatement();
			else if (LookAheadToken(TokenType::Identifier))
			{
				int startPos = pos;
				bool isVarDeclr = false;
				try
				{
					RefPtr<TypeSyntaxNode> type = ParseType();
					if (LookAheadToken(TokenType::Identifier))
					{
						type = nullptr;
						pos = startPos;
						statement = ParseVarDeclrStatement();
						isVarDeclr = true;
					}
				}
				catch (...)
				{
				}
				if (!isVarDeclr)
				{
					pos = startPos;
					statement = ParseExpressionStatement();
				}
			}
			else if (LookAheadToken(TokenType::Semicolon))
			{
				statement = new EmptyStatementSyntaxNode();
				FillPosition(statement.Ptr());
				ReadToken(TokenType::Semicolon);
			}
			else
			{
				errors.Add(CompileError(String(L"syntax error."), 20002, tokens[pos].Position));
				throw 20002;
			}
			return statement;
		}

		RefPtr<BlockStatementSyntaxNode> Parser::ParseBlockStatement()
		{
			RefPtr<BlockStatementSyntaxNode> blockStatement = new BlockStatementSyntaxNode();
			PushScope();
			ReadToken(TokenType::LBrace);
			if(pos < tokens.Count())
			{
				FillPosition(blockStatement.Ptr());
			}
			int lastErrorPos = 0;
			while (pos < tokens.Count() && !LookAheadToken(TokenType::RBrace))
			{
				try
				{
					blockStatement->Statements.Add(ParseStatement());
				}
				catch (int)
				{
					if (pos == lastErrorPos)
						pos++;
					lastErrorPos = pos;
				}
			}
			ReadToken(TokenType::RBrace);
			PopScope();
			return blockStatement;
		}

		VariableModifier Parser::ReadVariableModifier()
		{
			auto & token = ReadToken(TokenType::Identifier);
			if (token.Content == L"in")
				return VariableModifier::In;
			else if (token.Content == L"out")
				return VariableModifier::Out;
			else if (token.Content == L"uniform")
				return VariableModifier::Uniform;
			else if (token.Content == L"parameter")
				return VariableModifier::Parameter;
			else if (token.Content == L"const")
				return VariableModifier::Const;
			else if (token.Content == L"centroid")
				return VariableModifier::Centroid;
			else if (token.Content == L"instance")
				return VariableModifier::Instance;
			else if (token.Content == L"__builtin")
				return VariableModifier::Builtin;
			return VariableModifier::None; 
		}

		RefPtr<VarDeclrStatementSyntaxNode> Parser::ParseVarDeclrStatement()
		{
			RefPtr<VarDeclrStatementSyntaxNode>varDeclrStatement = new VarDeclrStatementSyntaxNode();
		
			if (pos < tokens.Count())
				FillPosition(varDeclrStatement.Ptr());
			while (pos < tokens.Count())
			{
				if (LookAheadToken(L"layout"))
				{
					ReadToken(L"layout");
					ReadToken(TokenType::LParent);
					StringBuilder layoutSB;
					while (!LookAheadToken(TokenType::RParent))
					{
						layoutSB.Append(ReadToken(TokenType::Identifier).Content);
						if (LookAheadToken(TokenType::OpAssign))
						{
							layoutSB.Append(ReadToken(TokenType::OpAssign).Content);
							layoutSB.Append(ReadToken(TokenType::IntLiterial).Content);
						}
						if (!LookAheadToken(TokenType::Comma))
							break;
						else
							layoutSB.Append(L", ");
					}
					ReadToken(TokenType::RParent);
					varDeclrStatement->LayoutString = layoutSB.ProduceString();
				}
				else
					break;
			}
			varDeclrStatement->Type = ParseType();
			while (pos < tokens.Count())
			{
				RefPtr<Variable> var = new Variable();
				FillPosition(var.Ptr());
				Token & name = ReadToken(TokenType::Identifier);
				var->Name = name.Content;
				if (LookAheadToken(TokenType::OpAssign))
				{
					ReadToken(TokenType::OpAssign);
					var->Expression = ParseExpression();
				}

				varDeclrStatement->Variables.Add(var);
				if (LookAheadToken(TokenType::Comma))
					ReadToken(TokenType::Comma);
				else
					break;
			}
			ReadToken(TokenType::Semicolon);
			
			return varDeclrStatement;
		}

		RefPtr<IfStatementSyntaxNode> Parser::ParseIfStatement()
		{
			RefPtr<IfStatementSyntaxNode> ifStatement = new IfStatementSyntaxNode();
			FillPosition(ifStatement.Ptr());
			ReadToken(TokenType::KeywordIf);
			ReadToken(TokenType::LParent);
			ifStatement->Predicate = ParseExpression();
			ReadToken(TokenType::RParent);
			ifStatement->PositiveStatement = ParseStatement();
			if (LookAheadToken(TokenType::KeywordElse))
			{
				ReadToken(TokenType::KeywordElse);
				ifStatement->NegativeStatement = ParseStatement();
			}
			return ifStatement;
		}

		RefPtr<ForStatementSyntaxNode> Parser::ParseForStatement()
		{
			RefPtr<ForStatementSyntaxNode> stmt = new ForStatementSyntaxNode();
			PushScope();
			FillPosition(stmt.Ptr());
			ReadToken(TokenType::KeywordFor);
			ReadToken(TokenType::LParent);
			if (IsTypeKeyword())
				stmt->TypeDef = ParseType();
			stmt->IterationVariable = ReadToken(TokenType::Identifier);
			ReadToken(TokenType::OpAssign);
			stmt->InitialExpression = ParseExpression();
			ReadToken(TokenType::Colon);
			stmt->EndExpression = ParseExpression();
			if (LookAheadToken(TokenType::Colon))
			{
				stmt->StepExpression = stmt->EndExpression;
				ReadToken(TokenType::Colon);
				stmt->EndExpression = ParseExpression();
			}
			ReadToken(TokenType::RParent);
			stmt->Statement = ParseStatement();
			PopScope();
			return stmt;
		}

		RefPtr<WhileStatementSyntaxNode> Parser::ParseWhileStatement()
		{
			RefPtr<WhileStatementSyntaxNode> whileStatement = new WhileStatementSyntaxNode();
			PushScope();
			FillPosition(whileStatement.Ptr());
			ReadToken(TokenType::KeywordWhile);
			ReadToken(TokenType::LParent);
			whileStatement->Predicate = ParseExpression();
			ReadToken(TokenType::RParent);
			whileStatement->Statement = ParseStatement();
			PopScope();
			return whileStatement;
		}

		RefPtr<DoWhileStatementSyntaxNode> Parser::ParseDoWhileStatement()
		{
			RefPtr<DoWhileStatementSyntaxNode> doWhileStatement = new DoWhileStatementSyntaxNode();
			PushScope();
			FillPosition(doWhileStatement.Ptr());
			ReadToken(TokenType::KeywordDo);
			doWhileStatement->Statement = ParseStatement();
			ReadToken(TokenType::KeywordWhile);
			ReadToken(TokenType::LParent);
			doWhileStatement->Predicate = ParseExpression();
			ReadToken(TokenType::RParent);
			ReadToken(TokenType::Semicolon);
			PopScope();
			return doWhileStatement;
		}

		RefPtr<BreakStatementSyntaxNode> Parser::ParseBreakStatement()
		{
			RefPtr<BreakStatementSyntaxNode> breakStatement = new BreakStatementSyntaxNode();
			FillPosition(breakStatement.Ptr());
			ReadToken(TokenType::KeywordBreak);
			ReadToken(TokenType::Semicolon);
			return breakStatement;
		}

		RefPtr<ContinueStatementSyntaxNode>	Parser::ParseContinueStatement()
		{
			RefPtr<ContinueStatementSyntaxNode> continueStatement = new ContinueStatementSyntaxNode();
			FillPosition(continueStatement.Ptr());
			ReadToken(TokenType::KeywordContinue);
			ReadToken(TokenType::Semicolon);
			return continueStatement;
		}

		RefPtr<ReturnStatementSyntaxNode> Parser::ParseReturnStatement()
		{
			RefPtr<ReturnStatementSyntaxNode> returnStatement = new ReturnStatementSyntaxNode();
			FillPosition(returnStatement.Ptr());
			ReadToken(TokenType::KeywordReturn);
			if (!LookAheadToken(TokenType::Semicolon))
				returnStatement->Expression = ParseExpression();
			ReadToken(TokenType::Semicolon);
			return returnStatement;
		}

		RefPtr<ExpressionStatementSyntaxNode> Parser::ParseExpressionStatement()
		{
			RefPtr<ExpressionStatementSyntaxNode> statement = new ExpressionStatementSyntaxNode();
			
			FillPosition(statement.Ptr());
			statement->Expression = ParseExpression();
			
			ReadToken(TokenType::Semicolon);
			return statement;
		}

		RefPtr<ParameterSyntaxNode> Parser::ParseParameter()
		{
			RefPtr<ParameterSyntaxNode> parameter = new ParameterSyntaxNode();
			
			parameter->Type = ParseType();
			Token & name = ReadToken(TokenType::Identifier);
			parameter->Name = name.Content;
			FillPosition(parameter.Ptr());
			
			return parameter;
		}

		RefPtr<TypeSyntaxNode> Parser::ParseType()
		{
			RefPtr<TypeSyntaxNode> type = new TypeSyntaxNode();
		
			FillPosition(type.Ptr());
			if (LookAheadToken(TokenType::Identifier))
				type->TypeName = ReadToken(TokenType::Identifier).Content;
			else
				type->TypeName = ReadTypeKeyword().Content;
	
			if (LookAheadToken(TokenType::OpLess))
			{
				ReadToken(TokenType::OpLess);
				type->GenericBaseType = ReadToken(TokenType::Identifier).Content;
				ReadToken(TokenType::OpGreater);
			}
			if(LookAheadToken(TokenType::LBracket))
			{
				ReadToken(TokenType::LBracket);
				type->IsArray = true;
				if (LookAheadToken(TokenType::IntLiterial))
					type->ArrayLength = atoi(ReadToken(TokenType::IntLiterial).Content.ToMultiByteString());
				else
					type->ArrayLength = 0;
				ReadToken(TokenType::RBracket);
			}
			return type;
		}

		enum class Associativity
		{
			Left, Right
		};

		Associativity GetAssociativityFromLevel(int level)
		{
			if (level == 0)
				return Associativity::Right;
			else
				return Associativity::Left;
		}

		int GetOpLevel(TokenType type)
		{
			switch(type)
			{
			case TokenType::OpAssign:
			case TokenType::OpMulAssign:
			case TokenType::OpDivAssign:
			case TokenType::OpAddAssign:
			case TokenType::OpSubAssign:
			case TokenType::OpModAssign:
				return 0;
			case TokenType::OpOr:
				return 2;
			case TokenType::OpAnd:
				return 3;
			case TokenType::OpBitOr:
				return 4;
			case TokenType::OpBitXor:
				return 5;
			case TokenType::OpBitAnd:
				return 6;
			case TokenType::OpEql:
			case TokenType::OpNeq:
				return 7;
			case TokenType::OpGeq:
			case TokenType::OpLeq:
			case TokenType::OpGreater:
			case TokenType::OpLess:
				return 8;
			case TokenType::OpLsh:
			case TokenType::OpRsh:
				return 9;
			case TokenType::OpAdd:
			case TokenType::OpSub:
				return 10;
			case TokenType::OpMul:
			case TokenType::OpDiv:
			case TokenType::OpMod:
				return 11;
			default:
				return -1;
			}
		}

		Operator GetOpFromToken(Token & token)
		{
			switch(token.Type)
			{
			case TokenType::OpAssign:
				return Operator::Assign;
			case TokenType::OpAddAssign:
				return Operator::AddAssign;
			case TokenType::OpSubAssign:
				return Operator::SubAssign;
			case TokenType::OpMulAssign:
				return Operator::MulAssign;
			case TokenType::OpDivAssign:
				return Operator::DivAssign;
			case TokenType::OpModAssign:
				return Operator::ModAssign;
			case TokenType::OpOr:
				return Operator::Or;
			case TokenType::OpAnd:
				return Operator::And;
			case TokenType::OpBitOr:
				return Operator::BitOr;
			case TokenType::OpBitXor:
				return Operator::BitXor;
			case TokenType::OpBitAnd:
				return Operator::BitAnd;
			case TokenType::OpEql:
				return Operator::Eql;
			case TokenType::OpNeq:
				return Operator::Neq;
			case TokenType::OpGeq:
				return Operator::Geq;
			case TokenType::OpLeq:
				return Operator::Leq;
			case TokenType::OpGreater:
				return Operator::Greater;
			case TokenType::OpLess:
				return Operator::Less;
			case TokenType::OpLsh:
				return Operator::Lsh;
			case TokenType::OpRsh:
				return Operator::Rsh;
			case TokenType::OpAdd:
				return Operator::Add;
			case TokenType::OpSub:
				return Operator::Sub;
			case TokenType::OpMul:
				return Operator::Mul;
			case TokenType::OpDiv:
				return Operator::Div;
			case TokenType::OpMod:
				return Operator::Mod;
			case TokenType::OpInc:
				return Operator::PostInc;
			case TokenType::OpDec:
				return Operator::PostDec;
			case TokenType::OpNot:
				return Operator::Not;
			case TokenType::OpBitNot:
				return Operator::BitNot;
			default:
				throw L"Illegal TokenType.";
			}
		}

		RefPtr<ExpressionSyntaxNode> Parser::ParseExpression(int level)
		{
			if (level == MaxExprLevel)
				return ParseLeafExpression();
			if (level == 1)
			{
				// parse select clause
				auto condition = ParseExpression(level + 1);
				if (LookAheadToken(TokenType::QuestionMark))
				{
					RefPtr<SelectExpressionSyntaxNode> select = new SelectExpressionSyntaxNode();
					FillPosition(select.Ptr());
					ReadToken(TokenType::QuestionMark);
					select->SelectorExpr = condition;
					select->Expr0 = ParseExpression(level);
					ReadToken(TokenType::Colon);
					select->Expr1 = ParseExpression(level);
					return select;
				}
				else
					return condition;
			}
			else
			{
				if (GetAssociativityFromLevel(level) == Associativity::Left)
				{
					auto left = ParseExpression(level + 1);
					while (pos < tokens.Count() && GetOpLevel(tokens[pos].Type) == level)
					{
						RefPtr<BinaryExpressionSyntaxNode> tmp = new BinaryExpressionSyntaxNode();
						tmp->LeftExpression = left;
						FillPosition(tmp.Ptr());
						Token & opToken = ReadToken(tokens[pos].Type);
						tmp->Operator = GetOpFromToken(opToken);
						tmp->RightExpression = ParseExpression(level + 1);
						left = tmp;
					}
					return left;
				}
				else
				{
					auto left = ParseExpression(level + 1);
					if (pos < tokens.Count() && GetOpLevel(tokens[pos].Type) == level)
					{
						RefPtr<BinaryExpressionSyntaxNode> tmp = new BinaryExpressionSyntaxNode();
						tmp->LeftExpression = left;
						FillPosition(tmp.Ptr());
						Token & opToken = ReadToken(tokens[pos].Type);
						tmp->Operator = GetOpFromToken(opToken);
						tmp->RightExpression = ParseExpression(level);
						left = tmp;
					}
					return left;
				}
			}
		}

		RefPtr<ExpressionSyntaxNode> Parser::ParseLeafExpression()
		{
			RefPtr<ExpressionSyntaxNode> rs;

			if (LookAheadToken(TokenType::OpInc) ||
				LookAheadToken(TokenType::OpDec) ||
				LookAheadToken(TokenType::OpNot) ||
				LookAheadToken(TokenType::OpBitNot) ||
				LookAheadToken(TokenType::OpSub))
			{
				RefPtr<UnaryExpressionSyntaxNode> unaryExpr = new UnaryExpressionSyntaxNode();
				Token & token = tokens[pos++];
				FillPosition(unaryExpr.Ptr());
				unaryExpr->Operator = GetOpFromToken(token);
				if (unaryExpr->Operator == Operator::PostInc)
					unaryExpr->Operator = Operator::PreInc;
				else if (unaryExpr->Operator == Operator::PostDec)
					unaryExpr->Operator = Operator::PreDec;
				else if (unaryExpr->Operator == Operator::Sub)
					unaryExpr->Operator = Operator::Neg;

				unaryExpr->Expression = ParseLeafExpression();
				rs = unaryExpr;
				return rs;
			}

			if (LookAheadToken(TokenType::LParent))
			{
				ReadToken(TokenType::LParent);
				RefPtr<ExpressionSyntaxNode> expr;
				if (IsTypeKeyword() && pos + 1 < tokens.Count() && tokens[pos+1].Type == TokenType::RParent)
				{
					RefPtr<TypeCastExpressionSyntaxNode> tcexpr = new TypeCastExpressionSyntaxNode();
					FillPosition(tcexpr.Ptr());
					tcexpr->TargetType = ParseType();
					ReadToken(TokenType::RParent);
					tcexpr->Expression = ParseExpression();
					expr = tcexpr;
				}
				else
				{
					expr = ParseExpression();
					ReadToken(TokenType::RParent);
				}
				rs = expr;
			}
			else if (LookAheadToken(TokenType::IntLiterial) ||
				LookAheadToken(TokenType::DoubleLiterial))
			{
				RefPtr<ConstantExpressionSyntaxNode> constExpr = new ConstantExpressionSyntaxNode();
				auto token = tokens[pos++];
				FillPosition(constExpr.Ptr());
				if (token.Type == TokenType::IntLiterial)
				{
					constExpr->ConstType = ConstantExpressionSyntaxNode::ConstantType::Int;
					constExpr->IntValue = StringToInt(token.Content);
				}
				else if (token.Type == TokenType::DoubleLiterial)
				{
					constExpr->ConstType = ConstantExpressionSyntaxNode::ConstantType::Float;
					constExpr->FloatValue = (float)StringToDouble(token.Content);
				}
				rs = constExpr;
			}
			else if (LookAheadToken(TokenType::Identifier))
			{
				RefPtr<VarExpressionSyntaxNode> varExpr = new VarExpressionSyntaxNode();
				FillPosition(varExpr.Ptr());
				auto & token = ReadToken(TokenType::Identifier);
				varExpr->Variable = token.Content;
				rs = varExpr;
			}

			while (pos < tokens.Count() &&
				(LookAheadToken(TokenType::OpInc) ||
				LookAheadToken(TokenType::OpDec) ||
				LookAheadToken(TokenType::Dot) ||
				LookAheadToken(TokenType::LBracket) ||
				LookAheadToken(TokenType::LParent)))
			{
				if (LookAheadToken(TokenType::OpInc))
				{
					RefPtr<UnaryExpressionSyntaxNode> unaryExpr = new UnaryExpressionSyntaxNode();
					FillPosition(unaryExpr.Ptr());
					ReadToken(TokenType::OpInc);
					unaryExpr->Operator = Operator::PostInc;
					unaryExpr->Expression = rs;
					rs = unaryExpr;
				}
				else if (LookAheadToken(TokenType::OpDec))
				{
					RefPtr<UnaryExpressionSyntaxNode> unaryExpr = new UnaryExpressionSyntaxNode();
					FillPosition(unaryExpr.Ptr());
					ReadToken(TokenType::OpDec);
					unaryExpr->Operator = Operator::PostDec;
					unaryExpr->Expression = rs;
					rs = unaryExpr;
				}
				else if (LookAheadToken(TokenType::LBracket))
				{
					RefPtr<IndexExpressionSyntaxNode> indexExpr = new IndexExpressionSyntaxNode();
					indexExpr->BaseExpression = rs;
					FillPosition(indexExpr.Ptr());
					ReadToken(TokenType::LBracket);
					indexExpr->IndexExpression = ParseExpression();
					ReadToken(TokenType::RBracket);
					rs = indexExpr;
				}
				else if (LookAheadToken(TokenType::LParent))
				{
					RefPtr<InvokeExpressionSyntaxNode> invokeExpr = new InvokeExpressionSyntaxNode();
					invokeExpr->FunctionExpr = rs;
					if (!invokeExpr->FunctionExpr)
					{
						errors.Add(CompileError(L"syntax error.", 20002, tokens[pos].Position));
					}
					FillPosition(invokeExpr.Ptr());
					ReadToken(TokenType::LParent);
					while (pos < tokens.Count())
					{
						if (!LookAheadToken(TokenType::RParent))
							invokeExpr->Arguments.Add(ParseExpression());
						else
						{
							break;
						}
						
						if (!LookAheadToken(TokenType::Comma))
							break;
						ReadToken(TokenType::Comma);
					}
					ReadToken(TokenType::RParent);
					rs = invokeExpr;
				}
				else if (LookAheadToken(TokenType::Dot))
				{
					RefPtr<MemberExpressionSyntaxNode> memberExpr = new MemberExpressionSyntaxNode();
					FillPosition(memberExpr.Ptr());
					memberExpr->BaseExpression = rs;
					ReadToken(TokenType::Dot); 
					memberExpr->MemberName = ReadToken(TokenType::Identifier).Content;
					rs = memberExpr;
				}
			}
			if (!rs)
			{
				CodePosition codePos;
				if (pos < tokens.Count())
				{
					codePos = tokens[pos].Position;
				}
				errors.Add(CompileError(String(L"syntax error."), 20002, codePos));
				throw 20005;
			}
			return rs;
		}
	}
}

/***********************************************************************
CORE\SCHEDULE.CPP
***********************************************************************/
using namespace CoreLib::Basic;

namespace Spire
{
	namespace Compiler
	{
		class ScheduleParser
		{
		private:
			List<CompileError>& errors;
			List<Token> tokens;
			int pos;
			String fileName;
			Token & ReadToken(const wchar_t * string)
			{
				if (pos >= tokens.Count())
				{
					errors.Add(CompileError(String(L"\"") + string + String(L"\" expected but end of file encountered."), 0, CodePosition(0, 0, fileName)));
					throw 0;
				}
				else if (tokens[pos].Content != string)
				{
					errors.Add(CompileError(String(L"\"") + string + String(L"\" expected"), 0, tokens[pos].Position));
					throw 20001;
				}
				return tokens[pos++];
			}

			Token & ReadToken(TokenType type)
			{
				if (pos >= tokens.Count())
				{
					errors.Add(CompileError(TokenTypeToString(type) + String(L" expected but end of file encountered."), 0, CodePosition(0, 0, fileName)));
					throw 0;
				}
				else if (tokens[pos].Type != type)
				{
					errors.Add(CompileError(TokenTypeToString(type) + String(L" expected"), 20001, tokens[pos].Position));
					throw 20001;
				}
				return tokens[pos++];
			}

			bool LookAheadToken(const wchar_t * string)
			{
				if (pos >= tokens.Count())
				{
					errors.Add(CompileError(String(L"\'") + string + String(L"\' expected but end of file encountered."), 0, CodePosition(0, 0, fileName)));
					return false;
				}
				else
				{
					if (tokens[pos].Content == string)
						return true;
					else
						return false;
				}
			}
		public:
			ScheduleParser(List<CompileError>& _errorList)
				: errors(_errorList)
			{}
			Schedule Parse(String source, String _fileName)
			{
				this->fileName = _fileName;
				Schedule schedule;
				Lexer lex;
				tokens = lex.Parse(fileName, source, errors);
				pos = 0;
				try
				{
					while (pos < tokens.Count())
					{
						if (LookAheadToken(L"attrib"))
						{
							EnumerableDictionary<String, String> additionalAttributes;
							ReadToken(L"attrib");
							String choiceName = ReadToken(TokenType::Identifier).Content;
							while (LookAheadToken(L"."))
							{
								choiceName = choiceName + L".";
								ReadToken(TokenType::Dot);
								choiceName = choiceName + ReadToken(TokenType::Identifier).Content;
							}
							ReadToken(TokenType::OpAssign);

							while (pos < tokens.Count())
							{
								auto name = ReadToken(TokenType::Identifier).Content;
								String value;
								if (LookAheadToken(L":"))
								{
									ReadToken(L":");
									value = ReadToken(TokenType::StringLiterial).Content;
								}
								additionalAttributes[name] = value;
								if (LookAheadToken(L","))
									ReadToken(TokenType::Comma);
								else
									break;
							}
							schedule.AddtionalAttributes[choiceName] = additionalAttributes;
						}
						else
						{
							String choiceName = ReadToken(TokenType::Identifier).Content;
							while (LookAheadToken(L"."))
							{
								choiceName = choiceName + L".";
								ReadToken(TokenType::Dot);
								choiceName = choiceName + ReadToken(TokenType::Identifier).Content;
							}
							ReadToken(TokenType::OpAssign);
							List<RefPtr<ChoiceValueSyntaxNode>> worlds;
							while (pos < tokens.Count())
							{
								auto & token = ReadToken(TokenType::StringLiterial);
								RefPtr<ChoiceValueSyntaxNode> choiceValue = new ChoiceValueSyntaxNode();
								choiceValue->Position = token.Position;
								int splitterPos = token.Content.IndexOf(L':');
								if (splitterPos != -1)
								{
									choiceValue->WorldName = token.Content.SubString(0, splitterPos);
									choiceValue->AlternateName = token.Content.SubString(splitterPos + 1, token.Content.Length() - splitterPos - 1);
								}
								else
								{
									choiceValue->WorldName = token.Content;
								}
								worlds.Add(choiceValue);
								if (LookAheadToken(L","))
									ReadToken(TokenType::Comma);
								else
									break;
							}
							schedule.Choices[choiceName] = worlds;
						}
						ReadToken(TokenType::Semicolon);
					}
				}
				catch (...)
				{
				}
				return schedule;
			}
		};
	
		Schedule Schedule::Parse(String source, String fileName, List<CompileError>& errorList)
		{
			return ScheduleParser(errorList).Parse(source, fileName);
		}
	}
}

/***********************************************************************
CORE\SEMANTICSVISITOR.CPP
***********************************************************************/

namespace Spire
{
	namespace Compiler
	{
		bool IsNumeric(BaseType t)
		{
			return t == BaseType::Int || t == BaseType::Float || t == BaseType::UInt;
		}
		class SemanticsVisitor : public SyntaxVisitor
		{
			ProgramSyntaxNode * program = nullptr;
			FunctionSyntaxNode * function = nullptr;
			FunctionSymbol * currentFunc = nullptr;
			ShaderSymbol * currentShader = nullptr;
			ShaderComponentSymbol * currentComp = nullptr;
			ComponentSyntaxNode * currentCompNode = nullptr;
			List<SyntaxNode *> loops;
			SymbolTable * symbolTable;
		public:
			SemanticsVisitor(SymbolTable * symbols, ErrorWriter * pErr)
				:SyntaxVisitor(pErr), symbolTable(symbols)
			{
			}
			// return true if world0 depends on world1 (there exists a series of import operators that converts world1 variables to world0)
			bool IsWorldDependent(PipelineSymbol * pipeline, String world0, String world1)
			{
				HashSet<String> depWorldsSet;
				List<String> depWorlds;
				depWorlds.Add(world0);
				for (int i = 0; i < depWorlds.Count(); i++)
				{
					auto & dep = pipeline->WorldDependency[world0].GetValue();
					if (dep.Contains(world1))
						return true;
					else
					{
						for (auto w : dep)
							if (depWorldsSet.Add(w))
								depWorlds.Add(w);
					}
				}
				return false;
			}

			void VisitPipeline(PipelineSyntaxNode * pipeline)
			{
				RefPtr<PipelineSymbol> psymbol = new PipelineSymbol();
				psymbol->SyntaxNode = pipeline;
				symbolTable->Pipelines.Add(pipeline->Name.Content, psymbol);
				for (auto world : pipeline->Worlds)
				{
					WorldSymbol worldSym;
					worldSym.IsAbstract = world->IsAbstract;
					worldSym.SyntaxNode = world.Ptr();
					if (!psymbol->Worlds.ContainsKey(world->Name.Content))
					{
						psymbol->Worlds.Add(world->Name.Content, worldSym);
						psymbol->WorldDependency.Add(world->Name.Content, EnumerableHashSet<String>());
						psymbol->ReachableWorlds.Add(world->Name.Content, EnumerableHashSet<String>());
					}
					else
					{
						Error(33001, L"world \'" + world->Name.Content + L"\' is already defined.", world.Ptr());
					}
				}
				for (auto comp : pipeline->AbstractComponents)
				{
					if (comp->IsParam || (comp->Rate && comp->Rate->Worlds.Count() == 1
						&& psymbol->IsAbstractWorld(comp->Rate->Worlds.First().World.Content)))
						AddNewComponentSymbol(psymbol->Components, comp);
					else
						Error(33003, L"cannot define components in a pipeline.",
							comp.Ptr());
				}
				for (auto world : pipeline->Worlds)
				{
					for (auto & varUsing : world->Usings)
					{
						if (!psymbol->Components.ContainsKey(varUsing.Content))
							Error(33043, L"'using': unknown component '" + varUsing.Content + L"\'.", varUsing);
					}
				}
				// add initial world dependency edges
				for (auto op : pipeline->ImportOperators)
				{
					if (!psymbol->WorldDependency.ContainsKey(op->DestWorld.Content))
						Error(33004, L"undefined world name '" + op->DestWorld.Content + L"'.", op->DestWorld);
					else
					{
						if (psymbol->Worlds[op->DestWorld.Content].GetValue().IsAbstract)
							Error(33005, L"abstract world cannot appear as target as an import operator.", op->DestWorld);
						else if (!psymbol->WorldDependency.ContainsKey(op->SourceWorld.Content))
							Error(33006, L"undefined world name '" + op->SourceWorld.Content + L"'.", op->SourceWorld);
						else
						{
							if (IsWorldDependent(psymbol.Ptr(), op->SourceWorld.Content, op->DestWorld.Content))
							{
								Error(33007, L"import operator '" + op->Name.Content + L"' creates a circular dependency between world '" + op->SourceWorld.Content + L"' and '" + op->DestWorld.Content + L"'",
									op->Name);
							}
							else
								psymbol->WorldDependency[op->DestWorld.Content].GetValue().Add(op->SourceWorld.Content);
						}
					}
				
				}
				// propagate world dependency graph
				bool changed = true;
				while (changed)
				{
					changed = false;
					for (auto world : pipeline->Worlds)
					{
						EnumerableHashSet<String> & dependentWorlds = psymbol->WorldDependency[world->Name.Content].GetValue();
						List<String> loopRange;
						for (auto w : dependentWorlds)
							loopRange.Add(w);
						for (auto w : loopRange)
						{
							EnumerableHashSet<String> & ddw = psymbol->WorldDependency[w].GetValue();
							for (auto ww : ddw)
							{
								if (!dependentWorlds.Contains(ww))
								{
									dependentWorlds.Add(ww);
									changed = true;
								}
							}
						}
					}
				}
				// fill in reachable worlds
				for (auto world : psymbol->Worlds)
				{
					if (auto depWorlds = psymbol->WorldDependency.TryGetValue(world.Key))
					{
						for (auto & dep : *depWorlds)
						{
							psymbol->ReachableWorlds[dep].GetValue().Add(world.Key);
						}
					}
				}

				for (auto & op : pipeline->ImportOperators)
				{
					for (auto & dep : op->Usings)
					{
						RefPtr<ShaderComponentSymbol> refComp;
						if (psymbol->Components.TryGetValue(dep.Content, refComp))
						{
							bool invalid = true;
							for (auto & depImpl : refComp->Implementations)
							{
								for (auto & w : depImpl->Worlds)
								{
									if (psymbol->IsWorldReachable(w, op->DestWorld.Content))
									{
										invalid = false;
									}
								}
							}
							if (invalid)
							{
								Error(30039, L"import operator '" + op->Name.Content + L"': none of the definitions for '" + dep.Content + L"' is available to destination world '" + op->DestWorld.Content + L"'.", dep);
							}
						}
						else
							Error(30034, L"import operator reference '" + dep.Content + L"' is not a defined shader component.", dep);

					}
				}
			}

			virtual void VisitImport(ImportSyntaxNode * import) override
			{
				RefPtr<ShaderSymbol> refShader;
				symbolTable->Shaders.TryGetValue(import->ShaderName.Content, refShader);
				if (refShader)
				{
					// type check
					List<ShaderComponentSymbol*> paramList;
					for (auto & comp : refShader->Components)
						if (comp.Value->IsParam())
							paramList.Add(comp.Value.Ptr());
					int position = 0;
					bool namedArgumentAppeared = false;
					for (auto & arg : import->Arguments)
					{
						if (arg->ArgumentName.Content.Length())
							namedArgumentAppeared = true;
						else
						{
							if (namedArgumentAppeared)
							{
								Error(33030, L"positional argument cannot appear after a named argument.", arg->Expression.Ptr());
								break;
							}
							if (position >= paramList.Count())
							{
								Error(33031, L"too many arguments.", arg->Expression.Ptr());
								break;
							}
							arg->ArgumentName.Content = paramList[position]->Name;
							arg->ArgumentName.Position = arg->Position;
						}
						position++;
						arg->Accept(this);
						RefPtr<ShaderComponentSymbol> refComp;
						if (refShader->Components.TryGetValue(arg->ArgumentName.Content, refComp))
						{
							if (refComp->Type->DataType != arg->Expression->Type)
							{
								Error(33027, L"argument type (" + arg->Expression->Type.ToString() + L") does not match parameter type (" + refComp->Type->DataType.ToString() + L")", arg->Expression.Ptr());
							}
							if (!refComp->IsParam())
								Error(33028, L"'" + arg->ArgumentName.Content + L"' is not a parameter of '" + import->ShaderName.Content + L"'.", arg->ArgumentName);
						}
						else
							Error(33028, L"'" + arg->ArgumentName.Content + L"' is not a parameter of '" + import->ShaderName.Content + L"'.", arg->ArgumentName);
					}
				}
			}

			class ShaderImportVisitor : public SyntaxVisitor
			{
			private:
				SymbolTable * symbolTable = nullptr;
				ShaderSymbol * currentShader = nullptr;
				ShaderComponentSymbol * currentComp = nullptr;
			public:
				ShaderImportVisitor(ErrorWriter * writer, SymbolTable * symTable)
					: SyntaxVisitor(writer), symbolTable(symTable)
				{}
				virtual void VisitShader(ShaderSyntaxNode * shader) override
				{
					currentShader = symbolTable->Shaders[shader->Name.Content].GetValue().Ptr();
					SyntaxVisitor::VisitShader(shader);
					currentShader = nullptr;
				}
				virtual void VisitComponent(ComponentSyntaxNode * comp) override
				{
					RefPtr<ShaderComponentSymbol> compSym;
					currentShader->Components.TryGetValue(comp->Name.Content, compSym);
					currentComp = compSym.Ptr();
					SyntaxVisitor::VisitComponent(comp);
					currentComp = nullptr;
				}
				virtual void VisitImport(ImportSyntaxNode * import) override
				{
					RefPtr<ShaderSymbol> refShader;
					symbolTable->Shaders.TryGetValue(import->ShaderName.Content, refShader);
					if (!refShader)
						Error(33015, L"undefined identifier \'" + import->ShaderName.Content + L"\'.", import->ShaderName);
					currentShader->DependentShaders.Add(refShader.Ptr());
					if (!currentComp)
					{
						ShaderUsing su;
						su.Shader = refShader.Ptr();
						su.IsPublic = import->IsPublic;
						if (import->IsInplace)
						{
							currentShader->ShaderUsings.Add(su);
						}
						else
						{
							if (currentShader->ShaderObjects.ContainsKey(import->ObjectName.Content) ||
								currentShader->Components.ContainsKey(import->ObjectName.Content))
							{
								Error(33018, L"\'" + import->ShaderName.Content + L"\' is already defined.", import->ShaderName);
							}
							currentShader->ShaderObjects[import->ObjectName.Content] = su;
						}
					}
					if (currentComp)
						Error(33016, L"'using': importing not allowed in component definition.", import->ShaderName);
				}
			};

			// pass 1: fill components in shader symbol table
			void VisitShaderPass1(ShaderSyntaxNode * shader)
			{
				HashSet<String> inheritanceSet;
				auto curShader = shader;
				inheritanceSet.Add(curShader->Name.Content);
				auto & shaderSymbol = symbolTable->Shaders[curShader->Name.Content].GetValue();
				this->currentShader = shaderSymbol.Ptr();
				if (shader->Pipeline.Content.Length() == 0) // implicit pipeline
				{
					if (program->Pipelines.Count() == 1)
					{
						shader->Pipeline = shader->Name; // get line and col from shader name
						shader->Pipeline.Content = program->Pipelines.First()->Name.Content;
					}
					else
					{
						// current compilation context has more than one pipeline defined,
						// in which case we do not allow implicit pipeline specification
						Error(33002, L"explicit pipeline specification required for shader '" +
							shader->Name.Content + L"' because multiple pipelines are defined in current context.", curShader->Name);
					}
				}
				
				auto pipelineName = shader->Pipeline.Content;
				auto pipeline = symbolTable->Pipelines.TryGetValue(pipelineName);
				if (pipeline)
					shaderSymbol->Pipeline = pipeline->Ptr();
				else
				{
					Error(33010, L"pipeline \'" + pipelineName + L"' is not defined.", shader->Pipeline);
					throw 0;
				}
				if (shader->IsModule)
					shaderSymbol->IsAbstract = true;
				// add components to symbol table
				for (auto & mbr : shader->Members)
				{
					if (auto comp = dynamic_cast<ComponentSyntaxNode*>(mbr.Ptr()))
					{
						if (comp->IsParam)
						{
							shaderSymbol->IsAbstract = true;
							if (!shaderSymbol->SyntaxNode->IsModule)
							{
								Error(33009, L"parameters can only be defined in modules.", shaderSymbol->SyntaxNode);
							}
						}
						AddNewComponentSymbol(shaderSymbol->Components, mbr);
					}
				}
				// add shader objects to symbol table
				ShaderImportVisitor importVisitor(err, symbolTable);
				shader->Accept(&importVisitor);

				for (auto & comp : shaderSymbol->Components)
				{
					for (auto & impl : comp.Value->Implementations)
					{
						bool inAbstractWorld = false;
						if (impl->SyntaxNode->Rate)
						{
							auto & userSpecifiedWorlds = impl->SyntaxNode->Rate->Worlds;
							for (auto & world : userSpecifiedWorlds)
							{
								if (!shaderSymbol->Pipeline->WorldDependency.ContainsKey(world.World.Content))
									Error(33012, L"\'" + world.World.Content + L"' is not a defined world in '" +
										pipelineName + L"'.", world.World);
								WorldSymbol worldSym;

								if (shaderSymbol->Pipeline->Worlds.TryGetValue(world.World.Content, worldSym))
								{
									if (worldSym.IsAbstract)
									{
										inAbstractWorld = true;
										if (userSpecifiedWorlds.Count() > 1)
										{
											Error(33013, L"abstract world cannot appear with other worlds.",
												world.World);
										}
									}
								}
							}
						}
						if (!inAbstractWorld && !impl->SyntaxNode->IsParam
							&& !impl->SyntaxNode->Expression && !impl->SyntaxNode->BlockStatement)
						{
							Error(33014, L"non-abstract component must have an implementation.",
								impl->SyntaxNode.Ptr());
						}
					}
				}
				this->currentShader = nullptr;
			}
			// pass 2: type checking component definitions
			void VisitShaderPass2(ShaderSyntaxNode * shaderNode)
			{
				RefPtr<ShaderSymbol> shaderSym;
				if (!symbolTable->Shaders.TryGetValue(shaderNode->Name.Content, shaderSym))
					return;
				this->currentShader = shaderSym.Ptr();
				for (auto & comp : shaderNode->Members)
				{
					comp->Accept(this);
				}
				this->currentShader = nullptr;
			}

			bool MatchType_ValueReceiver(ExpressionType receiverType, ExpressionType valueType)
			{
				if (receiverType == valueType)
					return true;
				if (receiverType.IsIntegral() && valueType == ExpressionType::Int)
					return true;
				if (receiverType == ExpressionType::Float && valueType.IsIntegral())
					return true;
				if (receiverType.IsVectorType() && valueType.IsVectorType())
				{
					if (GetVectorBaseType(receiverType.BaseType) == BaseType::Float &&
						GetVectorSize(receiverType.BaseType) == GetVectorSize(valueType.BaseType))
						return true;
					if (GetVectorBaseType(receiverType.BaseType) == BaseType::UInt &&
						GetVectorBaseType(valueType.BaseType) == BaseType::Int &&
						GetVectorSize(receiverType.BaseType) == GetVectorSize(valueType.BaseType))
						return true;
				}
				return false;
			}
			virtual void VisitComponent(ComponentSyntaxNode * comp) override
			{
				this->currentCompNode = comp;
				RefPtr<ShaderComponentSymbol> compSym;
				currentShader->Components.TryGetValue(comp->Name.Content, compSym);
				this->currentComp = compSym.Ptr();
				if (comp->Expression)
				{
					comp->Expression->Accept(this);
					if (!MatchType_ValueReceiver(compSym->Type->DataType, comp->Expression->Type) && comp->Expression->Type != ExpressionType::Error)
						Error(30019, L"type mismatch \'" + comp->Expression->Type.ToString() + L"\' and \'" +
							currentComp->Type->DataType.ToString() + L"\'", comp->Name);
				}
				if (comp->BlockStatement)
					comp->BlockStatement->Accept(this);
				this->currentComp = nullptr;
				this->currentCompNode = nullptr;
			}
			virtual void VisitImportStatement(ImportStatementSyntaxNode * importStmt) override
			{
				importStmt->Import->Accept(this);
			}
			void AddNewComponentSymbol(EnumerableDictionary<String, RefPtr<ShaderComponentSymbol>> & components, RefPtr<ComponentSyntaxNode> comp)
			{
				RefPtr<ShaderComponentSymbol> compSym;
				RefPtr<ShaderComponentImplSymbol> compImpl = new ShaderComponentImplSymbol();
				if (comp->Rate)
					for (auto w : comp->Rate->Worlds)
						compImpl->Worlds.Add(w.World.Content);
				compImpl->SyntaxNode = comp;
				if (compImpl->SyntaxNode->Rate)
				{
					for (auto & w : compImpl->SyntaxNode->Rate->Worlds)
						if (w.Pinned)
							compImpl->SrcPinnedWorlds.Add(w.World.Content);
				}
				if (compImpl->SyntaxNode->AlternateName.Type == TokenType::Identifier)
				{
					compImpl->AlternateName = compImpl->SyntaxNode->AlternateName.Content;
				}
				if (compImpl->SyntaxNode->IsOutput)
				{
					if (compImpl->SyntaxNode->Rate)
					{
						for (auto & w : compImpl->SyntaxNode->Rate->Worlds)
							compImpl->ExportWorlds.Add(w.World.Content);
					}
					else
					{
						Error(33019, L"component \'" + compImpl->SyntaxNode->Name.Content + L"\': definition marked as 'export' must have an explicitly specified world.",
							compImpl->SyntaxNode.Ptr());
					}
				}
				if (!components.TryGetValue(comp->Name.Content, compSym))
				{
					compSym = new ShaderComponentSymbol();
					compSym->Type = new Type();
					compSym->Name = comp->Name.Content;
					compSym->Type->DataType = comp->Type->ToExpressionType(symbolTable, err);
					components.Add(comp->Name.Content, compSym);
				}
				else
				{
					if (comp->IsParam)
						Error(33029, L"\'" + compImpl->SyntaxNode->Name.Content + L"\': requirement clash with previous definition.",
							compImpl->SyntaxNode.Ptr());
					symbolTable->CheckComponentImplementationConsistency(err, compSym.Ptr(), compImpl.Ptr());
				}
				compSym->Implementations.Add(compImpl);
			}
			virtual void VisitProgram(ProgramSyntaxNode * programNode) override
			{
				HashSet<String> funcNames;
				this->program = programNode;
				this->function = nullptr;
				for (auto & s : program->Structs)
				{
					RefPtr<StructSymbol> ssym = new StructSymbol();
					ssym->Name = s->Name.Content;
					ssym->SyntaxNode = s;
					ssym->Type = new ILStructType();
					symbolTable->Structs.Add(s->Name.Content, ssym);
				}
				for (auto & s : program->Structs)
					VisitStruct(s.Ptr());
				for (auto & pipeline : program->Pipelines)
				{
					VisitPipeline(pipeline.Ptr());
				}
				for (auto & func : program->Functions)
				{
					VisitFunctionDeclaration(func.Ptr());
					if (funcNames.Contains(func->InternalName))
					{
						StringBuilder argList;
						argList << L"(";
						for (auto & param : func->Parameters)
						{
							argList << param->Type->ToExpressionType(symbolTable, err).ToString();
							if (param != func->Parameters.Last())
								argList << L", ";
						}
						argList << L")";
						Error(30001, L"function \'" + func->Name + argList.ProduceString() + L"\' redefinition.", func.Ptr());
					}
					else
						funcNames.Add(func->InternalName);
				}
				for (auto & func : program->Functions)
				{
					func->Accept(this);
				}
				// build initial symbol table for shaders
				for (auto & shader : program->Shaders)
				{
					RefPtr<ShaderSymbol> shaderSym = new ShaderSymbol();
					shaderSym->SyntaxNode = shader.Ptr();
					if (symbolTable->Shaders.ContainsKey(shader->Name.Content))
					{
						Error(33018, L"shader '" + shader->Name.Content + "' has already been defined.", shader->Name);
					}
					symbolTable->Shaders[shader->Name.Content] = shaderSym;
				}
				HashSet<ShaderSyntaxNode*> validShaders;
				for (auto & shader : program->Shaders)
				{
					int lastErrorCount = err->GetErrorCount();
					VisitShaderPass1(shader.Ptr());
					if (err->GetErrorCount() == lastErrorCount)
						validShaders.Add(shader.Ptr());
				}
				if (err->GetErrorCount() != 0)
					return;
				// shader dependency is discovered in pass 1, we can now sort the shaders
				if (!symbolTable->SortShaders())
				{
					HashSet<ShaderSymbol*> sortedShaders;
					for (auto & shader : symbolTable->ShaderDependenceOrder)
						sortedShaders.Add(shader);
					for (auto & shader : symbolTable->Shaders)
						if (!sortedShaders.Contains(shader.Value.Ptr()))
						{
							Error(33011, L"shader '" + shader.Key + L"' involves circular reference.", shader.Value->SyntaxNode->Name);
						}
				}

				for (auto & shader : symbolTable->ShaderDependenceOrder)
				{
					if (!validShaders.Contains(shader->SyntaxNode))
						continue;
					int lastErrorCount = err->GetErrorCount();
					VisitShaderPass2(shader->SyntaxNode);
					if (err->GetErrorCount() != lastErrorCount)
						validShaders.Remove(shader->SyntaxNode);
				}
				// update symbol table with only valid shaders
				EnumerableDictionary<String, RefPtr<ShaderSymbol>> newShaderSymbols;
				for (auto & shader : symbolTable->Shaders)
				{
					if (validShaders.Contains(shader.Value->SyntaxNode))
						newShaderSymbols.AddIfNotExists(shader.Key, shader.Value);
				}
				symbolTable->Shaders = _Move(newShaderSymbols);
			}

			virtual void VisitStruct(StructSyntaxNode * structNode) override
			{
				RefPtr<StructSymbol> st;
				if (symbolTable->Structs.TryGetValue(structNode->Name.Content, st))
				{
					st->Type->TypeName = structNode->Name.Content;
					for (auto node : structNode->Fields)
					{
						ILStructType::ILStructField f;
						f.FieldName = node->Name.Content;
						f.Type = TranslateExpressionType(node->Type->ToExpressionType(symbolTable, err));
						st->Type->Members.Add(f);
					}
				}
			}

			virtual void VisitFunction(FunctionSyntaxNode *functionNode) override
			{
				if (!functionNode->IsExtern)
				{
					currentFunc = symbolTable->Functions.TryGetValue(functionNode->InternalName)->Ptr();
					this->function = functionNode;
					functionNode->Body->Accept(this);
					this->function = NULL;
					currentFunc = nullptr;
				}
				
			}
			void VisitFunctionDeclaration(FunctionSyntaxNode *functionNode)
			{
				this->function = functionNode;
				auto returnType = functionNode->ReturnType->ToExpressionType(symbolTable, err);
				if(returnType.BaseType == BaseType::Void && returnType.IsArray)
					Error(30024, L"function return type can not be 'void' array.", functionNode->ReturnType.Ptr());
				StringBuilder internalName;
				internalName << functionNode->Name;
				HashSet<String> paraNames;
				for (auto & para : functionNode->Parameters)
				{
					if (paraNames.Contains(para->Name))
						Error(30002, L"parameter \'" + para->Name + L"\' already defined.", para.Ptr());
					else
						paraNames.Add(para->Name);
					VariableEntry varEntry;
					varEntry.Name = para->Name;
					varEntry.Type.DataType = para->Type->ToExpressionType(symbolTable, err);
					functionNode->Scope->Variables.AddIfNotExists(varEntry.Name, varEntry);
					if (varEntry.Type.DataType.BaseType == BaseType::Void)
						Error(30016, L"'void' can not be parameter type.", para.Ptr());
					internalName << L"@" << varEntry.Type.DataType.ToString();
				}
				functionNode->InternalName = internalName.ProduceString();	
				RefPtr<FunctionSymbol> symbol = new FunctionSymbol();
				symbol->SyntaxNode = functionNode;
				symbolTable->Functions[functionNode->InternalName] = symbol;
				this->function = NULL;
			}
			
			virtual void VisitBlockStatement(BlockStatementSyntaxNode *stmt) override
			{
				for (auto & node : stmt->Statements)
				{
					node->Accept(this);
				}
			}
			virtual void VisitBreakStatement(BreakStatementSyntaxNode *stmt) override
			{
				if (!loops.Count())
					Error(30003, L"'break' must appear inside loop constructs.", stmt);
			}
			virtual void VisitContinueStatement(ContinueStatementSyntaxNode *stmt) override
			{
				if (!loops.Count())
					Error(30004, L"'continue' must appear inside loop constructs.", stmt);
			}
			virtual void VisitDoWhileStatement(DoWhileStatementSyntaxNode *stmt) override
			{
				loops.Add(stmt);
				if (stmt->Predicate != NULL)
					stmt->Predicate->Accept(this);
				if (stmt->Predicate->Type != ExpressionType::Error && stmt->Predicate->Type != ExpressionType::Int && stmt->Predicate->Type != ExpressionType::Bool)
					Error(30005, L"'while': expression must evaluate to int.", stmt);
				stmt->Statement->Accept(this);

				loops.RemoveAt(loops.Count() - 1);
			}
			virtual void VisitEmptyStatement(EmptyStatementSyntaxNode *) override {}
			virtual void VisitForStatement(ForStatementSyntaxNode *stmt) override
			{
				loops.Add(stmt);
				VariableEntry iterVar;
				if (stmt->TypeDef != nullptr)
				{
					VariableEntry varEntry;
					varEntry.IsComponent = false;
					varEntry.Name = stmt->IterationVariable.Content;
					varEntry.Type.DataType = stmt->TypeDef->ToExpressionType(symbolTable, err);
					stmt->Scope->Variables.AddIfNotExists(stmt->IterationVariable.Content, varEntry);
				}
				if (!stmt->Scope->FindVariable(stmt->IterationVariable.Content, iterVar))
					Error(30015, L"undefined identifier \'" + stmt->IterationVariable.Content + L"\'", stmt->IterationVariable);
				else
				{
					if (iterVar.Type.DataType != ExpressionType::Float && iterVar.Type.DataType != ExpressionType::Int)
						Error(30035, L"iteration variable \'" + stmt->IterationVariable.Content + L"\' can only be a int or float", stmt->IterationVariable);
					stmt->InitialExpression->Accept(this);
					if (stmt->InitialExpression->Type != iterVar.Type.DataType)
						Error(30019, L"type mismatch \'" + stmt->InitialExpression->Type.ToString() + L"\' and \'" +
							iterVar.Type.DataType.ToString() + L"\'", stmt->InitialExpression.Ptr());
					stmt->EndExpression->Accept(this);
					if (stmt->EndExpression->Type != iterVar.Type.DataType)
						Error(30019, L"type mismatch \'" + stmt->EndExpression->Type.ToString() + L"\' and \'" +
							iterVar.Type.DataType.ToString() + L"\'", stmt->EndExpression.Ptr());
					if (stmt->StepExpression != nullptr)
					{
						stmt->StepExpression->Accept(this);
						if (stmt->StepExpression->Type != iterVar.Type.DataType)
							Error(30019, L"type mismatch \'" + stmt->StepExpression->Type.ToString() + L"\' and \'" +
								iterVar.Type.DataType.ToString() + L"\'", stmt->StepExpression.Ptr());
					}
				}

				stmt->Statement->Accept(this);

				loops.RemoveAt(loops.Count() - 1);
			}
			virtual void VisitIfStatement(IfStatementSyntaxNode *stmt) override
			{
				if (stmt->Predicate != NULL)
					stmt->Predicate->Accept(this);
				if (stmt->Predicate->Type != ExpressionType::Error && (stmt->Predicate->Type != ExpressionType::Int && stmt->Predicate->Type != ExpressionType::Bool))
					Error(30006, L"'if': expression must evaluate to int.", stmt);

				if (stmt->PositiveStatement != NULL)
					stmt->PositiveStatement->Accept(this);
				
				if (stmt->NegativeStatement != NULL)
					stmt->NegativeStatement->Accept(this);
			}
			virtual void VisitReturnStatement(ReturnStatementSyntaxNode *stmt) override
			{
				if (currentCompNode && currentCompNode->BlockStatement->Statements.Count() &&
					stmt != currentCompNode->BlockStatement->Statements.Last().Ptr())
				{
					Error(30026, L"'return' can only appear as the last statement in component definition.", stmt);
				}
				if (!stmt->Expression)
				{
					if (function && function->ReturnType->ToExpressionType(symbolTable, err) != ExpressionType::Void)
						Error(30006, L"'return' should have an expression.", stmt);
				}
				else
				{
					stmt->Expression->Accept(this);
					if (stmt->Expression->Type != ExpressionType::Error)
					{
						if (function && !MatchType_ValueReceiver(function->ReturnType->ToExpressionType(symbolTable, err), stmt->Expression->Type))
							Error(30007, L"expression type '" + stmt->Expression->Type.ToString()
								+ L"' does not match function's return type '"
								+ function->ReturnType->ToExpressionType(symbolTable, err).ToString() + L"'", stmt);
						if (currentComp && !MatchType_ValueReceiver(currentComp->Type->DataType, stmt->Expression->Type))
						{
							Error(30007, L"expression type '" + stmt->Expression->Type.ToString()
								+ L"' does not match component's type '"
								+ currentComp->Type->DataType.ToString() + L"'", stmt);
						}
					}
				}
			}
			virtual void VisitVarDeclrStatement(VarDeclrStatementSyntaxNode *stmt) override
			{
				if (stmt->Type->ToExpressionType(symbolTable, err).IsTextureType())
				{
					Error(30033, L"cannot declare a local variable of 'texture' type.", stmt);
				}
				for (auto & para : stmt->Variables)
				{
					VariableEntry varDeclr;
					varDeclr.Name = para->Name;
					if (stmt->Scope->Variables.ContainsKey(para->Name))
						Error(30008, L"variable " + para->Name + L" already defined.", para.Ptr());

					varDeclr.Type.DataType = stmt->Type->ToExpressionType(symbolTable, err);
					if (varDeclr.Type.DataType.BaseType == BaseType::Void)
						Error(30009, L"invalid type 'void'.", stmt);
					if (varDeclr.Type.DataType.IsArray && varDeclr.Type.DataType.ArrayLength <= 0)
						Error(30025, L"array size must be larger than zero.", stmt);

					stmt->Scope->Variables.AddIfNotExists(para->Name, varDeclr);
					if (para->Expression != NULL)
					{
						para->Expression->Accept(this);
						if (!MatchType_ValueReceiver(varDeclr.Type.DataType, para->Expression->Type)
							&& para->Expression->Type != ExpressionType::Error)
						{
							Error(30019, L"type mismatch \'" + para->Expression->Type.ToString() + L"\' and \'" +
								varDeclr.Type.DataType.ToString() + L"\'", para.Ptr());
						}
					}
				}
			}
			virtual void VisitWhileStatement(WhileStatementSyntaxNode *stmt) override
			{
				loops.Add(stmt);
				stmt->Predicate->Accept(this);
				if (stmt->Predicate->Type != ExpressionType::Error && stmt->Predicate->Type != ExpressionType::Int && stmt->Predicate->Type != ExpressionType::Bool)
					Error(30010, L"'while': expression must evaluate to int.", stmt);

				stmt->Statement->Accept(this);
				loops.RemoveAt(loops.Count() - 1);
			}
			virtual void VisitExpressionStatement(ExpressionStatementSyntaxNode *stmt) override
			{
				stmt->Expression->Accept(this);
			}
			virtual void VisitBinaryExpression(BinaryExpressionSyntaxNode *expr) override
			{
				expr->LeftExpression->Accept(this);
				expr->RightExpression->Accept(this);
				auto & leftType = expr->LeftExpression->Type;
				auto & rightType = expr->RightExpression->Type;
				switch (expr->Operator)
				{
				case Operator::Add:
				case Operator::Sub:
				case Operator::Div:
					if (leftType == rightType && !leftType.IsArray && !leftType.IsTextureType() && leftType.BaseType != BaseType::Shader)
						expr->Type = leftType;
					else if (leftType.IsVectorType() && rightType == GetVectorBaseType(leftType.BaseType))
						expr->Type = leftType;
					else if (rightType.IsVectorType() && leftType == GetVectorBaseType(rightType.BaseType))
						expr->Type = rightType;
					else if ((rightType == ExpressionType::Float && leftType == ExpressionType::Int) ||
						(leftType == ExpressionType::Float && leftType == ExpressionType::Int))
						expr->Type = ExpressionType::Float;
					else if (leftType.IsIntegral() && rightType.IsIntegral())
						expr->Type = ExpressionType::Int;
					else
						expr->Type = ExpressionType::Error;
					break;
				case Operator::Mul:
					if (!leftType.IsArray && leftType.BaseType != BaseType::Shader)
					{
						if (leftType == rightType && !leftType.IsTextureType())
							expr->Type = leftType;
						else if ((leftType.BaseType == BaseType::Float3x3 && rightType == ExpressionType::Float3) ||
							(leftType.BaseType == BaseType::Float3 && rightType.BaseType == BaseType::Float3x3))
							expr->Type = ExpressionType::Float3;
						else if ((leftType.BaseType == BaseType::Float4x4 && rightType == ExpressionType::Float4) ||
							(leftType.BaseType == BaseType::Float4 && rightType.BaseType == BaseType::Float4x4))
							expr->Type = ExpressionType::Float4;
						else if (leftType.IsVectorType() && rightType == GetVectorBaseType(leftType.BaseType))
							expr->Type = leftType;
						else if (rightType.IsVectorType() && leftType == GetVectorBaseType(rightType.BaseType))
							expr->Type = rightType;
						else if ((rightType == ExpressionType::Float && leftType == ExpressionType::Int) ||
							(leftType == ExpressionType::Float && rightType == ExpressionType::Int))
							expr->Type = ExpressionType::Float;
						else
							expr->Type = ExpressionType::Error;
					}
					else
						expr->Type = ExpressionType::Error;
					break;
				case Operator::Mod:
				case Operator::Rsh:
				case Operator::Lsh:
				case Operator::BitAnd:
				case Operator::BitOr:
				case Operator::BitXor:
				case Operator::And:
				case Operator::Or:
					if (leftType == rightType && !leftType.IsArray && !IsTextureType(GetVectorBaseType(leftType.BaseType))
						&& leftType.BaseType != BaseType::Shader &&
						GetVectorBaseType(leftType.BaseType) != BaseType::Float)
						expr->Type = (expr->Operator == Operator::And || expr->Operator == Operator::Or ? ExpressionType::Bool : leftType);
					else if (leftType.IsIntegral() && rightType.IsIntegral())
						expr->Type = leftType;
					else
						expr->Type = ExpressionType::Error;
					break;
				case Operator::Neq:
				case Operator::Eql:
					if (leftType == rightType && !leftType.IsArray && !leftType.IsTextureType() && leftType.BaseType != BaseType::Shader)
						expr->Type = ExpressionType::Bool;
					else if ((leftType == ExpressionType::Int || leftType == ExpressionType::UInt) &&
						(rightType == ExpressionType::Int || rightType == ExpressionType::UInt))
						expr->Type = ExpressionType::Bool;
					else
						expr->Type = ExpressionType::Error;
					break;
				case Operator::Greater:
				case Operator::Geq:
				case Operator::Less:
				case Operator::Leq:
					if ((leftType == ExpressionType::Int || leftType == ExpressionType::UInt) && 
						(rightType == ExpressionType::Int || rightType == ExpressionType::UInt))
						expr->Type = ExpressionType::Bool;
					else if (leftType == ExpressionType::Float && rightType == ExpressionType::Float)
						expr->Type = ExpressionType::Bool;
					else
						expr->Type = ExpressionType::Error;
					break;
				case Operator::Assign:
				case Operator::AddAssign:
				case Operator::MulAssign:
				case Operator::DivAssign:
				case Operator::SubAssign:
				case Operator::ModAssign:
					if (!leftType.IsLeftValue && leftType != ExpressionType::Error)
						Error(30011, L"left of '=' is not an l-value.", expr->LeftExpression.Ptr());
					expr->LeftExpression->Access = ExpressionAccess::Write;
					if (MatchType_ValueReceiver(leftType, rightType))
						expr->Type = ExpressionType::Void;
					else
						expr->Type = ExpressionType::Error;
					break;
				default:
						expr->Type = ExpressionType::Error;
					break;
				}
				
				if (expr->Type == ExpressionType::Error &&
					leftType != ExpressionType::Error && rightType != ExpressionType::Error)
					Error(30012, L"no overload found for operator " + OperatorToString(expr->Operator)  + L" (" + leftType.ToString() + L", " + rightType.ToString() + L").", expr);
			}
			virtual void VisitConstantExpression(ConstantExpressionSyntaxNode *expr) override
			{
				switch (expr->ConstType)
				{
				case ConstantExpressionSyntaxNode::ConstantType::Int:
					expr->Type = ExpressionType::Int;
					break;
				case ConstantExpressionSyntaxNode::ConstantType::Float:
					expr->Type = ExpressionType::Float;
					break;
				default:
					expr->Type = ExpressionType::Error;
					throw "Invalid constant type.";
					break;
				}
			}
			virtual void VisitIndexExpression(IndexExpressionSyntaxNode *expr) override
			{
				expr->BaseExpression->Accept(this);
				expr->IndexExpression->Accept(this);
				if (expr->BaseExpression->Type == ExpressionType::Error)
					expr->Type = ExpressionType::Error;
				else
				{
					if (expr->BaseExpression->Type.IsArray &&
						GetVectorSize(expr->BaseExpression->Type.BaseType) == 0)
					{
						Error(30013, L"'[]' can only index on arrays and strings.", expr);
						expr->Type = ExpressionType::Error;
					}
					if (expr->IndexExpression->Type != ExpressionType::Int && expr->IndexExpression->Type != ExpressionType::UInt)
					{
						Error(30014, L"index expression must evaluate to int.", expr);
						expr->Type = ExpressionType::Error;
					}
				}
				if (expr->BaseExpression->Type.IsArray)
				{
					expr->Type = expr->BaseExpression->Type;
					expr->Type.IsArray = false;
					expr->Type.ArrayLength = 0;
				}
				else
				{
					if (expr->BaseExpression->Type.BaseType == BaseType::Float3x3)
						expr->Type.BaseType = BaseType::Float3;
					else if (expr->BaseExpression->Type.BaseType == BaseType::Float4x4)
						expr->Type.BaseType = BaseType::Float4;
					else
						expr->Type.BaseType = GetVectorBaseType(expr->BaseExpression->Type.BaseType);
				}
				expr->Type.IsLeftValue = true;
				expr->Type.IsReference = true;
			}
			bool MatchArguments(FunctionSyntaxNode * functionNode, List <RefPtr<ExpressionSyntaxNode>> &args)
			{
				if (functionNode->Parameters.Count() != args.Count())
					return false;
				for (int i = 0; i < functionNode->Parameters.Count(); i++)
				{
					if (functionNode->Parameters[i]->Type->ToExpressionType(symbolTable, err) != args[i]->Type)
						return false;
				}
				return true;
			}
			virtual void VisitInvokeExpression(InvokeExpressionSyntaxNode *expr) override
			{
				StringBuilder internalName;
				StringBuilder argList;
				internalName << expr->FunctionExpr->Variable;
				argList << L"(";
				for (int i = 0; i < expr->Arguments.Count(); i++)
				{
					expr->Arguments[i]->Accept(this);
					internalName << L"@" << expr->Arguments[i]->Type.ToString();
					argList << expr->Arguments[i]->Type.ToString();
					if (i != expr->Arguments.Count() - 1)
					{
						argList << L", ";
					}
					if (expr->Arguments[i]->Type == ExpressionType::Error)
					{
						expr->Type = ExpressionType::Error;
						return;
					}
				}
				argList << L")";
				String funcName = internalName.ProduceString();
				RefPtr<FunctionSymbol> func;
				bool found = symbolTable->Functions.TryGetValue(funcName, func);
				if (!found)
				{
					// find function overload with explicit conversions from int -> float
					auto namePrefix = expr->FunctionExpr->Variable + L"@";
					for (auto & f : symbolTable->Functions)
					{
						if (f.Key.StartsWith(namePrefix))
						{
							if (f.Value->SyntaxNode->Parameters.Count() == expr->Arguments.Count())
							{
								bool match = true;
								for (int i = 0; i < expr->Arguments.Count(); i++)
								{
									auto argType = expr->Arguments[i]->Type;
									auto paramType = f.Value->SyntaxNode->Parameters[i]->Type->ToExpressionType(symbolTable, err);
									if (argType == paramType)
										continue;
									else if (MatchType_ValueReceiver(paramType, argType))
										continue;
									else
									{
										match = false;
										break;
									}
								}
								if (match)
								{
									func = f.Value;
									funcName = f.Key;
									found = true;
								}
							}
						}
					}
				}

				if (!found)
				{
					expr->Type = ExpressionType::Error;
					Error(30021, expr->FunctionExpr->Variable + L": no overload takes arguments " + argList.ProduceString(), expr);
				}
				else
				{
					if (!func->SyntaxNode->IsExtern)
					{
						expr->FunctionExpr->Variable = funcName;
						if (currentFunc)
							currentFunc->ReferencedFunctions.Add(funcName);
					}
					expr->Type = func->SyntaxNode->ReturnType->ToExpressionType(symbolTable, err);
				}
			}

			String OperatorToString(Operator op)
			{
				switch (op)
				{
				case Spire::Compiler::Operator::Neg:
					return L"-";
				case Spire::Compiler::Operator::Not:
					return L"!";
				case Spire::Compiler::Operator::PreInc:
					return L"++";
				case Spire::Compiler::Operator::PreDec:
					return L"--";
				case Spire::Compiler::Operator::PostInc:
					return L"++";
				case Spire::Compiler::Operator::PostDec:
					return L"--";
				case Spire::Compiler::Operator::Mul:
					return L"*";
				case Spire::Compiler::Operator::Div:
					return L"/";
				case Spire::Compiler::Operator::Mod:
					return L"%";
				case Spire::Compiler::Operator::Add:
					return L"+";
				case Spire::Compiler::Operator::Sub:
					return L"-";
				case Spire::Compiler::Operator::Lsh:
					return L"<<";
				case Spire::Compiler::Operator::Rsh:
					return L">>";
				case Spire::Compiler::Operator::Eql:
					return L"==";
				case Spire::Compiler::Operator::Neq:
					return L"!=";
				case Spire::Compiler::Operator::Greater:
					return L">";
				case Spire::Compiler::Operator::Less:
					return L"<";
				case Spire::Compiler::Operator::Geq:
					return L">=";
				case Spire::Compiler::Operator::Leq:
					return L"<=";
				case Spire::Compiler::Operator::BitAnd:
					return L"&";
				case Spire::Compiler::Operator::BitXor:
					return L"^";
				case Spire::Compiler::Operator::BitOr:
					return L"|";
				case Spire::Compiler::Operator::And:
					return L"&&";
				case Spire::Compiler::Operator::Or:
					return L"||";
				case Spire::Compiler::Operator::Assign:
					return L"=";
				default:
					return L"ERROR";
				}
			}
			virtual void VisitUnaryExpression(UnaryExpressionSyntaxNode *expr) override
			{
				expr->Expression->Accept(this);
				
				switch (expr->Operator)
				{
				case Operator::Neg:
					if (expr->Expression->Type == ExpressionType::Int ||
						expr->Expression->Type == ExpressionType::Bool ||
						expr->Expression->Type == ExpressionType::Float ||
						expr->Expression->Type.IsVectorType())
						expr->Type = expr->Expression->Type;
					else
						expr->Type = ExpressionType::Error;
					break;
				case Operator::Not:
				case Operator::BitNot:
					if (expr->Expression->Type == ExpressionType::Int || expr->Expression->Type == ExpressionType::Bool ||
						expr->Expression->Type == ExpressionType::Int2
						|| expr->Expression->Type == ExpressionType::Int3 || expr->Expression->Type == ExpressionType::Int4)
						expr->Type = (expr->Operator == Operator::Not ? ExpressionType::Bool : expr->Expression->Type);
					else
						expr->Type = ExpressionType::Error;
					break;
				case Operator::PostDec:
				case Operator::PostInc:
				case Operator::PreDec:
				case Operator::PreInc:
					if (expr->Expression->Type == ExpressionType::Int)
						expr->Type = ExpressionType::Int;
					else
						expr->Type = ExpressionType::Error;
					break;
				default:
					expr->Type = ExpressionType::Error;
					break;
				}

				if(expr->Type == ExpressionType::Error && expr->Expression->Type != ExpressionType::Error)
					Error(30020, L"operator " + OperatorToString(expr->Operator) + L" can not be applied to " + expr->Expression->Type.ToString(), expr);
			}
			virtual void VisitVarExpression(VarExpressionSyntaxNode *expr) override
			{
				VariableEntry variable;
				ShaderUsing shaderObj;
				if (expr->Scope->FindVariable(expr->Variable, variable))
				{
					expr->Type = variable.Type.DataType;
					expr->Type.IsLeftValue = !variable.IsComponent;
				}
				else if (currentShader && currentShader->ShaderObjects.TryGetValue(expr->Variable, shaderObj))
				{
					expr->Type.BaseType = BaseType::Shader;
					expr->Type.Shader = shaderObj.Shader;
					expr->Type.IsLeftValue = false;
				}
				else
				{
					if (currentShader)
					{
						auto compRef = currentShader->ResolveComponentReference(expr->Variable);
						if (compRef.IsAccessible)
						{
							expr->Type = compRef.Component->Type->DataType;
							expr->Type.IsLeftValue = false;
						}
						else if (compRef.Component)
						{
							Error(30017, L"component \'" + expr->Variable + L"\' is not accessible from shader '" + currentShader->SyntaxNode->Name.Content + L"'.", expr);
						}
						else
							Error(30015, L"undefined identifier \'" + expr->Variable + L"\'", expr);
					}
					else
						Error(30015, L"undefined identifier \'" + expr->Variable + L"\'", expr);
				}
			}
			virtual void VisitTypeCastExpression(TypeCastExpressionSyntaxNode * expr) override
			{
				expr->Expression->Accept(this);
				auto targetType = expr->TargetType->ToExpressionType(symbolTable, err);
				
				if (expr->Expression->Type != ExpressionType::Error)
				{
					if (expr->Expression->Type.IsArray)
						expr->Type = ExpressionType::Error;
					else if (!IsNumeric(GetVectorBaseType(expr->Expression->Type.BaseType)) || !IsNumeric(GetVectorBaseType(targetType.BaseType)))
						expr->Type = ExpressionType::Error;
					else if (targetType.BaseType == BaseType::Void || expr->Expression->Type.BaseType == BaseType::Void)
						expr->Type = ExpressionType::Error;
					else
						expr->Type = targetType;
				}
				else
					expr->Type = ExpressionType::Error;
				if (expr->Type == ExpressionType::Error && expr->Expression->Type != ExpressionType::Error)
				{
					Error(30022, L"invalid type cast between \"" + expr->Expression->Type.ToString() + L"\" and \"" +
						targetType.ToString() + L"\".", expr);
				}
			}
			virtual void VisitSelectExpression(SelectExpressionSyntaxNode * expr) override
			{
				expr->SelectorExpr->Accept(this);
				if ((expr->SelectorExpr->Type != ExpressionType::Int && expr->SelectorExpr->Type != ExpressionType::Bool) && expr->SelectorExpr->Type != ExpressionType::Error)
				{
					expr->Type = ExpressionType::Error;
					Error(30079, L"selector must evaluate to int.", expr);
				}
				expr->Expr0->Accept(this);
				expr->Expr1->Accept(this);
				if (expr->Expr0->Type != expr->Expr1->Type)
				{
					Error(30080, L"the two value expressions in a select clause must evaluate to same type.", expr);
				}
				expr->Type = expr->Expr0->Type;
			}
			virtual void VisitMemberExpression(MemberExpressionSyntaxNode * expr) override
			{
				expr->BaseExpression->Accept(this);
				auto & baseType = expr->BaseExpression->Type;
				if (baseType.IsArray)
					expr->Type = ExpressionType::Error;
				else if (IsVector(baseType.BaseType))
				{
					Array<int, 4> children;
					if (expr->MemberName.Length() > 4)
						expr->Type = ExpressionType::Error;
					else
					{
						bool error = false;

						for (int i = 0; i < expr->MemberName.Length(); i++)
						{
							auto ch = expr->MemberName[i];
							switch (ch)
							{
							case L'x':
							case L'r':
								children.Add(0);
								break;
							case L'y':
							case L'g':
								children.Add(1);
								break;
							case L'z':
							case L'b':
								children.Add(2);
								break;
							case L'w':
							case L'a':
								children.Add(3);
								break;
							default:
								error = true;
								expr->Type = ExpressionType::Error;
								break;
							}
						}
						int vecLen = GetVectorSize(baseType.BaseType);
						for (auto m : children)
						{
							if (m >= vecLen)
							{
								error = true;
								expr->Type = ExpressionType::Error;
								break;
							}
						}
						if ((vecLen == 9 || vecLen == 16) && children.Count() > 1)
						{
							error = true;
							expr->Type = ExpressionType::Error;
						}
						if (!error)
						{
							expr->Type = baseType;
							if (vecLen == 9)
								expr->Type.BaseType = (BaseType)((int)GetVectorBaseType(baseType.BaseType) + 2);
							else if (vecLen == 16)
								expr->Type.BaseType = (BaseType)((int)GetVectorBaseType(baseType.BaseType) + 15);
							else
							{
								expr->Type.BaseType = (BaseType)((int)GetVectorBaseType(baseType.BaseType) + children.Count() - 1);
							}
						}
						expr->Type.IsLeftValue = true;
					}
				}
				else if (baseType.BaseType == BaseType::Shader)
				{
					ShaderUsing shaderObj;
					auto refComp = baseType.Shader->ResolveComponentReference(expr->MemberName);
					if (refComp.IsAccessible)
						expr->Type = refComp.Component->Type->DataType;
					else if (baseType.Shader->ShaderObjects.TryGetValue(expr->MemberName, shaderObj))
					{
						if (shaderObj.IsPublic)
						{
							expr->Type.BaseType = BaseType::Shader;
							expr->Type.Shader = shaderObj.Shader;
						}
						else
							expr->Type = ExpressionType::Error;
					}
					else
						expr->Type = ExpressionType::Error;
				}
				else if (baseType.BaseType == BaseType::Struct && baseType.Struct)
				{
					int id = baseType.Struct->SyntaxNode->FindField(expr->MemberName);
					if (id == -1)
					{
						expr->Type = ExpressionType::Error;
						Error(30027, L"\'" + expr->MemberName + L"\' is not a member of \'" +
							baseType.Struct->Name + L"\'.", expr);
					}
					else
						expr->Type = baseType.Struct->SyntaxNode->Fields[id]->Type->ToExpressionType(symbolTable, err);
				}
				else
					expr->Type = ExpressionType::Error;
				if (baseType != ExpressionType::Error &&
					expr->Type == ExpressionType::Error)
				{
					Error(30023, L"\"" + baseType.ToString() + L"\" does not have public member \"" +
						expr->MemberName + L"\".", expr);
				}
			}
			virtual void VisitParameter(ParameterSyntaxNode *) override {}
			virtual void VisitType(TypeSyntaxNode *) override {}
			virtual void VisitDeclrVariable(Variable *) override {}
			SemanticsVisitor & operator = (const SemanticsVisitor &) = delete;
		};

		SyntaxVisitor * CreateSemanticsVisitor(SymbolTable * symbols, ErrorWriter * err)
		{
			return new SemanticsVisitor(symbols, err);
		}
		
	}
}

/***********************************************************************
CORE\SHADERCOMPILER.CPP
***********************************************************************/
// Compiler.cpp : Defines the entry point for the console application.
//

#ifdef CreateDirectory
#undef CreateDirectory
#endif

using namespace CoreLib::Basic;
using namespace CoreLib::IO;
using namespace Spire::Compiler;

namespace Spire
{
	namespace Compiler
	{
		class ShaderCompilerImpl : public ShaderCompiler
		{
		private:
			Dictionary<String, RefPtr<CodeGenBackend>> backends;
			Dictionary<String, Dictionary<String, ImportOperatorHandler *>> opHandlers;
			Dictionary<String, Dictionary<String, ExportOperatorHandler *>> exportHandlers;

			void ResolveAttributes(SymbolTable * symTable)
			{
				for (auto & shader : symTable->ShaderDependenceOrder)
				{
					auto comps = shader->GetComponentDependencyOrder();
					for (auto & comp : comps)
					{
						for (auto & impl : comp->Implementations)
							for (auto & attrib : impl->SyntaxNode->LayoutAttributes)
							{
								try
								{
									if (attrib.Value.StartsWith(L"%"))
									{
										CoreLib::Text::Parser parser(attrib.Value.SubString(1, attrib.Value.Length() - 1));
										auto compName = parser.ReadWord();
										parser.Read(L".");
										auto compAttrib = parser.ReadWord();
										RefPtr<ShaderComponentSymbol> compSym;
										if (shader->Components.TryGetValue(compName, compSym))
										{
											for (auto & timpl : compSym->Implementations)
											{
												String attribValue;
												if (timpl->SyntaxNode->LayoutAttributes.TryGetValue(compAttrib, attribValue))
													attrib.Value = attribValue;
											}
										}
									}
								}
								catch (Exception)
								{
								}
							}
					}
				}
			}

			/* Generate a shader variant by applying mechanic choice rules and the choice file.
			   The choice file provides "preferred" definitions, as represented in ShaderComponentSymbol::Type::PinnedWorlds
		       The process resolves the component references by picking a pinned definition if one is available, or a definition
			   with the preferred import path as defined by import operator ordering.
			   After all references are resolved, all unreferenced definitions (dead code) are eliminated, 
			   resulting a shader variant ready for code generation.
			*/
			RefPtr<ShaderIR> GenerateShaderVariantIR(CompileResult & cresult, ShaderClosure * shader, Schedule & schedule)
			{
				RefPtr<ShaderIR> result = new ShaderIR();
				result->Shader = shader;
				// mark pinned worlds
				for (auto & comp : shader->Components)
				{
					for (auto & impl : comp.Value->Implementations)
					{
						for (auto & w : impl->Worlds)
						{
							if (impl->SrcPinnedWorlds.Contains(w) || impl->SyntaxNode->IsInline || impl->ExportWorlds.Contains(w))
							{
								comp.Value->Type->PinnedWorlds.Add(w);
							}
						}
					}
				}
				// apply choices
				Dictionary<String, ShaderComponentSymbol*> choiceComps;
				for (auto & comp : shader->AllComponents)
				{
					for (auto & choiceName : comp.Value->ChoiceNames)
						choiceComps[choiceName] = comp.Value;
				}
				HashSet<ShaderComponentImplSymbol*> pinnedImpl;
				for (auto & choice : schedule.Choices)
				{
					ShaderComponentSymbol * comp = nullptr;
					if (choiceComps.TryGetValue(choice.Key, comp))
					{
						comp->Type->PinnedWorlds.Clear();
						for (auto & selectedDef : choice.Value)
						{
							if (comp->Type->ConstrainedWorlds.Contains(selectedDef->WorldName))
							{
								comp->Type->PinnedWorlds.Add(selectedDef->WorldName);
								// find specified impl
								for (auto & impl : comp->Implementations)
								{
									if (impl->AlternateName == selectedDef->AlternateName && impl->Worlds.Contains(selectedDef->WorldName))
										pinnedImpl.Add(impl.Ptr());
								}
							}
							else
							{
								cresult.GetErrorWriter()->Warning(33101, L"'" + selectedDef->WorldName + L"' is not a valid choice for '" + choice.Key
									+ L"'.", selectedDef.Ptr()->Position);
							}
						}
					}
				}
				for (auto & attribs : schedule.AddtionalAttributes)
				{
					ShaderComponentSymbol * comp = nullptr;
					if (choiceComps.TryGetValue(attribs.Key, comp))
					{
						// apply attributes
						for (auto & impl : comp->Implementations)
						{
							for (auto & attrib : attribs.Value)
								impl->SyntaxNode->LayoutAttributes[attrib.Key] = attrib.Value;
						}
					}
				}
				// generate definitions
				for (auto & comp : shader->AllComponents)
				{
					EnumerableDictionary<String, ComponentDefinitionIR*> defs;
					for (auto & impl : comp.Value->Implementations)
					{
						for (auto & w : impl->Worlds)
						{
							RefPtr<ComponentDefinitionIR> def = new ComponentDefinitionIR();
							def->Component = comp.Value;
							def->Implementation = impl.Ptr();
							def->World = w;
							result->Definitions.Add(def);
							bool existingDefIsPinned = false;
							if (auto existingDef = defs.TryGetValue(w))
								existingDefIsPinned = pinnedImpl.Contains((*existingDef)->Implementation);
							if (!existingDefIsPinned)
								defs[w] = def.Ptr();
						}
					}
					result->DefinitionsByComponent[comp.Key] = defs;
				}
				bool changed = true;
				while (changed)
				{
					changed = false;
					result->ResolveComponentReference();
					result->EliminateDeadCode();
					// check circular references
					for (auto & def : result->Definitions)
					{
						if (def->Dependency.Contains(def.Ptr()))
						{
							cresult.GetErrorWriter()->Error(33102, L"component definition \'" + def->Component->Name + L"\' involves circular reference.",
								def->Implementation->SyntaxNode->Position);
							return nullptr;
						}
					}
					/*
					// eliminate redundant (downstream) definitions, one at a time
					auto comps = result->GetComponentDependencyOrder();
					for (int i = comps.Count() - 1; i >= 0; i--)
					{
						auto comp = comps[i];
						auto & defs = result->DefinitionsByComponent[comp->UniqueName]();
						EnumerableHashSet<ComponentDefinitionIR*> removedDefs;
						for (auto & def : defs)
							if (!def.Value->IsEntryPoint && !comp->Type->PinnedWorlds.Contains(def.Value->World))
							{
								for (auto & otherDef : defs)
								{
									if (otherDef.Value != def.Value && !removedDefs.Contains(otherDef.Value)
										&& shader->Pipeline->IsWorldReachable(otherDef.Value->World, def.Value->World))
									{
										removedDefs.Add(def.Value);
										break;
									}
								}
							}
						if (removedDefs.Count())
						{
							result->RemoveDefinitions([&](ComponentDefinitionIR* def) {return removedDefs.Contains(def); });
							changed = true;
						}
					}
					*/
				}
				return result;
			}
		public:
			virtual CompileUnit Parse(CompileResult & result, String source, String fileName) override
			{
				result.Success = false;
				Lexer lexer;
				auto tokens = lexer.Parse(fileName, source, result.ErrorList);
				Parser parser(tokens, result.ErrorList, fileName);
				CompileUnit rs;
				rs.SyntaxNode = parser.Parse();
				return rs;
			}
			virtual void Compile(CompileResult & result, List<CompileUnit> & units, const CompileOptions & options) override
			{
				result.Success = false;
				RefPtr<ProgramSyntaxNode> programSyntaxNode = new ProgramSyntaxNode();
				for (auto & unit : units)
				{
					programSyntaxNode->Include(unit.SyntaxNode.Ptr());
				}

				SymbolTable symTable;
				RefPtr<SyntaxVisitor> visitor = CreateSemanticsVisitor(&symTable, result.GetErrorWriter());
				try
				{
					programSyntaxNode->Accept(visitor.Ptr());
					visitor = nullptr;
					if (result.ErrorList.Count() > 0)
						return;
					symTable.EvalFunctionReferenceClosure();
					if (result.ErrorList.Count() > 0)
						return;
					List<RefPtr<ShaderClosure>> shaderClosures;

					for (auto & shader : symTable.ShaderDependenceOrder)
					{
						if (shader->IsAbstract)
							continue;
						auto shaderClosure = CreateShaderClosure(result.GetErrorWriter(), &symTable, shader);
						FlattenShaderClosure(result.GetErrorWriter(), shaderClosure.Ptr());
						shaderClosures.Add(shaderClosure);
					}
					
					ResolveAttributes(&symTable);

					if (result.ErrorList.Count() > 0)
						return;

					Schedule schedule;
					if (options.ScheduleSource != L"")
					{
						schedule = Schedule::Parse(options.ScheduleSource, options.ScheduleFileName, result.ErrorList);
					}
					for (auto shader : shaderClosures)
					{
						// generate shader variant from schedule file, and also apply mechanic deduction rules
						shader->IR = GenerateShaderVariantIR(result, shader.Ptr(), schedule);
					}
					if (options.Mode == CompilerMode::ProduceShader)
					{
						if (result.ErrorList.Count() > 0)
							return;
						// generate IL code
						RefPtr<ICodeGenerator> codeGen = CreateCodeGenerator(&symTable, result);
						for (auto & s : programSyntaxNode->Structs)
							codeGen->ProcessStruct(s.Ptr());
						for (auto & func : programSyntaxNode->Functions)
							codeGen->ProcessFunction(func.Ptr());
						for (auto & shader : shaderClosures)
							codeGen->ProcessShader(shader.Ptr());
						if (result.ErrorList.Count() > 0)
							return;
						// emit target code
						EnumerableHashSet<String> symbolsToGen;
						for (auto & unit : units)
						{
							for (auto & shader : unit.SyntaxNode->Shaders)
								if (!shader->IsModule)
									symbolsToGen.Add(shader->Name.Content);
							for (auto & func : unit.SyntaxNode->Functions)
								symbolsToGen.Add(func->Name);
						}
						auto IsSymbolToGen = [&](String & shaderName)
						{
							if (symbolsToGen.Contains(shaderName))
								return true;
							for (auto & symbol : symbolsToGen)
								if (shaderName.StartsWith(symbol))
									return true;
							return false;
						};
						for (auto & shader : result.Program->Shaders)
						{
							if ((options.SymbolToCompile.Length() == 0 && IsSymbolToGen(shader->MetaData.ShaderName))
								|| options.SymbolToCompile == shader->MetaData.ShaderName)
							{
								StringBuilder glslBuilder;
								Dictionary<String, String> targetCode;
								result.CompiledSource[shader->MetaData.ShaderName + L".glsl"] = EnumerableDictionary<String, CompiledShaderSource>();
								auto & worldSources = result.CompiledSource[shader->MetaData.ShaderName + L".glsl"]();
								for (auto & world : shader->Worlds)
								{
									if (world.Value->IsAbstract)
										continue;
									RefPtr<CodeGenBackend> backend;
									if (!backends.TryGetValue(world.Value->TargetMachine, backend))
									{
										result.GetErrorWriter()->Error(40000, L"backend '" + world.Value->TargetMachine + L"' is not supported.",
											world.Value->WorldDefPosition);
									}
									else
									{
										auto args = world.Value->BackendParameters;
										for (auto & arg : options.BackendArguments)
											args[arg.Key] = args[arg.Value];
										backend->SetParameters(args);
										Dictionary<String, ImportOperatorHandler*> importHandlers;
										Dictionary<String, ExportOperatorHandler*> beExportHandlers;

										opHandlers.TryGetValue(world.Value->TargetMachine, importHandlers);
										exportHandlers.TryGetValue(world.Value->TargetMachine, beExportHandlers);

										worldSources[world.Key] = backend->GenerateShaderWorld(result, &symTable, world.Value.Ptr(), importHandlers, beExportHandlers);
									}
								}
							}
						}
						result.Success = result.ErrorList.Count() == 0;
					}
					else if (options.Mode == CompilerMode::GenerateChoice)
					{
						for (auto shader : shaderClosures)
						{
							if (options.SymbolToCompile.Length() == 0 || shader->Name == options.SymbolToCompile)
							{
								auto &worldOrder = shader->Pipeline->GetWorldTopologyOrder();
								for (auto & comp : shader->AllComponents)
								{
									ShaderChoice choice;
									if (comp.Value->ChoiceNames.Count() == 0)
										continue;
									if (comp.Value->IsParam())
										continue;
									choice.ChoiceName = comp.Value->ChoiceNames.First();
									for (auto & impl : comp.Value->Implementations)
									{
										for (auto w : impl->Worlds)
											if (comp.Value->Type->ConstrainedWorlds.Contains(w))
												choice.Options.Add(ShaderChoiceValue(w, impl->AlternateName));
									}
									if (auto defs = shader->IR->DefinitionsByComponent.TryGetValue(comp.Key))
									{
										int latestWorldOrder = -1;
										for (auto & def : *defs)
										{
											int order = worldOrder.IndexOf(def.Key);
											if (latestWorldOrder < order)
											{
												choice.DefaultValue = def.Key;
												latestWorldOrder = order;
											}
										}
									}
									result.Choices.Add(choice);
								}
							}
						}
					}
					else
					{
						result.GetErrorWriter()->Error(2, L"unsupported compiler mode.", CodePosition());
						return;
					}
					result.Success = true;
				}
				catch (int)
				{
				}
				catch (...)
				{
					throw;
				}
				return;
			}

			virtual void RegisterImportOperator(String backendName, ImportOperatorHandler * handler) override
			{
				if (!opHandlers.ContainsKey(backendName))
					opHandlers[backendName] = Dictionary<String, ImportOperatorHandler*>();
				opHandlers[backendName]().Add(handler->GetName(), handler);
			}

			virtual void RegisterExportOperator(String backendName, ExportOperatorHandler * handler) override
			{
				if (!exportHandlers.ContainsKey(backendName))
					exportHandlers[backendName] = Dictionary<String, ExportOperatorHandler*>();
				exportHandlers[backendName]().Add(handler->GetName(), handler);
			}

			ShaderCompilerImpl()
			{
				backends.Add(L"glsl", CreateGLSLCodeGen());
				backends.Add(L"spirv", CreateSpirVCodeGen());
			}
		};

		ShaderCompiler * CreateShaderCompiler()
		{
			return new ShaderCompilerImpl();
		}

	}
}

/***********************************************************************
CORE\SPIRVCODEGEN.CPP
***********************************************************************/

using namespace CoreLib::Basic;

namespace Spire
{
	namespace Compiler
	{
		class SpirVCodeGen : public CodeGenBackend
		{
			virtual CompiledShaderSource GenerateShaderWorld(CompileResult & /*result*/, SymbolTable * /*symbols*/, CompiledWorld * /*shader*/, 
				Dictionary<String, ImportOperatorHandler*>& /*opHandlers*/, Dictionary<String, ExportOperatorHandler*>& /*exportHandlers*/) override
			{
				return CompiledShaderSource();
			}
			virtual void SetParameters(const EnumerableDictionary<String, String>& /*arguments*/) override
			{
			}
		};

		CodeGenBackend * CreateSpirVCodeGen()
		{
			return new SpirVCodeGen();
		}
	}
}

/***********************************************************************
CORE\STDINCLUDE.CPP
***********************************************************************/

const wchar_t * VertexShaderIncludeString = LR"(
__builtin out vec4 gl_Position;
)";

const wchar_t * LibIncludeString = LR"(
__intrinsic float dFdx(float v);
__intrinsic float dFdy(float v);
__intrinsic float fwidth(float v);
__intrinsic vec2 dFdx(vec2 v);
__intrinsic vec2 dFdy(vec2 v);
__intrinsic vec2 fwidth(vec2 v);
__intrinsic vec3 dFdx(vec3 v);
__intrinsic vec3 dFdy(vec3 v);
__intrinsic vec3 fwidth(vec3 v);
__intrinsic vec4 dFdx(vec4 v);
__intrinsic vec4 dFdy(vec4 v);
__intrinsic vec4 fwidth(vec4 v);

__intrinsic vec3 normalize(vec3 v);
__intrinsic float dot(vec2 v0, vec2 v1);
__intrinsic float dot(vec3 v0, vec3 v1);
__intrinsic float dot(vec4 v0, vec4 v1);
__intrinsic float sin(float v);
__intrinsic float cos(float v);
__intrinsic float tan(float v);
__intrinsic float sqrt(float v);
__intrinsic vec2 sin(vec2 v);
__intrinsic vec2 cos(vec2 v);
__intrinsic vec2 tan(vec2 v);
__intrinsic vec2 sqrt(vec2 v);
__intrinsic vec3 sin(vec3 v);
__intrinsic vec3 cos(vec3 v);
__intrinsic vec3 tan(vec3 v);
__intrinsic vec3 sqrt(vec3 v);
__intrinsic vec4 sin(vec4 v);
__intrinsic vec4 cos(vec4 v);
__intrinsic vec4 tan(vec4 v);
__intrinsic vec4 sqrt(vec4 v);
__intrinsic float abs(float v);
__intrinsic vec2 abs(vec2 v);
__intrinsic vec3 abs(vec3 v);
__intrinsic vec4 abs(vec4 v);
__intrinsic float exp(float v);
__intrinsic float log(float v);
__intrinsic float exp2(float v);
__intrinsic float log2(float v);
__intrinsic float asin(float v);
__intrinsic float acos(float v);
__intrinsic float atan(float v);
__intrinsic float sign(float x);
__intrinsic float pow(float base, float e);
__intrinsic vec2 pow(vec2 base, vec2 e);
__intrinsic vec3 pow(vec3 base, vec3 e);
__intrinsic vec4 pow(vec4 base, vec4 e);
__intrinsic float atan2(float x, float y);
__intrinsic float floor(float v);
__intrinsic vec2 floor(vec2 v);
__intrinsic vec3 floor(vec3 v);
__intrinsic vec4 floor(vec4 v);
__intrinsic float fract(float v);
__intrinsic vec2 fract(vec2 v);
__intrinsic vec3 fract(vec3 v);
__intrinsic vec4 fract(vec4 v);
__intrinsic float ceil(float v);
__intrinsic vec2 ceil(vec2 v);
__intrinsic vec3 ceil(vec3 v);
__intrinsic vec4 ceil(vec4 v);
__intrinsic float step(float v, float y);
__intrinsic vec2 step(vec2 v, vec2 v1);
__intrinsic vec3 step(vec3 v, vec3 v1);
__intrinsic vec4 step(vec4 v, vec4 v1);
__intrinsic float smoothstep(float e0, float e1, float v);
__intrinsic vec2 smoothstep(vec2 e0, vec2 e1, vec2 v);
__intrinsic vec3 smoothstep(vec3 e0, vec3 e1, vec3 v);
__intrinsic vec4 smoothstep(vec4 e0, vec4 e1, vec4 v);
__intrinsic vec4 texture(sampler2D tex, vec2 coord);
__intrinsic vec4 texture(samplerCube tex, vec3 coord);
__intrinsic vec4 texture(sampler2D tex, vec2 coord, vec2 dPdx, vec2 dPdy);
__intrinsic vec4 textureGrad(sampler2D tex, vec2 coord, vec2 dPdx, vec2 dPdy);
__intrinsic vec4 textureGrad(samplerCube tex, vec3 coord, vec3 dPdx, vec3 dPdy);
__intrinsic vec4 texture(samplerCube tex, vec3 coord, float bias);
__intrinsic float texture(sampler2DShadow tex, vec3 coord);
__intrinsic float texture(samplerCubeShadow tex, vec4 coord);
__intrinsic float textureProj(sampler2DShadow tex, vec4 coord);
__intrinsic float textureProj(samplerCubeShadow tex, vec4 coord);
__intrinsic float diff(float v);
__intrinsic float mod(float x, float y);
__intrinsic float max(float v);
__intrinsic float min(float v);
__intrinsic float max(float v, float v1);
__intrinsic float min(float v, float v1);
__intrinsic vec2 max(vec2 v, vec2 v1);
__intrinsic vec2 min(vec2 v, vec2 v1);
__intrinsic vec3 max(vec3 v, vec3 v1);
__intrinsic vec3 min(vec3 v, vec3 v1);
__intrinsic vec4 max(vec4 v, vec4 v1);
__intrinsic vec4 min(vec4 v, vec4 v1);
__intrinsic float clamp(float v, float v1, float v2);
__intrinsic vec2 clamp(vec2 v, vec2 v1, vec2 v2);
__intrinsic vec3 clamp(vec3 v, vec3 v1, vec3 v2);
__intrinsic vec4 clamp(vec4 v, vec4 v1, vec4 v2);

__intrinsic vec3 reflect(vec3 I, vec3 N);
__intrinsic vec3 reflect(vec3 I, vec3 N, float eta);

__intrinsic float length(vec2 v);
__intrinsic float length(vec3 v);
__intrinsic float length(vec4 v);

__intrinsic void alphaTest(float alpha, float threshold);
__intrinsic vec3 mix(vec3 v0, vec3 v1, float t);
__intrinsic vec4 mix(vec4 v0, vec4 v1, float t);
__intrinsic vec2 mix(vec2 v0, vec2 v1, float t);
__intrinsic float mix(float v0, float v1, float t);
__intrinsic vec3 mix(vec3 v0, vec3 v1, vec3 t);
__intrinsic vec4 mix(vec4 v0, vec4 v1, vec4 t);
__intrinsic vec2 mix(vec2 v0, vec2 v1, vec2 t);
__intrinsic mat3 mat3(vec3 a, vec3 b, vec3 c);
__intrinsic mat3 mat3(float a0, float a1, float a2, float a3, float a4, float a5, float a6, float a7, float a8);
__intrinsic vec3 cross(vec3 v1, vec3 v2);
__intrinsic vec2 vec2(float v);
__intrinsic vec3 vec3(float v);
__intrinsic vec4 vec4(float v);
__intrinsic vec2 vec2(float x, float y);
__intrinsic vec3 vec3(float x, float y, float z);
__intrinsic vec3 vec3(vec2 v, float z);
__intrinsic vec4 vec4(float x, float y, float z, float w);
__intrinsic vec4 vec4(vec3 v, float w);
__intrinsic vec4 vec4(vec2 v, float z, float w);
__intrinsic vec4 vec4(vec2 v, vec2 w);
__intrinsic ivec2 ivec2(int x, int y);
__intrinsic ivec3 ivec3(int x, int y, int z);
__intrinsic ivec3 ivec3(ivec2 v, int z);
__intrinsic ivec4 ivec4(int x, int y, int z, int w);
__intrinsic ivec4 ivec4(ivec3 v, int w);
__intrinsic ivec4 ivec4(ivec2 v, int z, int w);
__intrinsic ivec4 ivec4(ivec2 v, ivec2 w);
__intrinsic int int(uint val);
__intrinsic int int(float val);
__intrinsic uint uint(uint val);
__intrinsic uint uint(float val);
__intrinsic float float(int val);
__intrinsic float float(uint val);

__intrinsic mat3 transpose(mat3 in);
__intrinsic mat4 transpose(mat4 in);
#line_reset#
)";

/***********************************************************************
CORE\SYMBOLTABLE.CPP
***********************************************************************/

namespace Spire
{
	namespace Compiler
	{
		bool SymbolTable::SortShaders()
		{
			HashSet<ShaderSymbol*> shaderSet;
			ShaderDependenceOrder.Clear();
			List<ShaderSymbol *> nextShaders, currentShaders;
			// sort shaders in dependency order
			for (auto & shader : Shaders)
			{
				if (shader.Value->DependentShaders.Count() == 0)
				{
					ShaderDependenceOrder.Add(shader.Value.Ptr());
					shaderSet.Add(shader.Value.Ptr());
				}
				else
					currentShaders.Add(shader.Value.Ptr());
			}
			while (currentShaders.Count())
			{
				nextShaders.Clear();
				for (auto & shader : currentShaders)
				{
					bool pass = true;
					for (auto & dshader : shader->DependentShaders)
						if (!shaderSet.Contains(dshader))
						{
							pass = false;
							break;
						}
					if (pass)
					{
						ShaderDependenceOrder.Add(shader);
						shaderSet.Add(shader);
					}
					else
						nextShaders.Add(shader);
				}
				currentShaders.SwapWith(nextShaders);
			}
			return (ShaderDependenceOrder.Count() == Shaders.Count());
		}
		void SymbolTable::EvalFunctionReferenceClosure()
		{
			for (auto & func : Functions)
			{
				List<String> funcList;
				EnumerableHashSet<String> funcSet;
				for (auto & ref : func.Value->ReferencedFunctions)
				{
					funcList.Add(ref);
					funcSet.Add(ref);
				}
				for (int i = 0; i < funcList.Count(); i++)
				{
					RefPtr<FunctionSymbol> funcSym;
					if (Functions.TryGetValue(funcList[i], funcSym))
					{
						for (auto rfunc : funcSym->ReferencedFunctions)
						{
							if (funcSet.Add(rfunc))
								funcList.Add(rfunc);
						}
					}
				}
				func.Value->ReferencedFunctions = _Move(funcSet);
			}
		}

		bool PipelineSymbol::IsAbstractWorld(String world)
		{
			WorldSymbol ws;
			if (Worlds.TryGetValue(world, ws))
				return ws.IsAbstract;
			return false;
		}

		bool PipelineSymbol::IsWorldReachable(String src, String targetWorld)
		{
			if (src == targetWorld)
				return true;
			if (ReachableWorlds.ContainsKey(src))
				if (ReachableWorlds[src]().Contains(targetWorld))
					return true;
			return false;
		}

		bool PipelineSymbol::IsWorldDirectlyReachable(String src, String targetWorld)
		{
			if (src == targetWorld)
				return true;
			for (auto & op : SyntaxNode->ImportOperators)
				if (op->SourceWorld.Content == src && op->DestWorld.Content == targetWorld)
					return true;
			return false;
		}

		List<String>& PipelineSymbol::GetWorldTopologyOrder()
		{
			if (WorldTopologyOrder.Count() != 0)
				return WorldTopologyOrder;
			List<String> rs;
			HashSet<String> rsSet;
			bool changed = true;
			while (changed)
			{
				changed = false;
				for (auto & w : WorldDependency)
				{
					if (!rsSet.Contains(w.Key))
					{
						bool canAdd = true;
						for (auto & dw : w.Value)
							if (!rsSet.Contains(dw))
							{
								canAdd = false;
								break;
							}
						if (canAdd)
						{
							rsSet.Add(w.Key);
							rs.Add(w.Key);
							changed = true;
						}
					}
				}
			}
			WorldTopologyOrder = _Move(rs);
			return WorldTopologyOrder;
		}
		
		bool PipelineSymbol::IsWorldReachable(EnumerableHashSet<String>& src, String targetWorld)
		{
			for (auto srcW : src)
			{
				if (srcW == targetWorld)
					return true;
				if (ReachableWorlds.ContainsKey(srcW))
					if (ReachableWorlds[srcW]().Contains(targetWorld))
						return true;
			}
			return false;
		}
		
		List<ImportPath> PipelineSymbol::FindImportOperatorChain(String worldSrc, String worldDest)
		{
			List<ImportPath> resultPathes;
			if (worldSrc == worldDest)
				return resultPathes;
			List<ImportPath> pathes, pathes2;
			pathes.Add(ImportPath());
			pathes[0].Nodes.Add(ImportPath::Node(worldSrc, nullptr));
			while (pathes.Count())
			{
				pathes2.Clear();
				for (auto & p : pathes)
				{
					String world0 = p.Nodes.Last().TargetWorld;
					for (auto op : SyntaxNode->ImportOperators)
					{
						if (op->SourceWorld.Content == world0)
						{
							ImportPath np = p;
							np.Nodes.Add(ImportPath::Node(op->DestWorld.Content, op.Ptr()));
							if (op->DestWorld.Content == worldDest)
								resultPathes.Add(np);
							else
								pathes2.Add(np);
						}
					}
				}
				pathes.SwapWith(pathes2);
			}
			return resultPathes;
		}
		List<ImportOperatorDefSyntaxNode*> PipelineSymbol::GetImportOperatorsFromSourceWorld(String worldSrc)
		{
			List<ImportOperatorDefSyntaxNode*> rs;
			for (auto & op : this->SyntaxNode->ImportOperators)
			{
				if (op->SourceWorld.Content == worldSrc)
					rs.Add(op.Ptr());
			}
			return rs;
		}
		List<ShaderComponentSymbol*> ShaderSymbol::GetComponentDependencyOrder()
		{
			List<ShaderComponentSymbol*> components;

			for (auto & comp : Components)
			{
				components.Add(comp.Value.Ptr());
			}
			SortComponents(components);
			return components;
		}
		void ShaderSymbol::SortComponents(List<ShaderComponentSymbol*>& comps)
		{
			comps.Sort([&](ShaderComponentSymbol*c0, ShaderComponentSymbol*c1)
			{
				return c0->Implementations.First()->SyntaxNode->Position < c1->Implementations.First()->SyntaxNode->Position;
			});
			HashSet<ShaderComponentSymbol*> allSymbols, addedSymbols;
			for (auto & comp : comps)
				allSymbols.Add(comp);
			List<ShaderComponentSymbol*> sorted;
			bool changed = true;
			while (changed)
			{
				changed = false;
				for (auto & comp : comps)
				{
					if (!addedSymbols.Contains(comp))
					{
						bool isFirst = true;
						for (auto & impl : comp->Implementations)
							for (auto & dep : impl->DependentComponents)
								if (allSymbols.Contains(dep) && !addedSymbols.Contains(dep))
								{
									isFirst = false;
									goto loopEnd;
								}
					loopEnd:;
						if (isFirst)
						{
							addedSymbols.Add(comp);
							sorted.Add(comp);
							changed = true;
						}
					}
				}
			}
			comps = _Move(sorted);
		}

		ShaderSymbol::ComponentReference ShaderSymbol::ResolveComponentReference(String compName, bool topLevel)
		{
			ComponentReference result;
			result.IsAccessible = true;
			RefPtr<ShaderComponentSymbol> refComp, privateRefComp;
			if (Components.TryGetValue(compName, refComp))
			{
				result.Component = refComp.Ptr();
				return result;
			}
			for (auto & shaderUsing : ShaderUsings)
			{
				if (shaderUsing.Shader->Components.TryGetValue(compName, refComp))
				{
					if (refComp->Implementations.First()->SyntaxNode->IsPublic)
					{
						result.Component = refComp.Ptr();
						result.IsAccessible = true;
						return result;
					}
					else
					{
						result.Component = refComp.Ptr();
						result.IsAccessible = false;
					}
				}
				else if (shaderUsing.IsPublic || topLevel)
				{
					auto rresult = shaderUsing.Shader->ResolveComponentReference(compName, false);
					if (rresult.IsAccessible)
						return rresult;
					else
						result = rresult;
				}
			}
			result.IsAccessible = false;
			return result;
		}

		void ShaderIR::EliminateDeadCode()
		{
			// mark entry points
			auto MarkUsing = [&](String compName, String userWorld)
			{
				if (auto defs = DefinitionsByComponent.TryGetValue(compName))
				{
					if (auto def = defs->TryGetValue(userWorld))
						(*def)->IsEntryPoint = true;
					else
					{
						for (auto & world : Shader->Pipeline->WorldDependency[userWorld]())
						{
							if (auto def2 = defs->TryGetValue(world))
							{
								(*def2)->IsEntryPoint = true;
								break;
							}
						}
					}
				}
			};
			for (auto & impOp : Shader->Pipeline->SyntaxNode->ImportOperators)
				for (auto & ref : impOp->Usings)
					MarkUsing(ref.Content, impOp->DestWorld.Content);
			for (auto & w : Shader->Pipeline->SyntaxNode->Worlds)
				for (auto & ref : w->Usings)
					MarkUsing(ref.Content, w->Name.Content);
			for (auto & comp : Definitions)
				if (comp->Implementation->ExportWorlds.Contains(comp->World) ||
					(Shader->Pipeline->IsAbstractWorld(comp->World) &&
					(comp->Implementation->SyntaxNode->LayoutAttributes.ContainsKey(L"Pinned") || Shader->Pipeline->Worlds[comp->World]().SyntaxNode->LayoutAttributes.ContainsKey(L"Pinned"))))
				{
					comp->IsEntryPoint = true;
				}

			List<ComponentDefinitionIR*> workList;
			HashSet<ComponentDefinitionIR*> referencedDefs;
			for (auto & def : Definitions)
			{
				if (def->IsEntryPoint)
				{
					if (referencedDefs.Add(def.Ptr()))
						workList.Add(def.Ptr());
				}
			}
			for (int i = 0; i < workList.Count(); i++)
			{
				auto def = workList[i];
				for (auto & dep : def->Dependency)
				{
					if (referencedDefs.Add(dep))
						workList.Add(dep);
				}
			}
			List<RefPtr<ComponentDefinitionIR>> newDefinitions;
			for (auto & def : Definitions)
			{
				if (referencedDefs.Contains(def.Ptr()))
				{
					newDefinitions.Add(def);
					EnumerableHashSet<ComponentDefinitionIR*> newSet;
					for (auto & comp : def->Users)
						if (referencedDefs.Contains(comp))
						{
							newSet.Add(comp);
						}
					def->Users = newSet;
					newSet.Clear();
					for (auto & comp : def->Dependency)
						if (referencedDefs.Contains(comp))
						{
							newSet.Add(comp);
						}
					def->Dependency = newSet;
				}
			}
			Definitions = _Move(newDefinitions);
			for (auto & kv : DefinitionsByComponent)
			{
				for (auto & def : kv.Value)
					if (!referencedDefs.Contains(def.Value))
						kv.Value.Remove(def.Key);
			}
		}
		void ShaderIR::ResolveComponentReference()
		{
			// build bidirectional dependency map of component definitions
			for (auto & comp : Definitions)
			{
				comp->Dependency.Clear();
				comp->Users.Clear();
			}
			for (auto & comp : Definitions)
			{
				List<ShaderComponentSymbol *> workList;
				for (auto & dep : comp->Implementation->DependentComponents)
					workList.Add(dep);
				HashSet<ShaderComponentSymbol*> proceseedDefCompss;
				for (int i = 0; i < workList.Count(); i++)
				{
					auto dep = workList[i];
					if (!proceseedDefCompss.Add(dep))
						continue;
					auto & depDefs = DefinitionsByComponent[dep->UniqueName]();
					// select the best overload according to import operator ordering,
					// prefer user-pinned definitions (as provided in the choice file)
					List<String> depWorlds;
					depWorlds.Add(comp->World);
					for (auto & w : Shader->Pipeline->WorldDependency[comp->World]())
						depWorlds.Add(w);
					for (int pass = 0; pass < 2; pass++)
					{
						// in the first pass, examine the pinned definitions only
						// in the second pass, examine all the rest definitions
						for (auto & depWorld : depWorlds)
						{
							bool isPinned = dep->Type->PinnedWorlds.Contains(depWorld);
							if ((pass == 0 && !isPinned) || (pass == 1 && isPinned)) continue;
							ComponentDefinitionIR * depDef;
							if (depDefs.TryGetValue(depWorld, depDef))
							{
								comp->Dependency.Add(depDef);
								depDef->Users.Add(comp.Ptr());
								// add additional dependencies due to import operators
								if (depWorld != comp->World)
								{
									auto importPath = Shader->Pipeline->FindImportOperatorChain(depWorld, comp->World);
									if (importPath.Count() == 0)
										throw InvalidProgramException(L"no import path found.");
									auto & usings = importPath.First().Nodes.Last().ImportOperator->Usings;
									for (auto & importUsing : usings)
									{
										ShaderComponentSymbol* refComp;
										if (!Shader->AllComponents.TryGetValue(importUsing.Content, refComp))
											throw InvalidProgramException(L"import operator dependency not exists.");
										workList.Add(refComp);
									}
								}
								goto selectionEnd; // first preferred overload is found, terminate searching
							}
						}
					}
					selectionEnd:;
				}
			}
		}
		List<ShaderComponentSymbol*> ShaderIR::GetComponentDependencyOrder()
		{
			List<ShaderComponentSymbol*> result, workList;
			HashSet<String> set;
			for (auto & comp : DefinitionsByComponent)
			{
				bool emptyDependency = true;
				for (auto & def : comp.Value)
					if (def.Value->Dependency.Count())
					{
						emptyDependency = false;
						break;
					}
				if (emptyDependency)
				{
					workList.Add(Shader->AllComponents[comp.Key]());
				}
			}
			for (int i = 0; i < workList.Count(); i++)
			{
				auto comp = workList[i];
				if (!set.Contains(comp->UniqueName))
				{
					bool insertable = true;
					for (auto & def : DefinitionsByComponent[comp->UniqueName]())
					{
						for (auto & dep : def.Value->Dependency)
							if (!set.Contains(dep->Component->UniqueName))
							{
								insertable = false;
								goto breakLoc;
							}
					}
				breakLoc:;
					if (insertable)
					{
						if (set.Add(comp->UniqueName))
						{
							result.Add(comp);
							for (auto & def : DefinitionsByComponent[comp->UniqueName]())
								for (auto & user : def.Value->Users)
									workList.Add(user->Component);
						}
					}
				}
			}
			return result;
		}
		bool SymbolTable::CheckComponentImplementationConsistency(ErrorWriter * err, ShaderComponentSymbol * comp, ShaderComponentImplSymbol * impl)
		{
			bool rs = true;
			if (impl->SyntaxNode->Rate)
			{
				for (auto & cimpl : comp->Implementations)
				{
					for (auto & w : cimpl->Worlds)
						if (impl->Worlds.Contains(w) && impl->AlternateName == cimpl->AlternateName)
						{
							err->Error(33020, L"\'" + comp->Name + L"\' is already defined at '" + w + L"\'.", impl->SyntaxNode->Position);
							rs = false;
						}
				}
			}
			else
			{
				for (auto & cimpl : comp->Implementations)
				{
					if (cimpl->Worlds.Count() == 0 && impl->Worlds.Count() == 0 && impl->AlternateName == cimpl->AlternateName)
					{
						err->Error(33020, L"\'" + comp->Name + L"\' is already defined.", impl->SyntaxNode->Position);
						rs = false;
					}
				}
			}
			for (auto & cimpl : comp->Implementations)
			{
				if (impl->SyntaxNode->IsOutput != cimpl->SyntaxNode->IsOutput)
				{
					err->Error(33021, L"\'" + comp->Name + L"\': inconsistent signature.\nsee previous definition at " + cimpl->SyntaxNode->Position.ToString(), impl->SyntaxNode->Position);
					rs = false;
					break;
				}
				if (impl->SyntaxNode->IsParam != cimpl->SyntaxNode->IsParam)
				{
					err->Error(33021, L"\'" + comp->Name + L"\': inconsistent signature.\nsee previous definition at " + cimpl->SyntaxNode->Position.ToString(), impl->SyntaxNode->Position);
					rs = false;
					break;
				}
				if (impl->SyntaxNode->IsPublic != cimpl->SyntaxNode->IsPublic)
				{
					err->Error(33021, L"\'" + comp->Name + L"\': inconsistent signature.\nsee previous definition at " + cimpl->SyntaxNode->Position.ToString(), impl->SyntaxNode->Position);
					rs = false;
					break;
				}
				if (impl->SyntaxNode->Type->ToExpressionType(this) != cimpl->SyntaxNode->Type->ToExpressionType(this))
				{
					err->Error(33021, L"\'" + comp->Name + L"\': inconsistent signature.\nsee previous definition at " + cimpl->SyntaxNode->Position.ToString(), impl->SyntaxNode->Position);
					rs = false;
					break;
				}
			}
			if (impl->SyntaxNode->IsParam && comp->Implementations.Count() != 0)
			{
				err->Error(33022, L"\'" + comp->Name + L"\': parameter name conflicts with existing definition.", impl->SyntaxNode->Position);
				rs = false;
			}
			return rs;
		}

		int GUID::currentGUID = 0;
		void GUID::Clear()
		{
			currentGUID = 0;
		}
		int GUID::Next()
		{
			return currentGUID++;
		}
		RefPtr<ShaderComponentSymbol> ShaderClosure::FindComponent(String name, bool findInPrivate)
		{
			RefPtr<ShaderComponentSymbol> rs;
			if (RefMap.TryGetValue(name, rs))
				return rs;
			if (Components.TryGetValue(name, rs))
				return rs;
			for (auto & subClosure : SubClosures)
			{
				if (subClosure.Value->IsInPlace)
				{
					rs = subClosure.Value->FindComponent(name);
					if (rs && (findInPrivate || rs->Implementations.First()->SyntaxNode->IsPublic))
						return rs;
					else
						rs = nullptr;
				}
			}
			return rs;
		}
		RefPtr<ShaderClosure> ShaderClosure::FindClosure(String name)
		{
			RefPtr<ShaderClosure> rs;
			if (SubClosures.TryGetValue(name, rs))
				return rs;
			for (auto & subClosure : SubClosures)
			{
				if (subClosure.Value->IsInPlace)
				{
					rs = subClosure.Value->FindClosure(name);
					if (rs && rs->IsPublic)
						return rs;
					else
						rs = nullptr;
				}
			}
			return rs;
		}
		List<ShaderComponentSymbol*> ShaderClosure::GetDependencyOrder()
		{
			List<ShaderComponentSymbol*> comps;
			for (auto & comp : AllComponents)
				comps.Add(comp.Value);
			comps.Sort([&](ShaderComponentSymbol*c0, ShaderComponentSymbol*c1)
			{
				return c0->Implementations.First()->SyntaxNode->Position < c1->Implementations.First()->SyntaxNode->Position;
			});
			HashSet<ShaderComponentSymbol*> allSymbols, addedSymbols;
			for (auto & comp : comps)
				allSymbols.Add(comp);
			List<ShaderComponentSymbol*> sorted;
			bool changed = true;
			while (changed)
			{
				changed = false;
				for (auto & comp : comps)
				{
					if (!addedSymbols.Contains(comp))
					{
						bool isFirst = true;
						for (auto & impl : comp->Implementations)
							for (auto & dep : impl->DependentComponents)
								if (allSymbols.Contains(dep) && !addedSymbols.Contains(dep))
								{
									isFirst = false;
									goto loopEnd;
								}
					loopEnd:;
						if (isFirst)
						{
							addedSymbols.Add(comp);
							sorted.Add(comp);
							changed = true;
						}
					}
				}
			}
			return sorted;
		}
	}
}

/***********************************************************************
CORE\SYNTAX.CPP
***********************************************************************/

namespace Spire
{
	namespace Compiler
	{
		ExpressionType ExpressionType::Bool(Compiler::BaseType::Bool);
		ExpressionType ExpressionType::Int(Compiler::BaseType::Int);
		ExpressionType ExpressionType::UInt(Compiler::BaseType::UInt);
		ExpressionType ExpressionType::Float(Compiler::BaseType::Float);
		ExpressionType ExpressionType::Int2(Compiler::BaseType::Int2);
		ExpressionType ExpressionType::Float2(Compiler::BaseType::Float2);
		ExpressionType ExpressionType::Int3(Compiler::BaseType::Int3);
		ExpressionType ExpressionType::Float3(Compiler::BaseType::Float3);
		ExpressionType ExpressionType::Int4(Compiler::BaseType::Int4);
		ExpressionType ExpressionType::Float4(Compiler::BaseType::Float4);
		ExpressionType ExpressionType::Void(Compiler::BaseType::Void);
		ExpressionType ExpressionType::Error(Compiler::BaseType::Error);

		bool Scope::FindVariable(const String & name, VariableEntry & variable)
		{
			if (Variables.TryGetValue(name, variable))
				return true;
			if (Parent)
				return Parent->FindVariable(name, variable);
			return false;
		}

		int ExpressionType::GetSize()
		{
			int baseSize = GetVectorSize(BaseType);
			if (BaseType == Compiler::BaseType::Texture2D || BaseType == Compiler::BaseType::TextureCube ||
				BaseType == Compiler::BaseType::TextureCubeShadow || BaseType == Compiler::BaseType::TextureShadow)
				baseSize = sizeof(void*) / sizeof(int);
			else if (BaseType == Compiler::BaseType::Struct)
				baseSize = Struct->Type->GetSize();
			if (ArrayLength == 0)
				return baseSize;
			else
				return ArrayLength*baseSize;
		}

		CoreLib::Basic::String ExpressionType::ToString()
		{
			CoreLib::Basic::StringBuilder res;

			switch (BaseType)
			{
			case Compiler::BaseType::Int:
				res.Append(L"int");
				break;
			case Compiler::BaseType::UInt:
				res.Append(L"uint");
				break;
			case Compiler::BaseType::Float:
				res.Append(L"float");
				break;
			case Compiler::BaseType::Int2:
				res.Append(L"ivec2");
				break;
			case Compiler::BaseType::Float2:
				res.Append(L"vec2");
				break;
			case Compiler::BaseType::Int3:
				res.Append(L"ivec3");
				break;
			case Compiler::BaseType::Float3:
				res.Append(L"vec3");
				break;
			case Compiler::BaseType::Int4:
				res.Append(L"ivec4");
				break;
			case Compiler::BaseType::Float4:
				res.Append(L"vec4");
				break;
			case Compiler::BaseType::Float3x3:
				res.Append(L"mat3");
				break;
			case Compiler::BaseType::Float4x4:
				res.Append(L"mat4");
				break;
			case Compiler::BaseType::Texture2D:
				res.Append(L"sampler2D");
				break;
			case Compiler::BaseType::TextureCube:
				res.Append(L"samplerCube");
				break;
			case Compiler::BaseType::TextureShadow:
				res.Append(L"samplerShadow");
				break;
			case Compiler::BaseType::TextureCubeShadow:
				res.Append(L"samplerCubeShadow");
				break;
			case Compiler::BaseType::Function:
				res.Append(L"(");
				for (int i = 0; i < Func->Parameters.Count(); i++)
				{
					if (i > 0)
						res.Append(L",");
					res.Append(Func->Parameters[i]->Type->ToString());
				}
				res.Append(L") => ");
				res.Append(Func->ReturnType->ToString());
				break;
			case Compiler::BaseType::Shader:
				res.Append(Shader->SyntaxNode->Name.Content);
				break;
			case Compiler::BaseType::Void:
				res.Append("void");
				break;
			default:
				break;
			}
			if (ArrayLength != 0)
			{
				res.Append(L"[");
				res.Append(CoreLib::Basic::String(ArrayLength));
				res.Append(L"]");
			}
			return res.ToString();
		}


		void ProgramSyntaxNode::Accept(SyntaxVisitor * visitor)
		{
			visitor->VisitProgram(this);
		}
		ProgramSyntaxNode * ProgramSyntaxNode::Clone(CloneContext & ctx)
		{
			auto rs = CloneSyntaxNodeFields(new ProgramSyntaxNode(*this), ctx);
			rs->Structs.Clear();
			for (auto & x : Structs)
				rs->Structs.Add(x->Clone(ctx));
			rs->Functions.Clear();
			for (auto & x : Functions)
				rs->Functions.Add(x->Clone(ctx));
			rs->Pipelines.Clear();
			for (auto & x : Pipelines)
				rs->Pipelines.Add(x->Clone(ctx));
			rs->Shaders.Clear();
			for (auto & x : Shaders)
				rs->Shaders.Add(x->Clone(ctx));
			return rs;
		}
		void FunctionSyntaxNode::Accept(SyntaxVisitor * visitor)
		{
			visitor->VisitFunction(this);
		}
		FunctionSyntaxNode * FunctionSyntaxNode::Clone(CloneContext & ctx)
		{
			auto rs = CloneSyntaxNodeFields(new FunctionSyntaxNode(*this), ctx);
			rs->Parameters.Clear();
			for (auto & param : Parameters)
			{
				rs->Parameters.Add(param->Clone(ctx));
			}
			rs->ReturnType = ReturnType->Clone(ctx);
			rs->Body = Body->Clone(ctx);
			return rs;
		}
		void BlockStatementSyntaxNode::Accept(SyntaxVisitor * visitor)
		{
			visitor->VisitBlockStatement(this);
		}
		BlockStatementSyntaxNode * BlockStatementSyntaxNode::Clone(CloneContext & ctx)
		{
			auto rs = CloneSyntaxNodeFields(new BlockStatementSyntaxNode(*this), ctx);
			rs->Statements.Clear();
			for (auto & stmt : Statements)
			{
				rs->Statements.Add(stmt->Clone(ctx));
			}
			return rs;
		}
		void BreakStatementSyntaxNode::Accept(SyntaxVisitor * visitor)
		{
			visitor->VisitBreakStatement(this);
		}
		BreakStatementSyntaxNode * BreakStatementSyntaxNode::Clone(CloneContext & ctx)
		{
			return CloneSyntaxNodeFields(new BreakStatementSyntaxNode(*this), ctx);
		}
		void ContinueStatementSyntaxNode::Accept(SyntaxVisitor * visitor)
		{
			visitor->VisitContinueStatement(this);
		}
		ContinueStatementSyntaxNode * ContinueStatementSyntaxNode::Clone(CloneContext & ctx)
		{
			return CloneSyntaxNodeFields(new ContinueStatementSyntaxNode(*this), ctx);
		}
		void DoWhileStatementSyntaxNode::Accept(SyntaxVisitor * visitor)
		{
			visitor->VisitDoWhileStatement(this);
		}
		DoWhileStatementSyntaxNode * DoWhileStatementSyntaxNode::Clone(CloneContext & ctx)
		{
			auto rs = CloneSyntaxNodeFields(new DoWhileStatementSyntaxNode(*this), ctx);
			if (Predicate)
				rs->Predicate = Predicate->Clone(ctx);
			if (Statement)
				rs->Statement = Statement->Clone(ctx);
			return rs;
		}
		void EmptyStatementSyntaxNode::Accept(SyntaxVisitor * visitor)
		{
			visitor->VisitEmptyStatement(this);
		}
		EmptyStatementSyntaxNode * EmptyStatementSyntaxNode::Clone(CloneContext & ctx)
		{
			return CloneSyntaxNodeFields(new EmptyStatementSyntaxNode(*this), ctx);
		}
		void ForStatementSyntaxNode::Accept(SyntaxVisitor * visitor)
		{
			visitor->VisitForStatement(this);
		}
		ForStatementSyntaxNode * ForStatementSyntaxNode::Clone(CloneContext & ctx)
		{
			auto rs = CloneSyntaxNodeFields(new ForStatementSyntaxNode(*this), ctx);
			if (InitialExpression)
				rs->InitialExpression = InitialExpression->Clone(ctx);
			if (StepExpression)
				rs->StepExpression = StepExpression->Clone(ctx);
			if (EndExpression)
				rs->EndExpression = EndExpression->Clone(ctx);
			if (Statement)
				rs->Statement = Statement->Clone(ctx);
			rs->TypeDef = TypeDef->Clone(ctx);
			return rs;
		}
		void IfStatementSyntaxNode::Accept(SyntaxVisitor * visitor)
		{
			visitor->VisitIfStatement(this);
		}
		IfStatementSyntaxNode * IfStatementSyntaxNode::Clone(CloneContext & ctx)
		{
			auto rs = CloneSyntaxNodeFields(new IfStatementSyntaxNode(*this), ctx);
			if (Predicate)
				rs->Predicate = Predicate->Clone(ctx);
			if (PositiveStatement)
				rs->PositiveStatement = PositiveStatement->Clone(ctx);
			if (NegativeStatement)
				rs->NegativeStatement = NegativeStatement->Clone(ctx);
			return rs;
		}
		void ReturnStatementSyntaxNode::Accept(SyntaxVisitor * visitor)
		{
			visitor->VisitReturnStatement(this);
		}
		ReturnStatementSyntaxNode * ReturnStatementSyntaxNode::Clone(CloneContext & ctx)
		{
			auto rs = CloneSyntaxNodeFields(new ReturnStatementSyntaxNode(*this), ctx);
			if (Expression)
				rs->Expression = Expression->Clone(ctx);
			return rs;
		}
		void VarDeclrStatementSyntaxNode::Accept(SyntaxVisitor * visitor)
		{
			visitor->VisitVarDeclrStatement(this);
		}
		VarDeclrStatementSyntaxNode * VarDeclrStatementSyntaxNode::Clone(CloneContext & ctx)
		{
			auto rs = CloneSyntaxNodeFields(new VarDeclrStatementSyntaxNode(*this), ctx);
			rs->Type = Type->Clone(ctx);
			rs->Variables.Clear();
			for (auto & var : Variables)
				rs->Variables.Add(var->Clone(ctx));
			return rs;
		}
		void Variable::Accept(SyntaxVisitor * visitor)
		{
			visitor->VisitDeclrVariable(this);
		}
		Variable * Variable::Clone(CloneContext & ctx)
		{
			auto rs = CloneSyntaxNodeFields(new Variable(*this), ctx);
			if (Expression)
				rs->Expression = Expression->Clone(ctx);
			return rs;
		}
		void WhileStatementSyntaxNode::Accept(SyntaxVisitor * visitor)
		{
			visitor->VisitWhileStatement(this);
		}
		WhileStatementSyntaxNode * WhileStatementSyntaxNode::Clone(CloneContext & ctx)
		{
			auto rs = CloneSyntaxNodeFields(new WhileStatementSyntaxNode(*this), ctx);
			if (Predicate)
				rs->Predicate = Predicate->Clone(ctx);
			if (Statement)
				rs->Statement = Statement->Clone(ctx);
			return rs;
		}
		void ExpressionStatementSyntaxNode::Accept(SyntaxVisitor * visitor)
		{
			visitor->VisitExpressionStatement(this);
		}
		ExpressionStatementSyntaxNode * ExpressionStatementSyntaxNode::Clone(CloneContext & ctx)
		{
			auto rs = CloneSyntaxNodeFields(new ExpressionStatementSyntaxNode(*this), ctx);
			if (Expression)
				rs->Expression = Expression->Clone(ctx);
			return rs;
		}
		void BinaryExpressionSyntaxNode::Accept(SyntaxVisitor * visitor)
		{
			visitor->VisitBinaryExpression(this);
		}
		BinaryExpressionSyntaxNode * BinaryExpressionSyntaxNode::Clone(CloneContext & ctx)
		{
			auto rs = CloneSyntaxNodeFields(new BinaryExpressionSyntaxNode(*this), ctx);
			rs->LeftExpression = LeftExpression->Clone(ctx);
			rs->RightExpression = RightExpression->Clone(ctx);
			return rs;
		}
		void ConstantExpressionSyntaxNode::Accept(SyntaxVisitor * visitor)
		{
			visitor->VisitConstantExpression(this);
		}
		ConstantExpressionSyntaxNode * ConstantExpressionSyntaxNode::Clone(CloneContext & ctx)
		{
			return CloneSyntaxNodeFields(new ConstantExpressionSyntaxNode(*this), ctx);
		}
		IndexExpressionSyntaxNode * IndexExpressionSyntaxNode::Clone(CloneContext & ctx)
		{
			auto rs = CloneSyntaxNodeFields(new IndexExpressionSyntaxNode(*this), ctx);
			rs->BaseExpression = BaseExpression->Clone(ctx);
			rs->IndexExpression = IndexExpression->Clone(ctx);
			return rs;
		}
		void IndexExpressionSyntaxNode::Accept(SyntaxVisitor * visitor)
		{
			visitor->VisitIndexExpression(this);
		}
		void MemberExpressionSyntaxNode::Accept(SyntaxVisitor * visitor)
		{
			visitor->VisitMemberExpression(this);
		}
		MemberExpressionSyntaxNode * MemberExpressionSyntaxNode::Clone(CloneContext & ctx)
		{
			auto rs = CloneSyntaxNodeFields(new MemberExpressionSyntaxNode(*this), ctx);
			rs->BaseExpression = BaseExpression->Clone(ctx);
			return rs;
		}
		void InvokeExpressionSyntaxNode::Accept(SyntaxVisitor * visitor)
		{
			visitor->VisitInvokeExpression(this);
		}
		InvokeExpressionSyntaxNode * InvokeExpressionSyntaxNode::Clone(CloneContext & ctx)
		{
			auto rs = CloneSyntaxNodeFields(new InvokeExpressionSyntaxNode(*this), ctx);
			rs->FunctionExpr = FunctionExpr->Clone(ctx);
			rs->Arguments.Clear();
			for (auto & arg : Arguments)
			{
				rs->Arguments.Add(arg->Clone(ctx));
			}
			return rs;
		}
		void TypeCastExpressionSyntaxNode::Accept(SyntaxVisitor * visitor)
		{
			visitor->VisitTypeCastExpression(this);
		}
		TypeCastExpressionSyntaxNode * TypeCastExpressionSyntaxNode::Clone(CloneContext & ctx)
		{
			auto rs = CloneSyntaxNodeFields(new TypeCastExpressionSyntaxNode(*this), ctx);
			rs->TargetType = TargetType->Clone(ctx);
			rs->Expression = Expression->Clone(ctx);
			return rs;
		}
		void SelectExpressionSyntaxNode::Accept(SyntaxVisitor * visitor)
		{
			visitor->VisitSelectExpression(this);
		}
		SelectExpressionSyntaxNode * SelectExpressionSyntaxNode::Clone(CloneContext & ctx)
		{
			auto rs = CloneSyntaxNodeFields(new SelectExpressionSyntaxNode(*this), ctx);
			rs->SelectorExpr = SelectorExpr->Clone(ctx);
			rs->Expr0 = Expr0->Clone(ctx);
			rs->Expr1 = Expr1->Clone(ctx);
			return rs;
		}
		void UnaryExpressionSyntaxNode::Accept(SyntaxVisitor * visitor)
		{
			visitor->VisitUnaryExpression(this);
		}
		UnaryExpressionSyntaxNode * UnaryExpressionSyntaxNode::Clone(CloneContext & ctx)
		{
			auto rs = CloneSyntaxNodeFields(new UnaryExpressionSyntaxNode(*this), ctx);
			rs->Expression = Expression->Clone(ctx);
			return rs;
		}
		void VarExpressionSyntaxNode::Accept(SyntaxVisitor * visitor)
		{
			visitor->VisitVarExpression(this);
		}
		VarExpressionSyntaxNode * VarExpressionSyntaxNode::Clone(CloneContext & ctx)
		{
			return CloneSyntaxNodeFields(new VarExpressionSyntaxNode(*this), ctx);
		}
		void ParameterSyntaxNode::Accept(SyntaxVisitor * visitor)
		{
			visitor->VisitParameter(this);
		}
		ParameterSyntaxNode * ParameterSyntaxNode::Clone(CloneContext & ctx)
		{
			auto rs = CloneSyntaxNodeFields(new ParameterSyntaxNode(*this), ctx);
			rs->Type = Type->Clone(ctx);
			rs->Expr = Expr->Clone(ctx);
			return rs;
		}
		void TypeSyntaxNode::Accept(SyntaxVisitor * visitor)
		{
			visitor->VisitType(this);
		}
		TypeSyntaxNode * TypeSyntaxNode::FromExpressionType(ExpressionType t)
		{
			TypeSyntaxNode * rs = new TypeSyntaxNode();
			ExpressionType expType;
			if (t.BaseType == BaseType::Int)
				rs->TypeName = L"int";
			else if (t.BaseType == BaseType::Float)
				rs->TypeName = L"float";
			else if (t.BaseType == BaseType::Int2)
				rs->TypeName = L"ivec2";
			else if (t.BaseType == BaseType::Int3)
				rs->TypeName = L"ivec3";
			else if (t.BaseType == BaseType::Int4)
				rs->TypeName = L"ivec4";
			else if (t.BaseType == BaseType::Float2)
				rs->TypeName = L"vec2";
			else if (t.BaseType == BaseType::Float3)
				rs->TypeName = L"vec3";
			else if (t.BaseType == BaseType::Float4)
				rs->TypeName = L"vec4";
			else if (t.BaseType == BaseType::Float3x3)
				rs->TypeName = L"mat3";
			else if (t.BaseType == BaseType::Float4x4)
				rs->TypeName = L"mat4";
			else if (t.BaseType == BaseType::Texture2D)
				rs->TypeName = L"sampler2D";
			else if (t.BaseType == BaseType::TextureCube)
				rs->TypeName = L"samplerCube";
			else if (t.BaseType == BaseType::TextureShadow)
				rs->TypeName = L"samplerShadow";
			else if (t.BaseType == BaseType::TextureCubeShadow)
				rs->TypeName = L"samplerCubeShadow";
			rs->ArrayLength = 0;
			rs->IsArray = false;		
			return rs;
		}
		ExpressionType TypeSyntaxNode::ToExpressionType(SymbolTable * symTable, ErrorWriter * errWriter)
		{
			ExpressionType expType;
			if (TypeName == L"int")
				expType.BaseType = BaseType::Int;
			else if (TypeName == L"uint")
				expType.BaseType = BaseType::UInt;
			else if (TypeName == L"float")
				expType.BaseType = BaseType::Float;
			else if (TypeName == L"ivec2")
				expType.BaseType = BaseType::Int2;
			else if (TypeName == L"ivec3")
				expType.BaseType = BaseType::Int3;
			else if (TypeName == L"ivec4")
				expType.BaseType = BaseType::Int4;
			else if (TypeName == L"vec2")
				expType.BaseType = BaseType::Float2;
			else if (TypeName == L"vec3")
				expType.BaseType = BaseType::Float3;
			else if (TypeName == L"vec4")
				expType.BaseType = BaseType::Float4;
			else if (TypeName == L"mat3" || TypeName == L"mat3x3")
				expType.BaseType = BaseType::Float3x3;
			else if (TypeName == L"mat4" || TypeName == L"mat4x4")
				expType.BaseType = BaseType::Float4x4;
			else if (TypeName == L"sampler2D")
				expType.BaseType = BaseType::Texture2D;
			else if (TypeName == L"samplerCube")
				expType.BaseType = BaseType::TextureCube;
			else if (TypeName == L"sampler2DShadow")
				expType.BaseType = BaseType::TextureShadow;
			else if (TypeName == L"samplerCubeShadow")
				expType.BaseType = BaseType::TextureCubeShadow;
			else if (TypeName == L"void")
				expType.BaseType = BaseType::Void;
			else
			{
				expType.BaseType = BaseType::Struct;
				RefPtr<StructSymbol> ssym;
				if (symTable->Structs.TryGetValue(TypeName, ssym))
				{
					expType.Struct = ssym.Ptr();
				}
				else
				{
					if (errWriter)
					{
						errWriter->Error(31040, L"undefined type name: '" + TypeName + L"'.", Position);
					}
					return ExpressionType::Error;
				}
			}
			expType.ArrayLength = ArrayLength;
			expType.IsArray = IsArray;
			return expType;
		}
		void ComponentSyntaxNode::Accept(SyntaxVisitor * visitor)
		{
			visitor->VisitComponent(this);
		}
		ComponentSyntaxNode * ComponentSyntaxNode::Clone(CloneContext & ctx)
		{
			auto rs = CloneSyntaxNodeFields(new ComponentSyntaxNode(*this), ctx);
			rs->Type = Type->Clone(ctx);
			if (Rate)
				rs->Rate = Rate->Clone(ctx);
			if (BlockStatement)
				rs->BlockStatement = BlockStatement->Clone(ctx);
			if (Expression)
				rs->Expression = Expression->Clone(ctx);
			return rs;
		}
		void ShaderSyntaxNode::Accept(SyntaxVisitor * visitor)
		{
			visitor->VisitShader(this);
		}
		ShaderSyntaxNode * ShaderSyntaxNode::Clone(CloneContext & ctx)
		{
			auto rs = CloneSyntaxNodeFields(new ShaderSyntaxNode(*this), ctx);
			rs->Members.Clear();
			for (auto & comp : Members)
				rs->Members.Add(comp->Clone(ctx));
			return rs;
		}
		RateSyntaxNode * RateSyntaxNode::Clone(CloneContext & ctx)
		{
			return CloneSyntaxNodeFields(new RateSyntaxNode(*this), ctx);
		}
		WorldSyntaxNode * WorldSyntaxNode::Clone(CloneContext & ctx)
		{
			return CloneSyntaxNodeFields(new WorldSyntaxNode(*this), ctx);
		}
		ImportOperatorDefSyntaxNode * ImportOperatorDefSyntaxNode::Clone(CloneContext & ctx)
		{
			return CloneSyntaxNodeFields(new ImportOperatorDefSyntaxNode(*this), ctx);
		}
		PipelineSyntaxNode * PipelineSyntaxNode::Clone(CloneContext & ctx)
		{
			auto rs = CloneSyntaxNodeFields(new PipelineSyntaxNode(*this), ctx);
			rs->Worlds.Clear();
			for (auto & w : Worlds)
				rs->Worlds.Add(w->Clone(ctx));
			rs->ImportOperators.Clear();
			for (auto & imp : ImportOperators)
				rs->ImportOperators.Add(imp->Clone(ctx));
			rs->AbstractComponents.Clear();
			for (auto & comp : AbstractComponents)
				rs->AbstractComponents.Add(comp->Clone(ctx));
			return rs;
		}
		ChoiceValueSyntaxNode * ChoiceValueSyntaxNode::Clone(CloneContext & ctx)
		{
			return CloneSyntaxNodeFields(new ChoiceValueSyntaxNode(*this), ctx);
		}
		void ImportSyntaxNode::Accept(SyntaxVisitor * v)
		{
			v->VisitImport(this);
		}
		ImportSyntaxNode * ImportSyntaxNode::Clone(CloneContext & ctx)
		{
			auto rs = CloneSyntaxNodeFields(new ImportSyntaxNode(*this), ctx);
			rs->Arguments.Clear();
			for (auto & arg : Arguments)
				rs->Arguments.Add(arg->Clone(ctx));
			return rs;
		}
		void ImportArgumentSyntaxNode::Accept(SyntaxVisitor * visitor)
		{
			visitor->VisitImportArgument(this);
		}
		ImportArgumentSyntaxNode * ImportArgumentSyntaxNode::Clone(CloneContext & ctx)
		{
			auto rs = CloneSyntaxNodeFields(new ImportArgumentSyntaxNode(*this), ctx);
			rs->Expression = Expression->Clone(ctx);
			return rs;
		}
		void ImportStatementSyntaxNode::Accept(SyntaxVisitor * visitor)
		{
			visitor->VisitImportStatement(this);
		}
		ImportStatementSyntaxNode * ImportStatementSyntaxNode::Clone(CloneContext & ctx)
		{
			auto rs = CloneSyntaxNodeFields(new ImportStatementSyntaxNode(*this), ctx);
			rs->Import = Import->Clone(ctx);
			return rs;
		}
		void StructField::Accept(SyntaxVisitor * visitor)
		{
			visitor->VisitStructField(this);
		}
		void StructSyntaxNode::Accept(SyntaxVisitor * visitor)
		{
			visitor->VisitStruct(this);
		}
	}
}

/***********************************************************************
LIB\GLSLIMPORTOPERATORHANDLERS.CPP
***********************************************************************/
using namespace Spire::Compiler;
using namespace CoreLib::Basic;

class GLSLImportOperatorHandler : public ImportOperatorHandler
{
public:
	virtual void GenerateSetInput(StringBuilder &, ComponentDefinition *, const ImportOperatorContext &) override
	{}
	virtual void GeneratePreamble(StringBuilder &, InterfaceBlock *, const ImportOperatorContext &) override
	{}
	virtual void GenerateEpilogue(StringBuilder &, InterfaceBlock *, const ImportOperatorContext &) override
	{}
};

class StandardGLSLImportOperatorHandler : public GLSLImportOperatorHandler
{
	virtual String GetName() override
	{
		return L"standardImport";
	}
	virtual void GenerateInterfaceDefinition(StringBuilder & sb, InterfaceBlock * block, const ImportOperatorContext &) override
	{
		if (block->Entries.Count() == 0)
			return;
		sb << L"in " << block->Name << L"\n{\n";
		for (auto & ent : block->Entries)
		{
			if (ent.Value.Type->IsIntegral())
				sb << L"flat ";
			sb << ent.Value.Type->ToString() << L" " << ent.Key << L";\n";
		}
		sb << L"} blk" << block->Name << L";\n";
	}
	virtual void GenerateInterfaceLocalDefinition(StringBuilder & /*sb*/, ImportInstruction * instr, const ImportOperatorContext & ctx) override
	{
		auto block = ctx.SourceWorld->WorldOutput;
		instr->Name = L"blk" + block->Name + L"." + instr->ComponentName;		
	}
};

class VertexGLSLImportOperatorHandler : public GLSLImportOperatorHandler
{
	virtual String GetName() override
	{
		return L"vertexImport";
	}
	virtual void GenerateInterfaceDefinition(StringBuilder & sb, InterfaceBlock * block, const ImportOperatorContext & /*ctx*/) override
	{
		int location = 0;
		for (auto & ent : block->Entries)
		{
			sb << L"layout(location = " << location << L") ";
			sb << L"in " << ent.Value.Type->ToString() << L" " << ent.Key << L";\n";
			location++;
		}
	}
	virtual void GenerateInterfaceLocalDefinition(StringBuilder &/*sb*/, ImportInstruction * instr, const ImportOperatorContext & /*ctx*/) override
	{
		instr->Name = instr->ComponentName;
	}
};

void GenerateBufferInterfaceDefinition(StringBuilder & sb, InterfaceBlock * block)
{
	String strIdx;
	if (block->Attributes.TryGetValue(L"Index", strIdx))
		sb << L"layout(location = " << strIdx << L") ";
	sb << L"uniform float * " << block->Name << L";" << EndLine;
}

class BufferGLSLImportOperatorHandler : public GLSLImportOperatorHandler
{
	virtual String GetName() override
	{
		return L"bufferImport";
	}
	virtual void GenerateInterfaceDefinition(StringBuilder & sb, InterfaceBlock * block, const ImportOperatorContext &) override
	{
		GenerateBufferInterfaceDefinition(sb, block);
	}
	virtual void GenerateInterfaceLocalDefinition(StringBuilder & sb, ImportInstruction * instr, const ImportOperatorContext & ctx) override
	{
		auto block = ctx.SourceWorld->WorldOutput;
		sb << instr->Type->ToString() << L" " << instr->Name << L";\n";
		if (instr->Type->IsTexture())
		{
			sb << instr->Name << L" = *(" << instr->Type->ToString() << L"*)(" << block->Name <<
				L" + " << String(block->Entries[instr->ComponentName].GetValue().Offset / 4) << L" + gl_GlobalInvocationID.x * "
				<< String(block->Size / 4) << L");" << EndLine;
		}
		else
		{
			int vecSize = instr->Type->GetVectorSize();
			for (int i = 0; i < vecSize; i++)
			{
				sb << instr->Name;
				if (vecSize > 1)
				{
					if (vecSize == 9)
						sb << L"[" << i/3 << L"][" << i%3 << L"]";
					else if (vecSize == 16)
						sb << L"[" << i / 4 << L"][" << i % 4 << L"]";
					else
						sb << L"[" << i << L"]";
				}
				sb << L" = *";
				if (instr->Type->IsIntVector() || instr->Type->IsInt())
					sb << L"(int*)";
				sb<< L"(" << block->Name <<
					L" + " << String(block->Entries[instr->ComponentName].GetValue().Offset / 4 + i) << L" + gl_GlobalInvocationID.x * "
					<< String(block->Size / 4) << L");" << EndLine;
			}
		}
	}

	virtual void GeneratePreamble(StringBuilder & sb, InterfaceBlock * /*block*/, const ImportOperatorContext & /*context*/) override
	{
		sb << L"if (gl_GlobalInvocationID.x >= sys_thread_count) return;" << EndLine;
	}
	virtual void GenerateEpilogue(StringBuilder &, InterfaceBlock *, const ImportOperatorContext &) override
	{}
};

class BufferGLSLExportOperatorHandler : public ExportOperatorHandler
{
	virtual String GetName() override
	{
		return L"bufferExport";
	}
	virtual void GenerateInterfaceDefinition(StringBuilder & sb, InterfaceBlock * block) override
	{
		GenerateBufferInterfaceDefinition(sb, block);
		sb << L"uniform uint sys_thread_count;" << EndLine;
		sb << L"layout(local_size_x = 256) in;" << EndLine;
	}
	virtual void GenerateExport(StringBuilder & sb, InterfaceBlock * block, CompiledWorld *, String componentName, String valueVar) override
	{
		auto & comp = block->Entries[componentName].GetValue();
		if (comp.Type->IsTexture() || comp.Type->GetVectorSize() > 4)
		{
			throw NotImplementedException(L"exporting sampler2D or matrices is not supported.");
		}
		else
		{
			for (int i = 0; i < comp.Type->GetVectorSize(); i++)
			{
				sb << L"*";
				if (comp.Type->IsIntVector() || comp.Type->IsInt())
					sb << L"(int*)";

				sb << L"(" << block->Name <<
					L" + " << String(block->Entries[componentName].GetValue().Offset / 4 + i) << L" + gl_GlobalInvocationID.x * "
					<< String(block->Size / 4) << L") = " << valueVar;
				if (comp.Type->GetVectorSize() > 1)
					sb << L"[" << i << L"]";
				sb << L";" << EndLine;
			}
		}
	}
	virtual void GeneratePreamble(StringBuilder & sb, InterfaceBlock *) override
	{
		sb << L"if (gl_GlobalInvocationID.x >= sys_thread_count) return;" << EndLine;
	}
	virtual void GenerateEpilogue(StringBuilder &, InterfaceBlock *) override
	{}
};

class UniformGLSLImportOperatorHandler : public GLSLImportOperatorHandler
{
	virtual String GetName() override
	{
		return L"uniformImport";
	}
	virtual void GenerateInterfaceDefinition(StringBuilder & sb, InterfaceBlock * block, const ImportOperatorContext & ctx) override
	{
		if (block->Entries.Count() == 0)
			return;
		bool useBindlessTexture = ctx.BackendArguments.ContainsKey(L"bindless_texture");
		int activeEntryCount = 0;
		for (auto & ent : block->Entries)
		{
			if (useBindlessTexture || !ent.Value.Type->IsTexture())
				activeEntryCount++;
		}
		String bufferType = L"uniform";
		if (block->Attributes.ContainsKey(L"ShaderStorageBlock"))
			bufferType = L"buffer";

		if (activeEntryCount)
		{
			sb << L"layout(std140";
			String strIndex;
			if (block->Attributes.TryGetValue(L"Index", strIndex))
				sb << L", binding = " << strIndex;
			if (ctx.BackendArguments.ContainsKey(L"command_list"))
				sb << L", commandBindableNV";
			sb << L") ";
			sb << bufferType;
			sb << L" " << block->Name << L"\n{\n";
			for (auto & ent : block->Entries)
			{
				if (!useBindlessTexture && ent.Value.Type->IsTexture())
					continue;
				sb << ent.Value.Type->ToString() << L" " << ent.Key << L";\n";
			}
			sb << L"} blk" << block->Name << L";\n";
		}
		if (!useBindlessTexture)
		{
			int bindPoint = 0;
			String bindingStart;
			if (ctx.BackendArguments.TryGetValue(L"TextureBindingStart", bindingStart))
				bindPoint = StringToInt(bindingStart);
			for (auto & ent : block->Entries)
			{
				if (ent.Value.Type->IsTexture())
				{
					sb << L"layout(binding = " << bindPoint << L") uniform " << ent.Value.Type->ToString() << L" " << ent.Key << L";\n";
					bindPoint++;
				}
			}
		}
	}
	virtual void GenerateInterfaceLocalDefinition(StringBuilder & /*sb*/, ImportInstruction * instr, const ImportOperatorContext & ctx) override
	{
		auto block = ctx.SourceWorld->WorldOutput;
		if (ctx.BackendArguments.ContainsKey(L"bindless_texture") || !instr->Type->IsTexture())
			instr->Name = L"blk" + block->Name + L"." + instr->ComponentName;
		else
			instr->Name = instr->ComponentName;
	}
};


class TextureGLSLImportOperatorHandler : public GLSLImportOperatorHandler
{
	virtual String GetName() override
	{
		return L"textureImport";
	}
	virtual void GenerateInterfaceDefinition(StringBuilder & sb, InterfaceBlock * block, const ImportOperatorContext & ctx) override
	{
		if (block->Entries.Count() == 0)
			return;
		sb << L"layout(std140";
		String strIndex;
		if (block->Attributes.TryGetValue(L"Index", strIndex))
			sb << L", binding = " << strIndex;
		if (ctx.BackendArguments.ContainsKey(L"command_list"))
			sb << L", commandBindableNV";
		sb << L") ";
		sb << L"uniform " << block->Name << L"\n{\n";
		for (auto & ent : block->Entries)
		{
			sb << L"sampler2D " << ent.Key << L";\n";
		}
		sb << L"} blk" << block->Name << L";\n";
	}
	virtual void GenerateInterfaceLocalDefinition(StringBuilder & sb, ImportInstruction * instr, const ImportOperatorContext & context) override
	{
		if (instr->Arguments.Count() != 1)
		{
			context.Result.GetErrorWriter()->Error(50001, L"missing import operator argument.", instr->ImportOperator->Position);
			return;
		}
		sb << instr->Type->ToString() << L" " << instr->Name << L" = " << instr->Type->ToString() << "(texture(blk" << context.SourceWorld->WorldOutput->Name
			<< L"."<< instr->ComponentName << L", " << instr->Arguments[0]->Name << L")";
		int vecSize = instr->Type->GetVectorSize();
		if (vecSize <= 1)
			sb << L".x";
		else if (vecSize == 2)
			sb << L".xy";
		else if (vecSize == 3)
			sb << L".xyz";
		CompiledComponent ccomp;
		if (context.SourceWorld->LocalComponents.TryGetValue(instr->ComponentName, ccomp))
		{
			if (ccomp.Attributes.ContainsKey(L"Normal"))
			{
				sb << L" * 2.0 - 1.0";
			}
		}
		sb << L");\n";
	}
};

class StandardGLSLExportOperatorHandler : public ExportOperatorHandler
{
	virtual String GetName() override
	{
		return L"standardExport";
	}
	virtual void GenerateInterfaceDefinition(StringBuilder & sb, InterfaceBlock * block) override
	{
		if (block->Entries.Count() == 0)
			return;
		sb << L"out " << block->Name << L"\n{\n";
		for (auto & ent : block->Entries)
		{
			if (ent.Value.Type->IsIntegral())
				sb << L"flat ";
			sb << ent.Value.Type->ToString() << L" " << ent.Key << L";\n";
		}
		sb << L"} blk" << block->Name << L";\n";
	}
	virtual void GenerateExport(StringBuilder & sb, InterfaceBlock * block, CompiledWorld *, String componentName, String valueVar) override
	{
		sb << L"blk" << block->Name << L"." << componentName << L" = " << valueVar << L";\n";
	}
	virtual void GeneratePreamble(StringBuilder &, InterfaceBlock *) override
	{}
	virtual void GenerateEpilogue(StringBuilder &, InterfaceBlock *) override
	{}
};

class FragmentGLSLExportOperatorHandler : public ExportOperatorHandler
{
	virtual String GetName() override
	{
		return L"fragmentExport";
	}
	virtual void GenerateInterfaceDefinition(StringBuilder & sb, InterfaceBlock * block) override
	{
		if (block->Entries.Count() == 0)
			return;
		int idx = 0;
		for (auto & ent : block->Entries)
		{
			if (!ent.Value.LayoutAttribs.ContainsKey(L"DepthOutput"))
			{
				sb << L"layout(location = " << idx << L") out " << ent.Value.Type->ToString() << L" " << ent.Key << L";\n";
				idx++;
			}
		}
	}
	virtual void GenerateExport(StringBuilder & sb, InterfaceBlock * /*block*/, CompiledWorld * world, String componentName, String valueVar) override
	{
		CompiledComponent ccomp;
		bool isNormal = false;
		bool isDepthOutput = false;
		if (world->LocalComponents.TryGetValue(componentName, ccomp))
		{
			if (ccomp.Attributes.ContainsKey(L"Normal"))
				isNormal = true;
			if (ccomp.Attributes.ContainsKey(L"DepthOutput"))
				isDepthOutput = true;
		}
		if (isDepthOutput)
			sb << L"gl_FragDepth";
		else
			sb << componentName;
		sb << L" = ";
		if (isNormal)
			sb << valueVar << L" * 0.5 + 0.5";
		else
			sb << valueVar;
		sb << L";\n";
	}	
	virtual void GeneratePreamble(StringBuilder &, InterfaceBlock *) override
	{}
	virtual void GenerateEpilogue(StringBuilder &, InterfaceBlock *) override
	{}
};


void CreateGLSLImportOperatorHandlers(CoreLib::Basic::List<Spire::Compiler::ImportOperatorHandler *> & handlers)
{
	handlers.Add(new StandardGLSLImportOperatorHandler());
	handlers.Add(new UniformGLSLImportOperatorHandler());
	handlers.Add(new TextureGLSLImportOperatorHandler());
	handlers.Add(new VertexGLSLImportOperatorHandler());
	handlers.Add(new BufferGLSLImportOperatorHandler());
}

void CreateGLSLExportOperatorHandlers(CoreLib::Basic::List<Spire::Compiler::ExportOperatorHandler *> & handlers)
{
	handlers.Add(new StandardGLSLExportOperatorHandler());
	handlers.Add(new FragmentGLSLExportOperatorHandler());
	handlers.Add(new BufferGLSLExportOperatorHandler());
}


/***********************************************************************
LIB\IMPORTOPERATOR.CPP
***********************************************************************/
using namespace Spire::Compiler;
using namespace CoreLib::Basic;

void DestroyImportOperatorHanlders(CoreLib::Basic::List<Spire::Compiler::ImportOperatorHandler *> & handlers)
{
	for (auto handler : handlers)
		delete handler;
	handlers.Clear();
}

void DestroyExportOperatorHanlders(CoreLib::Basic::List<Spire::Compiler::ExportOperatorHandler *> & handlers)
{
	for (auto handler : handlers)
		delete handler;
	handlers.Clear();
}

/***********************************************************************
LIB\SPIRELIB.CPP
***********************************************************************/

using namespace CoreLib::Basic;
using namespace CoreLib::IO;
using namespace CoreLib::Text;
using namespace Spire::Compiler;

namespace SpireLib
{
	void ReadSource(EnumerableDictionary<CoreLib::Basic::String, CompiledShaderSource> & sources, CoreLib::Text::Parser & parser, String src)
	{
		auto getShaderSource = [&]()
		{
			auto token = parser.ReadToken();
			int endPos = token.Position + 1;
			int brace = 0;
			while (endPos < src.Length() && !(src[endPos] == L'}' && brace == 0))
			{
				if (src[endPos] == L'{')
					brace++;
				else if (src[endPos] == L'}')
					brace--;
				endPos++;
			}
			while (!parser.IsEnd() && parser.NextToken().Position != endPos)
				parser.ReadToken();
			parser.ReadToken();
			return src.SubString(token.Position + 1, endPos - token.Position - 1);
		};
		while (!parser.IsEnd() && !parser.LookAhead(L"}"))
		{
			auto worldName = parser.ReadWord();
			CompiledShaderSource compiledSrc;
			compiledSrc.ParseFromGLSL(getShaderSource());
			sources[worldName] = compiledSrc;
		}
	}
	CompiledShaderSource ShaderLib::GetWorldSource(String world)
	{
		CompiledShaderSource rs;
		Sources.TryGetValue(world, rs);
		return rs;
	}
	ShaderLib::ShaderLib(CoreLib::Basic::String fileName)
	{
		Reload(fileName);
	}
	void ShaderLib::Reload(CoreLib::Basic::String fileName)
	{
		Load(fileName);
	}
	bool ShaderLib::CompileFrom(String symbolName, String sourceFileName, String schedule)
	{
		CompileResult result;
		CompileOptions options;
		options.ScheduleSource = schedule;
		options.SymbolToCompile = symbolName;
		options.Mode = CompilerMode::ProduceShader;
		auto shaderLibs = CompileShaderSourceFromFile(result, sourceFileName, options);
		if (result.Success)
		{
			for (auto & lib : shaderLibs)
			{
				if (lib.MetaData.ShaderName == symbolName)
				{
					FromString(shaderLibs[0].ToString());
					return true;
				}
			}
		}
		result.PrintError(true);
		return false;
	}

	List<ShaderLibFile> CompileUnits(Spire::Compiler::CompileResult & compileResult,
		ShaderCompiler * compiler, List<CompileUnit> & units,
		Spire::Compiler::CompileOptions & options)
	{
		List<ShaderLibFile> resultFiles;
		List<ImportOperatorHandler*> importHandlers;
		List<ExportOperatorHandler*> exportHandlers;
		CreateGLSLImportOperatorHandlers(importHandlers);
		CreateGLSLExportOperatorHandlers(exportHandlers);
		for (auto handler : exportHandlers)
			compiler->RegisterExportOperator(L"glsl", handler);
		for (auto handler : importHandlers)
			compiler->RegisterImportOperator(L"glsl", handler);
		try
		{
			if (compileResult.ErrorList.Count() == 0)
				compiler->Compile(compileResult, units, options);
			DestroyImportOperatorHanlders(importHandlers);
			DestroyExportOperatorHanlders(exportHandlers);
		}
		catch (...)
		{
			DestroyImportOperatorHanlders(importHandlers);
			DestroyExportOperatorHanlders(exportHandlers);
			throw;
		}
		if (compileResult.Success)
		{
			if (options.Mode == CompilerMode::ProduceShader)
			{
				EnumerableDictionary<String, ShaderLibFile> shaderLibs;
				for (auto file : compileResult.CompiledSource)
				{
					auto shaderName = Path::GetFileNameWithoutEXT(file.Key);
					ShaderLibFile * libFile = shaderLibs.TryGetValue(shaderName);
					if (!libFile)
					{
						shaderLibs.Add(shaderName, ShaderLibFile());
						libFile = shaderLibs.TryGetValue(shaderName);
						libFile->MetaData.ShaderName = shaderName;
					}
					libFile->Sources = file.Value;
				}
				for (auto & libFile : shaderLibs)
				{
					for (auto & shader : compileResult.Program->Shaders)
					{
						if (shader->MetaData.ShaderName == libFile.Key)
						{
							// fill in meta data
							libFile.Value.MetaData = shader->MetaData;
						}
					}
					resultFiles.Add(libFile.Value);
				}
			}
		}
		return resultFiles;
	}

	List<ShaderLibFile> CompileShaderSource(Spire::Compiler::CompileResult & compileResult,
		const CoreLib::String & src, Spire::Compiler::CompileOptions & options)
	{
		Spire::Compiler::NamingCounter = 0;
		RefPtr<ShaderCompiler> compiler = CreateShaderCompiler();
		List<CompileUnit> units;
		HashSet<String> processedUnits;
		List<String> unitsToInclude;
		unitsToInclude.Add(L"");
		processedUnits.Add(L"");
		auto predefUnit = compiler->Parse(compileResult, LibIncludeString, L"stdlib");
		for (int i = 0; i < unitsToInclude.Count(); i++)
		{
			auto inputFileName = unitsToInclude[i];
			try
			{
				String source = src;
				if (i > 0)
					source = File::ReadAllText(inputFileName);
				auto unit = compiler->Parse(compileResult, source, Path::GetFileName(inputFileName));
				units.Add(unit);
				if (unit.SyntaxNode)
				{
					for (auto inc : unit.SyntaxNode->Usings)
					{
						String includeFile = Path::Combine(Path::GetDirectoryName(inputFileName), inc.Content);
						if (processedUnits.Add(includeFile))
						{
							unitsToInclude.Add(includeFile);
						}
					}
				}
			}
			catch (IOException)
			{
				compileResult.GetErrorWriter()->Error(1, L"cannot open file '" + Path::GetFileName(inputFileName) + L"'.", CodePosition(0, 0, L""));
			}
		}
		units.Add(predefUnit);
		return CompileUnits(compileResult, compiler.Ptr(), units, options);
	}

	List<ShaderLibFile> CompileShaderSourceFromFile(Spire::Compiler::CompileResult & compileResult, 
		CoreLib::Basic::String sourceFileName,
		Spire::Compiler::CompileOptions & options)
	{
		Spire::Compiler::NamingCounter = 0;
		RefPtr<ShaderCompiler> compiler = CreateShaderCompiler();
		List<CompileUnit> units;
		HashSet<String> processedUnits;
		List<String> unitsToInclude;
		unitsToInclude.Add(sourceFileName);
		processedUnits.Add(sourceFileName);
		auto predefUnit = compiler->Parse(compileResult, LibIncludeString, L"stdlib");
		for (int i = 0; i < unitsToInclude.Count(); i++)
		{
			auto inputFileName = unitsToInclude[i];
			try
			{
				String source = File::ReadAllText(inputFileName);
				auto unit = compiler->Parse(compileResult, source, Path::GetFileName(inputFileName));
				units.Add(unit);
				if (unit.SyntaxNode)
				{
					for (auto inc : unit.SyntaxNode->Usings)
					{
						String includeFile = Path::Combine(Path::GetDirectoryName(inputFileName), inc.Content);
						if (processedUnits.Add(includeFile))
						{
							unitsToInclude.Add(includeFile);
						}
					}
				}
			}
			catch (IOException)
			{
				compileResult.GetErrorWriter()->Error(1, L"cannot open file '" + Path::GetFileName(inputFileName) + L"'.", CodePosition(0, 0, sourceFileName));
			}
		}
		units.Add(predefUnit);
		return CompileUnits(compileResult, compiler.Ptr(), units, options);
	}
	void ShaderLibFile::AddSource(CoreLib::Basic::String source, CoreLib::Text::Parser & parser)
	{
		ReadSource(Sources, parser, source);
	}

	CoreLib::String ShaderLibFile::ToString()
	{
		StringBuilder writer;
		writer << L"name " << MetaData.ShaderName << EndLine;
		for (auto & world : MetaData.Worlds)
		{
			writer << L"world " << world.Key << EndLine << L"{" << EndLine;
			writer << L"target " << world.Value.TargetName << EndLine;
			for (auto & blk : world.Value.InputBlocks)
			{
				writer << L"in " << blk << L";\n";
			}
			writer << L"out " << world.Value.OutputBlock << L";\n";
			for (auto & comp : world.Value.Components)
				writer << L"comp " << comp << L";\n";
			writer << L"}" << EndLine;
		}
		for (auto & ublock : MetaData.InterfaceBlocks)
		{
			writer << L"interface " << ublock.Key << L" size " << ublock.Value.Size << L"\n{\n";
			for (auto & entry : ublock.Value.Entries)
			{
				writer << entry.Type->ToString() << L" " << entry.Name << L" : " << entry.Offset << L"," << entry.Size;
				if (entry.Attributes.Count())
				{
					writer << L"\n{\n";
					for (auto & attrib : entry.Attributes)
					{
						writer << attrib.Key << L" : " << CoreLib::Text::Parser::EscapeStringLiteral(attrib.Value) << L";\n";
					}
					writer << L"}";
				}
				writer << L";\n";
			}
			writer << L"}\n";
		}
		writer << L"source" << EndLine << L"{" << EndLine;
		for (auto & src : Sources)
		{
			writer << src.Key << EndLine;
			writer << L"{" << EndLine;
			writer << src.Value.GetAllCodeGLSL() << EndLine;
			writer << L"}" << EndLine;
		}
		writer << L"}" << EndLine;
		StringBuilder formatSB;
		IndentString(formatSB, writer.ProduceString());
		return formatSB.ProduceString();
	}
	
	void ShaderLibFile::Clear()
	{
		Sources.Clear();
		MetaData.Worlds.Clear();
		Sources.Clear();
	}

	void ShaderLibFile::SaveToFile(CoreLib::Basic::String fileName)
	{
		StreamWriter fwriter(fileName);
		fwriter.Write(ToString());
	}

	void ShaderLibFile::FromString(const String & src)
	{
		Clear();
		CoreLib::Text::Parser parser(src);
		while (!parser.IsEnd())
		{
			auto fieldName = parser.ReadWord();
			if (fieldName == L"name")
			{
				MetaData.ShaderName = parser.ReadWord();
			}
			else if (fieldName == L"source")
			{
				parser.Read(L"{");
				ReadSource(Sources, parser, src);
				parser.Read(L"}");
			}
			else if (fieldName == L"binary")
			{
			}
			else if (fieldName == L"world")
			{
				WorldMetaData world;
				world.Name = parser.ReadWord();
				parser.Read(L"{");
				while (!parser.LookAhead(L"}"))
				{
					auto subFieldName = parser.ReadWord();
					if (subFieldName == L"target")
						world.TargetName = parser.ReadWord();
					else if (subFieldName == L"in")
					{
						world.InputBlocks.Add(parser.ReadWord());
						parser.Read(L";");
					}
					else if (subFieldName == L"out")
					{
						world.OutputBlock = parser.ReadWord();
						parser.Read(L";");
					}
					else if (subFieldName == L"comp")
					{
						auto compName = parser.ReadWord();
						parser.Read(L";");
						world.Components.Add(compName);
					}
				}
				parser.Read(L"}");
				MetaData.Worlds[world.Name] = world;
			}
			else if (fieldName == L"interface")
			{
				InterfaceBlockMetaData block;
				if (!parser.LookAhead(L"{") && !parser.LookAhead(L"size"))
					block.Name = parser.ReadWord();
				if (parser.LookAhead(L"size"))
				{
					parser.ReadWord();
					block.Size = parser.ReadInt();
				}
				parser.Read(L"{");
				while (!parser.LookAhead(L"}") && !parser.IsEnd())
				{
					InterfaceBlockEntry entry;
					entry.Type = TypeFromString(parser);
					entry.Name = parser.ReadWord();
					parser.Read(L":");
					entry.Offset = parser.ReadInt();
					parser.Read(L",");
					entry.Size = parser.ReadInt();
					if (parser.LookAhead(L"{"))
					{
						parser.Read(L"{");
						while (!parser.LookAhead(L"}") && !parser.IsEnd())
						{
							auto attribName = parser.ReadWord();
							parser.Read(L":");
							auto attribValue = parser.ReadStringLiteral();
							parser.Read(L";");
							entry.Attributes[attribName] = attribValue;
						}
						parser.Read(L"}");
					}
					parser.Read(L";");
					block.Entries.Add(entry);
				}
				parser.Read(L"}");
				MetaData.InterfaceBlocks[block.Name] = block;
			}
		}
	}

	void ShaderLibFile::Load(String fileName)
	{
		String src = File::ReadAllText(fileName);
		FromString(src);
	}
}
