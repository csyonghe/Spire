/***********************************************************************

Spire - The MIT License (MIT)
Copyright (c) 2016, Carnegie Mellon University

Developers: Yong He, Haomin Long

Permission is hereby granted, free of charge, to any person obtaining a 
copy of this software and associated documentation files (the "Software"), 
to deal in the Software without restriction, including without limitation 
the rights to use, copy, modify, merge, publish, distribute, sublicense, 
and/or sell copies of the Software, and to permit persons to whom the 
Software is furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in 
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR 
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, 
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL 
THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER 
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING 
FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER 
DEALINGS IN THE SOFTWARE.


========================================================================
WARNING: THIS FILE IS AUTOMATICALLY GENERATED. DO NOT MODIFY
***********************************************************************/
#include "Basic.h"

/***********************************************************************
CORE\COMPILEERROR.H
***********************************************************************/
#ifndef RASTER_RENDERER_COMPILE_ERROR_H
#define RASTER_RENDERER_COMPILE_ERROR_H


namespace Spire
{
	namespace Compiler
	{
		using namespace CoreLib::Basic;

		class CodePosition
		{
		public:
			int Line = -1, Col = -1;
			String FileName;
			String ToString()
			{
				StringBuilder sb(100);
				sb << FileName;
				if (Line != -1)
					sb << L"(" << Line << L")";
				return sb.ProduceString();
			}
			CodePosition() = default;
			CodePosition(int line, int col, String fileName)
			{
				Line = line;
				Col = col;
				this->FileName = fileName;
			}
			bool operator < (const CodePosition & pos) const
			{
				return FileName < pos.FileName || (FileName == pos.FileName && Line < pos.Line) ||
					(FileName == pos.FileName && Line == pos.Line && Col < pos.Col);
			}
			bool operator == (const CodePosition & pos) const
			{
				return FileName == pos.FileName && Line == pos.Line && Col == pos.Col;
			}
		};

		class CompileError
		{
		public:
			String Message;
			CodePosition Position;
			int ErrorID;

			CompileError()
			{
				ErrorID = -1;
			}
			CompileError(const String & msg, int id,
						const CodePosition & pos)
			{
				Message = msg;
				ErrorID = id;
				Position = pos;
			}
		};

		class ErrorWriter
		{
		private:
			List<CompileError> & errors;
			List<CompileError> & warnings;
		public:
			ErrorWriter(List<CompileError> & perrors, List<CompileError> & pwarnings)
				: errors(perrors), warnings(pwarnings)
			{}
			void Error(int id, const String & msg, const CodePosition & pos)
			{
				errors.Add(CompileError(msg, id, pos));
			}
			void Warning(int id, const String & msg, const CodePosition & pos)
			{
				warnings.Add(CompileError(msg, id, pos));
			}
			int GetErrorCount()
			{
				return errors.Count();
			}
		};
	}
}

#endif

/***********************************************************************
CORE\LEXER.H
***********************************************************************/
#ifndef RASTER_RENDERER_LEXER_H
#define RASTER_RENDERER_LEXER_H


namespace Spire
{
	namespace Compiler
	{
		using namespace CoreLib::Basic;

		enum class TokenType
		{
			// illegal
			Unkown,
			// identifier
			Identifier,
			KeywordReturn, KeywordBreak, KeywordContinue,
			KeywordIf, KeywordElse, KeywordFor, KeywordWhile, KeywordDo,
			// constant
			IntLiterial, DoubleLiterial, StringLiterial, CharLiterial,
			// operators
			Semicolon, Comma, Dot, LBrace, RBrace, LBracket, RBracket, LParent, RParent,
			OpAssign, OpAdd, OpSub, OpMul, OpDiv, OpMod, OpNot, OpBitNot, OpLsh, OpRsh, 
			OpEql, OpNeq, OpGreater, OpLess, OpGeq, OpLeq,
			OpAnd, OpOr, OpBitXor, OpBitAnd, OpBitOr,
			OpInc, OpDec, OpAddAssign, OpSubAssign, OpMulAssign, OpDivAssign, OpModAssign,
			OpShlAssign, OpShrAssign, OpOrAssign, OpAndAssign, OpXorAssign,
			
			QuestionMark, Colon, RightArrow, At,
		};

		String TokenTypeToString(TokenType type);

		class Token
		{
		public:
			TokenType Type = TokenType::Unkown;
			String Content;
			CodePosition Position;
			Token() = default;
			Token(TokenType type, const String & content, int line, int col, String fileName)
			{
				Type = type;
				Content = content;
				Position = CodePosition(line, col, fileName);
			}
		};

		class Lexer
		{
		public:
			List<Token> Parse(const String & fileName, const String & str, List<CompileError> & errorList);
		};
	}
}

#endif

/***********************************************************************
CORE\SYNTAX.H
***********************************************************************/
#ifndef RASTER_RENDERER_SYNTAX_H
#define RASTER_RENDERER_SYNTAX_H


namespace Spire
{
	namespace Compiler
	{
		using namespace CoreLib::Basic;
		class SyntaxVisitor;
		class FunctionSyntaxNode;

		enum class VariableModifier
		{
			None = 0,
			Uniform = 1,
			Out = 2,
			In = 4,
			Centroid = 128,
			Const = 16,
			Instance = 1024,
			Builtin = 256,
			Parameter = 513
		};

		enum class BaseType
		{
			Void = 0,
			Int = 16, Int2 = 17, Int3 = 18, Int4 = 19,
			Float = 32, Float2 = 33, Float3 = 34, Float4 = 35,
			UInt = 512, UInt2 = 513, UInt3 = 514, UInt4 = 515,
			Float3x3 = 40, Float4x4 = 47,
			Texture2D = 48,
			TextureShadow = 49,
			TextureCube = 50,
			TextureCubeShadow = 51,
			Function = 64,
			Bool = 128,
			Shader = 256,
			Struct = 1024,
			Error = 2048,

		};

		inline const wchar_t * BaseTypeToString(BaseType t)
		{
			switch (t)
			{
			case BaseType::Void:
				return L"void";
			case BaseType::Bool:
			case BaseType::Int:
				return L"int";
			case BaseType::Int2:
				return L"int2";
			case BaseType::Int3:
				return L"int3";
			case BaseType::Int4:
				return L"int4";
			case BaseType::Float:
				return L"float";
			case BaseType::Float2:
				return L"float2";
			case BaseType::Float3:
				return L"float3";
			case BaseType::Float4:
				return L"float4";
			case BaseType::Float3x3:
				return L"float3x3";
			case BaseType::Float4x4:
				return L"float4x4";
			case BaseType::Texture2D:
				return L"sampler2D";
			case BaseType::TextureCube:
				return L"samplerCube";
			case BaseType::TextureShadow:
				return L"sampler2DShadow";
			case BaseType::TextureCubeShadow:
				return L"samplerCubeShadow";
			default:
				return L"<err-type>";
			}
		}

		inline bool IsVector(BaseType type)
		{
			return (((int)type) & 15) != 0;
		}

		inline int GetVectorSize(BaseType type)
		{
			return (((int)type) & 15) + 1;
		}

		inline BaseType GetVectorBaseType(BaseType type)
		{
			return (BaseType)(((int)type) & (~15));
		}

		inline bool IsTextureType(BaseType type)
		{
			return type == BaseType::Texture2D || type == BaseType::TextureCube || type == BaseType::TextureCubeShadow || type == BaseType::TextureShadow;
		}
		class SymbolTable;
		class ShaderSymbol;
		class StructSymbol;
		class ShaderClosure;
		class StructSyntaxNode;
		class ExpressionType
		{
		public:
			bool IsLeftValue;
			bool IsReference;
			BaseType BaseType;
			bool IsArray = false;
			int ArrayLength = 0;
			ShaderSymbol * Shader = nullptr;
			ShaderClosure * ShaderClosure = nullptr;
			FunctionSyntaxNode * Func = nullptr;
			StructSymbol * Struct = nullptr;
			ExpressionType GetBaseType()
			{
				ExpressionType rs;
				rs.IsLeftValue = IsLeftValue;
				rs.BaseType = BaseType;
				rs.IsArray = false;
				rs.IsReference = false;
				rs.ArrayLength = 0;
				rs.Func = Func;
				return rs;
			}
			ExpressionType()
			{
				BaseType = Compiler::BaseType::Int;
				ArrayLength = 0;
				IsArray = false;
				Func = 0;
				IsLeftValue = false;
				IsReference = false;
			}
			bool IsIntegral()
			{
				return !IsArray && (BaseType == Compiler::BaseType::Int || BaseType == Compiler::BaseType::UInt);
			}
			bool IsTextureType()
			{
				return !IsArray && (BaseType == Compiler::BaseType::Texture2D || BaseType == Compiler::BaseType::TextureCube || BaseType == Compiler::BaseType::TextureCubeShadow || BaseType == Compiler::BaseType::TextureShadow);
			}
			int GetSize();
			ExpressionType(Spire::Compiler::BaseType baseType)
			{
				BaseType = baseType;
				ArrayLength = 0;
				IsArray = false;
				Func = 0;
				IsLeftValue = false;
				IsReference = false;
			}

			static ExpressionType Bool;
			static ExpressionType UInt;
			static ExpressionType UInt2;
			static ExpressionType UInt3;
			static ExpressionType UInt4;
			static ExpressionType Int;
			static ExpressionType Int2;
			static ExpressionType Int3;
			static ExpressionType Int4;
			static ExpressionType Float;
			static ExpressionType Float2;
			static ExpressionType Float3;
			static ExpressionType Float4;
			static ExpressionType Void;
			static ExpressionType Error;

			bool operator == (const ExpressionType & type)
			{
				return (type.BaseType == BaseType &&
						type.IsArray == IsArray &&
						type.ArrayLength == ArrayLength &&
						type.Func == Func &&
						type.Shader == Shader &&
						type.Struct == Struct);
			}

			bool operator != (const ExpressionType & type)
			{
				return !(this->operator==(type));
			}

			bool IsVectorType()
			{
				return (!IsArray) && (IsVector(BaseType));
			}

			CoreLib::Basic::String ToString();
		};
		
		class Type
		{
		public:
			ExpressionType DataType;
			// ContrainedWorlds: Implementation must be defined at at least one of of these worlds in order to satisfy global dependency
			// FeasibleWorlds: The component can be computed at any of these worlds
			EnumerableHashSet<String> ConstrainedWorlds, FeasibleWorlds;
			EnumerableHashSet<String> PinnedWorlds; 
		};


		class VariableEntry
		{
		public:
			String Name;
			Type Type;
			bool IsComponent = false;
		};

		class Scope
		{
		public:
			Scope * Parent;
			Dictionary<String, VariableEntry> Variables;
			bool FindVariable(const String & name, VariableEntry & variable);
			Scope()
				: Parent(0)
			{}
		};

		class CloneContext
		{
		public:
			Dictionary<Spire::Compiler::Scope*, RefPtr<Spire::Compiler::Scope>> ScopeTranslateTable;
		};

		class SyntaxNode : public Object
		{
		protected:
			template<typename T>
			T* CloneSyntaxNodeFields(T * target, CloneContext & ctx)
			{
				if (this->Scope)
				{
					RefPtr<Spire::Compiler::Scope> newScope;
					if (ctx.ScopeTranslateTable.TryGetValue(this->Scope.Ptr(), newScope))
						target->Scope = newScope;
					else
					{
						target->Scope = new Spire::Compiler::Scope(*this->Scope);
						ctx.ScopeTranslateTable[this->Scope.Ptr()] = target->Scope;
						RefPtr<Spire::Compiler::Scope> parentScope;
						if (ctx.ScopeTranslateTable.TryGetValue(target->Scope->Parent, parentScope))
							target->Scope->Parent = parentScope.Ptr();
					}
					
				}
				target->Position = this->Position;
				Tags = this->Tags;
				return target;
			}
		public:
			EnumerableDictionary<String, RefPtr<Object>> Tags;
			CodePosition Position;
			RefPtr<Scope> Scope;
			virtual void Accept(SyntaxVisitor * visitor) = 0;
			virtual SyntaxNode * Clone(CloneContext & ctx) = 0;
		};

		class TypeSyntaxNode : public SyntaxNode
		{
		public:
			bool IsArray;
			String TypeName;
			int ArrayLength;
			String GenericBaseType;
			virtual void Accept(SyntaxVisitor * visitor);
			TypeSyntaxNode()
			{
				ArrayLength = 0;
				IsArray = false;
			}
			
			static TypeSyntaxNode * FromExpressionType(ExpressionType t);

			ExpressionType ToExpressionType(SymbolTable * symTable, ErrorWriter * errWriter = nullptr);
			virtual TypeSyntaxNode * Clone(CloneContext & ctx)
			{
				return CloneSyntaxNodeFields(new TypeSyntaxNode(*this), ctx);
			}
			String ToString()
			{
				StringBuilder rs;
				rs << TypeName;
				if (IsArray)
				{
					rs << L"[";
					if (ArrayLength > 0)
						rs << ArrayLength;
					rs << L"]";
				}
				return rs.ProduceString();
			}
		};

		class StructField : public SyntaxNode
		{
		public:
			RefPtr<TypeSyntaxNode> Type;
			Token Name;
			StructField()
			{}
			virtual void Accept(SyntaxVisitor * visitor) override;
			virtual StructField * Clone(CloneContext & ctx) override
			{
				auto rs = CloneSyntaxNodeFields(new StructField(*this), ctx);
				rs->Type = Type->Clone(ctx);
				return rs;
			}
		};

		class StructSyntaxNode : public SyntaxNode
		{
		public:
			List<RefPtr<StructField>> Fields;
			Token Name;
			virtual void Accept(SyntaxVisitor * visitor) override;
			int FindField(String name)
			{
				for (int i = 0; i < Fields.Count(); i++)
				{
					if (Fields[i]->Name.Content == name)
						return i;
				}
				return -1;
			}
			virtual StructSyntaxNode * Clone(CloneContext & ctx) override
			{
				auto rs = CloneSyntaxNodeFields(new StructSyntaxNode(*this), ctx);
				rs->Fields.Clear();
				for (auto & f : Fields)
					rs->Fields.Add(f->Clone(ctx));
				return rs;
			}
		};

		enum class ExpressionAccess
		{
			Read, Write
		};

		class ExpressionSyntaxNode : public SyntaxNode
		{
		public:
			ExpressionType Type;
			ExpressionAccess Access;
			ExpressionSyntaxNode()
			{
				Access = ExpressionAccess::Read;
			}
			ExpressionSyntaxNode(const ExpressionSyntaxNode & expr) = default;
		};

		class ParameterSyntaxNode : public SyntaxNode
		{
		public:
			RefPtr<TypeSyntaxNode> Type;
			String Name;
			RefPtr<ExpressionSyntaxNode> Expr;
			virtual void Accept(SyntaxVisitor * visitor);
			virtual ParameterSyntaxNode * Clone(CloneContext & ctx);
		};

		class ChoiceValueSyntaxNode : public ExpressionSyntaxNode
		{
		public:
			String WorldName, AlternateName;
			virtual void Accept(SyntaxVisitor *) {}
			virtual ChoiceValueSyntaxNode * Clone(CloneContext & ctx);
		};

		class VarExpressionSyntaxNode : public ExpressionSyntaxNode
		{
		public:
			String Variable;
			virtual void Accept(SyntaxVisitor * visitor);
			virtual VarExpressionSyntaxNode * Clone(CloneContext & ctx);
		};

		class ConstantExpressionSyntaxNode : public ExpressionSyntaxNode
		{
		public:
			enum class ConstantType
			{
				Int, Float
			};
			ConstantType ConstType;
			union
			{
				int IntValue;
				float FloatValue;
			};
			virtual void Accept(SyntaxVisitor * visitor);
			virtual ConstantExpressionSyntaxNode * Clone(CloneContext & ctx);
		};

		enum class Operator
		{
			Neg, Not, BitNot, PreInc, PreDec, PostInc, PostDec,
			Mul, Div, Mod,
			Add, Sub, 
			Lsh, Rsh,
			Eql, Neq, Greater, Less, Geq, Leq,
			BitAnd, BitXor, BitOr,
			And,
			Or,
			Assign, AddAssign, SubAssign, MulAssign, DivAssign, ModAssign,
			LshAssign, RshAssign, OrAssign, AndAssign, XorAssign
		};
		
		class UnaryExpressionSyntaxNode : public ExpressionSyntaxNode
		{
		public:
			Operator Operator;
			RefPtr<ExpressionSyntaxNode> Expression;
			virtual void Accept(SyntaxVisitor * visitor);
			virtual UnaryExpressionSyntaxNode * Clone(CloneContext & ctx);
		};
		
		class BinaryExpressionSyntaxNode : public ExpressionSyntaxNode
		{
		public:
			Operator Operator;
			RefPtr<ExpressionSyntaxNode> LeftExpression;
			RefPtr<ExpressionSyntaxNode> RightExpression;
			virtual void Accept(SyntaxVisitor * visitor);
			virtual BinaryExpressionSyntaxNode * Clone(CloneContext & ctx);
		};

		class IndexExpressionSyntaxNode : public ExpressionSyntaxNode
		{
		public:
			RefPtr<ExpressionSyntaxNode> BaseExpression;
			RefPtr<ExpressionSyntaxNode> IndexExpression;
			virtual IndexExpressionSyntaxNode * Clone(CloneContext & ctx);
			virtual void Accept(SyntaxVisitor * visitor);
		};

		class MemberExpressionSyntaxNode : public ExpressionSyntaxNode
		{
		public:
			RefPtr<ExpressionSyntaxNode> BaseExpression;
			String MemberName;
			virtual void Accept(SyntaxVisitor * visitor);
			virtual MemberExpressionSyntaxNode * Clone(CloneContext & ctx);
		};

		class InvokeExpressionSyntaxNode : public ExpressionSyntaxNode
		{
		public:
			RefPtr<VarExpressionSyntaxNode> FunctionExpr;
			List<RefPtr<ExpressionSyntaxNode>> Arguments;
			virtual void Accept(SyntaxVisitor * visitor);
			virtual InvokeExpressionSyntaxNode * Clone(CloneContext & ctx);
		};

		class TypeCastExpressionSyntaxNode : public ExpressionSyntaxNode
		{
		public:
			RefPtr<TypeSyntaxNode> TargetType;
			RefPtr<ExpressionSyntaxNode> Expression;
			virtual void Accept(SyntaxVisitor * visitor);
			virtual TypeCastExpressionSyntaxNode * Clone(CloneContext & ctx);
		};

		class SelectExpressionSyntaxNode : public ExpressionSyntaxNode
		{
		public:
			RefPtr<ExpressionSyntaxNode> SelectorExpr, Expr0, Expr1;
			virtual void Accept(SyntaxVisitor * visitor);
			virtual SelectExpressionSyntaxNode * Clone(CloneContext & ctx);
		};

		class StatementSyntaxNode : public SyntaxNode
		{
		};

		class EmptyStatementSyntaxNode : public StatementSyntaxNode
		{
		public:
			virtual void Accept(SyntaxVisitor * visitor);
			virtual EmptyStatementSyntaxNode * Clone(CloneContext & ctx);
		};

		class BlockStatementSyntaxNode : public StatementSyntaxNode
		{
		public:
			List<RefPtr<StatementSyntaxNode>> Statements;
			virtual void Accept(SyntaxVisitor * visitor);
			virtual BlockStatementSyntaxNode * Clone(CloneContext & ctx);
		};

		class DiscardStatementSyntaxNode : public StatementSyntaxNode
		{
		public:
			virtual void Accept(SyntaxVisitor * visitor);
			virtual DiscardStatementSyntaxNode * Clone(CloneContext & ctx);
		};

		class VariableDeclr
		{
		public:
			ExpressionType Type;
			String Name;

			bool operator ==(const VariableDeclr & var)
			{
				return Name == var.Name;
			}
			bool operator ==(const String & name)
			{
				return name == Name;
			}
		};
		class FunctionSyntaxNode : public SyntaxNode
		{
		public:
			String Name, InternalName;
			RefPtr<TypeSyntaxNode> ReturnType;
			List<RefPtr<ParameterSyntaxNode>> Parameters;
			RefPtr<BlockStatementSyntaxNode> Body;
			List<VariableDeclr> Variables;
			bool IsInline;
			bool IsExtern;
			bool HasSideEffect;
			virtual void Accept(SyntaxVisitor * visitor);
			FunctionSyntaxNode()
			{
				IsInline = false;
				IsExtern = false;
				HasSideEffect = true;
			}

			virtual FunctionSyntaxNode * Clone(CloneContext & ctx);
		};

		struct Variable : public SyntaxNode
		{
			String Name;
			RefPtr<ExpressionSyntaxNode> Expression;
			virtual void Accept(SyntaxVisitor * visitor);
			virtual Variable * Clone(CloneContext & ctx);
		};

		class VarDeclrStatementSyntaxNode : public StatementSyntaxNode
		{
		public:
			RefPtr<TypeSyntaxNode> Type;
			String LayoutString;
			List<RefPtr<Variable>> Variables;
			virtual void Accept(SyntaxVisitor * visitor);
			virtual VarDeclrStatementSyntaxNode * Clone(CloneContext & ctx);
		};

		class RateWorld
		{
		public:
			Token World;
			bool Pinned = false;
		};

		class RateSyntaxNode : public SyntaxNode
		{
		public:
			List<RateWorld> Worlds;
			virtual void Accept(SyntaxVisitor *) override {}
			virtual RateSyntaxNode * Clone(CloneContext & ctx) override;
		};

		class ShaderMemberNode : public SyntaxNode
		{};

		class ComponentSyntaxNode : public ShaderMemberNode
		{
		public:
			bool IsOutput = false, IsPublic = false, IsInline = false, IsParam = false;
			RefPtr<TypeSyntaxNode> Type;
			RefPtr<RateSyntaxNode> Rate;
			Token Name, AlternateName;
			EnumerableDictionary<String, String> LayoutAttributes;
			RefPtr<BlockStatementSyntaxNode> BlockStatement;
			RefPtr<ExpressionSyntaxNode> Expression;
			virtual void Accept(SyntaxVisitor * visitor) override;
			virtual ComponentSyntaxNode * Clone(CloneContext & ctx) override;
		};

		class WorldSyntaxNode : public SyntaxNode
		{
		public:
			bool IsAbstract = false;
			Token Name;
			Token ExportOperator;
			String TargetMachine;
			List<Token> Usings;
			EnumerableDictionary<String, String> LayoutAttributes;
			virtual void Accept(SyntaxVisitor *) override {}
			virtual WorldSyntaxNode * Clone(CloneContext & ctx) override;
		};

		class ImportOperatorDefSyntaxNode : public SyntaxNode
		{
		public:
			Token Name;
			Token SourceWorld, DestWorld;
			List<Token> Usings;
			EnumerableDictionary<String, String> LayoutAttributes;
			EnumerableDictionary<String, String> Arguments;
			virtual void Accept(SyntaxVisitor *) override {}
			virtual ImportOperatorDefSyntaxNode * Clone(CloneContext & ctx) override;
		};
		
		class PipelineSyntaxNode : public SyntaxNode
		{
		public:
			Token Name;
			List<RefPtr<WorldSyntaxNode>> Worlds;
			List<RefPtr<ImportOperatorDefSyntaxNode>> ImportOperators;
			List<RefPtr<ComponentSyntaxNode>> AbstractComponents;
			virtual void Accept(SyntaxVisitor *) override {}
			virtual PipelineSyntaxNode * Clone(CloneContext & ctx) override;
		};

		class ImportArgumentSyntaxNode : public SyntaxNode
		{
		public:
			RefPtr<ExpressionSyntaxNode> Expression;
			Token ArgumentName;
			virtual void Accept(SyntaxVisitor *) override;
			virtual ImportArgumentSyntaxNode * Clone(CloneContext & ctx) override;
		};

		class ImportSyntaxNode : public ShaderMemberNode
		{
		public:
			bool IsInplace = false;
			bool IsPublic = false;
			Token ShaderName;
			Token ObjectName;
			List<RefPtr<ImportArgumentSyntaxNode>> Arguments;
			virtual void Accept(SyntaxVisitor *) override;
			virtual ImportSyntaxNode * Clone(CloneContext & ctx) override;

		};

		class ShaderSyntaxNode : public SyntaxNode
		{
		public:
			Token Name;
			Token Pipeline;
			List<RefPtr<ShaderMemberNode>> Members;
			bool IsModule = false;
			virtual void Accept(SyntaxVisitor * visitor) override;
			virtual ShaderSyntaxNode * Clone(CloneContext & ctx) override;
		};

		class ProgramSyntaxNode : public SyntaxNode
		{
		public:
			List<Token> Usings;
			List<RefPtr<FunctionSyntaxNode>> Functions;
			List<RefPtr<PipelineSyntaxNode>> Pipelines;
			List<RefPtr<ShaderSyntaxNode>> Shaders;
			List<RefPtr<StructSyntaxNode>> Structs;
			void Include(ProgramSyntaxNode * other)
			{
				Functions.AddRange(other->Functions);
				Pipelines.AddRange(other->Pipelines);
				Shaders.AddRange(other->Shaders);
				Structs.AddRange(other->Structs);
			}
			virtual void Accept(SyntaxVisitor * visitor) override;
			virtual ProgramSyntaxNode * Clone(CloneContext & ctx) override;
		};

		class ImportStatementSyntaxNode : public StatementSyntaxNode
		{
		public:
			RefPtr<ImportSyntaxNode> Import;
			virtual void Accept(SyntaxVisitor * visitor) override;
			virtual ImportStatementSyntaxNode * Clone(CloneContext & ctx) override;
		};

		class IfStatementSyntaxNode : public StatementSyntaxNode
		{
		public:
			RefPtr<ExpressionSyntaxNode> Predicate;
			RefPtr<StatementSyntaxNode> PositiveStatement;
			RefPtr<StatementSyntaxNode> NegativeStatement;
			virtual void Accept(SyntaxVisitor * visitor) override;
			virtual IfStatementSyntaxNode * Clone(CloneContext & ctx) override;
		};

		class ForStatementSyntaxNode : public StatementSyntaxNode
		{
		public:
			RefPtr<TypeSyntaxNode> TypeDef;
			Token IterationVariable;

			RefPtr<ExpressionSyntaxNode> InitialExpression, StepExpression, EndExpression;
			RefPtr<StatementSyntaxNode> Statement;
			virtual void Accept(SyntaxVisitor * visitor) override;
			virtual ForStatementSyntaxNode * Clone(CloneContext & ctx) override;
		};

		class WhileStatementSyntaxNode : public StatementSyntaxNode
		{
		public:
			RefPtr<ExpressionSyntaxNode> Predicate;
			RefPtr<StatementSyntaxNode> Statement;
			virtual void Accept(SyntaxVisitor * visitor) override;
			virtual WhileStatementSyntaxNode * Clone(CloneContext & ctx) override;
		};

		class DoWhileStatementSyntaxNode : public StatementSyntaxNode
		{
		public:
			RefPtr<StatementSyntaxNode> Statement;
			RefPtr<ExpressionSyntaxNode> Predicate;
			virtual void Accept(SyntaxVisitor * visitor) override;
			virtual DoWhileStatementSyntaxNode * Clone(CloneContext & ctx) override;
		};

		class BreakStatementSyntaxNode : public StatementSyntaxNode
		{
		public:
			virtual void Accept(SyntaxVisitor * visitor) override;
			virtual BreakStatementSyntaxNode * Clone(CloneContext & ctx) override;
		};

		class ContinueStatementSyntaxNode : public StatementSyntaxNode
		{
		public:
			virtual void Accept(SyntaxVisitor * visitor) override;
			virtual ContinueStatementSyntaxNode * Clone(CloneContext & ctx) override;
		};

		class ReturnStatementSyntaxNode : public StatementSyntaxNode
		{
		public:
			RefPtr<ExpressionSyntaxNode> Expression;
			virtual void Accept(SyntaxVisitor * visitor) override;
			virtual ReturnStatementSyntaxNode * Clone(CloneContext & ctx) override;
		};

		class ExpressionStatementSyntaxNode : public StatementSyntaxNode
		{
		public:
			RefPtr<ExpressionSyntaxNode> Expression;
			virtual void Accept(SyntaxVisitor * visitor) override;
			virtual ExpressionStatementSyntaxNode * Clone(CloneContext & ctx) override;
		};

		class SyntaxVisitor : public Object
		{
		protected:
			ErrorWriter * err = nullptr;
			void Error(int id, const String & text, SyntaxNode * node)
			{
				err->Error(id, text, node->Position);
			}
			void Error(int id, const String & text, Token node)
			{
				err->Error(id, text, node.Position);
			}
			void Warning(int id, const String & text, SyntaxNode * node)
			{
				err->Warning(id, text, node->Position);
			}
			void Warning(int id, const String & text, Token node)
			{
				err->Warning(id, text, node.Position);
			}
		public:
			SyntaxVisitor(ErrorWriter * pErr)
				: err(pErr)
			{}
			virtual void VisitProgram(ProgramSyntaxNode * program)
			{
				program->Functions.ForEach([&](RefPtr<FunctionSyntaxNode> f){f->Accept(this);});
			}
			virtual void VisitShader(ShaderSyntaxNode * shader)
			{
				for (auto & comp : shader->Members)
					comp->Accept(this);
			}
			virtual void VisitComponent(ComponentSyntaxNode * comp)
			{
				if (comp->Expression)
					comp->Expression->Accept(this);
				if (comp->BlockStatement)
					comp->BlockStatement->Accept(this);
			}
			virtual void VisitFunction(FunctionSyntaxNode* func)
			{
				func->ReturnType->Accept(this);
				for (auto & param : func->Parameters)
					param->Accept(this);
				if (func->Body)
					func->Body->Accept(this);
			}
			virtual void VisitStruct(StructSyntaxNode * s)
			{
				for (auto & f : s->Fields)
					f->Accept(this);
			}
			virtual void VisitDiscardStatement(DiscardStatementSyntaxNode *)
			{}
			virtual void VisitStructField(StructField * f)
			{
				f->Type->Accept(this);
			}
			virtual void VisitBlockStatement(BlockStatementSyntaxNode* stmt)
			{
				for (auto & s : stmt->Statements)
					s->Accept(this);
			}
			virtual void VisitBreakStatement(BreakStatementSyntaxNode*){}
			virtual void VisitContinueStatement(ContinueStatementSyntaxNode*){}

			virtual void VisitDoWhileStatement(DoWhileStatementSyntaxNode* stmt)
			{
				if (stmt->Predicate)
					stmt->Predicate->Accept(this);
				if (stmt->Statement)
					stmt->Statement->Accept(this);
			}
			virtual void VisitEmptyStatement(EmptyStatementSyntaxNode*){}
			virtual void VisitForStatement(ForStatementSyntaxNode* stmt)
			{
				if (stmt->InitialExpression)
					stmt->InitialExpression->Accept(this);
				if (stmt->StepExpression)
					stmt->StepExpression->Accept(this);
				if (stmt->EndExpression)
					stmt->EndExpression->Accept(this);
				if (stmt->Statement)
					stmt->Statement->Accept(this);
			}
			virtual void VisitIfStatement(IfStatementSyntaxNode* stmt)
			{
				if (stmt->Predicate)
					stmt->Predicate->Accept(this);
				if (stmt->PositiveStatement)
					stmt->PositiveStatement->Accept(this);
				if (stmt->NegativeStatement)
					stmt->NegativeStatement->Accept(this);
			}
			virtual void VisitReturnStatement(ReturnStatementSyntaxNode* stmt)
			{
				if (stmt->Expression)
					stmt->Expression->Accept(this);
			}
			virtual void VisitVarDeclrStatement(VarDeclrStatementSyntaxNode* stmt)
			{
				for (auto & var : stmt->Variables)
					var->Accept(this);
			}
			virtual void VisitWhileStatement(WhileStatementSyntaxNode* stmt)
			{
				if (stmt->Predicate)
					stmt->Predicate->Accept(this);
				if (stmt->Statement)
					stmt->Statement->Accept(this);
			}
			virtual void VisitExpressionStatement(ExpressionStatementSyntaxNode* stmt)
			{
				if (stmt->Expression)
					stmt->Expression->Accept(this);
			}

			virtual void VisitBinaryExpression(BinaryExpressionSyntaxNode* expr)
			{
				if (expr->LeftExpression)
					expr->LeftExpression->Accept(this);
				if (expr->RightExpression)
					expr->RightExpression->Accept(this);
			}
			virtual void VisitConstantExpression(ConstantExpressionSyntaxNode*) {}
			virtual void VisitIndexExpression(IndexExpressionSyntaxNode* expr)
			{
				if (expr->BaseExpression)
					expr->BaseExpression->Accept(this);
				if (expr->IndexExpression)
					expr->IndexExpression->Accept(this);
			}
			virtual void VisitMemberExpression(MemberExpressionSyntaxNode * stmt)
			{
				if (stmt->BaseExpression)
					stmt->BaseExpression->Accept(this);
			}
			virtual void VisitInvokeExpression(InvokeExpressionSyntaxNode* stmt)
			{
				for (auto & arg : stmt->Arguments)
					arg->Accept(this);
			}
			virtual void VisitTypeCastExpression(TypeCastExpressionSyntaxNode * stmt)
			{
				if (stmt->Expression)
					stmt->Expression->Accept(this);
			}
			virtual void VisitSelectExpression(SelectExpressionSyntaxNode * expr)
			{
				if (expr->SelectorExpr)
					expr->SelectorExpr->Accept(this);
				if (expr->Expr0)
					expr->Expr0->Accept(this);
				if (expr->Expr1)
					expr->Expr1->Accept(this);
			}
			virtual void VisitUnaryExpression(UnaryExpressionSyntaxNode* expr)
			{
				if (expr->Expression)
					expr->Expression->Accept(this);
			}
			virtual void VisitVarExpression(VarExpressionSyntaxNode*){}
			virtual void VisitParameter(ParameterSyntaxNode*){}
			virtual void VisitType(TypeSyntaxNode*){}
			virtual void VisitDeclrVariable(Variable* dclr)
			{
				if (dclr->Expression)
					dclr->Expression->Accept(this);
			}
			virtual void VisitImport(ImportSyntaxNode* imp)
			{
				for (auto & arg : imp->Arguments)
					if (arg->Expression)
						arg->Expression->Accept(this);
			}
			virtual void VisitImportStatement(ImportStatementSyntaxNode* stmt)
			{
				if (stmt->Import)
					stmt->Import->Accept(this);
			}
			virtual void VisitImportArgument(ImportArgumentSyntaxNode * arg)
			{
				if (arg->Expression)
					arg->Expression->Accept(this);
			}

		};
	}
}

#endif

/***********************************************************************
CORE\IL.H
***********************************************************************/
#ifndef RASTER_RENDERER_IL_H
#define RASTER_RENDERER_IL_H


namespace Spire
{
	namespace Compiler
	{
		using namespace CoreLib::Basic;

		const int MaxSIMDSize = 8;

		enum ILBaseType
		{
			Int = 16, Int2 = 17, Int3 = 18, Int4 = 19,
			Float = 32, Float2 = 33, Float3 = 34, Float4 = 35,
			Float3x3 = 40, Float4x4 = 47,
			Texture2D = 48,
			TextureShadow = 49,
			TextureCube = 50,
			TextureCubeShadow = 51,
			UInt = 512, UInt2 = 513, UInt3 = 514, UInt4 = 515,
			Bool
		};
		int SizeofBaseType(ILBaseType type);
		int RoundToAlignment(int offset, int alignment);
		extern int NamingCounter;
		class ILType : public Object
		{
		public:
			bool IsBool();
			bool IsInt();
			bool IsUInt();
			bool IsIntegral();
			bool IsFloat();
			bool IsScalar()
			{
				return IsInt() || IsUInt() || IsFloat();
			}
			bool IsIntVector();
			bool IsUIntVector();
			bool IsFloatVector();
			bool IsFloatMatrix();
			bool IsVector()
			{
				return IsIntVector() || IsUIntVector() || IsFloatVector();
			}
			bool IsTexture();
			bool IsNonShadowTexture();
			int GetVectorSize();
			virtual ILType * Clone() = 0;
			virtual String ToString() = 0;
			virtual bool Equals(ILType* type) = 0;
			virtual int GetSize() = 0;
			virtual int GetAlignment() = 0;
		};

		RefPtr<ILType> TypeFromString(CoreLib::Text::Parser & parser);

		class ILBasicType : public ILType
		{
		public:
			ILBaseType Type;
			ILBasicType()
			{
				Type = ILBaseType::Int;
			}
			ILBasicType(ILBaseType t)
			{
				Type = t;
			}
			virtual bool Equals(ILType* type) override
			{
				auto btype = dynamic_cast<ILBasicType*>(type);
				if (!btype)
					return false;
				return Type == btype->Type;
			}

			virtual ILType * Clone() override
			{
				auto rs = new ILBasicType();
				rs->Type = Type;
				return rs;
			}
			virtual String ToString() override
			{
				if (Type == ILBaseType::Int)
					return L"int";
				else if (Type == ILBaseType::UInt)
					return L"uint";
				else if (Type == ILBaseType::UInt2)
					return L"uvec2";
				else if (Type == ILBaseType::UInt3)
					return L"uvec3";
				else if (Type == ILBaseType::UInt4)
					return L"uvec4";
				else if (Type == ILBaseType::Int2)
					return L"ivec2";
				else if (Type == ILBaseType::Int3)
					return L"ivec3";
				else if (Type == ILBaseType::Int4)
					return L"ivec4";
				else if (Type == ILBaseType::Float)
					return L"float";
				else if (Type == ILBaseType::Float2)
					return L"vec2";
				else if (Type == ILBaseType::Float3)
					return L"vec3";
				else if (Type == ILBaseType::Float4)
					return L"vec4";
				else if (Type == ILBaseType::Float3x3)
					return L"mat3";
				else if (Type == ILBaseType::Float4x4)
					return L"mat4";
				else if (Type == ILBaseType::Texture2D)
					return L"sampler2D";
				else if (Type == ILBaseType::TextureCube)
					return L"samplerCube";
				else if (Type == ILBaseType::TextureCubeShadow)
					return L"samplerCubeShadow";
				else if (Type == ILBaseType::TextureShadow)
					return L"sampler2DShadow";
				else if (Type == ILBaseType::Bool)
					return L"bool";
				else
					return L"?unkown";
			}
			virtual int GetAlignment() override
			{
				switch (Type)
				{
				case ILBaseType::Int:
					return 4;
				case ILBaseType::UInt:
					return 4;
				case ILBaseType::Int2:
				case ILBaseType::UInt2:
					return 8;
				case ILBaseType::Int3:
				case ILBaseType::UInt3:
					return 16;
				case ILBaseType::Int4:
				case ILBaseType::UInt4:
					return 16;
				case ILBaseType::Float:
					return 4;
				case ILBaseType::Float2:
					return 8;
				case  ILBaseType::Float3:
					return 16;
				case ILBaseType::Float4:
					return 16;
				case ILBaseType::Float3x3:
					return 16;
				case  ILBaseType::Float4x4:
					return 16;
				case ILBaseType::Texture2D:
					return 8;
				case ILBaseType::TextureCube:
					return 8;
				case ILBaseType::TextureCubeShadow:
					return 8;
				case ILBaseType::TextureShadow:
					return 8;
				default:
					return 0;
				}
			}
			virtual int GetSize() override
			{
				switch (Type)
				{
				case ILBaseType::Float:
				case ILBaseType::Int:
				case ILBaseType::UInt:
					return 4;
				case ILBaseType::Float2:
				case ILBaseType::Int2:
				case ILBaseType::UInt2:
					return 8;
				case ILBaseType::Int3:
				case ILBaseType::Float3:
				case ILBaseType::UInt3:
					return 12;
				case ILBaseType::Int4:
				case ILBaseType::Float4:
				case ILBaseType::UInt4:
					return 16;
				case ILBaseType::Float3x3:
					return 48;
				case ILBaseType::Float4x4:
					return 64;
				case ILBaseType::Texture2D:
				case ILBaseType::TextureCube:
				case ILBaseType::TextureCubeShadow:
				case ILBaseType::TextureShadow:
					return 8;
				default:
					return 0;
				}
			}
		};

		class ILArrayType : public ILType
		{
		public:
			RefPtr<ILType> BaseType;
			int ArrayLength;
			virtual bool Equals(ILType* type) override
			{
				auto btype = dynamic_cast<ILArrayType*>(type);
				if (!btype)
					return false;
				return BaseType->Equals(btype->BaseType.Ptr());;
			}
			virtual ILType * Clone() override
			{
				auto rs = new ILArrayType();
				rs->BaseType = BaseType->Clone();
				rs->ArrayLength = ArrayLength;
				return rs;
			}
			virtual String ToString() override
			{
				if (ArrayLength > 0)
					return BaseType->ToString() + L"[" + String(ArrayLength) + L"]";
				else
					return BaseType->ToString() + L"[]";
			}
			virtual int GetSize() override
			{
				return BaseType->GetSize() * ArrayLength;
			}
			virtual int GetAlignment() override
			{
				return BaseType->GetAlignment();
			}
		};

		class ILStructType : public ILType
		{
		public:
			String TypeName;
			class ILStructField
			{
			public:
				RefPtr<ILType> Type;
				String FieldName;
			};
			List<ILStructField> Members;
			virtual ILType * Clone() override;
			virtual String ToString() override;
			virtual bool Equals(ILType * type) override;
			virtual int GetSize() override;
			virtual int GetAlignment() override;
		};

		class ILOperand;

		class UserReferenceSet
		{
		private:
			EnumerableDictionary<ILOperand*, int> userRefCounts;
			int count;
		public:
			UserReferenceSet()
			{
				count = 0;
			}
			int Count()
			{
				return count;
			}
			int GetUseCount(ILOperand * op)
			{
				int rs = -1;
				userRefCounts.TryGetValue(op, rs);
				return rs;
			}
			void Add(ILOperand * user)
			{
				this->count++;
				int ncount = 0;
				if (userRefCounts.TryGetValue(user, ncount))
				{
					ncount++;
					userRefCounts[user] = ncount;
				}
				else
				{
					userRefCounts.Add(user, 1);
				}
			}
			void Remove(ILOperand * user)
			{
				int ncount = 0;
				if (userRefCounts.TryGetValue(user, ncount))
				{
					this->count--;
					ncount--;
					if (ncount)
						userRefCounts[user] = ncount;
					else
						userRefCounts.Remove(user);
				}
			}
			void RemoveAll(ILOperand * user)
			{
				int ncount = 0;
				if (userRefCounts.TryGetValue(user, ncount))
				{
					this->count -= ncount;
					userRefCounts.Remove(user);
				}
			}
			class UserIterator
			{
			private:
				EnumerableDictionary<ILOperand*, int>::Iterator iter;
			public:
				ILOperand * operator *()
				{
					return iter.Current->Value.Key;
				}
				ILOperand ** operator ->()
				{
					return &iter.Current->Value.Key;
				}
				UserIterator & operator ++()
				{
					iter++;
					return *this;
				}
				UserIterator operator ++(int)
				{
					UserIterator rs = *this;
					operator++();
					return rs;
				}
				bool operator != (const UserIterator & _that)
				{
					return iter != _that.iter;
				}
				bool operator == (const UserIterator & _that)
				{
					return iter == _that.iter;
				}
				UserIterator(const EnumerableDictionary<ILOperand*, int>::Iterator & iter)
				{
					this->iter = iter;
				}
				UserIterator()
				{
				}
			};
			UserIterator begin()
			{
				return UserIterator(userRefCounts.begin());
			}
			UserIterator end()
			{
				return UserIterator(userRefCounts.end());
			}
		};

		class ILOperand : public Object
		{
		public:
			String Name;
			RefPtr<ILType> Type;
			UserReferenceSet Users;
			String Attribute;
			void * Tag;
			union VMFields
			{
				void * VMData;
				struct Fields
				{
					int VMDataWords[2];
				} Fields;
			} VMFields;
			Procedure<ILOperand*> OnDelete;
			ILOperand()
			{
				Tag = nullptr;
			}
			ILOperand(const ILOperand & op)
			{
				Tag = op.Tag;
				Name = op.Name;
				Attribute = op.Attribute;
				if (op.Type)
					Type = op.Type->Clone();
				//Users = op.Users;
			}
			virtual ~ILOperand()
			{
				OnDelete(this);
			}
			virtual String ToString()
			{
				return L"<operand>";
			}
			virtual bool IsUndefined()
			{
				return false;
			}
		};

		class ILUndefinedOperand : public ILOperand
		{
		public:
			ILUndefinedOperand()
			{
				Name = L"<undef>";
			}
			virtual String ToString() override
			{
				return L"<undef>";
			}
			virtual bool IsUndefined() override
			{
				return true;
			}
		};

		class UseReference
		{
		private:
			ILOperand * user;
			ILOperand * reference;
		public:
			UseReference()
				: user(0), reference(0)
			{}
			UseReference(const UseReference &)
			{
				user = 0;
				reference = 0;
			}
			UseReference(ILOperand * user)
				: user(user), reference(0)
			{}
			UseReference(ILOperand * user, ILOperand * ref)
			{
				this->user = user;
				this->reference = ref;
			}
			~UseReference()
			{
				if (reference)
					reference->Users.Remove(user);
			}
			void SetUser(ILOperand * _user)
			{
				this->user = _user;
			}
			void operator = (const UseReference & ref)
			{
				if (reference)
					reference->Users.Remove(user);
				reference = ref.Ptr();
				if (ref.Ptr())
				{
					if (!user)
						throw InvalidOperationException(L"user not initialized.");
					ref.Ptr()->Users.Add(user);
				}
			}
			void operator = (ILOperand * newRef)
			{
				if (reference)
					reference->Users.Remove(user);
				reference = newRef;
				if (newRef)
				{
					if (!user)
						throw InvalidOperationException(L"user not initialized.");
					newRef->Users.Add(user);
				}
			}
			bool operator != (const UseReference & _that)
			{
				return reference != _that.reference || user != _that.user;
			}
			bool operator == (const UseReference & _that)
			{
				return reference == _that.reference && user == _that.user;
			}
			ILOperand * Ptr() const
			{
				return reference;
			}
			ILOperand * operator->()
			{
				return reference;
			}
			ILOperand & operator*()
			{
				return *reference;
			}
			explicit operator bool()
			{
				return (reference != 0);
			}
			String ToString()
			{
				if (reference)
					return reference->Name;
				else
					return L"<null>";
			}
		};

		class OperandIterator
		{
		private:
			UseReference * use;
		public:
			OperandIterator()
			{
				use = 0;
			}
			OperandIterator(UseReference * use)
				: use(use)
			{}
			ILOperand & operator *()
			{
				return use->operator*();
			}
			ILOperand * operator ->()
			{
				return use->operator->();
			}
			void Set(ILOperand * user, ILOperand * op)
			{
				(*use).SetUser(user);
				(*use) = op;
			}
			void Set(ILOperand * op)
			{
				(*use) = op; 
			}
			OperandIterator & operator ++()
			{
				use++;
				return *this;
			}
			OperandIterator operator ++(int)
			{
				OperandIterator rs = *this;
				operator++();
				return rs;
			}
			bool operator != (const OperandIterator & _that)
			{
				return use != _that.use;
			}
			bool operator == (const OperandIterator & _that)
			{
				return use == _that.use;
			}
			bool operator == (const ILOperand * op)
			{
				return use->Ptr() == op;
			}
			bool operator != (const ILOperand * op)
			{
				return use->Ptr() != op;
			}
		};

		class ILConstOperand : public ILOperand
		{
		public:
			union
			{
				int IntValues[16];
				float FloatValues[16];
			};
			virtual String ToString() override
			{
				if (Type->IsFloat())
					return String(FloatValues[0]) + L"f";
				else if (Type->IsInt())
					return String(IntValues[0]);
				else if (auto baseType = dynamic_cast<ILBasicType*>(Type.Ptr()))
				{
					StringBuilder sb(256);
					if (baseType->Type == ILBaseType::Float2)
						sb << L"vec2(" << FloatValues[0] << L"f, " << FloatValues[1] << L"f)";
					else if (baseType->Type == ILBaseType::Float3)
						sb << L"vec3(" << FloatValues[0] << L"f, " << FloatValues[1] << L"f, " << FloatValues[2] << L"f)";
					else if (baseType->Type == ILBaseType::Float4)
						sb << L"vec4(" << FloatValues[0] << L"f, " << FloatValues[1] << L"f, " << FloatValues[2] << L"f, " << FloatValues[3] << L"f)";
					else if (baseType->Type == ILBaseType::Float3x3)
						sb << L"mat3(...)";
					else if (baseType->Type == ILBaseType::Float4x4)
						sb << L"mat4(...)";
					else if (baseType->Type == ILBaseType::Int2)
						sb << L"ivec2(" << IntValues[0] << L", " << IntValues[1] << L")";
					else if (baseType->Type == ILBaseType::Int3)
						sb << L"ivec3(" << IntValues[0] << L", " << IntValues[1] << L", " << IntValues[2] << L")";
					else if (baseType->Type == ILBaseType::Int4)
						sb << L"ivec4(" << IntValues[0] << L", " << IntValues[1] << L", " << IntValues[2] << L", " << IntValues[3] << L")";
					else if (baseType->Type == ILBaseType::UInt2)
						sb << L"uvec2(" << IntValues[0] << L", " << IntValues[1] << L")";
					else if (baseType->Type == ILBaseType::UInt3)
						sb << L"uvec3(" << IntValues[0] << L", " << IntValues[1] << L", " << IntValues[2] << L")";
					else if (baseType->Type == ILBaseType::UInt4)
						sb << L"uvec4(" << IntValues[0] << L", " << IntValues[1] << L", " << IntValues[2] << L", " << IntValues[3] << L")";
					return sb.ToString();
				}
				else
					throw InvalidOperationException(L"Illegal constant.");
			}
		};

		class InstructionVisitor;

		class CFGNode;

		class ILInstruction : public ILOperand
		{
		private:
			ILInstruction *next, *prev;
		public:
			CFGNode * Parent;
			ILInstruction()
			{
				next = 0;
				prev = 0;
				Parent = 0;
			}
			ILInstruction(const ILInstruction & instr)
				: ILOperand(instr)
			{
				next = 0;
				prev = 0;
				Parent = 0;
			}
			~ILInstruction()
			{
				
			}
			virtual ILInstruction * Clone()
			{
				return new ILInstruction(*this);
			}

			virtual String GetOperatorString()
			{
				return L"<instruction>";
			}
			virtual bool HasSideEffect()
			{
				return false;
			}
			virtual bool IsDeterministic()
			{
				return true;
			}
			virtual void Accept(InstructionVisitor *)
			{
			}
			void InsertBefore(ILInstruction * instr)
			{
				instr->Parent = Parent;
				instr->prev = prev;
				instr->next = this;
				prev = instr;
				auto *npp = instr->prev;
				if (npp)
					npp->next = instr;
			}
			void InsertAfter(ILInstruction * instr)
			{
				instr->Parent = Parent;
				instr->prev = this;
				instr->next = this->next;
				next = instr;
				auto *npp = instr->next;
				if (npp)
					npp->prev = instr;
			}
			ILInstruction * GetNext()
			{
				return next;
			}
			ILInstruction * GetPrevious()
			{
				return prev;
			}
			void Remove()
			{
				if (prev)
					prev->next = next;
				if (next)
					next->prev = prev;
			}
			void Erase()
			{
				Remove();
				if (Users.Count())
				{
					throw InvalidOperationException(L"All uses must be removed before removing this instruction");
				}
				delete this;
			}
			virtual OperandIterator begin()
			{
				return OperandIterator();
			}
			virtual OperandIterator end()
			{
				return OperandIterator();
			}
			virtual int GetSubBlockCount()
			{
				return 0;
			}
			virtual CFGNode * GetSubBlock(int)
			{
				return nullptr;
			}
			template<typename T>
			T * As()
			{
				return dynamic_cast<T*>(this);
			}
			template<typename T>
			bool Is()
			{
				return dynamic_cast<T*>(this) != 0;
			}
		};

		template <typename T, typename TOperand>
		bool Is(TOperand * op)
		{
			auto ptr = dynamic_cast<T*>(op);
			if (ptr)
				return true;
			else
				return false;
		}

		class SwitchInstruction : public ILInstruction
		{
		public:
			List<UseReference> Candidates;
			virtual OperandIterator begin() override
			{
				return Candidates.begin();
			}
			virtual OperandIterator end() override
			{
				return Candidates.end();
			}
			virtual String ToString() override
			{
				StringBuilder sb(256);
				sb << Name;
				sb << L" = switch ";
				for (auto & op : Candidates)
				{
					sb << op.ToString();
					if (op != Candidates.Last())
						sb << L", ";
				}
				return sb.ProduceString();
			}
			virtual String GetOperatorString() override
			{
				return L"switch";
			}
			virtual bool HasSideEffect() override
			{
				return false;
			}
			SwitchInstruction(int argSize)
			{
				Candidates.SetSize(argSize);
				for (auto & use : Candidates)
					use.SetUser(this);
			}
			SwitchInstruction(const SwitchInstruction & other)
				: ILInstruction(other)
			{
				Candidates.SetSize(other.Candidates.Count());
				for (int i = 0; i < other.Candidates.Count(); i++)
				{
					Candidates[i].SetUser(this);
					Candidates[i] = other.Candidates[i].Ptr();
				}

			}
			virtual SwitchInstruction * Clone() override
			{
				return new SwitchInstruction(*this);
			}
			virtual void Accept(InstructionVisitor * visitor) override;
		};

		class LeaInstruction : public ILInstruction
		{};

		// retrieves pointer to a global entry
		class GLeaInstruction : public LeaInstruction
		{
		public:
			String VariableName;
			GLeaInstruction() = default;
			GLeaInstruction(const GLeaInstruction &) = default;
			GLeaInstruction(const String & varName)
				:VariableName(varName)
			{
			}
			virtual String ToString() override
			{
				return Name + L" = g_var [" + VariableName + L"]";
			}
			virtual String GetOperatorString() override
			{
				return L"glea " + VariableName;
			}
			virtual GLeaInstruction * Clone() override
			{
				return new GLeaInstruction(*this);
			}
			virtual void Accept(InstructionVisitor * visitor) override;
		};
		class ImportOperatorDefSyntaxNode;
		class CompiledWorld;
		class ImportInstruction : public LeaInstruction
		{
		public:
			String ComponentName;
			ImportOperatorDefSyntaxNode * ImportOperator;
			CompiledWorld * SourceWorld;

			List<UseReference> Arguments;
			virtual OperandIterator begin() override
			{
				return Arguments.begin();
			}
			virtual OperandIterator end() override
			{
				return Arguments.end();
			}

			ImportInstruction(int argSize = 0)
				: LeaInstruction()
			{
				Arguments.SetSize(argSize);
				for (auto & use : Arguments)
					use.SetUser(this);
			}
			ImportInstruction(const ImportInstruction & other)
				: LeaInstruction(other)
			{
				Arguments.SetSize(other.Arguments.Count());
				for (int i = 0; i < other.Arguments.Count(); i++)
				{
					Arguments[i].SetUser(this);
					Arguments[i] = other.Arguments[i].Ptr();
				}
			}

			ImportInstruction(int argSize, String compName, ImportOperatorDefSyntaxNode * importOp, CompiledWorld * srcWorld, RefPtr<ILType> type)
				:ImportInstruction(argSize)
			{
				this->ComponentName = compName;
				this->ImportOperator = importOp;
				this->SourceWorld = srcWorld;
				this->Type = type;
			}
			virtual String ToString() override;
			virtual String GetOperatorString() override;
			virtual ImportInstruction * Clone() override
			{
				return new ImportInstruction(*this);
			}
			virtual void Accept(InstructionVisitor * visitor) override;
		};

		class AllocVarInstruction : public LeaInstruction
		{
		public:
			UseReference Size;
			AllocVarInstruction(ILType * type, ILOperand * count)
				: Size(this)
			{
				this->Type = type;
				this->Size = count;
			}
			AllocVarInstruction(RefPtr<ILType> & type, ILOperand * count)
				: Size(this)
			{
				auto ptrType = type->Clone();
				if (!type)
					throw ArgumentException(L"type cannot be null.");
				this->Type = ptrType;
				this->Size = count;
			}
			AllocVarInstruction(const AllocVarInstruction & other)
				:LeaInstruction(other), Size(this)
			{
				Size = other.Size.Ptr();
			}
			virtual bool IsDeterministic() override
			{
				return false;
			}
			virtual String ToString() override
			{
				return Name + L" = VAR " + Type->ToString() + L", " + Size.ToString();
			}
			virtual OperandIterator begin() override
			{
				return &Size;
			}
			virtual OperandIterator end() override
			{
				return &Size + 1;
			}
			virtual String GetOperatorString() override
			{
				return L"avar";
			}
			virtual AllocVarInstruction * Clone() override
			{
				return new AllocVarInstruction(*this);
			}
			virtual void Accept(InstructionVisitor * visitor) override;
		};

		class FetchArgInstruction : public LeaInstruction
		{
		public:
			int ArgId;
			FetchArgInstruction(RefPtr<ILType> type)
			{
				this->Type = type;
				ArgId = 0;
			}
			virtual String ToString() override
			{
				return Name + L" = ARG " + Type->ToString();
			}
			virtual String GetOperatorString() override
			{
				return L"arg " + String(ArgId);
			}
			virtual bool IsDeterministic() override
			{
				return false;
			}
			virtual FetchArgInstruction * Clone() override
			{
				return new FetchArgInstruction(*this);
			}
			virtual void Accept(InstructionVisitor * visitor) override;
		};

		class CFGNode;

		class AllInstructionsIterator
		{
		private:
			struct StackItem
			{
				ILInstruction* instr;
				int subBlockPtr;
			};
			List<StackItem> stack;
			ILInstruction * curInstr = nullptr;
			int subBlockPtr = 0;
		public:
			AllInstructionsIterator(ILInstruction * instr)
			{
				curInstr = instr;
			}
			AllInstructionsIterator & operator ++();
			
			AllInstructionsIterator operator ++(int)
			{
				AllInstructionsIterator rs = *this;
				operator++();
				return rs;
			}
			bool operator != (const AllInstructionsIterator & _that)
			{
				return curInstr != _that.curInstr || subBlockPtr != _that.subBlockPtr;
			}
			bool operator == (const AllInstructionsIterator & _that)
			{
				return curInstr == _that.curInstr && subBlockPtr == _that.subBlockPtr;
			}
			ILOperand & operator *()
			{
				return *curInstr;
			}
			ILOperand * operator ->()
			{
				return curInstr;
			}
		};

		class AllInstructionsCollection
		{
		private:
			CFGNode * node;
		public:
			AllInstructionsCollection(CFGNode * _node)
				: node(_node)
			{}
			AllInstructionsIterator begin();
			AllInstructionsIterator end();
		};

		class CFGNode : public Object
		{
		private:
			ILInstruction *headInstr, *tailInstr;
		public:
			class Iterator
			{
			public:
				ILInstruction * Current, *Next;
				void SetCurrent(ILInstruction * cur)
				{
					Current = cur;
					if (Current)
						Next = Current->GetNext();
					else
						Next = 0;
				}
				Iterator(ILInstruction * cur)
				{
					SetCurrent(cur);
				}
				ILInstruction & operator *() const
				{
					return *Current;
				}
				Iterator& operator ++()
				{
					SetCurrent(Next);
					return *this;
				}
				Iterator operator ++(int)
				{
					Iterator rs = *this;
					SetCurrent(Next);
					return rs;
				}
				bool operator != (const Iterator & iter) const
				{
					return Current != iter.Current;
				}
				bool operator == (const Iterator & iter) const
				{
					return Current == iter.Current;
				}
			};

			String ToString() {
				StringBuilder sb;
				bool first = true;
				auto pintr = begin();
				while (pintr != end()) {
					if (!first)
						sb << EndLine;
					first = false;
					sb << pintr.Current->ToString();
					pintr++;
				}
				return sb.ToString();
			}

			Iterator begin() const
			{
				return Iterator(headInstr->GetNext());
			}

			Iterator end() const
			{
				return Iterator(tailInstr);
			}

			AllInstructionsCollection GetAllInstructions()
			{
				return AllInstructionsCollection(this);
			}
			
			ILInstruction * GetFirstNonPhiInstruction();
			bool HasPhiInstruction();

			ILInstruction * GetLastInstruction()
			{
				return (tailInstr->GetPrevious());
			}

			String Name;

			CFGNode()
			{
				headInstr = new ILInstruction();
				tailInstr = new ILInstruction();
				headInstr->Parent = this;
				headInstr->InsertAfter(tailInstr);
			}
			~CFGNode()
			{
				ILInstruction * instr = headInstr;
				while (instr)
				{
					for (auto user : instr->Users)
					{
						auto userInstr = dynamic_cast<ILInstruction*>(user);
						if (userInstr)
						{
							for (auto iter = userInstr->begin(); iter != userInstr->end(); ++iter)
							if (iter == instr)
								iter.Set(0);
						}
					}
				
					auto next = instr->GetNext();
					delete instr;
					instr = next;
				}
			}
			void InsertHead(ILInstruction * instr)
			{
				headInstr->InsertAfter(instr);
			}
			void InsertTail(ILInstruction * instr)
			{
				tailInstr->InsertBefore(instr);
			}
			void NameAllInstructions();
			void DebugPrint();
		};

		template<typename T>
		struct ConstKey
		{
			Array<T, 16> Value;
			int Size;
			ConstKey()
			{
				Value.SetSize(Value.GetCapacity());
			}
			ConstKey(T value, int size)
			{
				if (size == 0)
					size = 1;
				Value.SetSize(Value.GetCapacity());
				for (int i = 0; i < size; i++)
					Value[i] = value;
				Size = size;
			}
			static ConstKey<T> FromValues(T value, T value1)
			{
				ConstKey<T> result;
				result.Value.SetSize(result.Value.GetCapacity());
				result.Size = 2;
				result.Value[0] = value;
				result.Value[1] = value1;
				return result;
			}
			static ConstKey<T> FromValues(T value, T value1, T value2)
			{
				ConstKey<T> result;
				result.Value.SetSize(result.Value.GetCapacity());
				result.Size = 3;
				result.Value[0] = value;
				result.Value[1] = value1;
				result.Value[2] = value2;
				return result;
			}
			static ConstKey<T> FromValues(T value, T value1, T value2, T value3)
			{
				ConstKey<T> result;
				result.Value.SetSize(result.Value.GetCapacity());
				result.Size = 4;
				result.Value[0] = value;
				result.Value[1] = value1;
				result.Value[2] = value2;
				result.Value[3] = value3;
				return result;
			}
			int GetHashCode()
			{
				int result = Size;
				for (int i = 0; i < Size; i++)
					result ^= ((*(int*)&Value) << 5);
				return result;
			}
			bool operator == (const ConstKey<T> & other)
			{
				if (Size != other.Size)
					return false;
				for (int i = 0; i < Size; i++)
					if (Value[i] != other.Value[i])
						return false;
				return true;
			}
		};

		class PhiInstruction : public ILInstruction
		{
		public:
			List<UseReference> Operands; // Use as fixed array, no insert or resize
		public:
			PhiInstruction(int opCount)
			{
				Operands.SetSize(opCount);
				for (int i = 0; i < opCount; i++)
					Operands[i].SetUser(this);
			}
			PhiInstruction(const PhiInstruction & other)
				: ILInstruction(other)
			{
				Operands.SetSize(other.Operands.Count());
				for (int i = 0; i < Operands.Count(); i++)
				{
					Operands[i].SetUser(this);
					Operands[i] = other.Operands[i].Ptr();
				}
			}
			virtual String GetOperatorString() override
			{
				return L"phi";
			}
			virtual OperandIterator begin() override
			{
				return Operands.begin();
			}
			virtual OperandIterator end() override
			{
				return Operands.end();
			}
			virtual String ToString() override
			{
				StringBuilder sb;
				sb << Name << L" = phi ";
				for (auto & op : Operands)
				{
					if (op)
					{
						sb << op.ToString();
					}
					else
						sb << L"<?>";
					sb << L", ";
				}
				return sb.ProduceString();
			}
			virtual PhiInstruction * Clone() override
			{
				return new PhiInstruction(*this);
			}
			virtual void Accept(InstructionVisitor * visitor) override;
		};

		class UnaryInstruction : public ILInstruction
		{
		public:
			UseReference Operand;
			UnaryInstruction()
				: Operand(this)
			{}
			UnaryInstruction(const UnaryInstruction & other)
				: ILInstruction(other), Operand(this)
			{
				Operand = other.Operand.Ptr();
			}
			virtual OperandIterator begin() override
			{
				return &Operand;
			}
			virtual OperandIterator end() override
			{
				return &Operand + 1;
			}
		};

		class ExportInstruction : public UnaryInstruction
		{
		public:
			String ComponentName;
			String ExportOperator;
			CompiledWorld * World;

			ExportInstruction() = default;
			ExportInstruction(const ExportInstruction &) = default;

			ExportInstruction(String compName, String exportOp, CompiledWorld * srcWorld, ILOperand * value)
				: UnaryInstruction()
			{
				this->Operand = value;
				this->ComponentName = compName;
				this->ExportOperator = exportOp;
				this->World = srcWorld;
				this->Type = value->Type;
			}
			virtual String ToString() override
			{
				return L"export<" + ExportOperator + L">[" + ComponentName + L"], " + Operand.ToString();
			}
			virtual String GetOperatorString() override
			{
				return L"export<" + ExportOperator + L">[" + ComponentName + L"]";
			}
			virtual ExportInstruction * Clone() override
			{
				return new ExportInstruction(*this);
			}
			virtual bool HasSideEffect() override
			{
				return true;
			}
			virtual void Accept(InstructionVisitor * visitor) override;
		};

		class BinaryInstruction : public ILInstruction
		{
		public:
			Array<UseReference, 2> Operands;
			BinaryInstruction()
			{
				Operands.SetSize(2);
				Operands[0].SetUser(this);
				Operands[1].SetUser(this);
			}
			BinaryInstruction(const BinaryInstruction & other)
				: ILInstruction(other)
			{
				Operands.SetSize(2);
				Operands[0].SetUser(this);
				Operands[1].SetUser(this);
				Operands[0] = other.Operands[0].Ptr();
				Operands[1] = other.Operands[1].Ptr();
			}
			virtual OperandIterator begin() override
			{
				return Operands.begin();
			}
			virtual OperandIterator end() override
			{
				return Operands.end();
			}
		};

		class SelectInstruction : public ILInstruction
		{
		public:
			UseReference Operands[3];
			SelectInstruction()
			{
				Operands[0].SetUser(this);
				Operands[1].SetUser(this);
				Operands[2].SetUser(this);
			}
			SelectInstruction(const SelectInstruction & other)
				: ILInstruction(other)
			{
				Operands[0].SetUser(this);
				Operands[1].SetUser(this);
				Operands[2].SetUser(this);
				Operands[0] = other.Operands[0].Ptr();
				Operands[1] = other.Operands[1].Ptr();
				Operands[2] = other.Operands[2].Ptr();
			}
			SelectInstruction(ILOperand * mask, ILOperand * val0, ILOperand * val1)
			{
				Operands[0].SetUser(this);
				Operands[1].SetUser(this);
				Operands[2].SetUser(this);
				Operands[0] = mask;
				Operands[1] = val0;
				Operands[2] = val1;
				Type = val0->Type->Clone();
			}
			virtual OperandIterator begin() override
			{
				return Operands;
			}
			virtual OperandIterator end() override
			{
				return Operands + 3;
			}

			virtual String ToString() override
			{
				return Name + L" = select " + Operands[0].ToString() + L": " + Operands[1].ToString() + L", " + Operands[2].ToString();
			}
			virtual String GetOperatorString() override
			{
				return L"select";
			}
			virtual SelectInstruction * Clone() override
			{
				return new SelectInstruction(*this);
			}
			virtual void Accept(InstructionVisitor * visitor) override;
		};

		class CallInstruction : public ILInstruction
		{
		public:
			String Function;
			List<UseReference> Arguments;
			virtual OperandIterator begin() override
			{
				return Arguments.begin();
			}
			virtual OperandIterator end() override
			{
				return Arguments.end();
			}
			virtual String ToString() override
			{
				StringBuilder sb(256);
				sb << Name;
				sb << L" = call " << Function << L"(";
				for (auto & op : Arguments)
				{
					sb << op.ToString();
					if (op != Arguments.Last())
						sb << L", ";
				}
				sb << L")";
				return sb.ProduceString();
			}
			virtual String GetOperatorString() override
			{
				return L"call " + Function;
			}
			virtual bool HasSideEffect() override
			{
				return false;
			}
			CallInstruction(int argSize)
			{
				Arguments.SetSize(argSize);
				for (auto & use : Arguments)
					use.SetUser(this);
			}
			CallInstruction(const CallInstruction & other)
				: ILInstruction(other)
			{
				Function = other.Function;
				Arguments.SetSize(other.Arguments.Count());
				for (int i = 0; i < other.Arguments.Count(); i++)
				{
					Arguments[i].SetUser(this);
					Arguments[i] = other.Arguments[i].Ptr();
				}

			}
			virtual CallInstruction * Clone() override
			{
				return new CallInstruction(*this);
			}
			virtual void Accept(InstructionVisitor * visitor) override;
		};

		class NotInstruction : public UnaryInstruction
		{
		public:
			virtual String ToString() override
			{
				return  Name + L" = not " + Operand.ToString();
			}
			virtual String GetOperatorString() override
			{
				return L"not";
			}
			virtual NotInstruction * Clone() override
			{
				return new NotInstruction(*this);
			}
			NotInstruction() = default;
			NotInstruction(const NotInstruction & other) = default;

			NotInstruction(ILOperand * op)
			{
				Operand = op;
				Type = op->Type->Clone();
			}
			virtual void Accept(InstructionVisitor * visitor) override;
		};

		class NegInstruction : public UnaryInstruction
		{
		public:
			virtual String ToString() override
			{
				return  Name + L" = neg " + Operand.ToString();
			}
			virtual String GetOperatorString() override
			{
				return L"neg";
			}
			virtual NegInstruction * Clone() override
			{
				return new NegInstruction(*this);
			}
			virtual void Accept(InstructionVisitor * visitor) override;
		};

		class BitNotInstruction : public UnaryInstruction
		{
		public:
			virtual String ToString() override
			{
				return  Name + L" = bnot " + Operand.ToString();
			}
			virtual String GetOperatorString() override
			{
				return L"bnot";
			}
			virtual BitNotInstruction * Clone() override
			{
				return new BitNotInstruction(*this);
			}
			BitNotInstruction() = default;
			BitNotInstruction(const BitNotInstruction & instr) = default;

			BitNotInstruction(ILOperand * op)
			{
				Operand = op;
				Type = op->Type->Clone();
			}
			virtual void Accept(InstructionVisitor * visitor) override;
		};

		class AddInstruction : public BinaryInstruction
		{
		public:
			AddInstruction() = default;
			AddInstruction(const AddInstruction & instr) = default;
			AddInstruction(ILOperand * v0, ILOperand * v1)
			{
				Operands[0] = v0;
				Operands[1] = v1;
				Type = v0->Type->Clone();
			}
			virtual String ToString() override
			{
				return Name + L" = add " + Operands[0].ToString() + L", " + Operands[1].ToString();
			}
			virtual String GetOperatorString() override
			{
				return L"add";
			}
			virtual AddInstruction * Clone() override
			{
				return new AddInstruction(*this);
			}
			virtual void Accept(InstructionVisitor * visitor) override;
		};

		class MemberLoadInstruction : public BinaryInstruction
		{
		public:
			MemberLoadInstruction() = default;
			MemberLoadInstruction(const MemberLoadInstruction &) = default;
			MemberLoadInstruction(ILOperand * v0, ILOperand * v1)
			{
				Operands[0] = v0;
				Operands[1] = v1;
				if (auto arrType = dynamic_cast<ILArrayType *>(v0->Type.Ptr()))
				{
					Type = arrType->BaseType->Clone();
				}
				else if (auto baseType = dynamic_cast<ILBasicType *>(v0->Type.Ptr()))
				{
					switch (baseType->Type)
					{
					case ILBaseType::Float2:
					case ILBaseType::Float3:
					case ILBaseType::Float4:
						Type = new ILBasicType(ILBaseType::Float);
						break;
					case ILBaseType::Float3x3:
						Type = new ILBasicType(ILBaseType::Float3);
						break;
					case ILBaseType::Float4x4:
						Type = new ILBasicType(ILBaseType::Float4);
						break;
					case ILBaseType::Int2:
					case ILBaseType::Int3:
					case ILBaseType::Int4:
						Type = new ILBasicType(ILBaseType::Int);
						break;
					case ILBaseType::UInt2:
					case ILBaseType::UInt3:
					case ILBaseType::UInt4:
						Type = new ILBasicType(ILBaseType::UInt);
						break;
					default:
						throw InvalidOperationException(L"Unsupported aggregate type.");
					}
				}
				else if (auto structType = dynamic_cast<ILStructType*>(v0->Type.Ptr()))
				{
					auto cv1 = dynamic_cast<ILConstOperand*>(v1);
					if (!cv1)
						throw InvalidProgramException(L"member field access offset is not constant.");
					if (cv1->IntValues[0] < 0 || cv1->IntValues[0] >= structType->Members.Count())
						throw InvalidProgramException(L"member field access offset out of bounds.");
					Type = structType->Members[cv1->IntValues[0]].Type;
				}
			}
			virtual String ToString() override
			{
				return Name + L" = retrieve " + Operands[0].ToString() + L", " + Operands[1].ToString();
			}
			virtual String GetOperatorString() override
			{
				return L"retrieve";
			}
			virtual MemberLoadInstruction * Clone() override
			{
				return new MemberLoadInstruction(*this);
			}
			virtual void Accept(InstructionVisitor * visitor) override;
		};

		class SubInstruction : public BinaryInstruction
		{
		public:
			virtual String ToString() override
			{
				return Name + L" = sub " + Operands[0].ToString() + L", " + Operands[1].ToString();
			}
			virtual String GetOperatorString() override
			{
				return L"sub";
			}
			virtual SubInstruction * Clone() override
			{
				return new SubInstruction(*this);
			}
			virtual void Accept(InstructionVisitor * visitor) override;
		};

		class MulInstruction : public BinaryInstruction
		{
		public:
			MulInstruction(){}
			MulInstruction(ILOperand * v0, ILOperand * v1)
			{
				Operands[0] = v0;
				Operands[1] = v1;
				Type = v0->Type->Clone();
			}
			MulInstruction(const MulInstruction &) = default;

			virtual String ToString() override
			{
				return Name + L" = mul " + Operands[0].ToString() + L", " + Operands[1].ToString();
			}
			virtual String GetOperatorString() override
			{
				return L"mul";
			}
			virtual MulInstruction * Clone() override
			{
				return new MulInstruction(*this);
			}
			virtual void Accept(InstructionVisitor * visitor) override;
		};

		class DivInstruction : public BinaryInstruction
		{
		public:
			virtual String ToString() override
			{
				return Name + L" = div " + Operands[0].ToString() + L", " + Operands[1].ToString();
			}
			virtual String GetOperatorString() override
			{
				return L"div";
			}
			virtual DivInstruction * Clone() override
			{
				return new DivInstruction(*this);
			}
			virtual void Accept(InstructionVisitor * visitor) override;
		};
		class ModInstruction : public BinaryInstruction
		{
		public:
			virtual String ToString() override
			{
				return Name + L" = mod " + Operands[0].ToString() + L", " + Operands[1].ToString();
			}
			virtual String GetOperatorString() override
			{
				return L"mod";
			}
			virtual ModInstruction * Clone() override
			{
				return new ModInstruction(*this);
			}
			virtual void Accept(InstructionVisitor * visitor) override;
		};
		class AndInstruction : public BinaryInstruction
		{
		public:
			virtual String ToString() override
			{
				return Name + L" = and " + Operands[0].ToString() + L", " + Operands[1].ToString();
			}
			virtual String GetOperatorString() override
			{
				return L"and";
			}
			virtual AndInstruction * Clone() override
			{
				return new AndInstruction(*this);
			}
			virtual void Accept(InstructionVisitor * visitor) override;
		};

		class OrInstruction : public BinaryInstruction
		{
		public:
			virtual String ToString() override
			{
				return Name + L" = or " + Operands[0].ToString() + L", " + Operands[1].ToString();
			}
			virtual String GetOperatorString() override
			{
				return L"or";
			}
			virtual OrInstruction * Clone() override
			{
				return new OrInstruction(*this);
			}
			virtual void Accept(InstructionVisitor * visitor) override;
		};

		class BitAndInstruction : public BinaryInstruction
		{
		public:
			BitAndInstruction(){}
			BitAndInstruction(ILOperand * v0, ILOperand * v1)
			{
				Operands[0] = v0;
				Operands[1] = v1;
				Type = v0->Type->Clone();
			}
			BitAndInstruction(const BitAndInstruction &) = default;
			virtual String ToString() override
			{
				return Name + L" = band " + Operands[0].ToString() + L", " + Operands[1].ToString();
			}
			virtual String GetOperatorString() override
			{
				return L"band";
			}
			virtual BitAndInstruction * Clone() override
			{
				return new BitAndInstruction(*this);
			}
			virtual void Accept(InstructionVisitor * visitor) override;
		};

		class BitOrInstruction : public BinaryInstruction
		{
		public:
			virtual String ToString() override
			{
				return Name + L" = bor " + Operands[0].ToString() + L", " + Operands[1].ToString();
			}
			virtual String GetOperatorString() override
			{
				return L"bor";
			}
			virtual BitOrInstruction * Clone() override
			{
				return new BitOrInstruction(*this);
			}
			BitOrInstruction(){}
			BitOrInstruction(const BitOrInstruction &) = default;
			BitOrInstruction(ILOperand * v0, ILOperand * v1)
			{
				Operands[0] = v0;
				Operands[1] = v1;
				Type = v0->Type->Clone();
			}
			virtual void Accept(InstructionVisitor * visitor) override;
		};

		class BitXorInstruction : public BinaryInstruction
		{
		public:
			virtual String ToString() override
			{
				return Name + L" = bxor " + Operands[0].ToString() + L", " + Operands[1].ToString();
			}
			virtual String GetOperatorString() override
			{
				return L"bxor";
			}
			virtual BitXorInstruction * Clone() override
			{
				return new BitXorInstruction(*this);
			}
			virtual void Accept(InstructionVisitor * visitor) override;
		};

		class ShlInstruction : public BinaryInstruction
		{
		public:
			virtual String ToString() override
			{
				return Name + L" = shl " + Operands[0].ToString() + L", " + Operands[1].ToString();
			}
			virtual String GetOperatorString() override
			{
				return L"shl";
			}
			virtual ShlInstruction * Clone() override
			{
				return new ShlInstruction(*this);
			}
			virtual void Accept(InstructionVisitor * visitor) override;
		};
		class ShrInstruction : public BinaryInstruction
		{
		public:
			virtual String ToString() override
			{
				return Name + L" = shr " + Operands[0].ToString() + L", " + Operands[1].ToString();
			}
			virtual String GetOperatorString() override
			{
				return L"shr";
			}
			virtual ShrInstruction * Clone() override
			{
				return new ShrInstruction(*this);
			}
			virtual void Accept(InstructionVisitor * visitor) override;
		};
		class CompareInstruction : public BinaryInstruction
		{};
		class CmpgtInstruction : public CompareInstruction
		{
		public:
			virtual String ToString() override
			{
				return Name + L" = gt " + Operands[0].ToString() + L", " + Operands[1].ToString();
			}
			virtual String GetOperatorString() override
			{
				return L"gt";
			}
			virtual CmpgtInstruction * Clone() override
			{
				return new CmpgtInstruction(*this);
			}
			virtual void Accept(InstructionVisitor * visitor) override;
		};
		class CmpgeInstruction : public CompareInstruction
		{
		public:
			virtual String ToString() override
			{
				return Name + L" = ge " + Operands[0].ToString() + L", " + Operands[1].ToString();
			}
			virtual String GetOperatorString() override
			{
				return L"ge";
			}
			virtual CmpgeInstruction * Clone() override
			{
				return new CmpgeInstruction(*this);
			}
			virtual void Accept(InstructionVisitor * visitor) override;
		};
		class CmpltInstruction : public CompareInstruction
		{
		public:
			virtual String ToString() override
			{
				return Name + L" = lt " + Operands[0].ToString() + L", " + Operands[1].ToString();
			}
			virtual String GetOperatorString() override
			{
				return L"lt";
			}
			virtual CmpltInstruction * Clone() override
			{
				return new CmpltInstruction(*this);
			}
			virtual void Accept(InstructionVisitor * visitor) override;
		};
		class CmpleInstruction : public CompareInstruction
		{
		public:
			CmpleInstruction() = default;
			CmpleInstruction(const CmpleInstruction &) = default;
			CmpleInstruction(ILOperand * v0, ILOperand * v1)
			{
				Operands[0] = v0;
				Operands[1] = v1;
				Type = v0->Type->Clone();
			}

			virtual String ToString() override
			{
				return Name + L" = le " + Operands[0].ToString() + L", " + Operands[1].ToString();
			}
			virtual String GetOperatorString() override
			{
				return L"le";
			}
			virtual CmpleInstruction * Clone() override
			{
				return new CmpleInstruction(*this);
			}
			virtual void Accept(InstructionVisitor * visitor) override;
		};
		class CmpeqlInstruction : public CompareInstruction
		{
		public:
			virtual String ToString() override
			{
				return Name + L" = eql " + Operands[0].ToString()
					+ L", " + Operands[1].ToString();
			}
			virtual String GetOperatorString() override
			{
				return L"eql";
			}
			virtual CmpeqlInstruction * Clone() override
			{
				return new CmpeqlInstruction(*this);
			}
			virtual void Accept(InstructionVisitor * visitor) override;
		};
		class CmpneqInstruction : public CompareInstruction
		{
		public:
			virtual String ToString() override
			{
				return Name + L" = neq " + Operands[0].ToString() + L", " + Operands[1].ToString();
			}
			virtual String GetOperatorString() override
			{
				return L"neq";
			}
			virtual CmpneqInstruction * Clone() override
			{
				return new CmpneqInstruction(*this);
			}
			virtual void Accept(InstructionVisitor * visitor) override;
		};

		class CastInstruction : public UnaryInstruction
		{};

		class Float2IntInstruction : public CastInstruction
		{
		public:
			Float2IntInstruction(){}
			Float2IntInstruction(const Float2IntInstruction &) = default;

			Float2IntInstruction(ILOperand * op)
			{
				Operand = op;
				Type = new ILBasicType(ILBaseType::Int);
			}
		public:
			virtual String ToString() override
			{
				return Name + L" = f2i " + Operand.ToString();
			}
			virtual String GetOperatorString() override
			{
				return L"f2i";
			}
			virtual Float2IntInstruction * Clone() override
			{
				return new Float2IntInstruction(*this);
			}
			virtual void Accept(InstructionVisitor * visitor) override;
		};

		class Int2FloatInstruction : public CastInstruction
		{
		public:
			Int2FloatInstruction(){}
			Int2FloatInstruction(ILOperand * op)
			{
				Operand = op;
				Type = new ILBasicType(ILBaseType::Float);
			}
			Int2FloatInstruction(const Int2FloatInstruction &) = default;

		public:
			virtual String ToString() override
			{
				return Name + L" = i2f " + Operand.ToString();
			}
			virtual String GetOperatorString() override
			{
				return L"i2f";
			}
			virtual Int2FloatInstruction * Clone() override
			{
				return new Int2FloatInstruction(*this);
			}
			virtual void Accept(InstructionVisitor * visitor) override;
		};

		class CopyInstruction : public UnaryInstruction
		{
		public:
			CopyInstruction(){}
			CopyInstruction(const CopyInstruction &) = default;

			CopyInstruction(ILOperand * dest)
			{
				Operand = dest;
				Type = dest->Type->Clone();
			}
		public:
			virtual String ToString() override
			{
				return Name + L" = " + Operand.ToString();
			}
			virtual String GetOperatorString() override
			{
				return L"copy";
			}
			virtual CopyInstruction * Clone() override
			{
				return new CopyInstruction(*this);
			}
			virtual void Accept(InstructionVisitor * visitor) override;
		};
		// load(src)
		class LoadInstruction : public UnaryInstruction
		{
		public:
			bool Deterministic;
			LoadInstruction()
			{
				Deterministic = false;
			}
			LoadInstruction(const LoadInstruction & other)
				: UnaryInstruction(other)
			{
				Deterministic = other.Deterministic;
			}
			LoadInstruction(ILOperand * dest);
		public:
			virtual String ToString() override
			{
				return Name + L" = load " + Operand.ToString();
			}
			virtual bool IsDeterministic() override
			{
				return Deterministic;
			}
			virtual String GetOperatorString() override
			{
				return L"ld";
			}
			virtual LoadInstruction * Clone() override
			{
				auto rs = new LoadInstruction(*this);
				if (!rs->Type)
					printf("shit");
				return rs;
			}
			virtual void Accept(InstructionVisitor * visitor) override;
		};

		class DiscardInstruction : public ILInstruction
		{
		public:
			virtual bool IsDeterministic() override
			{
				return true;
			}
			virtual bool HasSideEffect() override
			{
				return true;
			}
			virtual String ToString() override
			{
				return  L"discard";
			}
			virtual String GetOperatorString() override
			{
				return L"discard";
			}
			virtual DiscardInstruction * Clone() override
			{
				return new DiscardInstruction(*this);
			}
			virtual void Accept(InstructionVisitor * visitor) override;
		};

		// store(dest, value)
		class StoreInstruction : public BinaryInstruction
		{
		public:
			StoreInstruction(){}
			StoreInstruction(const StoreInstruction &) = default;

			StoreInstruction(ILOperand * dest, ILOperand * value)
			{
				Operands.SetSize(2);
				Operands[0] = dest;
				Operands[1] = value;
			}
		public:
			virtual String ToString() override
			{
				return L"store " + Operands[0].ToString() + L", " +
					Operands[1].ToString();
			}
			virtual String GetOperatorString() override
			{
				return L"st";
			}
			virtual bool HasSideEffect() override
			{
				return true;
			}
			virtual StoreInstruction * Clone() override
			{
				return new StoreInstruction(*this);
			}
			virtual void Accept(InstructionVisitor * visitor) override;
		};
		class MemberUpdateInstruction : public ILInstruction
		{
		public:
			UseReference Operands[3];
			MemberUpdateInstruction()
			{
				Operands[0].SetUser(this);
				Operands[1].SetUser(this);
				Operands[2].SetUser(this);
			}
			MemberUpdateInstruction(const MemberUpdateInstruction & other)
				: ILInstruction(other)
			{
				Operands[0].SetUser(this);
				Operands[1].SetUser(this);
				Operands[2].SetUser(this);
				Operands[0] = other.Operands[0].Ptr();
				Operands[1] = other.Operands[1].Ptr();
				Operands[2] = other.Operands[2].Ptr();
			}
			MemberUpdateInstruction(ILOperand * var, ILOperand * offset, ILOperand * value)
			{
				Operands[0].SetUser(this);
				Operands[1].SetUser(this);
				Operands[2].SetUser(this);
				Operands[0] = var;
				Operands[1] = offset;
				Operands[2] = value;
				Type = var->Type->Clone();
			}
			virtual OperandIterator begin() override
			{
				return Operands;
			}
			virtual OperandIterator end() override
			{
				return Operands + 3;
			}
			virtual String ToString() override
			{
				return Name + L" = update " + Operands[0].ToString() + L", " + Operands[1].ToString() + L"," + Operands[2].ToString();
			}
			virtual String GetOperatorString() override
			{
				return L"update";
			}
			virtual MemberUpdateInstruction * Clone() override
			{
				return new MemberUpdateInstruction(*this);
			}
			virtual void Accept(InstructionVisitor * visitor) override;
		};


		class InstructionVisitor : public Object
		{
		public:
			virtual void VisitAddInstruction(AddInstruction *){}
			virtual void VisitSubInstruction(SubInstruction *){}
			virtual void VisitDivInstruction(DivInstruction *){}
			virtual void VisitMulInstruction(MulInstruction *){}
			virtual void VisitModInstruction(ModInstruction *){}
			virtual void VisitNegInstruction(NegInstruction *){}
			virtual void VisitAndInstruction(AndInstruction *){}
			virtual void VisitOrInstruction(OrInstruction *){}
			virtual void VisitBitAndInstruction(BitAndInstruction *){}
			virtual void VisitBitOrInstruction(BitOrInstruction *){}
			virtual void VisitBitXorInstruction(BitXorInstruction *){}
			virtual void VisitShlInstruction(ShlInstruction *){}
			virtual void VisitShrInstruction(ShrInstruction *){}
			virtual void VisitBitNotInstruction(BitNotInstruction *){}
			virtual void VisitNotInstruction(NotInstruction *){}
			virtual void VisitCmpeqlInstruction(CmpeqlInstruction *){}
			virtual void VisitCmpneqInstruction(CmpneqInstruction *){}
			virtual void VisitCmpltInstruction(CmpltInstruction *){}
			virtual void VisitCmpleInstruction(CmpleInstruction *){}
			virtual void VisitCmpgtInstruction(CmpgtInstruction *){}
			virtual void VisitCmpgeInstruction(CmpgeInstruction *){}

			virtual void VisitLoadInstruction(LoadInstruction *){}
			virtual void VisitStoreInstruction(StoreInstruction *){}
			virtual void VisitCopyInstruction(CopyInstruction *){}

			virtual void VisitAllocVarInstruction(AllocVarInstruction *){}
			virtual void VisitFetchArgInstruction(FetchArgInstruction *){}
			virtual void VisitGLeaInstruction(GLeaInstruction *){}
			virtual void VisitCastInstruction(CastInstruction *){}
			virtual void VisitInt2FloatInstruction(Int2FloatInstruction *){}
			virtual void VisitFloat2IntInstruction(Float2IntInstruction *){}
			virtual void VisitMemberLoadInstruction(MemberLoadInstruction *){}
			virtual void VisitMemberUpdateInstruction(MemberUpdateInstruction *) {}
			virtual void VisitImportInstruction(ImportInstruction*) {}
			virtual void VisitExportInstruction(ExportInstruction*) {}
			virtual void VisitSelectInstruction(SelectInstruction *){}
			virtual void VisitCallInstruction(CallInstruction *){}
			virtual void VisitSwitchInstruction(SwitchInstruction *){}
			virtual void VisitDiscardInstruction(DiscardInstruction *) {}

			virtual void VisitPhiInstruction(PhiInstruction *){}
		};

		class ForInstruction : public ILInstruction
		{
		public:
			RefPtr<CFGNode> ConditionCode, SideEffectCode, BodyCode;
			virtual int GetSubBlockCount()
			{
				return 3;
			}
			virtual CFGNode * GetSubBlock(int i)
			{
				if (i == 0)
					return ConditionCode.Ptr();
				else if (i == 1)
					return SideEffectCode.Ptr();
				else if (i == 2)
					return BodyCode.Ptr();
				return nullptr;
			}
			//__DEBUG__
			virtual String ToString()override {
				StringBuilder sb;
				sb << L"for (; " << ConditionCode->ToString() << L"; ";
				sb << SideEffectCode->ToString() << L")" << EndLine;
				sb << L"{" << EndLine;
				sb << BodyCode->ToString() << EndLine;
				sb << L"}" << EndLine;
				return sb.ProduceString();
			}
		};
		class IfInstruction : public UnaryInstruction
		{
		public:
			RefPtr<CFGNode> TrueCode, FalseCode;
			virtual int GetSubBlockCount()
			{
				if (FalseCode)
					return 2;
				else
					return 1;
			}
			virtual CFGNode * GetSubBlock(int i)
			{
				if (i == 0)
					return TrueCode.Ptr();
				else if (i == 1)
					return FalseCode.Ptr();
				return nullptr;
			}
			//__DEBUG__
			virtual String ToString()override {
				StringBuilder sb;
				sb << L"if (" << Operand->ToString() << L")" << EndLine;
				sb << L"{" << EndLine;
				sb << TrueCode->ToString() << EndLine;
				sb << L"}" << EndLine;
				if (FalseCode)
				{
					sb << L"else" << EndLine;
					sb << L"{" << EndLine;
					sb << FalseCode->ToString() << EndLine;
					sb << L"}" << EndLine;
				}
				return sb.ProduceString();
			}
		};
		class WhileInstruction : public ILInstruction
		{
		public:
			RefPtr<CFGNode> ConditionCode, BodyCode;
			virtual int GetSubBlockCount()
			{
				return 2;
			}
			virtual CFGNode * GetSubBlock(int i)
			{
				if (i == 0)
					return ConditionCode.Ptr();
				else if (i == 1)
					return BodyCode.Ptr();
				return nullptr;
			}
			//__DEBUG__
			virtual String ToString() override {
				StringBuilder sb;
				sb << L"while (" << ConditionCode->ToString() << L")" << EndLine;
				sb << L"{" << EndLine;
				sb << BodyCode->ToString();
				sb << L"}" << EndLine;
				return sb.ProduceString();
			}
		};
		class DoInstruction : public ILInstruction
		{
		public:
			RefPtr<CFGNode> ConditionCode, BodyCode;
			virtual int GetSubBlockCount()
			{
				return 2;
			}
			virtual CFGNode * GetSubBlock(int i)
			{
				if (i == 1)
					return ConditionCode.Ptr();
				else if (i == 0)
					return BodyCode.Ptr();
				return nullptr;
			}
			//__DEBUG__
			virtual String ToString() override {
				StringBuilder sb;
				sb << L"{" << EndLine;
				sb << BodyCode->ToString();
				sb << L"}" << EndLine;
				sb << L"while (" << ConditionCode->ToString() << L")" << EndLine;
				return sb.ProduceString();
			}
		};
		class ReturnInstruction : public UnaryInstruction
		{
		public:
			ReturnInstruction(ILOperand * op)
				:UnaryInstruction()
			{
				Operand = op;
			}
			//__DEBUG__
			virtual String ToString() override {
				return L"return " + Operand->ToString() + L";";
			}
		};
		class BreakInstruction : public ILInstruction
		{};
		class ContinueInstruction : public ILInstruction
		{};

		class KeyHoleNode
		{
		public:
			String NodeType;
			int CaptureId = -1;
			List<RefPtr<KeyHoleNode>> Children;
			bool Match(List<ILOperand*> & matchResult, ILOperand * instr);
			static RefPtr<KeyHoleNode> Parse(String format);
		};
	}
}

#endif

/***********************************************************************
CORE\SYMBOLTABLE.H
***********************************************************************/
#ifndef RASTER_RENDERER_SYMBOL_TABLE_H
#define RASTER_RENDERER_SYMBOL_TABLE_H


namespace Spire
{
	namespace Compiler
	{
		
		class FunctionSymbol
		{
		public:
			FunctionSyntaxNode * SyntaxNode;
			EnumerableHashSet<String> ReferencedFunctions;
		};
		class ShaderComponentSymbol;
		class ShaderComponentImplSymbol : public Object
		{
		public:
			String AlternateName;
			EnumerableHashSet<String> Worlds, ExportWorlds, SrcPinnedWorlds;
			RefPtr<ComponentSyntaxNode> SyntaxNode;
			EnumerableHashSet<ShaderComponentSymbol *> DependentComponents;
			EnumerableDictionary<ShaderComponentSymbol *, CodePosition> ComponentReferencePositions;
			ShaderComponentImplSymbol() = default;
			ShaderComponentImplSymbol(const ShaderComponentImplSymbol & other)
			{
				AlternateName = other.AlternateName;
				Worlds = other.Worlds;
				ExportWorlds = other.ExportWorlds;
				SrcPinnedWorlds = other.SrcPinnedWorlds;
				CloneContext ctx;
				SyntaxNode = other.SyntaxNode->Clone(ctx);
			}
		};

		class ShaderComponentSymbol : public Object
		{
		public:
			bool IsDceEntryPoint = false;
			String Name, UniqueName, UniqueKey;
			List<String> ChoiceNames;
			EnumerableHashSet<ShaderComponentSymbol *> DependentComponents, UserComponents;
			List<RefPtr<ShaderComponentImplSymbol>> Implementations;
			RefPtr<Type> Type;
			bool IsParam()
			{
				for (auto & impl : Implementations)
					if (impl->SyntaxNode->IsParam)
						return true;
				return false;
			}
			ShaderComponentSymbol() = default;
			ShaderComponentSymbol(const ShaderComponentSymbol & other)
			{
				Type = new Spire::Compiler::Type(*other.Type);
				for (auto &impl : other.Implementations)
					this->Implementations.Add(new ShaderComponentImplSymbol(*impl));
				this->Name = other.Name;
			}
		};
		
		class WorldSymbol
		{
		public:
			bool IsAbstract = false;
			WorldSyntaxNode * SyntaxNode = nullptr;
		};

		class PipelineSymbol;

		class ComponentDefinitionIR
		{
		public:
			ShaderComponentSymbol * Component;
			ShaderComponentImplSymbol * Implementation;
			String World;
			bool IsEntryPoint = false;
			EnumerableHashSet<ComponentDefinitionIR*> Users, Dependency; // Bidirectional dependency;
		};
		
		class ShaderClosure;

		class ShaderIR
		{
		public:
			ShaderClosure * Shader;
			List<RefPtr<ComponentDefinitionIR>> Definitions;
			EnumerableDictionary<String, EnumerableDictionary<String, ComponentDefinitionIR*>> DefinitionsByComponent;
			void EliminateDeadCode(); // returns remaining definitions in reverse dependency order
			void ResolveComponentReference(); // resolve reference and build dependency map
			List<ShaderComponentSymbol*> GetComponentDependencyOrder();
			template<typename ShouldRemoveFunc>
			void RemoveDefinitions(const ShouldRemoveFunc &shouldRemove)
			{
				List<RefPtr<ComponentDefinitionIR>> newDefinitions;
				for (auto & def : Definitions)
				{
					if (!shouldRemove(def.Ptr()))
					{
						newDefinitions.Add(def);
					}
				}
				Definitions = _Move(newDefinitions);
				for (auto & kv : DefinitionsByComponent)
				{
					for (auto & def : kv.Value)
						if (shouldRemove(def.Value))
							kv.Value.Remove(def.Key);
				}
			}

		};
		
		class ShaderSymbol;

		class ShaderUsing
		{
		public:
			ShaderSymbol * Shader;
			bool IsPublic;
		};

		class ShaderSymbol
		{
		public:
			bool IsAbstract = false;
			ShaderSyntaxNode * SyntaxNode = nullptr;
			PipelineSymbol * Pipeline = nullptr;
			EnumerableDictionary<String, RefPtr<ShaderComponentSymbol>> Components;
			List<ShaderComponentSymbol*> GetComponentDependencyOrder();
			EnumerableHashSet<ShaderSymbol*> DependentShaders;
			List<ShaderUsing> ShaderUsings;
			EnumerableDictionary<String, ShaderUsing> ShaderObjects;
			void SortComponents(List<ShaderComponentSymbol*> & comps);
			struct ComponentReference
			{
				ShaderComponentSymbol * Component;
				bool IsAccessible = false;
			};
			ComponentReference ResolveComponentReference(String compName, bool topLevel = true);
		};

		class ShaderClosure : public Object
		{
		public:
			ShaderClosure * Parent = nullptr;
			CodePosition Position;
			PipelineSymbol * Pipeline = nullptr;
			bool IsInPlace = false;
			bool IsPublic = false;
			String Name;
			CodePosition UsingPosition;
			Dictionary<String, RefPtr<ShaderComponentSymbol>> RefMap;
			EnumerableDictionary<String, RefPtr<ShaderComponentSymbol>> Components;
			EnumerableDictionary<String, ShaderComponentSymbol *> AllComponents;
			EnumerableDictionary<String, RefPtr<ShaderClosure>> SubClosures;
			RefPtr<ShaderComponentSymbol> FindComponent(String name, bool findInPrivate = false);
			RefPtr<ShaderClosure> FindClosure(String name);
			List<ShaderComponentSymbol*> GetDependencyOrder();
			RefPtr<ShaderIR> IR;
		};

		class ImportPath
		{
		public:
			class Node
			{
			public:
				String TargetWorld;
				ImportOperatorDefSyntaxNode * ImportOperator;
				Node() = default;
				Node(String world, ImportOperatorDefSyntaxNode * imp)
					: TargetWorld(world), ImportOperator(imp)
				{}
			};
			List<Node> Nodes;
		};

		class PipelineSymbol
		{
		private:
			List<String> WorldTopologyOrder;
		public:
			PipelineSyntaxNode * SyntaxNode;
			EnumerableDictionary<String, RefPtr<ShaderComponentSymbol>> Components;
			EnumerableDictionary<String, EnumerableHashSet<String>> ReachableWorlds;
			EnumerableDictionary<String, EnumerableHashSet<String>> WorldDependency;
			EnumerableDictionary<String, WorldSymbol> Worlds;
			bool IsAbstractWorld(String world);
			bool IsWorldReachable(EnumerableHashSet<String> & src, String targetWorld);
			bool IsWorldReachable(String src, String targetWorld);
			bool IsWorldDirectlyReachable(String src, String targetWorld);
			List<String> & GetWorldTopologyOrder();
			List<ImportPath> FindImportOperatorChain(String worldSrc, String worldDest);
			List<ImportOperatorDefSyntaxNode*> GetImportOperatorsFromSourceWorld(String worldSrc);
		};

		class CompileResult;

		class StructSymbol
		{
		public:
			String Name;
			RefPtr<StructSyntaxNode> SyntaxNode;
			RefPtr<ILStructType> Type;
		};

		class SymbolTable
		{
		public:
			EnumerableDictionary<String, RefPtr<FunctionSymbol>> Functions;
			EnumerableDictionary<String, RefPtr<ShaderSymbol>> Shaders;
			EnumerableDictionary<String, RefPtr<PipelineSymbol>> Pipelines;
			EnumerableDictionary<String, RefPtr<StructSymbol>> Structs;
			List<ShaderSymbol*> ShaderDependenceOrder;
			bool SortShaders(); // return true if success, return false if dependency is cyclic
			void EvalFunctionReferenceClosure();
			bool CheckComponentImplementationConsistency(ErrorWriter * err, ShaderComponentSymbol * comp, ShaderComponentImplSymbol * impl);
		};

		class GUID
		{
		private:
			static int currentGUID;
		public:
			static void Clear();
			static int Next();
		};


		template<typename T, typename GetDependencyFunc>
		void DependencySort(List<T> & list, const GetDependencyFunc & getDep)
		{
			HashSet<T> allSymbols, addedSymbols;
			for (auto & comp : list)
				allSymbols.Add(comp);
			List<T> sorted;
			bool changed = true;
			while (changed)
			{
				changed = false;
				for (auto & comp : list)
				{
					if (!addedSymbols.Contains(comp))
					{
						bool isFirst = true;
						auto && dependency = getDep(comp);
						for (auto & dep : dependency)
							if (allSymbols.Contains(dep) && !addedSymbols.Contains(dep))
							{
								isFirst = false;
								break;
							}
						if (isFirst)
						{
							addedSymbols.Add(comp);
							sorted.Add(comp);
							changed = true;
						}
					}
				}
			}
			list = _Move(sorted);
		}

	}
}
#endif

/***********************************************************************
CORE\COMPILEDPROGRAM.H
***********************************************************************/
#ifndef BAKER_SL_COMPILED_PROGRAM_H
#define BAKER_SL_COMPILED_PROGRAM_H


namespace Spire
{
	namespace Compiler
	{
		class ConstantPoolImpl;

		class ConstantPool
		{
		private:
			ConstantPoolImpl * impl;
		public:
			ILConstOperand * CreateConstant(ILConstOperand * c);
			ILConstOperand * CreateConstantIntVec(int val0, int val1);
			ILConstOperand * CreateConstantIntVec(int val0, int val1, int val2);
			ILConstOperand * CreateConstantIntVec(int val0, int val1, int val3, int val4);
			ILConstOperand * CreateConstant(int val, int vectorSize = 0);
			ILConstOperand * CreateConstant(float val, int vectorSize = 0);
			ILConstOperand * CreateConstant(float val, float val1);
			ILConstOperand * CreateConstant(float val, float val1, float val2);
			ILConstOperand * CreateConstant(float val, float val1, float val2, float val3);
			ILOperand * CreateDefaultValue(ILType * type);
			ILUndefinedOperand * GetUndefinedOperand();
			ConstantPool();
			~ConstantPool();
		};

		enum class InterfaceQualifier
		{
			Input, Output
		};

		

		class CompiledGlobalVar
		{
		public:
			String Name;
			String InputSourceWorld;
			String OrderingStr;
			ImportOperatorDefSyntaxNode ImportOperator;
			InterfaceQualifier Qualifier;
			RefPtr<ILType> Type;
			int OutputIndex = -1, InputIndex = -1;
			bool IsBuiltin = false;
			EnumerableDictionary<String, String> LayoutAttribs;
		};

		class ComponentDefinition
		{
		public:
			String Name;
			String OrderingStr;
			int Offset = 0;
			RefPtr<ILType> Type;
			EnumerableDictionary<String, String> LayoutAttribs;
		};

		class InterfaceBlock : public Object
		{
		public:
			String Name;
			String SourceWorld;
			int Size = 0;
			EnumerableDictionary<String, String> Attributes;
			EnumerableHashSet<String> UserWorlds;
			EnumerableDictionary<String, ComponentDefinition> Entries;
		};

		class InputInterface
		{
		public:
			InterfaceBlock * Block;
			ImportOperatorDefSyntaxNode ImportOperator;
		};

		class CompiledShader;

		class CompiledComponent
		{
		public:
			ILOperand * CodeOperand;
			EnumerableDictionary<String, String> Attributes;
		};

		class CompiledWorld
		{
		public:
			String TargetMachine;
			String ShaderName, WorldName;
			Token ExportOperator;
			EnumerableDictionary<String, String> BackendParameters;
			EnumerableDictionary<String, InputInterface> WorldInputs;
			InterfaceBlock * WorldOutput;

			bool IsAbstract = false;
			CodePosition WorldDefPosition;
			EnumerableDictionary<String, String> Attributes;
			EnumerableHashSet<String> ReferencedFunctions;
			EnumerableDictionary<String, CompiledComponent> LocalComponents;
			EnumerableDictionary<String, ImportInstruction*> ImportInstructions;
			RefPtr<CFGNode> Code = new CFGNode();
			CompiledShader * Shader;
		};

		class InterfaceMetaData
		{
		public:
			CoreLib::Basic::String Name;
			RefPtr<Spire::Compiler::ILType> Type;
			EnumerableDictionary<String, String> Attributes;

			int GetHashCode()
			{
				return Name.GetHashCode();
			}
			bool operator == (const InterfaceMetaData & other)
			{
				return Name == other.Name;
			}
		};

		class WorldMetaData
		{
		public:
			CoreLib::Basic::String Name;
			CoreLib::Basic::String TargetName;
			CoreLib::Basic::String OutputBlock;
			CoreLib::Basic::List<CoreLib::Basic::String> InputBlocks;
			CoreLib::Basic::List<CoreLib::Basic::String> Components;
		};

		class InterfaceBlockEntry : public InterfaceMetaData
		{
		public:
			int Offset = 0, Size = 0;
		};
		class InterfaceBlockMetaData
		{
		public:
			String Name;
			int Size = 0;
			EnumerableHashSet<InterfaceBlockEntry> Entries;
			EnumerableDictionary<String, String> Attributes;
			EnumerableHashSet<String> UserWorlds;
		};
		class ShaderMetaData
		{
		public:
			CoreLib::String ShaderName;
			CoreLib::EnumerableDictionary<CoreLib::String, WorldMetaData> Worlds;
			EnumerableDictionary<String, InterfaceBlockMetaData> InterfaceBlocks;
		};

		class CompiledShader
		{
		public:
			ShaderMetaData MetaData;
			EnumerableDictionary<String, RefPtr<InterfaceBlock>> InterfaceBlocks;
			EnumerableDictionary<String, RefPtr<CompiledWorld>> Worlds;
		};
		class CompiledFunction
		{
		public:
			EnumerableDictionary<String, RefPtr<ILType>> Parameters;
			RefPtr<ILType> ReturnType;
			RefPtr<CFGNode> Code;
			String Name;
		};
		class CompiledProgram
		{
		public:
			RefPtr<ConstantPool> ConstantPool = new Compiler::ConstantPool();
			List<RefPtr<CompiledShader>> Shaders;
			List<RefPtr<CompiledFunction>> Functions;
			List<RefPtr<ILStructType>> Structs;
		};

		class ShaderChoiceValue
		{
		public:
			String WorldName, AlternateName;
			ShaderChoiceValue() = default;
			ShaderChoiceValue(String world, String alt)
			{
				WorldName = world;
				AlternateName = alt;
			}
			static ShaderChoiceValue Parse(String str);
			String ToString()
			{
				if (AlternateName.Length() == 0)
					return WorldName;
				else
					return WorldName + L":" + AlternateName;
			}
			bool operator == (const ShaderChoiceValue & val)
			{
				return WorldName == val.WorldName && AlternateName == val.AlternateName;
			}
			bool operator != (const ShaderChoiceValue & val)
			{
				return WorldName != val.WorldName || AlternateName != val.AlternateName;
			}
			int GetHashCode()
			{
				return WorldName.GetHashCode() ^ AlternateName.GetHashCode();
			}
		};

		class ShaderChoice
		{
		public:
			String ChoiceName;
			String DefaultValue;
			List<ShaderChoiceValue> Options;
		};

		class CompiledShaderSource
		{
		private:
			void PrintAdditionalCode(StringBuilder & sb, String userCode);
		public:
			String GlobalHeader;
			EnumerableDictionary<String, String> InputDeclarations; // indexed by world
			String OutputDeclarations;
			String GlobalDefinitions;
			String LocalDeclarations;
			String MainCode;
			List<unsigned char> BinaryCode;
			CoreLib::Basic::EnumerableDictionary<CoreLib::String, CoreLib::String> ComponentAccessNames;
			String GetAllCodeGLSL(String additionalHeader, String additionalGlobalDeclaration, String preambleCode, String epilogCode);
			String GetAllCodeGLSL()
			{
				return GetAllCodeGLSL(L"", L"", L"", L"");
			}
			void ParseFromGLSL(String code);
		};

		void IndentString(StringBuilder & sb, String src);

		class CompileResult
		{
		private:
			ErrorWriter errWriter;
		public:
			bool Success;
			List<CompileError> ErrorList, WarningList;
			String ScheduleFile;
			RefPtr<CompiledProgram> Program;
			List<ShaderChoice> Choices;
			EnumerableDictionary<String, EnumerableDictionary<String, CompiledShaderSource>> CompiledSource; // file -> world -> code
			void PrintError(bool printWarning = false)
			{
				for (int i = 0; i < ErrorList.Count(); i++)
				{
					printf("%s(%d): error %d: %s\n", ErrorList[i].Position.FileName.ToMultiByteString(), ErrorList[i].Position.Line,
						ErrorList[i].ErrorID, ErrorList[i].Message.ToMultiByteString());
				}
				if (printWarning)
					for (int i = 0; i < WarningList.Count(); i++)
					{
						printf("%s(%d): warning %d: %s\n", WarningList[i].Position.FileName.ToMultiByteString(),
							WarningList[i].Position.Line, WarningList[i].ErrorID, WarningList[i].Message.ToMultiByteString());
					}
			}
			CompileResult()
				: errWriter(ErrorList, WarningList)
			{}
			ErrorWriter * GetErrorWriter()
			{
				return &errWriter;
			}
		};

	}
}

#endif

/***********************************************************************
CORE\CODEGENBACKEND.H
***********************************************************************/
#ifndef CODE_GEN_BACKEND_H
#define CODE_GEN_BACKEND_H


namespace Spire
{
	namespace Compiler
	{
		class ImportOperatorContext
		{
		public:
			EnumerableDictionary<String, String> & Arguments;
			EnumerableDictionary<String, String> & BackendArguments;
			CompiledWorld * SourceWorld, * DestWorld;
			CompileResult & Result;
			void * CodeGenContext = nullptr;
			ImportOperatorContext(EnumerableDictionary<String, String> & args,
				EnumerableDictionary<String, String> & backendArgs,
				CompiledWorld * destWorld,
				CompileResult & result, CompiledWorld * srcWorld, void * codeGenContext = nullptr)
				: Arguments(args), BackendArguments(backendArgs), SourceWorld(srcWorld), DestWorld(destWorld),
				 Result(result), CodeGenContext(codeGenContext)
			{}
		};
		class ImportOperatorHandler : public CoreLib::Object
		{
		public:
			virtual String GetName() = 0;
			virtual void GenerateInterfaceDefinition(StringBuilder & sb, InterfaceBlock * block, const ImportOperatorContext & context) = 0;
			virtual void GeneratePreamble(StringBuilder & sb, InterfaceBlock * block, const ImportOperatorContext & context) = 0;
			virtual void GenerateEpilogue(StringBuilder & sb, InterfaceBlock * block, const ImportOperatorContext & context) = 0;
			virtual void GenerateInterfaceLocalDefinition(StringBuilder & sb, ImportInstruction * instr, const ImportOperatorContext & context) = 0;
			virtual void GenerateSetInput(StringBuilder & sb, ComponentDefinition * gvar, const ImportOperatorContext & context) = 0;
		};

		class ExportOperatorHandler : public CoreLib::Object
		{
		public:
			virtual String GetName() = 0;
			virtual void GenerateInterfaceDefinition(StringBuilder & sb, InterfaceBlock * block) = 0;
			virtual void GeneratePreamble(StringBuilder & sb, InterfaceBlock * block) = 0;
			virtual void GenerateEpilogue(StringBuilder & sb, InterfaceBlock * block) = 0;
			virtual void GenerateExport(StringBuilder & sb, InterfaceBlock * block, CompiledWorld * world, String compName, String valueVar) = 0;
		};

		class CodeGenBackend : public CoreLib::Basic::Object
		{
		public:
			virtual CompiledShaderSource GenerateShaderWorld(CompileResult & result, SymbolTable * symbols, CompiledWorld * shader,
				Dictionary<String, ImportOperatorHandler *> & opHandlers,
				Dictionary<String, ExportOperatorHandler *> & exportHandlers) = 0;
			virtual void SetParameters(const EnumerableDictionary<String, String> & arguments) = 0;
		};

		CodeGenBackend * CreateGLSLCodeGen();
		CodeGenBackend * CreateSpirVCodeGen();
	}
}

#endif

/***********************************************************************
CORE\SHADERCOMPILER.H
***********************************************************************/
#ifndef RASTER_SHADER_COMPILER_H
#define RASTER_SHADER_COMPILER_H


namespace Spire
{
	namespace Compiler
	{
		class ILConstOperand;

		enum class CompilerMode
		{
			ProduceShader,
			GenerateChoice
		};

		class CompileOptions
		{
		public:
			CompilerMode Mode = CompilerMode::ProduceShader;
			EnumerableDictionary<String, String> BackendArguments;
			String ScheduleSource, ScheduleFileName;
			String SymbolToCompile;
		};

		class CompileUnit
		{
		public:
			RefPtr<ProgramSyntaxNode> SyntaxNode;
		};

		class ShaderCompiler : public CoreLib::Basic::Object
		{
		public:
			virtual CompileUnit Parse(CompileResult & result, String source, String fileName) = 0;
			virtual void Compile(CompileResult & result, List<CompileUnit> & units, const CompileOptions & options) = 0;
			virtual void RegisterImportOperator(String backendName, ImportOperatorHandler * handler) = 0;
			virtual void RegisterExportOperator(String backendName, ExportOperatorHandler * handler) = 0;

		};
		ShaderCompiler * CreateShaderCompiler();
	}
}

#endif

/***********************************************************************
CORE\CLOSURE.H
***********************************************************************/
#ifndef BAKERSL_SHADER_CLOSURE_H
#define BAKERSL_SHADER_CLOSURE_H

namespace Spire
{
	namespace Compiler
	{
		RefPtr<ShaderClosure> CreateShaderClosure(ErrorWriter * err, SymbolTable * symTable, ShaderSymbol * shader);
		void FlattenShaderClosure(ErrorWriter * err, ShaderClosure * shader);
	}
}

#endif

/***********************************************************************
CORE\SYNTAXVISITORS.H
***********************************************************************/
#ifndef RASTER_RENDERER_SYNTAX_PRINTER_H
#define RASTER_RENDERER_SYNTAX_PRINTER_H


namespace Spire
{
	namespace Compiler
	{
		class ShaderCompiler;
		class ShaderLinkInfo;
		class ShaderSymbol;

		class ICodeGenerator : public SyntaxVisitor
		{
		public:
			ICodeGenerator(ErrorWriter * perr)
				: SyntaxVisitor(perr)
			{}
			virtual void ProcessFunction(FunctionSyntaxNode * func) = 0;
			virtual void ProcessShader(ShaderClosure * shader) = 0;
			virtual void ProcessStruct(StructSyntaxNode * st) = 0;
		};

		SyntaxVisitor * CreateSemanticsVisitor(SymbolTable * symbols, ErrorWriter * err);
		ICodeGenerator * CreateCodeGenerator(SymbolTable * symbols, CompileResult & result);
		RefPtr<ILType> TranslateExpressionType(const ExpressionType & type);
	}
}

#endif

/***********************************************************************
CORE\SCOPEDICTIONARY.H
***********************************************************************/
#ifndef RASTER_RENDERER_SCOPE_DICTIONARY_H
#define RASTER_RENDERER_SCOPE_DICTIONARY_H


using namespace CoreLib::Basic;

namespace Spire
{
	namespace Compiler
	{
		template <typename TKey, typename TValue>
		class ScopeDictionary
		{
		public:
			LinkedList<Dictionary<TKey, TValue>> dicts;
		public:
			void PushScope()
			{
				dicts.AddLast();
			}
			void PopScope()
			{
				dicts.Delete(dicts.LastNode());
			}
			bool TryGetValue(const TKey & key, TValue & value)
			{
				for (auto iter = dicts.LastNode(); iter; iter = iter->GetPrevious())
				{
					bool rs = iter->Value.TryGetValue(key, value);
					if (rs)
						return true;
				}
				return false;
			}
			bool TryGetValueInCurrentScope(const TKey & key, TValue & value)
			{
				return dicts.Last().TryGetValue(key, value);
			}
			void Add(const TKey & key, const TValue & value)
			{
				dicts.Last().Add(key, value);
			}
			void Set(const TKey & key, const TValue & value)
			{
				dicts.Last()[key] = value;
			}
		};
	}
}

#endif

/***********************************************************************
CORE\CODEWRITER.H
***********************************************************************/
#ifndef IL_CODE_WRITER_H
#define IL_CODE_WRITER_H


namespace Spire
{
	namespace Compiler
	{
		class CodeWriter
		{
		private:
			List<RefPtr<CFGNode>> cfgNode;
			ConstantPool * constantPool = nullptr;
		public:
			void SetConstantPool(ConstantPool * pool)
			{
				constantPool = pool;
			}
			CFGNode * GetCurrentNode()
			{
				return cfgNode.Last().Ptr();
			}
			void PushNode()
			{
				RefPtr<CFGNode> n = new CFGNode();
				cfgNode.Add(n);
			}
			RefPtr<CFGNode> PopNode()
			{
				auto rs = cfgNode.Last();
				cfgNode.SetSize(cfgNode.Count() - 1);
				return rs;
			}
			void Assign(ILType * type, ILOperand * dest, ILOperand * src) // handles base type and ILArrayType assignment
			{
				auto arrType = dynamic_cast<ILArrayType*>(type);
				if (arrType)
				{
					for (int i = 0; i < arrType->ArrayLength; i++)
					{
						auto srcAddr = Add(src, i);
						auto destAddr = Add(dest, i);
						Store(destAddr, Load(srcAddr));
					}
				}
				else
					Store(dest, Load(src));
			}
			ILOperand * Select(ILOperand * cond, ILOperand * v0, ILOperand * v1)
			{
				auto rs = new SelectInstruction(cond, v0, v1);
				cfgNode.Last()->InsertTail(rs);
				return rs;
			}
			ILOperand * BitAnd(ILOperand * v0, ILOperand * v1)
			{
				auto instr = new BitAndInstruction(v0, v1);
				cfgNode.Last()->InsertTail(instr);
				return instr;
			}
			ILOperand * BitAnd(ILOperand * v0, int c)
			{
				auto instr = new BitAndInstruction(v0, constantPool->CreateConstant(c));
				cfgNode.Last()->InsertTail(instr);
				return instr;
			}
			ILOperand * Add(ILOperand * v0, ILOperand * v1)
			{
				auto instr = new AddInstruction(v0, v1);
				cfgNode.Last()->InsertTail(instr);
				return instr;
			}
			ILOperand * Add(ILOperand * v0, int v1)
			{
				auto instr = new AddInstruction(v0, constantPool->CreateConstant(v1));
				cfgNode.Last()->InsertTail(instr);
				return instr;
			}
			ILOperand * Mul(ILOperand * v0, ILOperand * v1)
			{
				auto instr = new MulInstruction(v0, v1);
				cfgNode.Last()->InsertTail(instr);
				return instr;
			}
			ILOperand * Copy(ILOperand * src)
			{
				auto rs = new CopyInstruction(src);
				cfgNode.Last()->InsertTail(rs);
				return rs;
			}
			ILOperand * Load(ILOperand * src, int offset)
			{
				if (offset == 0)
				{
					auto instr = new LoadInstruction(src);
					cfgNode.Last()->InsertTail(instr);
					return instr;
				}
				else
				{
					auto dest = new AddInstruction(src, constantPool->CreateConstant(offset));
					cfgNode.Last()->InsertTail(dest);
					auto instr = new LoadInstruction(dest);
					cfgNode.Last()->InsertTail(instr);
					return instr;
				}
			}
			ILOperand * Load(ILOperand * src)
			{
				auto instr = new LoadInstruction(src);
				cfgNode.Last()->InsertTail(instr);
				return instr;
			}
			ILOperand * Load(ILOperand * src, ILOperand * offset)
			{
				auto dest = new AddInstruction(src, offset);
				cfgNode.Last()->InsertTail(dest);
				return Load(dest);
			}
			StoreInstruction * Store(ILOperand * dest, ILOperand * value)
			{
				auto instr = new StoreInstruction(dest, value);
				cfgNode.Last()->InsertTail(instr);
				return instr;
			}
			DiscardInstruction * Discard()
			{
				auto instr = new DiscardInstruction();
				cfgNode.Last()->InsertTail(instr);
				return instr;
			}
			MemberUpdateInstruction * Update(ILOperand * dest, ILOperand * offset, ILOperand * value)
			{
				auto instr = new MemberUpdateInstruction(dest, offset, value);
				cfgNode.Last()->InsertTail(instr);
				return instr;
			}
			MemberLoadInstruction * Retrieve(ILOperand * dest, ILOperand * offset)
			{
				auto instr = new MemberLoadInstruction(dest, offset);
				cfgNode.Last()->InsertTail(instr);
				return instr;
			}
			//AllocVarInstruction * AllocVar(ILType * type, ILOperand * size)
			//{
			//	auto arrType = dynamic_cast<ILArrayType*>(type);
			//	if (arrType)
			//	{
			//		// check: size must be constant 1. Do not support array of array in IL level.
			//		auto s = dynamic_cast<ILConstOperand*>(size);
			//		if (!s || s->IntValues[0] != 1)
			//			throw ArgumentException(L"AllocVar(arrayType, size): size must be constant 1.");
			//		auto instr = new AllocVarInstruction(arrType->BaseType, program.CreateConstant(arrType->ArrayLength));
			//		cfgNode->InsertTail(instr);
			//		return instr;
			//	}
			//	else
			//	{
			//		auto instr = new AllocVarInstruction(type, size);
			//		cfgNode->InsertTail(instr);
			//		return instr;
			//	}
			//}
			AllocVarInstruction * AllocVar(RefPtr<ILType> & type, ILOperand * size)
			{
				auto arrType = dynamic_cast<ILArrayType*>(type.Ptr());
				if (arrType)
				{
					// check: size must be constant 1. Do not support array of array in IL level.
					auto s = dynamic_cast<ILConstOperand*>(size);
					if (!s || s->IntValues[0] != 1)
						throw ArgumentException(L"AllocVar(arrayType, size): size must be constant 1.");
					auto instr = new AllocVarInstruction(arrType->BaseType, constantPool->CreateConstant(arrType->ArrayLength));
					cfgNode.Last()->InsertTail(instr);
					return instr;
				}
				else
				{
					auto instr = new AllocVarInstruction(type, size);
					cfgNode.Last()->InsertTail(instr);
					return instr;
				}
			}
			/*GLeaInstruction * GLea(ILType * type, const String & name)
			{
				auto arrType = dynamic_cast<ILArrayType*>(type);
				auto instr = new GLeaInstruction();
				if (arrType)
					instr->Type = new ILPointerType(arrType->BaseType);
				else
					instr->Type = new ILPointerType(type);
				instr->Name = name;
				instr->VariableName = name;
				cfgNode->InsertTail(instr);
				return instr;
			}*/
			GLeaInstruction * GLea(RefPtr<ILType> & type, const String & name)
			{
				auto instr = new GLeaInstruction();
				instr->Type = type;
				instr->Name = name;
				instr->VariableName = name;
				cfgNode.Last()->InsertTail(instr);
				return instr;
			}
			FetchArgInstruction * FetchArg(RefPtr<ILType> type, int argId)
			{
				auto instr = new FetchArgInstruction(type);
				cfgNode.Last()->InsertTail(instr);
				instr->ArgId = argId;
				return instr;
			}
			
			void Insert(ILInstruction * instr)
			{
				cfgNode.Last()->InsertTail(instr);
			}
		};
	}
}

#endif

/***********************************************************************
CORE\PARSER.H
***********************************************************************/
#ifndef RASTER_RENDERER_PARSER_H
#define RASTER_RENDERER_PARSER_H


namespace Spire
{
	namespace Compiler
	{
		const int MaxExprLevel = 12;

		class Parser
		{
		private:
			int pos;
			List<RefPtr<Scope>> scopeStack;
			List<Token> & tokens;
			List<CompileError> & errors;
			String fileName;
			HashSet<String> typeNames;
			HashSet<String> classNames;
			void FillPosition(SyntaxNode * node)
			{
				int id = Math::Min(pos, tokens.Count() - 1);
				if (id >= 0)
				{
					node->Position = tokens[id].Position;
				}
				else
				{
					node->Position = CodePosition(0, 0, fileName);
				}
				node->Scope = scopeStack.Last();
			}
			void PushScope()
			{
				scopeStack.Add(new Scope());
				if (scopeStack.Count() > 1)
					scopeStack.Last()->Parent = scopeStack[scopeStack.Count() - 2].Ptr();
			}
			void PopScope()
			{
				scopeStack.Last() = 0;
				scopeStack.RemoveAt(scopeStack.Count() - 1);
			}
		public:
			Parser(List<Token> & _tokens, List<CompileError> & _errors, String _fileName)
				: pos(0), tokens(_tokens), errors(_errors), fileName(_fileName)
			{
				typeNames.Add(L"int");
				typeNames.Add(L"uint");
				typeNames.Add(L"float");
				typeNames.Add(L"void");
				typeNames.Add(L"ivec2");
				typeNames.Add(L"ivec3");
				typeNames.Add(L"ivec4");
				typeNames.Add(L"uvec2");
				typeNames.Add(L"uvec3");
				typeNames.Add(L"uvec4");
				typeNames.Add(L"vec2");
				typeNames.Add(L"vec3");
				typeNames.Add(L"vec4");
				typeNames.Add(L"mat3");
				typeNames.Add(L"mat4");
				typeNames.Add(L"mat4x4");
				typeNames.Add(L"mat3x3");
				typeNames.Add(L"sampler2D");
				typeNames.Add(L"sampler2DShadow");
				typeNames.Add(L"samplerCube");
				typeNames.Add(L"samplerCubeShadow");
			}
			RefPtr<ProgramSyntaxNode> Parse();
		private:
			Token & ReadToken();
			Token & ReadToken(TokenType type);
			Token & ReadToken(const wchar_t * string);
			bool LookAheadToken(TokenType type, int offset = 0);
			bool LookAheadToken(const wchar_t * string, int offset = 0);
			Token & ReadTypeKeyword();
			VariableModifier ReadVariableModifier();
			bool IsTypeKeyword();
			EnumerableDictionary<String, String>	ParseAttribute();
			RefPtr<ProgramSyntaxNode>				ParseProgram();
			RefPtr<ShaderSyntaxNode>				ParseShader();
			RefPtr<PipelineSyntaxNode>				ParsePipeline();
			RefPtr<ComponentSyntaxNode>				ParseComponent();
			RefPtr<WorldSyntaxNode>					ParseWorld();
			RefPtr<RateSyntaxNode>					ParseRate();
			RefPtr<ImportSyntaxNode>				ParseImport();
			RefPtr<ImportStatementSyntaxNode>		ParseImportStatement();
			RefPtr<ImportOperatorDefSyntaxNode>		ParseImportOperator();
			RefPtr<FunctionSyntaxNode>				ParseFunction();
			RefPtr<StructSyntaxNode>				ParseStruct();
			RefPtr<StatementSyntaxNode>				ParseStatement();
			RefPtr<BlockStatementSyntaxNode>		ParseBlockStatement();
			RefPtr<VarDeclrStatementSyntaxNode>		ParseVarDeclrStatement();
			RefPtr<IfStatementSyntaxNode>			ParseIfStatement();
			RefPtr<ForStatementSyntaxNode>			ParseForStatement();
			RefPtr<WhileStatementSyntaxNode>		ParseWhileStatement();
			RefPtr<DoWhileStatementSyntaxNode>		ParseDoWhileStatement();
			RefPtr<BreakStatementSyntaxNode>		ParseBreakStatement();
			RefPtr<ContinueStatementSyntaxNode>		ParseContinueStatement();
			RefPtr<ReturnStatementSyntaxNode>		ParseReturnStatement();
			RefPtr<ExpressionStatementSyntaxNode>	ParseExpressionStatement();
			RefPtr<ExpressionSyntaxNode>			ParseExpression(int level = 0);
			RefPtr<ExpressionSyntaxNode>			ParseLeafExpression();
			RefPtr<ParameterSyntaxNode>				ParseParameter();
			RefPtr<TypeSyntaxNode>					ParseType();

			Parser & operator = (const Parser &) = delete;
		};
		
	}
}

#endif

/***********************************************************************
CORE\SCHEDULE.H
***********************************************************************/
#ifndef BAKER_SL_SCHEDULE_H
#define BAKER_SL_SCHEDULE_H


namespace Spire
{
	namespace Compiler
	{
		class Schedule
		{
		public:
			CoreLib::EnumerableDictionary<CoreLib::String, CoreLib::List<RefPtr<ChoiceValueSyntaxNode>>> Choices;
			CoreLib::EnumerableDictionary<CoreLib::String, CoreLib::EnumerableDictionary<CoreLib::String, CoreLib::String>> AddtionalAttributes;
			static Schedule Parse(CoreLib::String source, CoreLib::String fileName, CoreLib::List<CompileError> & errorList);
		};
	}
}

#endif

/***********************************************************************
CORE\STDINCLUDE.H
***********************************************************************/
#ifndef SHADER_COMPILER_STD_LIB_H
#define SHADER_COMPILER_STD_LIB_H

extern const wchar_t * LibIncludeString;
extern const wchar_t * VertexShaderIncludeString;
#endif

/***********************************************************************
LIB\IMPORTOPERATOR.H
***********************************************************************/
#ifndef IMPORT_OPERATOR_HANDLERS_H
#define IMPORT_OPERATOR_HANDLERS_H


void CreateGLSLImportOperatorHandlers(CoreLib::Basic::List<Spire::Compiler::ImportOperatorHandler *> & handlers);
void CreateGLSLExportOperatorHandlers(CoreLib::Basic::List<Spire::Compiler::ExportOperatorHandler *> & handlers);
void DestroyImportOperatorHanlders(CoreLib::Basic::List<Spire::Compiler::ImportOperatorHandler *> & handlers);
void DestroyExportOperatorHanlders(CoreLib::Basic::List<Spire::Compiler::ExportOperatorHandler *> & handlers);

#endif

/***********************************************************************
LIB\SPIRELIB.H
***********************************************************************/
#ifndef LIB_BAKER_SL_H
#define LIB_BAKER_SL_H


namespace SpireLib
{
	class ShaderLibFile : public CoreLib::Basic::Object
	{
	public:
		CoreLib::Basic::EnumerableDictionary<CoreLib::Basic::String, Spire::Compiler::CompiledShaderSource> Sources; // indexed by world
		Spire::Compiler::ShaderMetaData MetaData;
		void AddSource(CoreLib::Basic::String source, CoreLib::Text::Parser & parser);
		void FromString(const CoreLib::String & str);
		CoreLib::String ToString();
		void SaveToFile(CoreLib::Basic::String fileName);
		ShaderLibFile() = default;
		void Clear();
		void Load(CoreLib::Basic::String fileName);
	};
	
	CoreLib::Basic::List<ShaderLibFile> CompileShaderSourceFromFile(Spire::Compiler::CompileResult & result,
		CoreLib::Basic::String sourceFileName,
		Spire::Compiler::CompileOptions &options);

	CoreLib::Basic::List<ShaderLibFile> CompileShaderSource(Spire::Compiler::CompileResult & result,
		const CoreLib::Basic::String &source, Spire::Compiler::CompileOptions &options);

	class ShaderLib : public ShaderLibFile
	{
	public:
		Spire::Compiler::CompiledShaderSource GetWorldSource(CoreLib::Basic::String world);
		ShaderLib() = default;
		ShaderLib(CoreLib::Basic::String fileName);
		void Reload(CoreLib::Basic::String fileName);
		bool CompileFrom(CoreLib::Basic::String symbolName, CoreLib::Basic::String sourceFileName, CoreLib::Basic::String schedule);
	};
}

#endif
