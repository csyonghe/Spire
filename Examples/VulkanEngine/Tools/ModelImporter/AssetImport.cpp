/***********************************************************************


========================================================================
WARNING: THIS FILE IS AUTOMATICALLY GENERATED. DO NOT MODIFY
***********************************************************************/
#include "AssetImport.h"

/***********************************************************************
FBXIMPORT\BASEIMPORTER.CPP
***********************************************************************/
/*
---------------------------------------------------------------------------
Open Asset Import Library (assimp)
---------------------------------------------------------------------------

Copyright (c) 2006-2016, assimp team

All rights reserved.

Redistribution and use of this software in source and binary forms,
with or without modification, are permitted provided that the following
conditions are met:

* Redistributions of source code must retain the above
  copyright notice, this list of conditions and the
  following disclaimer.

* Redistributions in binary form must reproduce the above
  copyright notice, this list of conditions and the
  following disclaimer in the documentation and/or other
  materials provided with the distribution.

* Neither the name of the assimp team, nor the names of its
  contributors may be used to endorse or promote products
  derived from this software without specific prior
  written permission of the assimp team.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
"AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
---------------------------------------------------------------------------
*/

/** @file  BaseImporter.cpp
 *  @brief Implementation of BaseImporter
 */
#include <ios>


using namespace Assimp;

// ------------------------------------------------------------------------------------------------
// Constructor to be privately used by Importer
BaseImporter::BaseImporter()
: m_progress()
{
    // nothing to do here
}

// ------------------------------------------------------------------------------------------------
// Destructor, private as well
BaseImporter::~BaseImporter()
{
    // nothing to do here
}

// ------------------------------------------------------------------------------------------------
// Imports the given file and returns the imported data.
aiScene* BaseImporter::ReadFile(const Importer* pImp, const std::string& pFile, IOSystem* pIOHandler)
{
    m_progress = pImp->GetProgressHandler();
    ai_assert(m_progress);

    // Gather configuration properties for this run
    SetupProperties( pImp );

    // Construct a file system filter to improve our success ratio at reading external files
    FileSystemFilter filter(pFile,pIOHandler);

    // create a scene object to hold the data
    ScopeGuard<aiScene> sc(new aiScene());

    // dispatch importing
    try
    {
        InternReadFile( pFile, sc, &filter);

    } catch( const std::exception& err )    {
        // extract error description
        m_ErrorText = err.what();
        DefaultLogger::get()->error(m_ErrorText);
        return NULL;
    }

    // return what we gathered from the import.
    sc.dismiss();
    return sc;
}

// ------------------------------------------------------------------------------------------------
void BaseImporter::SetupProperties(const Importer* /*pImp*/)
{
    // the default implementation does nothing
}

// ------------------------------------------------------------------------------------------------
void BaseImporter::GetExtensionList(std::set<std::string>& extensions)
{
    const aiImporterDesc* desc = GetInfo();
    ai_assert(desc != NULL);

    const char* ext = desc->mFileExtensions;
    ai_assert(ext != NULL);

    const char* last = ext;
    do {
        if (!*ext || *ext == ' ') {
            extensions.insert(std::string(last,ext-last));
            ai_assert(ext-last > 0);
            last = ext;
            while(*last == ' ') {
                ++last;
            }
        }
    }
    while(*ext++);
}

// ------------------------------------------------------------------------------------------------
/*static*/ bool BaseImporter::SearchFileHeaderForToken(IOSystem* pIOHandler,
    const std::string&  pFile,
    const char**        tokens,
    unsigned int        numTokens,
    unsigned int        searchBytes /* = 200 */,
    bool                tokensSol /* false */)
{
    ai_assert(NULL != tokens && 0 != numTokens && 0 != searchBytes);
    if (!pIOHandler)
        return false;

    std::unique_ptr<IOStream> pStream (pIOHandler->Open(pFile));
    if (pStream.get() ) {
        // read 200 characters from the file
        std::unique_ptr<char[]> _buffer (new char[searchBytes+1 /* for the '\0' */]);
        char* buffer = _buffer.get();
        if( NULL == buffer ) {
            return false;
        }

        const size_t read = pStream->Read(buffer,1,searchBytes);
        if( !read ) {
            return false;
        }

        for( size_t i = 0; i < read; ++i ) {
            buffer[ i ] = ::tolower( buffer[ i ] );
        }

        // It is not a proper handling of unicode files here ...
        // ehm ... but it works in most cases.
        char* cur = buffer,*cur2 = buffer,*end = &buffer[read];
        while (cur != end)  {
            if( *cur ) {
                *cur2++ = *cur;
            }
            ++cur;
        }
        *cur2 = '\0';

        for (unsigned int i = 0; i < numTokens;++i) {
            ai_assert(NULL != tokens[i]);


            const char* r = strstr(buffer,tokens[i]);
            if( !r ) {
                continue;
            }
            // We got a match, either we don't care where it is, or it happens to
            // be in the beginning of the file / line
            if (!tokensSol || r == buffer || r[-1] == '\r' || r[-1] == '\n') {
                DefaultLogger::get()->debug(std::string("Found positive match for header keyword: ") + tokens[i]);
                return true;
            }
        }
    }

    return false;
}

// ------------------------------------------------------------------------------------------------
// Simple check for file extension
/*static*/ bool BaseImporter::SimpleExtensionCheck (const std::string& pFile,
    const char* ext0,
    const char* ext1,
    const char* ext2)
{
    std::string::size_type pos = pFile.find_last_of('.');

    // no file extension - can't read
    if( pos == std::string::npos)
        return false;

    const char* ext_real = & pFile[ pos+1 ];
    if( !ASSIMP_stricmp(ext_real,ext0) )
        return true;

    // check for other, optional, file extensions
    if (ext1 && !ASSIMP_stricmp(ext_real,ext1))
        return true;

    if (ext2 && !ASSIMP_stricmp(ext_real,ext2))
        return true;

    return false;
}

// ------------------------------------------------------------------------------------------------
// Get file extension from path
/*static*/ std::string BaseImporter::GetExtension (const std::string& pFile)
{
    std::string::size_type pos = pFile.find_last_of('.');

    // no file extension at all
    if( pos == std::string::npos)
        return "";

    std::string ret = pFile.substr(pos+1);
    std::transform(ret.begin(),ret.end(),ret.begin(),::tolower); // thanks to Andy Maloney for the hint
    return ret;
}

// ------------------------------------------------------------------------------------------------
// Check for magic bytes at the beginning of the file.
/* static */ bool BaseImporter::CheckMagicToken(IOSystem* pIOHandler, const std::string& pFile,
    const void* _magic, unsigned int num, unsigned int offset, unsigned int size)
{
    ai_assert(size <= 16 && _magic);

    if (!pIOHandler) {
        return false;
    }
    union {
        const char* magic;
        const uint16_t* magic_u16;
        const uint32_t* magic_u32;
    };
    magic = reinterpret_cast<const char*>(_magic);
    std::unique_ptr<IOStream> pStream (pIOHandler->Open(pFile));
    if (pStream.get() ) {

        // skip to offset
        pStream->Seek(offset,aiOrigin_SET);

        // read 'size' characters from the file
        union {
            char data[16];
            uint16_t data_u16[8];
            uint32_t data_u32[4];
        };
        if(size != pStream->Read(data,1,size)) {
            return false;
        }

        for (unsigned int i = 0; i < num; ++i) {
            // also check against big endian versions of tokens with size 2,4
            // that's just for convenience, the chance that we cause conflicts
            // is quite low and it can save some lines and prevent nasty bugs
            if (2 == size) {
                uint16_t rev = *magic_u16;
                ByteSwap::Swap(&rev);
                if (data_u16[0] == *magic_u16 || data_u16[0] == rev) {
                    return true;
                }
            }
            else if (4 == size) {
                uint32_t rev = *magic_u32;
                ByteSwap::Swap(&rev);
                if (data_u32[0] == *magic_u32 || data_u32[0] == rev) {
                    return true;
                }
            }
            else {
                // any length ... just compare
                if(!memcmp(magic,data,size)) {
                    return true;
                }
            }
            magic += size;
        }
    }
    return false;
}


// ------------------------------------------------------------------------------------------------
void ReportResult(ConversionResult res)
{
    if(res == sourceExhausted) {
        DefaultLogger::get()->error("Source ends with incomplete character sequence, transformation to UTF-8 fails");
    }
    else if(res == sourceIllegal) {
        DefaultLogger::get()->error("Source contains illegal character sequence, transformation to UTF-8 fails");
    }
}

// ------------------------------------------------------------------------------------------------
// Convert to UTF8 data
void BaseImporter::ConvertToUTF8(std::vector<char>& data)
{
    ConversionResult result;
    if(data.size() < 8) {
        throw DeadlyImportError("File is too small");
    }

    // UTF 8 with BOM
    if((uint8_t)data[0] == 0xEF && (uint8_t)data[1] == 0xBB && (uint8_t)data[2] == 0xBF) {
        DefaultLogger::get()->debug("Found UTF-8 BOM ...");

        std::copy(data.begin()+3,data.end(),data.begin());
        data.resize(data.size()-3);
        return;
    }

    // UTF 32 BE with BOM
    if(*((uint32_t*)&data.front()) == 0xFFFE0000) {

        // swap the endianness ..
        for(uint32_t* p = (uint32_t*)&data.front(), *end = (uint32_t*)&data.back(); p <= end; ++p) {
            AI_SWAP4P(p);
        }
    }

    // UTF 32 LE with BOM
    if(*((uint32_t*)&data.front()) == 0x0000FFFE) {
        DefaultLogger::get()->debug("Found UTF-32 BOM ...");

        const uint32_t* sstart = (uint32_t*)&data.front()+1, *send = (uint32_t*)&data.back()+1;
        char* dstart,*dend;
        std::vector<char> output;
        do {
            output.resize(output.size()?output.size()*3/2:data.size()/2);
            dstart = &output.front(),dend = &output.back()+1;

            result = ConvertUTF32toUTF8((const UTF32**)&sstart,(const UTF32*)send,(UTF8**)&dstart,(UTF8*)dend,lenientConversion);
        } while(result == targetExhausted);

        ReportResult(result);

        // copy to output buffer.
        const size_t outlen = (size_t)(dstart-&output.front());
        data.assign(output.begin(),output.begin()+outlen);
        return;
    }

    // UTF 16 BE with BOM
    if(*((uint16_t*)&data.front()) == 0xFFFE) {

        // swap the endianness ..
        for(uint16_t* p = (uint16_t*)&data.front(), *end = (uint16_t*)&data.back(); p <= end; ++p) {
            ByteSwap::Swap2(p);
        }
    }

    // UTF 16 LE with BOM
    if(*((uint16_t*)&data.front()) == 0xFEFF) {
        DefaultLogger::get()->debug("Found UTF-16 BOM ...");

        const uint16_t* sstart = (uint16_t*)&data.front()+1, *send = (uint16_t*)(&data.back()+1);
        char* dstart,*dend;
        std::vector<char> output;
        do {
            output.resize(output.size()?output.size()*3/2:data.size()*3/4);
            dstart = &output.front(),dend = &output.back()+1;

            result = ConvertUTF16toUTF8((const UTF16**)&sstart,(const UTF16*)send,(UTF8**)&dstart,(UTF8*)dend,lenientConversion);
        } while(result == targetExhausted);

        ReportResult(result);

        // copy to output buffer.
        const size_t outlen = (size_t)(dstart-&output.front());
        data.assign(output.begin(),output.begin()+outlen);
        return;
    }
}

// ------------------------------------------------------------------------------------------------
// Convert to UTF8 data to ISO-8859-1
void BaseImporter::ConvertUTF8toISO8859_1(std::string& data)
{
    size_t size = data.size();
    size_t i = 0, j = 0;

    while(i < size) {
        if ((unsigned char) data[i] < (size_t) 0x80) {
            data[j] = data[i];
        } else if(i < size - 1) {
            if((unsigned char) data[i] == 0xC2) {
                data[j] = data[++i];
            } else if((unsigned char) data[i] == 0xC3) {
                data[j] = ((unsigned char) data[++i] + 0x40);
            } else {
                std::stringstream stream;

                stream << "UTF8 code " << std::hex << data[i] << data[i + 1] << " can not be converted into ISA-8859-1.";

                DefaultLogger::get()->error(stream.str());

                data[j++] = data[i++];
                data[j] = data[i];
            }
        } else {
            DefaultLogger::get()->error("UTF8 code but only one character remaining");

            data[j] = data[i];
        }

        i++; j++;
    }

    data.resize(j);
}

// ------------------------------------------------------------------------------------------------
void BaseImporter::TextFileToBuffer(IOStream* stream,
    std::vector<char>& data,
    TextFileMode mode)
{
    ai_assert(NULL != stream);

    const size_t fileSize = stream->FileSize();
    if (mode == FORBID_EMPTY) {
        if(!fileSize) {
            throw DeadlyImportError("File is empty");
        }
    }

    data.reserve(fileSize+1);
    data.resize(fileSize);
    if(fileSize > 0) {
        if(fileSize != stream->Read( &data[0], 1, fileSize)) {
            throw DeadlyImportError("File read error");
        }

        ConvertToUTF8(data);
    }

    // append a binary zero to simplify string parsing
    data.push_back(0);
}

// ------------------------------------------------------------------------------------------------
namespace Assimp
{
    // Represents an import request
    struct LoadRequest
    {
        LoadRequest(const std::string& _file, unsigned int _flags,const BatchLoader::PropertyMap* _map, unsigned int _id)
            : file(_file), flags(_flags), refCnt(1),scene(NULL), loaded(false), id(_id)
        {
            if (_map)
                map = *_map;
        }

        const std::string file;
        unsigned int flags;
        unsigned int refCnt;
        aiScene* scene;
        bool loaded;
        BatchLoader::PropertyMap map;
        unsigned int id;

        bool operator== (const std::string& f) {
            return file == f;
        }
    };
}

// ------------------------------------------------------------------------------------------------
// BatchLoader::pimpl data structure
struct Assimp::BatchData
{
    BatchData()
        : pIOSystem()
        , pImporter()
        , next_id(0xffff)
    {}

    // IO system to be used for all imports
    IOSystem* pIOSystem;

    // Importer used to load all meshes
    Importer* pImporter;

    // List of all imports
    std::list<LoadRequest> requests;

    // Base path
    std::string pathBase;

    // Id for next item
    unsigned int next_id;
};

// ------------------------------------------------------------------------------------------------
BatchLoader::BatchLoader(IOSystem* pIO)
{
    ai_assert(NULL != pIO);

    data = new BatchData();
    data->pIOSystem = pIO;

    data->pImporter = new Importer();
    data->pImporter->SetIOHandler(data->pIOSystem);
}

// ------------------------------------------------------------------------------------------------
BatchLoader::~BatchLoader()
{
    // delete all scenes wthat have not been polled by the user
    for (std::list<LoadRequest>::iterator it = data->requests.begin();it != data->requests.end(); ++it) {

        delete (*it).scene;
    }
    data->pImporter->SetIOHandler(NULL); /* get pointer back into our possession */
    delete data->pImporter;
    delete data;
}


// ------------------------------------------------------------------------------------------------
unsigned int BatchLoader::AddLoadRequest    (const std::string& file,
    unsigned int steps /*= 0*/, const PropertyMap* map /*= NULL*/)
{
    ai_assert(!file.empty());

    // check whether we have this loading request already
    std::list<LoadRequest>::iterator it;
    for (it = data->requests.begin();it != data->requests.end(); ++it)  {

        // Call IOSystem's path comparison function here
        if (data->pIOSystem->ComparePaths((*it).file,file)) {

            if (map) {
                if (!((*it).map == *map))
                    continue;
            }
            else if (!(*it).map.empty())
                continue;

            (*it).refCnt++;
            return (*it).id;
        }
    }

    // no, we don't have it. So add it to the queue ...
    data->requests.push_back(LoadRequest(file,steps,map,data->next_id));
    return data->next_id++;
}

// ------------------------------------------------------------------------------------------------
aiScene* BatchLoader::GetImport     (unsigned int which)
{
    for (std::list<LoadRequest>::iterator it = data->requests.begin();it != data->requests.end(); ++it) {

        if ((*it).id == which && (*it).loaded)  {

            aiScene* sc = (*it).scene;
            if (!(--(*it).refCnt))  {
                data->requests.erase(it);
            }
            return sc;
        }
    }
    return NULL;
}

// ------------------------------------------------------------------------------------------------
void BatchLoader::LoadAll()
{
    // no threaded implementation for the moment
    for (std::list<LoadRequest>::iterator it = data->requests.begin();it != data->requests.end(); ++it) {
        // force validation in debug builds
        unsigned int pp = (*it).flags;
#ifdef ASSIMP_BUILD_DEBUG
        pp |= aiProcess_ValidateDataStructure;
#endif
        // setup config properties if necessary
        ImporterPimpl* pimpl = data->pImporter->Pimpl();
        pimpl->mFloatProperties  = (*it).map.floats;
        pimpl->mIntProperties    = (*it).map.ints;
        pimpl->mStringProperties = (*it).map.strings;
        pimpl->mMatrixProperties = (*it).map.matrices;

        if (!DefaultLogger::isNullLogger())
        {
            DefaultLogger::get()->info("%%% BEGIN EXTERNAL FILE %%%");
            DefaultLogger::get()->info("File: " + (*it).file);
        }
        data->pImporter->ReadFile((*it).file,pp);
        (*it).scene = data->pImporter->GetOrphanedScene();
        (*it).loaded = true;

        DefaultLogger::get()->info("%%% END EXTERNAL FILE %%%");
    }
}

/***********************************************************************
FBXIMPORT\BASEPROCESS.CPP
***********************************************************************/
/*
---------------------------------------------------------------------------
Open Asset Import Library (assimp)
---------------------------------------------------------------------------

Copyright (c) 2006-2016, assimp team

All rights reserved.

Redistribution and use of this software in source and binary forms,
with or without modification, are permitted provided that the following
conditions are met:

* Redistributions of source code must retain the above
  copyright notice, this list of conditions and the
  following disclaimer.

* Redistributions in binary form must reproduce the above
  copyright notice, this list of conditions and the
  following disclaimer in the documentation and/or other
  materials provided with the distribution.

* Neither the name of the assimp team, nor the names of its
  contributors may be used to endorse or promote products
  derived from this software without specific prior
  written permission of the assimp team.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
"AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
---------------------------------------------------------------------------
*/

/** @file Implementation of BaseProcess */


using namespace Assimp;

// ------------------------------------------------------------------------------------------------
// Constructor to be privately used by Importer
BaseProcess::BaseProcess()
: shared()
, progress()
{
}

// ------------------------------------------------------------------------------------------------
// Destructor, private as well
BaseProcess::~BaseProcess()
{
    // nothing to do here
}

// ------------------------------------------------------------------------------------------------
void BaseProcess::ExecuteOnScene( Importer* pImp)
{
    ai_assert(NULL != pImp && NULL != pImp->Pimpl()->mScene);

    progress = pImp->GetProgressHandler();
    ai_assert(progress);

    SetupProperties( pImp );

    // catch exceptions thrown inside the PostProcess-Step
    try
    {
        Execute(pImp->Pimpl()->mScene);

    } catch( const std::exception& err )    {

        // extract error description
        pImp->Pimpl()->mErrorString = err.what();
        DefaultLogger::get()->error(pImp->Pimpl()->mErrorString);

        // and kill the partially imported data
        delete pImp->Pimpl()->mScene;
        pImp->Pimpl()->mScene = NULL;
    }
}

// ------------------------------------------------------------------------------------------------
void BaseProcess::SetupProperties(const Importer* /*pImp*/)
{
    // the default implementation does nothing
}

// ------------------------------------------------------------------------------------------------
bool BaseProcess::RequireVerboseFormat() const
{
    return true;
}


/***********************************************************************
FBXIMPORT\CALCTANGENTSPROCESS.CPP
***********************************************************************/
/*
---------------------------------------------------------------------------
Open Asset Import Library (assimp)
---------------------------------------------------------------------------

Copyright (c) 2006-2016, assimp team

All rights reserved.

Redistribution and use of this software in source and binary forms,
with or without modification, are permitted provided that the following
conditions are met:

* Redistributions of source code must retain the above
  copyright notice, this list of conditions and the
  following disclaimer.

* Redistributions in binary form must reproduce the above
  copyright notice, this list of conditions and the
  following disclaimer in the documentation and/or other
  materials provided with the distribution.

* Neither the name of the assimp team, nor the names of its
  contributors may be used to endorse or promote products
  derived from this software without specific prior
  written permission of the assimp team.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
"AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
---------------------------------------------------------------------------
*/

/** @file Implementation of the post processing step to calculate
 *  tangents and bitangents for all imported meshes
 */

// internal headers

using namespace Assimp;

// ------------------------------------------------------------------------------------------------
// Constructor to be privately used by Importer
CalcTangentsProcess::CalcTangentsProcess()
: configMaxAngle( AI_DEG_TO_RAD(45.f) )
, configSourceUV( 0 ) {
    // nothing to do here
}

// ------------------------------------------------------------------------------------------------
// Destructor, private as well
CalcTangentsProcess::~CalcTangentsProcess()
{
    // nothing to do here
}

// ------------------------------------------------------------------------------------------------
// Returns whether the processing step is present in the given flag field.
bool CalcTangentsProcess::IsActive( unsigned int pFlags) const
{
    return (pFlags & aiProcess_CalcTangentSpace) != 0;
}

// ------------------------------------------------------------------------------------------------
// Executes the post processing step on the given imported data.
void CalcTangentsProcess::SetupProperties(const Importer* pImp)
{
    ai_assert( NULL != pImp );

    // get the current value of the property
    configMaxAngle = pImp->GetPropertyFloat(AI_CONFIG_PP_CT_MAX_SMOOTHING_ANGLE,45.f);
    configMaxAngle = std::max(std::min(configMaxAngle,45.0f),0.0f);
    configMaxAngle = AI_DEG_TO_RAD(configMaxAngle);

    configSourceUV = pImp->GetPropertyInteger(AI_CONFIG_PP_CT_TEXTURE_CHANNEL_INDEX,0);
}

// ------------------------------------------------------------------------------------------------
// Executes the post processing step on the given imported data.
void CalcTangentsProcess::Execute( aiScene* pScene)
{
    ai_assert( NULL != pScene );

    DefaultLogger::get()->debug("CalcTangentsProcess begin");

    bool bHas = false;
    for ( unsigned int a = 0; a < pScene->mNumMeshes; a++ ) {
        if(ProcessMesh( pScene->mMeshes[a],a))bHas = true;
    }

    if ( bHas ) {
        DefaultLogger::get()->info("CalcTangentsProcess finished. Tangents have been calculated");
    } else {
        DefaultLogger::get()->debug("CalcTangentsProcess finished");
    }
}

// ------------------------------------------------------------------------------------------------
// Calculates tangents and bi-tangents for the given mesh
bool CalcTangentsProcess::ProcessMesh( aiMesh* pMesh, unsigned int meshIndex)
{
    // we assume that the mesh is still in the verbose vertex format where each face has its own set
    // of vertices and no vertices are shared between faces. Sadly I don't know any quick test to
    // assert() it here.
    // assert( must be verbose, dammit);

    if (pMesh->mTangents) // this implies that mBitangents is also there
        return false;

    // If the mesh consists of lines and/or points but not of
    // triangles or higher-order polygons the normal vectors
    // are undefined.
    if (!(pMesh->mPrimitiveTypes & (aiPrimitiveType_TRIANGLE | aiPrimitiveType_POLYGON)))
    {
        DefaultLogger::get()->info("Tangents are undefined for line and point meshes");
        return false;
    }

    // what we can check, though, is if the mesh has normals and texture coordinates. That's a requirement
    if( pMesh->mNormals == NULL)
    {
        DefaultLogger::get()->error("Failed to compute tangents; need normals");
        return false;
    }
    if( configSourceUV >= AI_MAX_NUMBER_OF_TEXTURECOORDS || !pMesh->mTextureCoords[configSourceUV] )
    {
        DefaultLogger::get()->error((Formatter::format("Failed to compute tangents; need UV data in channel"),configSourceUV));
        return false;
    }

    const float angleEpsilon = 0.9999f;

    std::vector<bool> vertexDone( pMesh->mNumVertices, false);
    const float qnan = get_qnan();

    // create space for the tangents and bitangents
    pMesh->mTangents = new aiVector3D[pMesh->mNumVertices];
    pMesh->mBitangents = new aiVector3D[pMesh->mNumVertices];

    const aiVector3D* meshPos = pMesh->mVertices;
    const aiVector3D* meshNorm = pMesh->mNormals;
    const aiVector3D* meshTex = pMesh->mTextureCoords[configSourceUV];
    aiVector3D* meshTang = pMesh->mTangents;
    aiVector3D* meshBitang = pMesh->mBitangents;

    // calculate the tangent and bitangent for every face
    for( unsigned int a = 0; a < pMesh->mNumFaces; a++)
    {
        const aiFace& face = pMesh->mFaces[a];
        if (face.mNumIndices < 3)
        {
            // There are less than three indices, thus the tangent vector
            // is not defined. We are finished with these vertices now,
            // their tangent vectors are set to qnan.
            for (unsigned int i = 0; i < face.mNumIndices;++i)
            {
                unsigned int idx = face.mIndices[i];
                vertexDone  [idx] = true;
                meshTang    [idx] = aiVector3D(qnan);
                meshBitang  [idx] = aiVector3D(qnan);
            }

            continue;
        }

        // triangle or polygon... we always use only the first three indices. A polygon
        // is supposed to be planar anyways....
        // FIXME: (thom) create correct calculation for multi-vertex polygons maybe?
        const unsigned int p0 = face.mIndices[0], p1 = face.mIndices[1], p2 = face.mIndices[2];

        // position differences p1->p2 and p1->p3
        aiVector3D v = meshPos[p1] - meshPos[p0], w = meshPos[p2] - meshPos[p0];

        // texture offset p1->p2 and p1->p3
        float sx = meshTex[p1].x - meshTex[p0].x, sy = meshTex[p1].y - meshTex[p0].y;
        float tx = meshTex[p2].x - meshTex[p0].x, ty = meshTex[p2].y - meshTex[p0].y;
        float dirCorrection = (tx * sy - ty * sx) < 0.0f ? -1.0f : 1.0f;
        // when t1, t2, t3 in same position in UV space, just use default UV direction.
        if ( 0 == sx && 0 ==sy && 0 == tx && 0 == ty ) {
            sx = 0.0; sy = 1.0;
            tx = 1.0; ty = 0.0;
        }

        // tangent points in the direction where to positive X axis of the texture coord's would point in model space
        // bitangent's points along the positive Y axis of the texture coord's, respectively
        aiVector3D tangent, bitangent;
        tangent.x = (w.x * sy - v.x * ty) * dirCorrection;
        tangent.y = (w.y * sy - v.y * ty) * dirCorrection;
        tangent.z = (w.z * sy - v.z * ty) * dirCorrection;
        bitangent.x = (w.x * sx - v.x * tx) * dirCorrection;
        bitangent.y = (w.y * sx - v.y * tx) * dirCorrection;
        bitangent.z = (w.z * sx - v.z * tx) * dirCorrection;

        // store for every vertex of that face
        for( unsigned int b = 0; b < face.mNumIndices; ++b ) {
            unsigned int p = face.mIndices[b];

            // project tangent and bitangent into the plane formed by the vertex' normal
            aiVector3D localTangent = tangent - meshNorm[p] * (tangent * meshNorm[p]);
            aiVector3D localBitangent = bitangent - meshNorm[p] * (bitangent * meshNorm[p]);
            localTangent.Normalize(); localBitangent.Normalize();

            // reconstruct tangent/bitangent according to normal and bitangent/tangent when it's infinite or NaN.
            bool invalid_tangent = is_special_float(localTangent.x) || is_special_float(localTangent.y) || is_special_float(localTangent.z);
            bool invalid_bitangent = is_special_float(localBitangent.x) || is_special_float(localBitangent.y) || is_special_float(localBitangent.z);
            if (invalid_tangent != invalid_bitangent) {
                if (invalid_tangent) {
                    localTangent = meshNorm[p] ^ localBitangent;
                    localTangent.Normalize();
                } else {
                    localBitangent = localTangent ^ meshNorm[p];
                    localBitangent.Normalize();
                }
            }

            // and write it into the mesh.
            meshTang[ p ]   = localTangent;
            meshBitang[ p ] = localBitangent;
        }
    }


    // create a helper to quickly find locally close vertices among the vertex array
    // FIX: check whether we can reuse the SpatialSort of a previous step
    SpatialSort* vertexFinder = NULL;
    SpatialSort  _vertexFinder;
    float posEpsilon;
    if (shared)
    {
        std::vector<std::pair<SpatialSort,float> >* avf;
        shared->GetProperty(AI_SPP_SPATIAL_SORT,avf);
        if (avf)
        {
            std::pair<SpatialSort,float>& blubb = avf->operator [] (meshIndex);
            vertexFinder = &blubb.first;
            posEpsilon = blubb.second;;
        }
    }
    if (!vertexFinder)
    {
        _vertexFinder.Fill(pMesh->mVertices, pMesh->mNumVertices, sizeof( aiVector3D));
        vertexFinder = &_vertexFinder;
        posEpsilon = ComputePositionEpsilon(pMesh);
    }
    std::vector<unsigned int> verticesFound;

    const float fLimit = cosf(configMaxAngle);
    std::vector<unsigned int> closeVertices;

    // in the second pass we now smooth out all tangents and bitangents at the same local position
    // if they are not too far off.
    for( unsigned int a = 0; a < pMesh->mNumVertices; a++)
    {
        if( vertexDone[a])
            continue;

        const aiVector3D& origPos = pMesh->mVertices[a];
        const aiVector3D& origNorm = pMesh->mNormals[a];
        const aiVector3D& origTang = pMesh->mTangents[a];
        const aiVector3D& origBitang = pMesh->mBitangents[a];
        closeVertices.resize( 0 );

        // find all vertices close to that position
        vertexFinder->FindPositions( origPos, posEpsilon, verticesFound);

        closeVertices.reserve (verticesFound.size()+5);
        closeVertices.push_back( a);

        // look among them for other vertices sharing the same normal and a close-enough tangent/bitangent
        for( unsigned int b = 0; b < verticesFound.size(); b++)
        {
            unsigned int idx = verticesFound[b];
            if( vertexDone[idx])
                continue;
            if( meshNorm[idx] * origNorm < angleEpsilon)
                continue;
            if(  meshTang[idx] * origTang < fLimit)
                continue;
            if( meshBitang[idx] * origBitang < fLimit)
                continue;

            // it's similar enough -> add it to the smoothing group
            closeVertices.push_back( idx);
            vertexDone[idx] = true;
        }

        // smooth the tangents and bitangents of all vertices that were found to be close enough
        aiVector3D smoothTangent( 0, 0, 0), smoothBitangent( 0, 0, 0);
        for( unsigned int b = 0; b < closeVertices.size(); ++b)
        {
            smoothTangent += meshTang[ closeVertices[b] ];
            smoothBitangent += meshBitang[ closeVertices[b] ];
        }
        smoothTangent.Normalize();
        smoothBitangent.Normalize();

        // and write it back into all affected tangents
        for( unsigned int b = 0; b < closeVertices.size(); ++b)
        {
            meshTang[ closeVertices[b] ] = smoothTangent;
            meshBitang[ closeVertices[b] ] = smoothBitangent;
        }
    }
    return true;
}

/***********************************************************************
FBXIMPORT\COMPUTEUVMAPPINGPROCESS.CPP
***********************************************************************/
/*
Open Asset Import Library (assimp)
----------------------------------------------------------------------

Copyright (c) 2006-2016, assimp team
All rights reserved.

Redistribution and use of this software in source and binary forms,
with or without modification, are permitted provided that the
following conditions are met:

* Redistributions of source code must retain the above
  copyright notice, this list of conditions and the
  following disclaimer.

* Redistributions in binary form must reproduce the above
  copyright notice, this list of conditions and the
  following disclaimer in the documentation and/or other
  materials provided with the distribution.

* Neither the name of the assimp team, nor the names of its
  contributors may be used to endorse or promote products
  derived from this software without specific prior
  written permission of the assimp team.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
"AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

----------------------------------------------------------------------
*/

/** @file GenUVCoords step */



using namespace Assimp;

namespace {

    const static aiVector3D base_axis_y(0.f,1.f,0.f);
    const static aiVector3D base_axis_x(1.f,0.f,0.f);
    const static aiVector3D base_axis_z(0.f,0.f,1.f);
    const static float angle_epsilon = 0.95f;
}

// ------------------------------------------------------------------------------------------------
// Constructor to be privately used by Importer
ComputeUVMappingProcess::ComputeUVMappingProcess()
{
    // nothing to do here
}

// ------------------------------------------------------------------------------------------------
// Destructor, private as well
ComputeUVMappingProcess::~ComputeUVMappingProcess()
{
    // nothing to do here
}

// ------------------------------------------------------------------------------------------------
// Returns whether the processing step is present in the given flag field.
bool ComputeUVMappingProcess::IsActive( unsigned int pFlags) const
{
    return  (pFlags & aiProcess_GenUVCoords) != 0;
}

// ------------------------------------------------------------------------------------------------
// Check whether a ray intersects a plane and find the intersection point
inline bool PlaneIntersect(const aiRay& ray, const aiVector3D& planePos,
    const aiVector3D& planeNormal, aiVector3D& pos)
{
    const float b = planeNormal * (planePos - ray.pos);
    float h = ray.dir * planeNormal;
    if ((h < 10e-5f && h > -10e-5f) || (h = b/h) < 0)
        return false;

    pos = ray.pos + (ray.dir * h);
    return true;
}

// ------------------------------------------------------------------------------------------------
// Find the first empty UV channel in a mesh
inline unsigned int FindEmptyUVChannel (aiMesh* mesh)
{
    for (unsigned int m = 0; m < AI_MAX_NUMBER_OF_TEXTURECOORDS;++m)
        if (!mesh->mTextureCoords[m])return m;

    DefaultLogger::get()->error("Unable to compute UV coordinates, no free UV slot found");
    return UINT_MAX;
}

// ------------------------------------------------------------------------------------------------
// Try to remove UV seams
void RemoveUVSeams (aiMesh* mesh, aiVector3D* out)
{
    // TODO: just a very rough algorithm. I think it could be done
    // much easier, but I don't know how and am currently too tired to
    // to think about a better solution.

    const static float LOWER_LIMIT = 0.1f;
    const static float UPPER_LIMIT = 0.9f;

    const static float LOWER_EPSILON = 10e-3f;
    const static float UPPER_EPSILON = 1.f-10e-3f;

    for (unsigned int fidx = 0; fidx < mesh->mNumFaces;++fidx)
    {
        const aiFace& face = mesh->mFaces[fidx];
        if (face.mNumIndices < 3) continue; // triangles and polygons only, please

        unsigned int small = face.mNumIndices, large = small;
        bool zero = false, one = false, round_to_zero = false;

        // Check whether this face lies on a UV seam. We can just guess,
        // but the assumption that a face with at least one very small
        // on the one side and one very large U coord on the other side
        // lies on a UV seam should work for most cases.
        for (unsigned int n = 0; n < face.mNumIndices;++n)
        {
            if (out[face.mIndices[n]].x < LOWER_LIMIT)
            {
                small = n;

                // If we have a U value very close to 0 we can't
                // round the others to 0, too.
                if (out[face.mIndices[n]].x <= LOWER_EPSILON)
                    zero = true;
                else round_to_zero = true;
            }
            if (out[face.mIndices[n]].x > UPPER_LIMIT)
            {
                large = n;

                // If we have a U value very close to 1 we can't
                // round the others to 1, too.
                if (out[face.mIndices[n]].x >= UPPER_EPSILON)
                    one = true;
            }
        }
        if (small != face.mNumIndices && large != face.mNumIndices)
        {
            for (unsigned int n = 0; n < face.mNumIndices;++n)
            {
                // If the u value is over the upper limit and no other u
                // value of that face is 0, round it to 0
                if (out[face.mIndices[n]].x > UPPER_LIMIT && !zero)
                    out[face.mIndices[n]].x = 0.f;

                // If the u value is below the lower limit and no other u
                // value of that face is 1, round it to 1
                else if (out[face.mIndices[n]].x < LOWER_LIMIT && !one)
                    out[face.mIndices[n]].x = 1.f;

                // The face contains both 0 and 1 as UV coords. This can occur
                // for faces which have an edge that lies directly on the seam.
                // Due to numerical inaccuracies one U coord becomes 0, the
                // other 1. But we do still have a third UV coord to determine
                // to which side we must round to.
                else if (one && zero)
                {
                    if (round_to_zero && out[face.mIndices[n]].x >=  UPPER_EPSILON)
                        out[face.mIndices[n]].x = 0.f;
                    else if (!round_to_zero && out[face.mIndices[n]].x <= LOWER_EPSILON)
                        out[face.mIndices[n]].x = 1.f;
                }
            }
        }
    }
}

// ------------------------------------------------------------------------------------------------
void ComputeUVMappingProcess::ComputeSphereMapping(aiMesh* mesh,const aiVector3D& axis, aiVector3D* out)
{
    aiVector3D center, min, max;
    FindMeshCenter(mesh, center, min, max);

    // If the axis is one of x,y,z run a faster code path. It's worth the extra effort ...
    // currently the mapping axis will always be one of x,y,z, except if the
    // PretransformVertices step is used (it transforms the meshes into worldspace,
    // thus changing the mapping axis)
    if (axis * base_axis_x >= angle_epsilon)    {

        // For each point get a normalized projection vector in the sphere,
        // get its longitude and latitude and map them to their respective
        // UV axes. Problems occur around the poles ... unsolvable.
        //
        // The spherical coordinate system looks like this:
        // x = cos(lon)*cos(lat)
        // y = sin(lon)*cos(lat)
        // z = sin(lat)
        //
        // Thus we can derive:
        // lat  = arcsin (z)
        // lon  = arctan (y/x)
        for (unsigned int pnt = 0; pnt < mesh->mNumVertices;++pnt)  {
            const aiVector3D diff = (mesh->mVertices[pnt]-center).Normalize();
            out[pnt] = aiVector3D((atan2 (diff.z, diff.y) + AI_MATH_PI_F ) / AI_MATH_TWO_PI_F,
                (std::asin  (diff.x) + AI_MATH_HALF_PI_F) / AI_MATH_PI_F, 0.f);
        }
    }
    else if (axis * base_axis_y >= angle_epsilon)   {
        // ... just the same again
        for (unsigned int pnt = 0; pnt < mesh->mNumVertices;++pnt)  {
            const aiVector3D diff = (mesh->mVertices[pnt]-center).Normalize();
            out[pnt] = aiVector3D((atan2 (diff.x, diff.z) + AI_MATH_PI_F ) / AI_MATH_TWO_PI_F,
                (std::asin  (diff.y) + AI_MATH_HALF_PI_F) / AI_MATH_PI_F, 0.f);
        }
    }
    else if (axis * base_axis_z >= angle_epsilon)   {
        // ... just the same again
        for (unsigned int pnt = 0; pnt < mesh->mNumVertices;++pnt)  {
            const aiVector3D diff = (mesh->mVertices[pnt]-center).Normalize();
            out[pnt] = aiVector3D((atan2 (diff.y, diff.x) + AI_MATH_PI_F ) / AI_MATH_TWO_PI_F,
                (std::asin  (diff.z) + AI_MATH_HALF_PI_F) / AI_MATH_PI_F, 0.f);
        }
    }
    // slower code path in case the mapping axis is not one of the coordinate system axes
    else    {
        aiMatrix4x4 mTrafo;
        aiMatrix4x4::FromToMatrix(axis,base_axis_y,mTrafo);

        // again the same, except we're applying a transformation now
        for (unsigned int pnt = 0; pnt < mesh->mNumVertices;++pnt)  {
            const aiVector3D diff = ((mTrafo*mesh->mVertices[pnt])-center).Normalize();
            out[pnt] = aiVector3D((atan2 (diff.y, diff.x) + AI_MATH_PI_F ) / AI_MATH_TWO_PI_F,
                (asin  (diff.z) + AI_MATH_HALF_PI_F) / AI_MATH_PI_F, 0.f);
        }
    }


    // Now find and remove UV seams. A seam occurs if a face has a tcoord
    // close to zero on the one side, and a tcoord close to one on the
    // other side.
    RemoveUVSeams(mesh,out);
}

// ------------------------------------------------------------------------------------------------
void ComputeUVMappingProcess::ComputeCylinderMapping(aiMesh* mesh,const aiVector3D& axis, aiVector3D* out)
{
    aiVector3D center, min, max;

    // If the axis is one of x,y,z run a faster code path. It's worth the extra effort ...
    // currently the mapping axis will always be one of x,y,z, except if the
    // PretransformVertices step is used (it transforms the meshes into worldspace,
    // thus changing the mapping axis)
    if (axis * base_axis_x >= angle_epsilon)    {
        FindMeshCenter(mesh, center, min, max);
        const float diff = max.x - min.x;

        // If the main axis is 'z', the z coordinate of a point 'p' is mapped
        // directly to the texture V axis. The other axis is derived from
        // the angle between ( p.x - c.x, p.y - c.y ) and (1,0), where
        // 'c' is the center point of the mesh.
        for (unsigned int pnt = 0; pnt < mesh->mNumVertices;++pnt)  {
            const aiVector3D& pos = mesh->mVertices[pnt];
            aiVector3D& uv  = out[pnt];

            uv.y = (pos.x - min.x) / diff;
            uv.x = (atan2 ( pos.z - center.z, pos.y - center.y) +(float)AI_MATH_PI ) / (float)AI_MATH_TWO_PI;
        }
    }
    else if (axis * base_axis_y >= angle_epsilon)   {
        FindMeshCenter(mesh, center, min, max);
        const float diff = max.y - min.y;

        // just the same ...
        for (unsigned int pnt = 0; pnt < mesh->mNumVertices;++pnt)  {
            const aiVector3D& pos = mesh->mVertices[pnt];
            aiVector3D& uv  = out[pnt];

            uv.y = (pos.y - min.y) / diff;
            uv.x = (atan2 ( pos.x - center.x, pos.z - center.z) +(float)AI_MATH_PI ) / (float)AI_MATH_TWO_PI;
        }
    }
    else if (axis * base_axis_z >= angle_epsilon)   {
        FindMeshCenter(mesh, center, min, max);
        const float diff = max.z - min.z;

        // just the same ...
        for (unsigned int pnt = 0; pnt < mesh->mNumVertices;++pnt)  {
            const aiVector3D& pos = mesh->mVertices[pnt];
            aiVector3D& uv  = out[pnt];

            uv.y = (pos.z - min.z) / diff;
            uv.x = (atan2 ( pos.y - center.y, pos.x - center.x) +(float)AI_MATH_PI ) / (float)AI_MATH_TWO_PI;
        }
    }
    // slower code path in case the mapping axis is not one of the coordinate system axes
    else {
        aiMatrix4x4 mTrafo;
        aiMatrix4x4::FromToMatrix(axis,base_axis_y,mTrafo);
        FindMeshCenterTransformed(mesh, center, min, max,mTrafo);
        const float diff = max.y - min.y;

        // again the same, except we're applying a transformation now
        for (unsigned int pnt = 0; pnt < mesh->mNumVertices;++pnt){
            const aiVector3D pos = mTrafo* mesh->mVertices[pnt];
            aiVector3D& uv  = out[pnt];

            uv.y = (pos.y - min.y) / diff;
            uv.x = (atan2 ( pos.x - center.x, pos.z - center.z) +(float)AI_MATH_PI ) / (float)AI_MATH_TWO_PI;
        }
    }

    // Now find and remove UV seams. A seam occurs if a face has a tcoord
    // close to zero on the one side, and a tcoord close to one on the
    // other side.
    RemoveUVSeams(mesh,out);
}

// ------------------------------------------------------------------------------------------------
void ComputeUVMappingProcess::ComputePlaneMapping(aiMesh* mesh,const aiVector3D& axis, aiVector3D* out)
{
    float diffu,diffv;
    aiVector3D center, min, max;

    // If the axis is one of x,y,z run a faster code path. It's worth the extra effort ...
    // currently the mapping axis will always be one of x,y,z, except if the
    // PretransformVertices step is used (it transforms the meshes into worldspace,
    // thus changing the mapping axis)
    if (axis * base_axis_x >= angle_epsilon)    {
        FindMeshCenter(mesh, center, min, max);
        diffu = max.z - min.z;
        diffv = max.y - min.y;

        for (unsigned int pnt = 0; pnt < mesh->mNumVertices;++pnt)  {
            const aiVector3D& pos = mesh->mVertices[pnt];
            out[pnt].Set((pos.z - min.z) / diffu,(pos.y - min.y) / diffv,0.f);
        }
    }
    else if (axis * base_axis_y >= angle_epsilon)   {
        FindMeshCenter(mesh, center, min, max);
        diffu = max.x - min.x;
        diffv = max.z - min.z;

        for (unsigned int pnt = 0; pnt < mesh->mNumVertices;++pnt)  {
            const aiVector3D& pos = mesh->mVertices[pnt];
            out[pnt].Set((pos.x - min.x) / diffu,(pos.z - min.z) / diffv,0.f);
        }
    }
    else if (axis * base_axis_z >= angle_epsilon)   {
        FindMeshCenter(mesh, center, min, max);
        diffu = max.y - min.y;
        diffv = max.z - min.z;

        for (unsigned int pnt = 0; pnt < mesh->mNumVertices;++pnt)  {
            const aiVector3D& pos = mesh->mVertices[pnt];
            out[pnt].Set((pos.y - min.y) / diffu,(pos.x - min.x) / diffv,0.f);
        }
    }
    // slower code path in case the mapping axis is not one of the coordinate system axes
    else
    {
        aiMatrix4x4 mTrafo;
        aiMatrix4x4::FromToMatrix(axis,base_axis_y,mTrafo);
        FindMeshCenterTransformed(mesh, center, min, max,mTrafo);
        diffu = max.x - min.x;
        diffv = max.z - min.z;

        // again the same, except we're applying a transformation now
        for (unsigned int pnt = 0; pnt < mesh->mNumVertices;++pnt)  {
            const aiVector3D pos = mTrafo * mesh->mVertices[pnt];
            out[pnt].Set((pos.x - min.x) / diffu,(pos.z - min.z) / diffv,0.f);
        }
    }

    // shouldn't be necessary to remove UV seams ...
}

// ------------------------------------------------------------------------------------------------
void ComputeUVMappingProcess::ComputeBoxMapping( aiMesh*, aiVector3D* )
{
    DefaultLogger::get()->error("Mapping type currently not implemented");
}

// ------------------------------------------------------------------------------------------------
void ComputeUVMappingProcess::Execute( aiScene* pScene)
{
    DefaultLogger::get()->debug("GenUVCoordsProcess begin");
    char buffer[1024];

    if (pScene->mFlags & AI_SCENE_FLAGS_NON_VERBOSE_FORMAT)
        throw DeadlyImportError("Post-processing order mismatch: expecting pseudo-indexed (\"verbose\") vertices here");

    std::list<MappingInfo> mappingStack;

    /*  Iterate through all materials and search for non-UV mapped textures
     */
    for (unsigned int i = 0; i < pScene->mNumMaterials;++i)
    {
        mappingStack.clear();
        aiMaterial* mat = pScene->mMaterials[i];
        for (unsigned int a = 0; a < mat->mNumProperties;++a)
        {
            aiMaterialProperty* prop = mat->mProperties[a];
            if (!::strcmp( prop->mKey.data, "$tex.mapping"))
            {
                aiTextureMapping& mapping = *((aiTextureMapping*)prop->mData);
                if (aiTextureMapping_UV != mapping)
                {
                    if (!DefaultLogger::isNullLogger())
                    {
                        ai_snprintf(buffer, 1024, "Found non-UV mapped texture (%s,%u). Mapping type: %s",
                            TextureTypeToString((aiTextureType)prop->mSemantic),prop->mIndex,
                            MappingTypeToString(mapping));

                        DefaultLogger::get()->info(buffer);
                    }

                    if (aiTextureMapping_OTHER == mapping)
                        continue;

                    MappingInfo info (mapping);

                    // Get further properties - currently only the major axis
                    for (unsigned int a2 = 0; a2 < mat->mNumProperties;++a2)
                    {
                        aiMaterialProperty* prop2 = mat->mProperties[a2];
                        if (prop2->mSemantic != prop->mSemantic || prop2->mIndex != prop->mIndex)
                            continue;

                        if ( !::strcmp( prop2->mKey.data, "$tex.mapaxis"))  {
                            info.axis = *((aiVector3D*)prop2->mData);
                            break;
                        }
                    }

                    unsigned int idx;

                    // Check whether we have this mapping mode already
                    std::list<MappingInfo>::iterator it = std::find (mappingStack.begin(),mappingStack.end(), info);
                    if (mappingStack.end() != it)
                    {
                        idx = (*it).uv;
                    }
                    else
                    {
                        /*  We have found a non-UV mapped texture. Now
                        *   we need to find all meshes using this material
                        *   that we can compute UV channels for them.
                        */
                        for (unsigned int m = 0; m < pScene->mNumMeshes;++m)
                        {
                            aiMesh* mesh = pScene->mMeshes[m];
                            unsigned int outIdx = 0;
                            if ( mesh->mMaterialIndex != i || ( outIdx = FindEmptyUVChannel(mesh) ) == UINT_MAX ||
                                !mesh->mNumVertices)
                            {
                                continue;
                            }

                            // Allocate output storage
                            aiVector3D* p = mesh->mTextureCoords[outIdx] = new aiVector3D[mesh->mNumVertices];

                            switch (mapping)
                            {
                            case aiTextureMapping_SPHERE:
                                ComputeSphereMapping(mesh,info.axis,p);
                                break;
                            case aiTextureMapping_CYLINDER:
                                ComputeCylinderMapping(mesh,info.axis,p);
                                break;
                            case aiTextureMapping_PLANE:
                                ComputePlaneMapping(mesh,info.axis,p);
                                break;
                            case aiTextureMapping_BOX:
                                ComputeBoxMapping(mesh,p);
                                break;
                            default:
                                ai_assert(false);
                            }
                            if (m && idx != outIdx)
                            {
                                DefaultLogger::get()->warn("UV index mismatch. Not all meshes assigned to "
                                    "this material have equal numbers of UV channels. The UV index stored in  "
                                    "the material structure does therefore not apply for all meshes. ");
                            }
                            idx = outIdx;
                        }
                        info.uv = idx;
                        mappingStack.push_back(info);
                    }

                    // Update the material property list
                    mapping = aiTextureMapping_UV;
                    ((aiMaterial*)mat)->AddProperty(&idx,1,AI_MATKEY_UVWSRC(prop->mSemantic,prop->mIndex));
                }
            }
        }
    }
    DefaultLogger::get()->debug("GenUVCoordsProcess finished");
}

/***********************************************************************
FBXIMPORT\CONVERTTOLHPROCESS.CPP
***********************************************************************/
/*
---------------------------------------------------------------------------
Open Asset Import Library (assimp)
---------------------------------------------------------------------------

Copyright (c) 2006-2016, assimp team

All rights reserved.

Redistribution and use of this software in source and binary forms,
with or without modification, are permitted provided that the following
conditions are met:

* Redistributions of source code must retain the above
  copyright notice, this list of conditions and the
  following disclaimer.

* Redistributions in binary form must reproduce the above
  copyright notice, this list of conditions and the
  following disclaimer in the documentation and/or other
  materials provided with the distribution.

* Neither the name of the assimp team, nor the names of its
  contributors may be used to endorse or promote products
  derived from this software without specific prior
  written permission of the assimp team.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
"AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
---------------------------------------------------------------------------
*/

/** @file  MakeLeftHandedProcess.cpp
 *  @brief Implementation of the post processing step to convert all
 *  imported data to a left-handed coordinate system.
 *
 *  Face order & UV flip are also implemented here, for the sake of a
 *  better location.
 */



using namespace Assimp;

#ifndef ASSIMP_BUILD_NO_MAKELEFTHANDED_PROCESS

// ------------------------------------------------------------------------------------------------
// Constructor to be privately used by Importer
MakeLeftHandedProcess::MakeLeftHandedProcess()
: BaseProcess() {
    // empty
}

// ------------------------------------------------------------------------------------------------
// Destructor, private as well
MakeLeftHandedProcess::~MakeLeftHandedProcess() {
    // empty
}

// ------------------------------------------------------------------------------------------------
// Returns whether the processing step is present in the given flag field.
bool MakeLeftHandedProcess::IsActive( unsigned int pFlags) const
{
    return 0 != (pFlags & aiProcess_MakeLeftHanded);
}

// ------------------------------------------------------------------------------------------------
// Executes the post processing step on the given imported data.
void MakeLeftHandedProcess::Execute( aiScene* pScene)
{
    // Check for an existent root node to proceed
    ai_assert(pScene->mRootNode != NULL);
    DefaultLogger::get()->debug("MakeLeftHandedProcess begin");

    // recursively convert all the nodes
    ProcessNode( pScene->mRootNode, aiMatrix4x4());

    // process the meshes accordingly
    for( unsigned int a = 0; a < pScene->mNumMeshes; ++a)
        ProcessMesh( pScene->mMeshes[a]);

    // process the materials accordingly
    for( unsigned int a = 0; a < pScene->mNumMaterials; ++a)
        ProcessMaterial( pScene->mMaterials[a]);

    // transform all animation channels as well
    for( unsigned int a = 0; a < pScene->mNumAnimations; a++)
    {
        aiAnimation* anim = pScene->mAnimations[a];
        for( unsigned int b = 0; b < anim->mNumChannels; b++)
        {
            aiNodeAnim* nodeAnim = anim->mChannels[b];
            ProcessAnimation( nodeAnim);
        }
    }
    DefaultLogger::get()->debug("MakeLeftHandedProcess finished");
}

// ------------------------------------------------------------------------------------------------
// Recursively converts a node, all of its children and all of its meshes
void MakeLeftHandedProcess::ProcessNode( aiNode* pNode, const aiMatrix4x4& pParentGlobalRotation)
{
    // mirror all base vectors at the local Z axis
    pNode->mTransformation.c1 = -pNode->mTransformation.c1;
    pNode->mTransformation.c2 = -pNode->mTransformation.c2;
    pNode->mTransformation.c3 = -pNode->mTransformation.c3;
    pNode->mTransformation.c4 = -pNode->mTransformation.c4;

    // now invert the Z axis again to keep the matrix determinant positive.
    // The local meshes will be inverted accordingly so that the result should look just fine again.
    pNode->mTransformation.a3 = -pNode->mTransformation.a3;
    pNode->mTransformation.b3 = -pNode->mTransformation.b3;
    pNode->mTransformation.c3 = -pNode->mTransformation.c3;
    pNode->mTransformation.d3 = -pNode->mTransformation.d3; // useless, but anyways...

    // continue for all children
    for( size_t a = 0; a < pNode->mNumChildren; ++a ) {
        ProcessNode( pNode->mChildren[ a ], pParentGlobalRotation * pNode->mTransformation );
    }
}

// ------------------------------------------------------------------------------------------------
// Converts a single mesh to left handed coordinates.
void MakeLeftHandedProcess::ProcessMesh( aiMesh* pMesh)
{
    // mirror positions, normals and stuff along the Z axis
    for( size_t a = 0; a < pMesh->mNumVertices; ++a)
    {
        pMesh->mVertices[a].z *= -1.0f;
        if( pMesh->HasNormals())
            pMesh->mNormals[a].z *= -1.0f;
        if( pMesh->HasTangentsAndBitangents())
        {
            pMesh->mTangents[a].z *= -1.0f;
            pMesh->mBitangents[a].z *= -1.0f;
        }
    }

    // mirror offset matrices of all bones
    for( size_t a = 0; a < pMesh->mNumBones; ++a)
    {
        aiBone* bone = pMesh->mBones[a];
        bone->mOffsetMatrix.a3 = -bone->mOffsetMatrix.a3;
        bone->mOffsetMatrix.b3 = -bone->mOffsetMatrix.b3;
        bone->mOffsetMatrix.d3 = -bone->mOffsetMatrix.d3;
        bone->mOffsetMatrix.c1 = -bone->mOffsetMatrix.c1;
        bone->mOffsetMatrix.c2 = -bone->mOffsetMatrix.c2;
        bone->mOffsetMatrix.c4 = -bone->mOffsetMatrix.c4;
    }

    // mirror bitangents as well as they're derived from the texture coords
    if( pMesh->HasTangentsAndBitangents())
    {
        for( unsigned int a = 0; a < pMesh->mNumVertices; a++)
            pMesh->mBitangents[a] *= -1.0f;
    }
}

// ------------------------------------------------------------------------------------------------
// Converts a single material to left handed coordinates.
void MakeLeftHandedProcess::ProcessMaterial( aiMaterial* _mat)
{
    aiMaterial* mat = (aiMaterial*)_mat;
    for (unsigned int a = 0; a < mat->mNumProperties;++a)   {
        aiMaterialProperty* prop = mat->mProperties[a];

        // Mapping axis for UV mappings?
        if (!::strcmp( prop->mKey.data, "$tex.mapaxis"))    {
            ai_assert( prop->mDataLength >= sizeof(aiVector3D)); /* something is wrong with the validation if we end up here */
            aiVector3D* pff = (aiVector3D*)prop->mData;

            pff->z *= -1.f;
        }
    }
}

// ------------------------------------------------------------------------------------------------
// Converts the given animation to LH coordinates.
void MakeLeftHandedProcess::ProcessAnimation( aiNodeAnim* pAnim)
{
    // position keys
    for( unsigned int a = 0; a < pAnim->mNumPositionKeys; a++)
        pAnim->mPositionKeys[a].mValue.z *= -1.0f;

    // rotation keys
    for( unsigned int a = 0; a < pAnim->mNumRotationKeys; a++)
    {
        /* That's the safe version, but the float errors add up. So we try the short version instead
        aiMatrix3x3 rotmat = pAnim->mRotationKeys[a].mValue.GetMatrix();
        rotmat.a3 = -rotmat.a3; rotmat.b3 = -rotmat.b3;
        rotmat.c1 = -rotmat.c1; rotmat.c2 = -rotmat.c2;
        aiQuaternion rotquat( rotmat);
        pAnim->mRotationKeys[a].mValue = rotquat;
        */
        pAnim->mRotationKeys[a].mValue.x *= -1.0f;
        pAnim->mRotationKeys[a].mValue.y *= -1.0f;
    }
}

#endif // !!  ASSIMP_BUILD_NO_MAKELEFTHANDED_PROCESS
#ifndef  ASSIMP_BUILD_NO_FLIPUVS_PROCESS
// # FlipUVsProcess

// ------------------------------------------------------------------------------------------------
// Constructor to be privately used by Importer
FlipUVsProcess::FlipUVsProcess()
{}

// ------------------------------------------------------------------------------------------------
// Destructor, private as well
FlipUVsProcess::~FlipUVsProcess()
{}

// ------------------------------------------------------------------------------------------------
// Returns whether the processing step is present in the given flag field.
bool FlipUVsProcess::IsActive( unsigned int pFlags) const
{
    return 0 != (pFlags & aiProcess_FlipUVs);
}

// ------------------------------------------------------------------------------------------------
// Executes the post processing step on the given imported data.
void FlipUVsProcess::Execute( aiScene* pScene)
{
    DefaultLogger::get()->debug("FlipUVsProcess begin");
    for (unsigned int i = 0; i < pScene->mNumMeshes;++i)
        ProcessMesh(pScene->mMeshes[i]);

    for (unsigned int i = 0; i < pScene->mNumMaterials;++i)
        ProcessMaterial(pScene->mMaterials[i]);
    DefaultLogger::get()->debug("FlipUVsProcess finished");
}

// ------------------------------------------------------------------------------------------------
// Converts a single material
void FlipUVsProcess::ProcessMaterial (aiMaterial* _mat)
{
    aiMaterial* mat = (aiMaterial*)_mat;
    for (unsigned int a = 0; a < mat->mNumProperties;++a)   {
        aiMaterialProperty* prop = mat->mProperties[a];
        if( !prop ) {
            DefaultLogger::get()->debug( "Property is null" );
            continue;
        }

        // UV transformation key?
        if (!::strcmp( prop->mKey.data, "$tex.uvtrafo"))    {
            ai_assert( prop->mDataLength >= sizeof(aiUVTransform));  /* something is wrong with the validation if we end up here */
            aiUVTransform* uv = (aiUVTransform*)prop->mData;

            // just flip it, that's everything
            uv->mTranslation.y *= -1.f;
            uv->mRotation *= -1.f;
        }
    }
}

// ------------------------------------------------------------------------------------------------
// Converts a single mesh
void FlipUVsProcess::ProcessMesh( aiMesh* pMesh)
{
    // mirror texture y coordinate
    for( unsigned int a = 0; a < AI_MAX_NUMBER_OF_TEXTURECOORDS; a++)   {
        if( !pMesh->HasTextureCoords( a ) ) {
            break;
        }

        for( unsigned int b = 0; b < pMesh->mNumVertices; b++ ) {
            pMesh->mTextureCoords[ a ][ b ].y = 1.0f - pMesh->mTextureCoords[ a ][ b ].y;
        }
    }
}

#endif // !ASSIMP_BUILD_NO_FLIPUVS_PROCESS
#ifndef  ASSIMP_BUILD_NO_FLIPWINDING_PROCESS
// # FlipWindingOrderProcess

// ------------------------------------------------------------------------------------------------
// Constructor to be privately used by Importer
FlipWindingOrderProcess::FlipWindingOrderProcess()
{}

// ------------------------------------------------------------------------------------------------
// Destructor, private as well
FlipWindingOrderProcess::~FlipWindingOrderProcess()
{}

// ------------------------------------------------------------------------------------------------
// Returns whether the processing step is present in the given flag field.
bool FlipWindingOrderProcess::IsActive( unsigned int pFlags) const
{
    return 0 != (pFlags & aiProcess_FlipWindingOrder);
}

// ------------------------------------------------------------------------------------------------
// Executes the post processing step on the given imported data.
void FlipWindingOrderProcess::Execute( aiScene* pScene)
{
    DefaultLogger::get()->debug("FlipWindingOrderProcess begin");
    for (unsigned int i = 0; i < pScene->mNumMeshes;++i)
        ProcessMesh(pScene->mMeshes[i]);
    DefaultLogger::get()->debug("FlipWindingOrderProcess finished");
}

// ------------------------------------------------------------------------------------------------
// Converts a single mesh
void FlipWindingOrderProcess::ProcessMesh( aiMesh* pMesh)
{
    // invert the order of all faces in this mesh
    for( unsigned int a = 0; a < pMesh->mNumFaces; a++)
    {
        aiFace& face = pMesh->mFaces[a];
        for( unsigned int b = 0; b < face.mNumIndices / 2; b++)
            std::swap( face.mIndices[b], face.mIndices[ face.mNumIndices - 1 - b]);
    }
}

#endif // !! ASSIMP_BUILD_NO_FLIPWINDING_PROCESS

/***********************************************************************
FBXIMPORT\DEBONEPROCESS.CPP
***********************************************************************/
/*
Open Asset Import Library (assimp)
----------------------------------------------------------------------

Copyright (c) 2006-2016, assimp team
All rights reserved.

Redistribution and use of this software in source and binary forms,
with or without modification, are permitted provided that the
following conditions are met:

* Redistributions of source code must retain the above
  copyright notice, this list of conditions and the
  following disclaimer.

* Redistributions in binary form must reproduce the above
  copyright notice, this list of conditions and the
  following disclaimer in the documentation and/or other
  materials provided with the distribution.

* Neither the name of the assimp team, nor the names of its
  contributors may be used to endorse or promote products
  derived from this software without specific prior
  written permission of the assimp team.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
"AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

----------------------------------------------------------------------
*/

/// @file DeboneProcess.cpp
/** Implementation of the DeboneProcess post processing step */



// internal headers of the post-processing framework


using namespace Assimp;

// ------------------------------------------------------------------------------------------------
// Constructor to be privately used by Importer
DeboneProcess::DeboneProcess()
{
    mNumBones = 0;
    mNumBonesCanDoWithout = 0;

    mThreshold = AI_DEBONE_THRESHOLD;
    mAllOrNone = false;
}

// ------------------------------------------------------------------------------------------------
// Destructor, private as well
DeboneProcess::~DeboneProcess()
{
    // nothing to do here
}

// ------------------------------------------------------------------------------------------------
// Returns whether the processing step is present in the given flag field.
bool DeboneProcess::IsActive( unsigned int pFlags) const
{
    return (pFlags & aiProcess_Debone) != 0;
}

// ------------------------------------------------------------------------------------------------
// Executes the post processing step on the given imported data.
void DeboneProcess::SetupProperties(const Importer* pImp)
{
    // get the current value of the property
    mAllOrNone = pImp->GetPropertyInteger(AI_CONFIG_PP_DB_ALL_OR_NONE,0)?true:false;
    mThreshold = pImp->GetPropertyFloat(AI_CONFIG_PP_DB_THRESHOLD,AI_DEBONE_THRESHOLD);
}

// ------------------------------------------------------------------------------------------------
// Executes the post processing step on the given imported data.
void DeboneProcess::Execute( aiScene* pScene)
{
    DefaultLogger::get()->debug("DeboneProcess begin");

    if(!pScene->mNumMeshes) {
        return;
    }

    std::vector<bool> splitList(pScene->mNumMeshes);
    for( unsigned int a = 0; a < pScene->mNumMeshes; a++) {
        splitList[a] = ConsiderMesh( pScene->mMeshes[a] );
    }

    int numSplits = 0;

    if(!!mNumBonesCanDoWithout && (!mAllOrNone||mNumBonesCanDoWithout==mNumBones))  {
        for(unsigned int a = 0; a < pScene->mNumMeshes; a++)    {
            if(splitList[a]) {
                numSplits++;
            }
        }
    }

    if(numSplits)   {
        // we need to do something. Let's go.
        //mSubMeshIndices.clear();                  // really needed?
        mSubMeshIndices.resize(pScene->mNumMeshes); // because we're doing it here anyway

        // build a new array of meshes for the scene
        std::vector<aiMesh*> meshes;

        for(unsigned int a=0;a<pScene->mNumMeshes;a++)
        {
            aiMesh* srcMesh = pScene->mMeshes[a];

            std::vector<std::pair<aiMesh*,const aiBone*> > newMeshes;

            if(splitList[a]) {
                SplitMesh(srcMesh,newMeshes);
            }

            // mesh was split
            if(!newMeshes.empty())  {
                unsigned int out = 0, in = srcMesh->mNumBones;

                // store new meshes and indices of the new meshes
                for(unsigned int b=0;b<newMeshes.size();b++)    {
                    const aiString *find = newMeshes[b].second?&newMeshes[b].second->mName:0;

                    aiNode *theNode = find?pScene->mRootNode->FindNode(*find):0;
                    std::pair<unsigned int,aiNode*> push_pair(meshes.size(),theNode);

                    mSubMeshIndices[a].push_back(push_pair);
                    meshes.push_back(newMeshes[b].first);

                    out+=newMeshes[b].first->mNumBones;
                }

                if(!DefaultLogger::isNullLogger()) {
                    char buffer[1024];
                    ::ai_snprintf(buffer,1024,"Removed %u bones. Input bones: %u. Output bones: %u",in-out,in,out);
                    DefaultLogger::get()->info(buffer);
                }

                // and destroy the source mesh. It should be completely contained inside the new submeshes
                delete srcMesh;
            }
            else    {
                // Mesh is kept unchanged - store it's new place in the mesh array
                mSubMeshIndices[a].push_back(std::pair<unsigned int,aiNode*>(meshes.size(),(aiNode*)0));
                meshes.push_back(srcMesh);
            }
        }

        // rebuild the scene's mesh array
        pScene->mNumMeshes = meshes.size();
        delete [] pScene->mMeshes;
        pScene->mMeshes = new aiMesh*[pScene->mNumMeshes];
        std::copy( meshes.begin(), meshes.end(), pScene->mMeshes);

        // recurse through all nodes and translate the node's mesh indices to fit the new mesh array
        UpdateNode( pScene->mRootNode);
    }

    DefaultLogger::get()->debug("DeboneProcess end");
}

// ------------------------------------------------------------------------------------------------
// Counts bones total/removable in a given mesh.
bool DeboneProcess::ConsiderMesh(const aiMesh* pMesh)
{
    if(!pMesh->HasBones()) {
        return false;
    }

    bool split = false;

    //interstitial faces not permitted
    bool isInterstitialRequired = false;

    std::vector<bool> isBoneNecessary(pMesh->mNumBones,false);
    std::vector<unsigned int> vertexBones(pMesh->mNumVertices,UINT_MAX);

    const unsigned int cUnowned = UINT_MAX;
    const unsigned int cCoowned = UINT_MAX-1;

    for(unsigned int i=0;i<pMesh->mNumBones;i++)    {
        for(unsigned int j=0;j<pMesh->mBones[i]->mNumWeights;j++)   {
            float w = pMesh->mBones[i]->mWeights[j].mWeight;

            if(w==0.0f) {
                continue;
            }

            unsigned int vid = pMesh->mBones[i]->mWeights[j].mVertexId;
            if(w>=mThreshold)   {

                if(vertexBones[vid]!=cUnowned)  {
                    if(vertexBones[vid]==i) //double entry
                    {
                        DefaultLogger::get()->warn("Encountered double entry in bone weights");
                    }
                    else //TODO: track attraction in order to break tie
                    {
                        vertexBones[vid] = cCoowned;
                    }
                }
                else vertexBones[vid] = i;
            }

            if(!isBoneNecessary[i]) {
                isBoneNecessary[i] = w<mThreshold;
            }
        }

        if(!isBoneNecessary[i])  {
            isInterstitialRequired = true;
        }
    }

    if(isInterstitialRequired) {
        for(unsigned int i=0;i<pMesh->mNumFaces;i++) {
            unsigned int v = vertexBones[pMesh->mFaces[i].mIndices[0]];

            for(unsigned int j=1;j<pMesh->mFaces[i].mNumIndices;j++) {
                unsigned int w = vertexBones[pMesh->mFaces[i].mIndices[j]];

                if(v!=w)    {
                    if(v<pMesh->mNumBones) isBoneNecessary[v] = true;
                    if(w<pMesh->mNumBones) isBoneNecessary[w] = true;
                }
            }
        }
    }

    for(unsigned int i=0;i<pMesh->mNumBones;i++)    {
        if(!isBoneNecessary[i]) {
            mNumBonesCanDoWithout++;
            split = true;
        }

        mNumBones++;
    }
    return split;
}

// ------------------------------------------------------------------------------------------------
// Splits the given mesh by bone count.
void DeboneProcess::SplitMesh( const aiMesh* pMesh, std::vector< std::pair< aiMesh*,const aiBone* > >& poNewMeshes) const
{
    // same deal here as ConsiderMesh basically

    std::vector<bool> isBoneNecessary(pMesh->mNumBones,false);
    std::vector<unsigned int> vertexBones(pMesh->mNumVertices,UINT_MAX);

    const unsigned int cUnowned = UINT_MAX;
    const unsigned int cCoowned = UINT_MAX-1;

    for(unsigned int i=0;i<pMesh->mNumBones;i++)    {
        for(unsigned int j=0;j<pMesh->mBones[i]->mNumWeights;j++)   {
            float w = pMesh->mBones[i]->mWeights[j].mWeight;

            if(w==0.0f) {
                continue;
            }

            unsigned int vid = pMesh->mBones[i]->mWeights[j].mVertexId;

            if(w>=mThreshold) {
                if(vertexBones[vid]!=cUnowned)  {
                    if(vertexBones[vid]==i) //double entry
                    {
                        //DefaultLogger::get()->warn("Encountered double entry in bone weights");
                    }
                    else //TODO: track attraction in order to break tie
                    {
                        vertexBones[vid] = cCoowned;
                    }
                }
                else vertexBones[vid] = i;
            }

            if(!isBoneNecessary[i]) {
                isBoneNecessary[i] = w<mThreshold;
            }
        }
    }

    unsigned int nFacesUnowned = 0;

    std::vector<unsigned int> faceBones(pMesh->mNumFaces,UINT_MAX);
    std::vector<unsigned int> facesPerBone(pMesh->mNumBones,0);

    for(unsigned int i=0;i<pMesh->mNumFaces;i++) {
        unsigned int nInterstitial = 1;

        unsigned int v = vertexBones[pMesh->mFaces[i].mIndices[0]];

        for(unsigned int j=1;j<pMesh->mFaces[i].mNumIndices;j++) {
            unsigned int w = vertexBones[pMesh->mFaces[i].mIndices[j]];

            if(v!=w)    {
                if(v<pMesh->mNumBones) isBoneNecessary[v] = true;
                if(w<pMesh->mNumBones) isBoneNecessary[w] = true;
            }
            else nInterstitial++;
        }

        if(v<pMesh->mNumBones &&nInterstitial==pMesh->mFaces[i].mNumIndices)    {
            faceBones[i] = v; //primitive belongs to bone #v
            facesPerBone[v]++;
        }
        else nFacesUnowned++;
    }

    // invalidate any "cojoined" faces
    for(unsigned int i=0;i<pMesh->mNumFaces;i++) {
        if(faceBones[i]<pMesh->mNumBones&&isBoneNecessary[faceBones[i]])
        {
            ai_assert(facesPerBone[faceBones[i]]>0);
            facesPerBone[faceBones[i]]--;

            nFacesUnowned++;
            faceBones[i] = cUnowned;
        }
    }

    if(nFacesUnowned) {
        std::vector<unsigned int> subFaces;

        for(unsigned int i=0;i<pMesh->mNumFaces;i++)    {
            if(faceBones[i]==cUnowned) {
                subFaces.push_back(i);
            }
        }

        aiMesh *baseMesh = MakeSubmesh(pMesh,subFaces,0);
        std::pair<aiMesh*,const aiBone*> push_pair(baseMesh,(const aiBone*)0);

        poNewMeshes.push_back(push_pair);
    }

    for(unsigned int i=0;i<pMesh->mNumBones;i++) {

        if(!isBoneNecessary[i]&&facesPerBone[i]>0)  {
            std::vector<unsigned int> subFaces;

            for(unsigned int j=0;j<pMesh->mNumFaces;j++)    {
                if(faceBones[j]==i) {
                    subFaces.push_back(j);
                }
            }

            unsigned int f = AI_SUBMESH_FLAGS_SANS_BONES;
            aiMesh *subMesh =MakeSubmesh(pMesh,subFaces,f);

            //Lifted from PretransformVertices.cpp
            ApplyTransform(subMesh,pMesh->mBones[i]->mOffsetMatrix);
            std::pair<aiMesh*,const aiBone*> push_pair(subMesh,pMesh->mBones[i]);

            poNewMeshes.push_back(push_pair);
        }
    }
}

// ------------------------------------------------------------------------------------------------
// Recursively updates the node's mesh list to account for the changed mesh list
void DeboneProcess::UpdateNode(aiNode* pNode) const
{
    // rebuild the node's mesh index list

    std::vector<unsigned int> newMeshList;

    // this will require two passes

    unsigned int m = pNode->mNumMeshes, n = mSubMeshIndices.size();

    // first pass, look for meshes which have not moved

    for(unsigned int a=0;a<m;a++)   {

        unsigned int srcIndex = pNode->mMeshes[a];
        const std::vector< std::pair< unsigned int,aiNode* > > &subMeshes = mSubMeshIndices[srcIndex];
        unsigned int nSubmeshes = subMeshes.size();

        for(unsigned int b=0;b<nSubmeshes;b++) {
            if(!subMeshes[b].second) {
                newMeshList.push_back(subMeshes[b].first);
            }
        }
    }

    // second pass, collect deboned meshes

    for(unsigned int a=0;a<n;a++)
    {
        const std::vector< std::pair< unsigned int,aiNode* > > &subMeshes = mSubMeshIndices[a];
        unsigned int nSubmeshes = subMeshes.size();

        for(unsigned int b=0;b<nSubmeshes;b++) {
            if(subMeshes[b].second == pNode)    {
                newMeshList.push_back(subMeshes[b].first);
            }
        }
    }

    if( pNode->mNumMeshes > 0 ) {
        delete [] pNode->mMeshes; pNode->mMeshes = NULL;
    }

    pNode->mNumMeshes = newMeshList.size();

    if(pNode->mNumMeshes)   {
        pNode->mMeshes = new unsigned int[pNode->mNumMeshes];
        std::copy( newMeshList.begin(), newMeshList.end(), pNode->mMeshes);
    }

    // do that also recursively for all children
    for( unsigned int a = 0; a < pNode->mNumChildren; ++a ) {
        UpdateNode( pNode->mChildren[a]);
    }
}

// ------------------------------------------------------------------------------------------------
// Apply the node transformation to a mesh
void DeboneProcess::ApplyTransform(aiMesh* mesh, const aiMatrix4x4& mat)const
{
    // Check whether we need to transform the coordinates at all
    if (!mat.IsIdentity()) {

        if (mesh->HasPositions()) {
            for (unsigned int i = 0; i < mesh->mNumVertices; ++i) {
                mesh->mVertices[i] = mat * mesh->mVertices[i];
            }
        }
        if (mesh->HasNormals() || mesh->HasTangentsAndBitangents()) {
            aiMatrix4x4 mWorldIT = mat;
            mWorldIT.Inverse().Transpose();

            // TODO: implement Inverse() for aiMatrix3x3
            aiMatrix3x3 m = aiMatrix3x3(mWorldIT);

            if (mesh->HasNormals()) {
                for (unsigned int i = 0; i < mesh->mNumVertices; ++i) {
                    mesh->mNormals[i] = (m * mesh->mNormals[i]).Normalize();
                }
            }
            if (mesh->HasTangentsAndBitangents()) {
                for (unsigned int i = 0; i < mesh->mNumVertices; ++i) {
                    mesh->mTangents[i]   = (m * mesh->mTangents[i]).Normalize();
                    mesh->mBitangents[i] = (m * mesh->mBitangents[i]).Normalize();
                }
            }
        }
    }
}

/***********************************************************************
FBXIMPORT\DEFAULTIOSTREAM.CPP
***********************************************************************/
/*
---------------------------------------------------------------------------
Open Asset Import Library (assimp)
---------------------------------------------------------------------------

Copyright (c) 2006-2016, assimp team

All rights reserved.

Redistribution and use of this software in source and binary forms,
with or without modification, are permitted provided that the following
conditions are met:

* Redistributions of source code must retain the above
  copyright notice, this list of conditions and the
  following disclaimer.

* Redistributions in binary form must reproduce the above
  copyright notice, this list of conditions and the
  following disclaimer in the documentation and/or other
  materials provided with the distribution.

* Neither the name of the assimp team, nor the names of its
  contributors may be used to endorse or promote products
  derived from this software without specific prior
  written permission of the assimp team.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
"AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
---------------------------------------------------------------------------
*/
/** @file  DefaultIOStream.cpp
 *  @brief Default File I/O implementation for #Importer
 */


#include <sys/stat.h>

using namespace Assimp;

// ----------------------------------------------------------------------------------
DefaultIOStream::~DefaultIOStream()
{
    if (mFile) {
        ::fclose(mFile);
    }
}

// ----------------------------------------------------------------------------------
size_t DefaultIOStream::Read(void* pvBuffer,
    size_t pSize,
    size_t pCount)
{
    ai_assert(NULL != pvBuffer && 0 != pSize && 0 != pCount);
    return (mFile ? ::fread(pvBuffer, pSize, pCount, mFile) : 0);
}

// ----------------------------------------------------------------------------------
size_t DefaultIOStream::Write(const void* pvBuffer,
    size_t pSize,
    size_t pCount)
{
    ai_assert(NULL != pvBuffer && 0 != pSize && 0 != pCount);
    return (mFile ? ::fwrite(pvBuffer, pSize, pCount, mFile) : 0);
}

// ----------------------------------------------------------------------------------
aiReturn DefaultIOStream::Seek(size_t pOffset,
     aiOrigin pOrigin)
{
    if (!mFile) {
        return AI_FAILURE;
    }

    // Just to check whether our enum maps one to one with the CRT constants
    static_assert(aiOrigin_CUR == SEEK_CUR &&
        aiOrigin_END == SEEK_END && aiOrigin_SET == SEEK_SET, "aiOrigin_CUR == SEEK_CUR && \
        aiOrigin_END == SEEK_END && aiOrigin_SET == SEEK_SET");

    // do the seek
    return (0 == ::fseek(mFile, (long)pOffset,(int)pOrigin) ? AI_SUCCESS : AI_FAILURE);
}

// ----------------------------------------------------------------------------------
size_t DefaultIOStream::Tell() const
{
    if (!mFile) {
        return 0;
    }
    return ::ftell(mFile);
}

// ----------------------------------------------------------------------------------
size_t DefaultIOStream::FileSize() const
{
    if (! mFile || mFilename.empty()) {
        return 0;
    }

    if (SIZE_MAX == cachedSize) {

        // Although fseek/ftell would allow us to reuse the exising file handle here,
        // it is generally unsafe because:
        //  - For binary streams, it is not technically well-defined
        //  - For text files the results are meaningless
        // That's why we use the safer variant fstat here.
        //
        // See here for details:
        // https://www.securecoding.cert.org/confluence/display/seccode/FIO19-C.+Do+not+use+fseek()+and+ftell()+to+compute+the+size+of+a+regular+file
#if defined _WIN32 && !defined __GNUC__
        struct __stat64 fileStat;
        int err = _stat64(  mFilename.c_str(), &fileStat );
        if (0 != err)
            return 0;
        cachedSize = (size_t) (fileStat.st_size);
#else
        struct stat fileStat;
        int err = stat(mFilename.c_str(), &fileStat );
        if (0 != err)
            return 0;
        cachedSize = (size_t) (fileStat.st_size);
#endif
    }
    return cachedSize;
}

// ----------------------------------------------------------------------------------
void DefaultIOStream::Flush()
{
    if (mFile) {
        ::fflush(mFile);
    }
}

// ----------------------------------------------------------------------------------

/***********************************************************************
FBXIMPORT\DEFAULTIOSYSTEM.CPP
***********************************************************************/
/*
---------------------------------------------------------------------------
Open Asset Import Library (assimp)
---------------------------------------------------------------------------

Copyright (c) 2006-2016, assimp team

All rights reserved.

Redistribution and use of this software in source and binary forms,
with or without modification, are permitted provided that the following
conditions are met:

* Redistributions of source code must retain the above
  copyright notice, this list of conditions and the
  following disclaimer.

* Redistributions in binary form must reproduce the above
  copyright notice, this list of conditions and the
  following disclaimer in the documentation and/or other
  materials provided with the distribution.

* Neither the name of the assimp team, nor the names of its
  contributors may be used to endorse or promote products
  derived from this software without specific prior
  written permission of the assimp team.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
"AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
---------------------------------------------------------------------------
*/
/** @file Default implementation of IOSystem using the standard C file functions */




#ifdef __unix__
#include <sys/param.h>
#endif

using namespace Assimp;

// ------------------------------------------------------------------------------------------------
// Constructor.
DefaultIOSystem::DefaultIOSystem()
{
    // nothing to do here
}

// ------------------------------------------------------------------------------------------------
// Destructor.
DefaultIOSystem::~DefaultIOSystem()
{
    // nothing to do here
}

// ------------------------------------------------------------------------------------------------
// Tests for the existence of a file at the given path.
bool DefaultIOSystem::Exists( const char* pFile) const
{
    FILE* file = ::fopen( pFile, "rb");
    if( !file)
        return false;

    ::fclose( file);
    return true;
}

// ------------------------------------------------------------------------------------------------
// Open a new file with a given path.
IOStream* DefaultIOSystem::Open( const char* strFile, const char* strMode)
{
    ai_assert(NULL != strFile);
    ai_assert(NULL != strMode);

    FILE* file = ::fopen( strFile, strMode);
    if( NULL == file)
        return NULL;

    return new DefaultIOStream(file, (std::string) strFile);
}

// ------------------------------------------------------------------------------------------------
// Closes the given file and releases all resources associated with it.
void DefaultIOSystem::Close( IOStream* pFile)
{
    delete pFile;
}

// ------------------------------------------------------------------------------------------------
// Returns the operation specific directory separator
char DefaultIOSystem::getOsSeparator() const
{
#ifndef _WIN32
    return '/';
#else
    return '\\';
#endif
}

// ------------------------------------------------------------------------------------------------
// IOSystem default implementation (ComparePaths isn't a pure virtual function)
bool IOSystem::ComparePaths (const char* one, const char* second) const
{
    return !ASSIMP_stricmp(one,second);
}

// maximum path length
// XXX http://insanecoding.blogspot.com/2007/11/pathmax-simply-isnt.html
#ifdef PATH_MAX
#   define PATHLIMIT PATH_MAX
#else
#   define PATHLIMIT 4096
#endif

// ------------------------------------------------------------------------------------------------
// Convert a relative path into an absolute path
inline void MakeAbsolutePath (const char* in, char* _out)
{
    ai_assert(in && _out);
    char* ret;
#if defined( _MSC_VER ) || defined( __MINGW32__ )
    ret = ::_fullpath( _out, in, PATHLIMIT );
#else
    // use realpath
    ret = realpath(in, _out);
#endif
    if(!ret) {
        // preserve the input path, maybe someone else is able to fix
        // the path before it is accessed (e.g. our file system filter)
        DefaultLogger::get()->warn("Invalid path: "+std::string(in));
        strcpy(_out,in);
    }
}

// ------------------------------------------------------------------------------------------------
// DefaultIOSystem's more specialized implementation
bool DefaultIOSystem::ComparePaths (const char* one, const char* second) const
{
    // chances are quite good both paths are formatted identically,
    // so we can hopefully return here already
    if( !ASSIMP_stricmp(one,second) )
        return true;

    char temp1[PATHLIMIT];
    char temp2[PATHLIMIT];

    MakeAbsolutePath (one, temp1);
    MakeAbsolutePath (second, temp2);

    return !ASSIMP_stricmp(temp1,temp2);
}

// ------------------------------------------------------------------------------------------------
std::string DefaultIOSystem::fileName( const std::string &path )
{
    std::string ret = path;
    std::size_t last = ret.find_last_of("\\/");
    if (last != std::string::npos) ret = ret.substr(last + 1);
    return ret;
}

// ------------------------------------------------------------------------------------------------
std::string DefaultIOSystem::completeBaseName( const std::string &path )
{
    std::string ret = fileName(path);
    std::size_t pos = ret.find_last_of('.');
    if(pos != ret.npos) ret = ret.substr(0, pos);
    return ret;
}

// ------------------------------------------------------------------------------------------------
std::string DefaultIOSystem::absolutePath( const std::string &path )
{
    std::string ret = path;
    std::size_t last = ret.find_last_of("\\/");
    if (last != std::string::npos) ret = ret.substr(0, last);
    return ret;
}

// ------------------------------------------------------------------------------------------------

#undef PATHLIMIT

/***********************************************************************
FBXIMPORT\DEFAULTLOGGER.CPP
***********************************************************************/
/*
---------------------------------------------------------------------------
Open Asset Import Library (assimp)
---------------------------------------------------------------------------

Copyright (c) 2006-2016, assimp team

All rights reserved.

Redistribution and use of this software in source and binary forms,
with or without modification, are permitted provided that the following
conditions are met:

* Redistributions of source code must retain the above
  copyright notice, this list of conditions and the
  following disclaimer.

* Redistributions in binary form must reproduce the above
  copyright notice, this list of conditions and the
  following disclaimer in the documentation and/or other
  materials provided with the distribution.

* Neither the name of the assimp team, nor the names of its
  contributors may be used to endorse or promote products
  derived from this software without specific prior
  written permission of the assimp team.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
"AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
---------------------------------------------------------------------------
*/

/** @file  DefaultLogger.cpp
 *  @brief Implementation of DefaultLogger (and Logger)
 */


// Default log streams
#include <iostream>

#ifndef ASSIMP_BUILD_SINGLETHREADED
#   include <thread>
#   include <mutex>

std::mutex loggerMutex;
#endif

namespace Assimp    {

// ----------------------------------------------------------------------------------
NullLogger DefaultLogger::s_pNullLogger;
Logger *DefaultLogger::m_pLogger = &DefaultLogger::s_pNullLogger;

static const unsigned int SeverityAll = Logger::Info | Logger::Err | Logger::Warn | Logger::Debugging;

// ----------------------------------------------------------------------------------
// Represents a log-stream + its error severity
struct LogStreamInfo
{
    unsigned int m_uiErrorSeverity;
    LogStream *m_pStream;

    // Constructor
    LogStreamInfo( unsigned int uiErrorSev, LogStream *pStream ) :
        m_uiErrorSeverity( uiErrorSev ),
        m_pStream( pStream )
    {
        // empty
    }

    // Destructor
    ~LogStreamInfo()
    {
        delete m_pStream;
    }
};

// ----------------------------------------------------------------------------------
// Construct a default log stream
LogStream* LogStream::createDefaultStream(aiDefaultLogStream    streams,
    const char* name /*= "AssimpLog.txt"*/,
    IOSystem* io            /*= NULL*/)
{
    switch (streams)
    {
        // This is a platform-specific feature
    case aiDefaultLogStream_DEBUGGER:
#ifdef WIN32
        return new Win32DebugLogStream();
#else
        return NULL;
#endif

        // Platform-independent default streams
    case aiDefaultLogStream_STDERR:
        return new StdOStreamLogStream(std::cerr);
    case aiDefaultLogStream_STDOUT:
        return new StdOStreamLogStream(std::cout);
    default:
        // We don't know this default log stream, so raise an assertion
        ai_assert(false);

    };

    // For compilers without dead code path detection
    return NULL;
}

// ----------------------------------------------------------------------------------
//  Creates the only singleton instance
Logger *DefaultLogger::create(const char* name /*= "AssimpLog.txt"*/,
    LogSeverity severity                       /*= NORMAL*/,
    unsigned int defStreams                    /*= aiDefaultLogStream_DEBUGGER | aiDefaultLogStream_FILE*/,
    IOSystem* io                               /*= NULL*/)
{
    // enter the mutex here to avoid concurrency problems
#ifndef ASSIMP_BUILD_SINGLETHREADED
    std::lock_guard<std::mutex> lock(loggerMutex);
#endif

    if (m_pLogger && !isNullLogger() )
        delete m_pLogger;

    m_pLogger = new DefaultLogger( severity );

    // Attach default log streams
    // Stream the log to the MSVC debugger?
    if (defStreams & aiDefaultLogStream_DEBUGGER)
        m_pLogger->attachStream( LogStream::createDefaultStream(aiDefaultLogStream_DEBUGGER));

    // Stream the log to COUT?
    if (defStreams & aiDefaultLogStream_STDOUT)
        m_pLogger->attachStream( LogStream::createDefaultStream(aiDefaultLogStream_STDOUT));

    // Stream the log to CERR?
    if (defStreams & aiDefaultLogStream_STDERR)
         m_pLogger->attachStream( LogStream::createDefaultStream(aiDefaultLogStream_STDERR));

    // Stream the log to a file
    if (defStreams & aiDefaultLogStream_FILE && name && *name)
        m_pLogger->attachStream( LogStream::createDefaultStream(aiDefaultLogStream_FILE,name,io));

    return m_pLogger;
}

// ----------------------------------------------------------------------------------
void Logger::debug(const char* message) {

    // SECURITY FIX: otherwise it's easy to produce overruns since
    // sometimes importers will include data from the input file
    // (i.e. node names) in their messages.
    if (strlen(message)>MAX_LOG_MESSAGE_LENGTH) {
        return;
    }
    return OnDebug(message);
}

// ----------------------------------------------------------------------------------
void Logger::info(const char* message)  {

    // SECURITY FIX: see above
    if (strlen(message)>MAX_LOG_MESSAGE_LENGTH) {
        return;
    }
    return OnInfo(message);
}

// ----------------------------------------------------------------------------------
void Logger::warn(const char* message)  {

    // SECURITY FIX: see above
    if (strlen(message)>MAX_LOG_MESSAGE_LENGTH) {
        return;
    }
    return OnWarn(message);
}

// ----------------------------------------------------------------------------------
void Logger::error(const char* message) {

    // SECURITY FIX: see above
    if (strlen(message)>MAX_LOG_MESSAGE_LENGTH) {
        return;
    }
    return OnError(message);
}

// ----------------------------------------------------------------------------------
void DefaultLogger::set( Logger *logger )
{
    // enter the mutex here to avoid concurrency problems
#ifndef ASSIMP_BUILD_SINGLETHREADED
    std::lock_guard<std::mutex> lock(loggerMutex);
#endif

    if (!logger)logger = &s_pNullLogger;
    if (m_pLogger && !isNullLogger() )
        delete m_pLogger;

    DefaultLogger::m_pLogger = logger;
}

// ----------------------------------------------------------------------------------
bool DefaultLogger::isNullLogger()
{
    return m_pLogger == &s_pNullLogger;
}

// ----------------------------------------------------------------------------------
Logger *DefaultLogger::get() {
    return m_pLogger;
}

// ----------------------------------------------------------------------------------
//  Kills the only instance
void DefaultLogger::kill()
{
    // enter the mutex here to avoid concurrency problems
#ifndef ASSIMP_BUILD_SINGLETHREADED
    std::lock_guard<std::mutex> lock(loggerMutex);
#endif

	if ( m_pLogger == &s_pNullLogger ) {
		return;
	}
    delete m_pLogger;
    m_pLogger = &s_pNullLogger;
}

// ----------------------------------------------------------------------------------
//  Debug message
void DefaultLogger::OnDebug( const char* message )
{
    if ( m_Severity == Logger::NORMAL )
        return;

	static const size_t Size = MAX_LOG_MESSAGE_LENGTH + 16;
	char msg[Size];
	ai_snprintf(msg, Size, "Debug, T%u: %s", GetThreadID(), message);

    WriteToStreams( msg, Logger::Debugging );
}

// ----------------------------------------------------------------------------------
//  Logs an info
void DefaultLogger::OnInfo( const char* message )
{
	static const size_t Size = MAX_LOG_MESSAGE_LENGTH + 16;
	char msg[Size];
    ai_snprintf(msg, Size, "Info,  T%u: %s", GetThreadID(), message );

    WriteToStreams( msg , Logger::Info );
}

// ----------------------------------------------------------------------------------
//  Logs a warning
void DefaultLogger::OnWarn( const char* message )
{
	static const size_t Size = MAX_LOG_MESSAGE_LENGTH + 16;
	char msg[Size];
	ai_snprintf(msg, Size, "Warn,  T%u: %s", GetThreadID(), message );

    WriteToStreams( msg, Logger::Warn );
}

// ----------------------------------------------------------------------------------
//  Logs an error
void DefaultLogger::OnError( const char* message )
{
	static const size_t Size = MAX_LOG_MESSAGE_LENGTH + 16;
	char msg[ Size ];
    ai_snprintf(msg, Size, "Error, T%u: %s", GetThreadID(), message );

    WriteToStreams( msg, Logger::Err );
}

// ----------------------------------------------------------------------------------
//  Will attach a new stream
bool DefaultLogger::attachStream( LogStream *pStream, unsigned int severity )
{
    if (!pStream)
        return false;

    if (0 == severity)  {
        severity = Logger::Info | Logger::Err | Logger::Warn | Logger::Debugging;
    }

    for ( StreamIt it = m_StreamArray.begin();
        it != m_StreamArray.end();
        ++it )
    {
        if ( (*it)->m_pStream == pStream )
        {
            (*it)->m_uiErrorSeverity |= severity;
            return true;
        }
    }

    LogStreamInfo *pInfo = new LogStreamInfo( severity, pStream );
    m_StreamArray.push_back( pInfo );
    return true;
}

// ----------------------------------------------------------------------------------
//  Detach a stream
bool DefaultLogger::detatchStream( LogStream *pStream, unsigned int severity )
{
    if (!pStream)
        return false;

    if (0 == severity)  {
        severity = SeverityAll;
    }

    for ( StreamIt it = m_StreamArray.begin();
        it != m_StreamArray.end();
        ++it )
    {
        if ( (*it)->m_pStream == pStream )
        {
            (*it)->m_uiErrorSeverity &= ~severity;
            if ( (*it)->m_uiErrorSeverity == 0 )
            {
                // don't delete the underlying stream 'cause the caller gains ownership again
                (**it).m_pStream = NULL;
                delete *it;
                m_StreamArray.erase( it );
                break;
            }
            return true;
        }
    }
    return false;
}

// ----------------------------------------------------------------------------------
//  Constructor
DefaultLogger::DefaultLogger(LogSeverity severity)
    :   Logger  ( severity )
    ,   noRepeatMsg (false)
    ,   lastLen( 0 )
{
    lastMsg[0] = '\0';
}

// ----------------------------------------------------------------------------------
//  Destructor
DefaultLogger::~DefaultLogger()
{
    for ( StreamIt it = m_StreamArray.begin(); it != m_StreamArray.end(); ++it ) {
        // also frees the underlying stream, we are its owner.
        delete *it;
    }
}

// ----------------------------------------------------------------------------------
//  Writes message to stream
void DefaultLogger::WriteToStreams(const char *message, ErrorSeverity ErrorSev )
{
    ai_assert(NULL != message);

    // Check whether this is a repeated message
    if (! ::strncmp( message,lastMsg, lastLen-1))
    {
        if (!noRepeatMsg)
        {
            noRepeatMsg = true;
            message = "Skipping one or more lines with the same contents\n";
        }
        else return;
    }
    else
    {
        // append a new-line character to the message to be printed
        lastLen = ::strlen(message);
        ::memcpy(lastMsg,message,lastLen+1);
        ::strcat(lastMsg+lastLen,"\n");

        message = lastMsg;
        noRepeatMsg = false;
        ++lastLen;
    }
    for ( ConstStreamIt it = m_StreamArray.begin();
        it != m_StreamArray.end();
        ++it)
    {
        if ( ErrorSev & (*it)->m_uiErrorSeverity )
            (*it)->m_pStream->write( message);
    }
}

// ----------------------------------------------------------------------------------
//  Returns thread id, if not supported only a zero will be returned.
unsigned int DefaultLogger::GetThreadID()
{
    // fixme: we can get this value via std::threads
    // std::this_thread::get_id().hash() returns a (big) size_t, not sure if this is useful in this case.
#ifdef WIN32
    return (unsigned int)::GetCurrentThreadId();
#else
    return 0; // not supported
#endif
}

// ----------------------------------------------------------------------------------

} // !namespace Assimp

/***********************************************************************
FBXIMPORT\FBXANIMATION.CPP
***********************************************************************/
/*
Open Asset Import Library (assimp)
----------------------------------------------------------------------

Copyright (c) 2006-2016, assimp team
All rights reserved.

Redistribution and use of this software in source and binary forms,
with or without modification, are permitted provided that the
following conditions are met:

* Redistributions of source code must retain the above
  copyright notice, this list of conditions and the
  following disclaimer.

* Redistributions in binary form must reproduce the above
  copyright notice, this list of conditions and the
  following disclaimer in the documentation and/or other
  materials provided with the distribution.

* Neither the name of the assimp team, nor the names of its
  contributors may be used to endorse or promote products
  derived from this software without specific prior
  written permission of the assimp team.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
"AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

----------------------------------------------------------------------
*/

/** @file  FBXAnimation.cpp
 *  @brief Assimp::FBX::AnimationCurve, Assimp::FBX::AnimationCurveNode,
 *         Assimp::FBX::AnimationLayer, Assimp::FBX::AnimationStack
 */

#ifndef ASSIMP_BUILD_NO_FBX_IMPORTER


namespace Assimp {
namespace FBX {

    using namespace Util;

// ------------------------------------------------------------------------------------------------
AnimationCurve::AnimationCurve(uint64_t id, const Element& element, const std::string& name, const Document& /*doc*/)
: Object(id, element, name)
{
    const Scope& sc = GetRequiredScope(element);
    const Element& KeyTime = GetRequiredElement(sc,"KeyTime");
    const Element& KeyValueFloat = GetRequiredElement(sc,"KeyValueFloat");

    ParseVectorDataArray(keys, KeyTime);
    ParseVectorDataArray(values, KeyValueFloat);

    if(keys.size() != values.size()) {
        DOMError("the number of key times does not match the number of keyframe values",&KeyTime);
    }

    // check if the key times are well-ordered
    if(!std::equal(keys.begin(), keys.end() - 1, keys.begin() + 1, std::less<KeyTimeList::value_type>())) {
        DOMError("the keyframes are not in ascending order",&KeyTime);
    }

    const Element* KeyAttrDataFloat = sc["KeyAttrDataFloat"];
    if(KeyAttrDataFloat) {
        ParseVectorDataArray(attributes, *KeyAttrDataFloat);
    }

    const Element* KeyAttrFlags = sc["KeyAttrFlags"];
    if(KeyAttrFlags) {
        ParseVectorDataArray(flags, *KeyAttrFlags);
    }
}


// ------------------------------------------------------------------------------------------------
AnimationCurve::~AnimationCurve()
{

}


// ------------------------------------------------------------------------------------------------
AnimationCurveNode::AnimationCurveNode(uint64_t id, const Element& element, const std::string& name, const Document& doc,
    const char* const * target_prop_whitelist /*= NULL*/, size_t whitelist_size /*= 0*/)
: Object(id, element, name)
, target()
, doc(doc)
{
    const Scope& sc = GetRequiredScope(element);

    // find target node
    const char* whitelist[] = {"Model","NodeAttribute"};
    const std::vector<const Connection*>& conns = doc.GetConnectionsBySourceSequenced(ID(),whitelist,2);

    for(const Connection* con : conns) {

        // link should go for a property
        if (!con->PropertyName().length()) {
            continue;
        }

        if(target_prop_whitelist) {
            const char* const s = con->PropertyName().c_str();
            bool ok = false;
            for (size_t i = 0; i < whitelist_size; ++i) {
                if (!strcmp(s, target_prop_whitelist[i])) {
                    ok = true;
                    break;
                }
            }

            if (!ok) {
                throw std::range_error("AnimationCurveNode target property is not in whitelist");
            }
        }

        const Object* const ob = con->DestinationObject();
        if(!ob) {
            DOMWarning("failed to read destination object for AnimationCurveNode->Model link, ignoring",&element);
            continue;
        }

        // XXX support constraints as DOM class
        //ai_assert(dynamic_cast<const Model*>(ob) || dynamic_cast<const NodeAttribute*>(ob));
        target = ob;
        if(!target) {
            continue;
        }

        prop = con->PropertyName();
        break;
    }

    if(!target) {
        DOMWarning("failed to resolve target Model/NodeAttribute/Constraint for AnimationCurveNode",&element);
    }

    props = GetPropertyTable(doc,"AnimationCurveNode.FbxAnimCurveNode",element,sc,false);
}


// ------------------------------------------------------------------------------------------------
AnimationCurveNode::~AnimationCurveNode()
{

}


// ------------------------------------------------------------------------------------------------
const AnimationCurveMap& AnimationCurveNode::Curves() const
{
    if(curves.empty()) {
        // resolve attached animation curves
        const std::vector<const Connection*>& conns = doc.GetConnectionsByDestinationSequenced(ID(),"AnimationCurve");

        for(const Connection* con : conns) {

            // link should go for a property
            if (!con->PropertyName().length()) {
                continue;
            }

            const Object* const ob = con->SourceObject();
            if(!ob) {
                DOMWarning("failed to read source object for AnimationCurve->AnimationCurveNode link, ignoring",&element);
                continue;
            }

            const AnimationCurve* const anim = dynamic_cast<const AnimationCurve*>(ob);
            if(!anim) {
                DOMWarning("source object for ->AnimationCurveNode link is not an AnimationCurve",&element);
                continue;
            }

            curves[con->PropertyName()] = anim;
        }
    }

    return curves;
}


// ------------------------------------------------------------------------------------------------
AnimationLayer::AnimationLayer(uint64_t id, const Element& element, const std::string& name, const Document& doc)
: Object(id, element, name)
, doc(doc)
{
    const Scope& sc = GetRequiredScope(element);

    // note: the props table here bears little importance and is usually absent
    props = GetPropertyTable(doc,"AnimationLayer.FbxAnimLayer",element,sc, true);
}


// ------------------------------------------------------------------------------------------------
AnimationLayer::~AnimationLayer()
{

}


// ------------------------------------------------------------------------------------------------
AnimationCurveNodeList AnimationLayer::Nodes(const char* const * target_prop_whitelist /*= NULL*/,
    size_t whitelist_size /*= 0*/) const
{
    AnimationCurveNodeList nodes;

    // resolve attached animation nodes
    const std::vector<const Connection*>& conns = doc.GetConnectionsByDestinationSequenced(ID(),"AnimationCurveNode");
    nodes.reserve(conns.size());

    for(const Connection* con : conns) {

        // link should not go to a property
        if (con->PropertyName().length()) {
            continue;
        }

        const Object* const ob = con->SourceObject();
        if(!ob) {
            DOMWarning("failed to read source object for AnimationCurveNode->AnimationLayer link, ignoring",&element);
            continue;
        }

        const AnimationCurveNode* const anim = dynamic_cast<const AnimationCurveNode*>(ob);
        if(!anim) {
            DOMWarning("source object for ->AnimationLayer link is not an AnimationCurveNode",&element);
            continue;
        }

        if(target_prop_whitelist) {
            const char* s = anim->TargetProperty().c_str();
            bool ok = false;
            for (size_t i = 0; i < whitelist_size; ++i) {
                if (!strcmp(s, target_prop_whitelist[i])) {
                    ok = true;
                    break;
                }
            }
            if(!ok) {
                continue;
            }
        }
        nodes.push_back(anim);
    }

    return nodes; // pray for NRVO
}

// ------------------------------------------------------------------------------------------------
AnimationStack::AnimationStack(uint64_t id, const Element& element, const std::string& name, const Document& doc)
: Object(id, element, name)
{
    const Scope& sc = GetRequiredScope(element);

    // note: we don't currently use any of these properties so we shouldn't bother if it is missing
    props = GetPropertyTable(doc,"AnimationStack.FbxAnimStack",element,sc, true);

    // resolve attached animation layers
    const std::vector<const Connection*>& conns = doc.GetConnectionsByDestinationSequenced(ID(),"AnimationLayer");
    layers.reserve(conns.size());

    for(const Connection* con : conns) {

        // link should not go to a property
        if (con->PropertyName().length()) {
            continue;
        }

        const Object* const ob = con->SourceObject();
        if(!ob) {
            DOMWarning("failed to read source object for AnimationLayer->AnimationStack link, ignoring",&element);
            continue;
        }

        const AnimationLayer* const anim = dynamic_cast<const AnimationLayer*>(ob);
        if(!anim) {
            DOMWarning("source object for ->AnimationStack link is not an AnimationLayer",&element);
            continue;
        }
        layers.push_back(anim);
    }
}


// ------------------------------------------------------------------------------------------------
AnimationStack::~AnimationStack()
{

}

} //!FBX
} //!Assimp

#endif

/***********************************************************************
FBXIMPORT\FBXBINARYTOKENIZER.CPP
***********************************************************************/
/*
Open Asset Import Library (assimp)
----------------------------------------------------------------------

Copyright (c) 2006-2016, assimp team
All rights reserved.

Redistribution and use of this software in source and binary forms,
with or without modification, are permitted provided that the
following conditions are met:

* Redistributions of source code must retain the above
  copyright notice, this list of conditions and the
  following disclaimer.

* Redistributions in binary form must reproduce the above
  copyright notice, this list of conditions and the
  following disclaimer in the documentation and/or other
  materials provided with the distribution.

* Neither the name of the assimp team, nor the names of its
  contributors may be used to endorse or promote products
  derived from this software without specific prior
  written permission of the assimp team.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
"AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

----------------------------------------------------------------------
*/
/** @file  FBXBinaryTokenizer.cpp
 *  @brief Implementation of a fake lexer for binary fbx files -
 *    we emit tokens so the parser needs almost no special handling
 *    for binary files.
 */

#ifndef ASSIMP_BUILD_NO_FBX_IMPORTER


namespace Assimp {
namespace FBX {


// ------------------------------------------------------------------------------------------------
Token::Token(const char* sbegin, const char* send, TokenType type, unsigned int offset)
    :
    #ifdef DEBUG
    contents(sbegin, static_cast<size_t>(send-sbegin)),
    #endif
    sbegin(sbegin)
    , send(send)
    , type(type)
    , line(offset)
    , column(BINARY_MARKER)
{
    ai_assert(sbegin);
    ai_assert(send);

    // binary tokens may have zero length because they are sometimes dummies
    // inserted by TokenizeBinary()
    ai_assert(send >= sbegin);
}


namespace {

// ------------------------------------------------------------------------------------------------
// signal tokenization error, this is always unrecoverable. Throws DeadlyImportError.
AI_WONT_RETURN void TokenizeError(const std::string& message, unsigned int offset) AI_WONT_RETURN_SUFFIX;
AI_WONT_RETURN void TokenizeError(const std::string& message, unsigned int offset)
{
    throw DeadlyImportError(Util::AddOffset("FBX-Tokenize",message,offset));
}


// ------------------------------------------------------------------------------------------------
uint32_t Offset(const char* begin, const char* cursor)
{
    ai_assert(begin <= cursor);
    return static_cast<unsigned int>(cursor - begin);
}


// ------------------------------------------------------------------------------------------------
void TokenizeError(const std::string& message, const char* begin, const char* cursor)
{
    TokenizeError(message, Offset(begin, cursor));
}


// ------------------------------------------------------------------------------------------------
uint32_t ReadWord(const char* input, const char*& cursor, const char* end)
{
    if(Offset(cursor, end) < 4) {
        TokenizeError("cannot ReadWord, out of bounds",input, cursor);
    }

    uint32_t word = *reinterpret_cast<const uint32_t*>(cursor);
    AI_SWAP4(word);

    cursor += 4;

    return word;
}


// ------------------------------------------------------------------------------------------------
uint8_t ReadByte(const char* input, const char*& cursor, const char* end)
{
    if(Offset(cursor, end) < 1) {
        TokenizeError("cannot ReadByte, out of bounds",input, cursor);
    }

    uint8_t word = *reinterpret_cast<const uint8_t*>(cursor);
    ++cursor;

    return word;
}


// ------------------------------------------------------------------------------------------------
unsigned int ReadString(const char*& sbegin_out, const char*& send_out, const char* input, const char*& cursor, const char* end,
    bool long_length = false,
    bool allow_null = false)
{
    const uint32_t len_len = long_length ? 4 : 1;
    if(Offset(cursor, end) < len_len) {
        TokenizeError("cannot ReadString, out of bounds reading length",input, cursor);
    }

    const uint32_t length = long_length ? ReadWord(input, cursor, end) : ReadByte(input, cursor, end);

    if (Offset(cursor, end) < length) {
        TokenizeError("cannot ReadString, length is out of bounds",input, cursor);
    }

    sbegin_out = cursor;
    cursor += length;

    send_out = cursor;

    if(!allow_null) {
        for (unsigned int i = 0; i < length; ++i) {
            if(sbegin_out[i] == '\0') {
                TokenizeError("failed ReadString, unexpected NUL character in string",input, cursor);
            }
        }
    }

    return length;
}



// ------------------------------------------------------------------------------------------------
void ReadData(const char*& sbegin_out, const char*& send_out, const char* input, const char*& cursor, const char* end)
{
    if(Offset(cursor, end) < 1) {
        TokenizeError("cannot ReadData, out of bounds reading length",input, cursor);
    }

    const char type = *cursor;
    sbegin_out = cursor++;

    switch(type)
    {
        // 16 bit int
    case 'Y':
        cursor += 2;
        break;

        // 1 bit bool flag (yes/no)
    case 'C':
        cursor += 1;
        break;

        // 32 bit int
    case 'I':
        // <- fall through

        // float
    case 'F':
        cursor += 4;
        break;

        // double
    case 'D':
        cursor += 8;
        break;

        // 64 bit int
    case 'L':
        cursor += 8;
        break;

        // note: do not write cursor += ReadWord(...cursor) as this would be UB

        // raw binary data
    case 'R':
    {
        const uint32_t length = ReadWord(input, cursor, end);
        cursor += length;
        break;
    }

    case 'b':
        // TODO: what is the 'b' type code? Right now we just skip over it /
        // take the full range we could get
        cursor = end;
        break;

        // array of *
    case 'f':
    case 'd':
    case 'l':
    case 'i':   {

        const uint32_t length = ReadWord(input, cursor, end);
        const uint32_t encoding = ReadWord(input, cursor, end);

        const uint32_t comp_len = ReadWord(input, cursor, end);

        // compute length based on type and check against the stored value
        if(encoding == 0) {
            uint32_t stride = 0;
            switch(type)
            {
            case 'f':
            case 'i':
                stride = 4;
                break;

            case 'd':
            case 'l':
                stride = 8;
                break;

            default:
                ai_assert(false);
            };
            ai_assert(stride > 0);
            if(length * stride != comp_len) {
                TokenizeError("cannot ReadData, calculated data stride differs from what the file claims",input, cursor);
            }
        }
        // zip/deflate algorithm (encoding==1)? take given length. anything else? die
        else if (encoding != 1) {
            TokenizeError("cannot ReadData, unknown encoding",input, cursor);
        }
        cursor += comp_len;
        break;
    }

        // string
    case 'S': {
        const char* sb, *se;
        // 0 characters can legally happen in such strings
        ReadString(sb, se, input, cursor, end, true, true);
        break;
    }
    default:
        TokenizeError("cannot ReadData, unexpected type code: " + std::string(&type, 1),input, cursor);
    }

    if(cursor > end) {
        TokenizeError("cannot ReadData, the remaining size is too small for the data type: " + std::string(&type, 1),input, cursor);
    }

    // the type code is contained in the returned range
    send_out = cursor;
}


// ------------------------------------------------------------------------------------------------
bool ReadScope(TokenList& output_tokens, const char* input, const char*& cursor, const char* end)
{
    // the first word contains the offset at which this block ends
    const uint32_t end_offset = ReadWord(input, cursor, end);

    // we may get 0 if reading reached the end of the file -
    // fbx files have a mysterious extra footer which I don't know
    // how to extract any information from, but at least it always
    // starts with a 0.
    if(!end_offset) {
        return false;
    }

    if(end_offset > Offset(input, end)) {
        TokenizeError("block offset is out of range",input, cursor);
    }
    else if(end_offset < Offset(input, cursor)) {
        TokenizeError("block offset is negative out of range",input, cursor);
    }

    // the second data word contains the number of properties in the scope
    const uint32_t prop_count = ReadWord(input, cursor, end);

    // the third data word contains the length of the property list
    const uint32_t prop_length = ReadWord(input, cursor, end);

    // now comes the name of the scope/key
    const char* sbeg, *send;
    ReadString(sbeg, send, input, cursor, end);

    output_tokens.push_back(new_Token(sbeg, send, TokenType_KEY, Offset(input, cursor) ));

    // now come the individual properties
    const char* begin_cursor = cursor;
    for (unsigned int i = 0; i < prop_count; ++i) {
        ReadData(sbeg, send, input, cursor, begin_cursor + prop_length);

        output_tokens.push_back(new_Token(sbeg, send, TokenType_DATA, Offset(input, cursor) ));

        if(i != prop_count-1) {
            output_tokens.push_back(new_Token(cursor, cursor + 1, TokenType_COMMA, Offset(input, cursor) ));
        }
    }

    if (Offset(begin_cursor, cursor) != prop_length) {
        TokenizeError("property length not reached, something is wrong",input, cursor);
    }

    // at the end of each nested block, there is a NUL record to indicate
    // that the sub-scope exists (i.e. to distinguish between P: and P : {})
    // this NUL record is 13 bytes long.
#define BLOCK_SENTINEL_LENGTH 13

    if (Offset(input, cursor) < end_offset) {

        if (end_offset - Offset(input, cursor) < BLOCK_SENTINEL_LENGTH) {
            TokenizeError("insufficient padding bytes at block end",input, cursor);
        }

        output_tokens.push_back(new_Token(cursor, cursor + 1, TokenType_OPEN_BRACKET, Offset(input, cursor) ));

        // XXX this is vulnerable to stack overflowing ..
        while(Offset(input, cursor) < end_offset - BLOCK_SENTINEL_LENGTH) {
            ReadScope(output_tokens, input, cursor, input + end_offset - BLOCK_SENTINEL_LENGTH);
        }
        output_tokens.push_back(new_Token(cursor, cursor + 1, TokenType_CLOSE_BRACKET, Offset(input, cursor) ));

        for (unsigned int i = 0; i < BLOCK_SENTINEL_LENGTH; ++i) {
            if(cursor[i] != '\0') {
                TokenizeError("failed to read nested block sentinel, expected all bytes to be 0",input, cursor);
            }
        }
        cursor += BLOCK_SENTINEL_LENGTH;
    }

    if (Offset(input, cursor) != end_offset) {
        TokenizeError("scope length not reached, something is wrong",input, cursor);
    }

    return true;
}


}

// ------------------------------------------------------------------------------------------------
void TokenizeBinary(TokenList& output_tokens, const char* input, unsigned int length)
{
    ai_assert(input);

    if(length < 0x1b) {
        TokenizeError("file is too short",0);
    }

    if (strncmp(input,"Kaydara FBX Binary",18)) {
        TokenizeError("magic bytes not found",0);
    }


    //uint32_t offset = 0x1b;

    const char* cursor = input + 0x1b;

    while (cursor < input + length) {
        if(!ReadScope(output_tokens, input, cursor, input + length)) {
            break;
        }
    }
}

} // !FBX
} // !Assimp

#endif

/***********************************************************************
FBXIMPORT\FBXCONVERTER.CPP
***********************************************************************/
/*
Open Asset Import Library (assimp)
----------------------------------------------------------------------

Copyright (c) 2006-2016, assimp team
All rights reserved.

Redistribution and use of this software in source and binary forms,
with or without modification, are permitted provided that the
following conditions are met:

* Redistributions of source code must retain the above
  copyright notice, this list of conditions and the
  following disclaimer.

* Redistributions in binary form must reproduce the above
  copyright notice, this list of conditions and the
  following disclaimer in the documentation and/or other
  materials provided with the distribution.

* Neither the name of the assimp team, nor the names of its
  contributors may be used to endorse or promote products
  derived from this software without specific prior
  written permission of the assimp team.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
"AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

----------------------------------------------------------------------
*/

/** @file  FBXConverter.cpp
 *  @brief Implementation of the FBX DOM -> aiScene converter
 */

#ifndef ASSIMP_BUILD_NO_FBX_IMPORTER


#include <tuple>

#include <iterator>

namespace Assimp {
namespace FBX {

using namespace Util;


#define MAGIC_NODE_TAG "_$AssimpFbx$"

#define CONVERT_FBX_TIME(time) static_cast<double>(time) / 46186158000L

    // XXX vc9's debugger won't step into anonymous namespaces
//namespace {

/** Dummy class to encapsulate the conversion process */
class Converter
{
public:
    /**
     *  The different parts that make up the final local transformation of a fbx-node
     */
    enum TransformationComp
    {
        TransformationComp_Translation = 0,
        TransformationComp_RotationOffset,
        TransformationComp_RotationPivot,
        TransformationComp_PreRotation,
        TransformationComp_Rotation,
        TransformationComp_PostRotation,
        TransformationComp_RotationPivotInverse,
        TransformationComp_ScalingOffset,
        TransformationComp_ScalingPivot,
        TransformationComp_Scaling,
        TransformationComp_ScalingPivotInverse,
        TransformationComp_GeometricTranslation,
        TransformationComp_GeometricRotation,
        TransformationComp_GeometricScaling,

        TransformationComp_MAXIMUM
    };

public:
    Converter( aiScene* out, const Document& doc );
    ~Converter();

private:
    // ------------------------------------------------------------------------------------------------
    // find scene root and trigger recursive scene conversion
    void ConvertRootNode();

    // ------------------------------------------------------------------------------------------------
    // collect and assign child nodes
    void ConvertNodes( uint64_t id, aiNode& parent, const aiMatrix4x4& parent_transform = aiMatrix4x4() );


    // ------------------------------------------------------------------------------------------------
    void ConvertLights( const Model& model );


    // ------------------------------------------------------------------------------------------------
    void ConvertCameras( const Model& model );

    // ------------------------------------------------------------------------------------------------
    void ConvertLight( const Model& model, const Light& light );

    // ------------------------------------------------------------------------------------------------
    void ConvertCamera( const Model& model, const Camera& cam );

    // ------------------------------------------------------------------------------------------------
    // this returns unified names usable within assimp identifiers (i.e. no space characters -
    // while these would be allowed, they are a potential trouble spot so better not use them).
    const char* NameTransformationComp( TransformationComp comp );

    // ------------------------------------------------------------------------------------------------
    // note: this returns the REAL fbx property names
    const char* NameTransformationCompProperty( TransformationComp comp );

    // ------------------------------------------------------------------------------------------------
    aiVector3D TransformationCompDefaultValue( TransformationComp comp );

    // ------------------------------------------------------------------------------------------------
    void GetRotationMatrix( Model::RotOrder mode, const aiVector3D& rotation, aiMatrix4x4& out );
    // ------------------------------------------------------------------------------------------------
    /**
     *  checks if a node has more than just scaling, rotation and translation components
     */
    bool NeedsComplexTransformationChain( const Model& model );

    // ------------------------------------------------------------------------------------------------
    // note: name must be a FixNodeName() result
    std::string NameTransformationChainNode( const std::string& name, TransformationComp comp );

    // ------------------------------------------------------------------------------------------------
    /**
     *  note: memory for output_nodes will be managed by the caller
     */
    void GenerateTransformationNodeChain( const Model& model, std::vector<aiNode*>& output_nodes );

    // ------------------------------------------------------------------------------------------------
    void SetupNodeMetadata( const Model& model, aiNode& nd );

    // ------------------------------------------------------------------------------------------------
    void ConvertModel( const Model& model, aiNode& nd, const aiMatrix4x4& node_global_transform );

    // ------------------------------------------------------------------------------------------------
    // MeshGeometry -> aiMesh, return mesh index + 1 or 0 if the conversion failed
    std::vector<unsigned int> ConvertMesh( const MeshGeometry& mesh, const Model& model,
        const aiMatrix4x4& node_global_transform );

    // ------------------------------------------------------------------------------------------------
    aiMesh* SetupEmptyMesh( const MeshGeometry& mesh );

    // ------------------------------------------------------------------------------------------------
    unsigned int ConvertMeshSingleMaterial( const MeshGeometry& mesh, const Model& model,
        const aiMatrix4x4& node_global_transform );

    // ------------------------------------------------------------------------------------------------
    std::vector<unsigned int> ConvertMeshMultiMaterial( const MeshGeometry& mesh, const Model& model,
        const aiMatrix4x4& node_global_transform );

    // ------------------------------------------------------------------------------------------------
    unsigned int ConvertMeshMultiMaterial( const MeshGeometry& mesh, const Model& model,
        MatIndexArray::value_type index,
        const aiMatrix4x4& node_global_transform );

    // ------------------------------------------------------------------------------------------------
    static const unsigned int NO_MATERIAL_SEPARATION = /* std::numeric_limits<unsigned int>::max() */
        static_cast<unsigned int>(-1);


    // ------------------------------------------------------------------------------------------------
    /**
     *  - if materialIndex == NO_MATERIAL_SEPARATION, materials are not taken into
     *    account when determining which weights to include.
     *  - outputVertStartIndices is only used when a material index is specified, it gives for
     *    each output vertex the DOM index it maps to.
     */
    void ConvertWeights( aiMesh* out, const Model& model, const MeshGeometry& geo,
        const aiMatrix4x4& node_global_transform = aiMatrix4x4(),
        unsigned int materialIndex = NO_MATERIAL_SEPARATION,
        std::vector<unsigned int>* outputVertStartIndices = NULL );

    // ------------------------------------------------------------------------------------------------
    void ConvertCluster( std::vector<aiBone*>& bones, const Model& /*model*/, const Cluster& cl,
        std::vector<size_t>& out_indices,
        std::vector<size_t>& index_out_indices,
        std::vector<size_t>& count_out_indices,
        const aiMatrix4x4& node_global_transform );

    // ------------------------------------------------------------------------------------------------
    void ConvertMaterialForMesh( aiMesh* out, const Model& model, const MeshGeometry& geo,
        MatIndexArray::value_type materialIndex );

    // ------------------------------------------------------------------------------------------------
    unsigned int GetDefaultMaterial();


    // ------------------------------------------------------------------------------------------------
    // Material -> aiMaterial
    unsigned int ConvertMaterial( const Material& material, const MeshGeometry* const mesh );

    // ------------------------------------------------------------------------------------------------
    // Video -> aiTexture
    unsigned int ConvertVideo( const Video& video );

    // ------------------------------------------------------------------------------------------------
    void TrySetTextureProperties( aiMaterial* out_mat, const TextureMap& textures,
        const std::string& propName,
        aiTextureType target, const MeshGeometry* const mesh );

    // ------------------------------------------------------------------------------------------------
    void TrySetTextureProperties( aiMaterial* out_mat, const LayeredTextureMap& layeredTextures,
        const std::string& propName,
        aiTextureType target, const MeshGeometry* const mesh );

    // ------------------------------------------------------------------------------------------------
    void SetTextureProperties( aiMaterial* out_mat, const TextureMap& textures, const MeshGeometry* const mesh );

    // ------------------------------------------------------------------------------------------------
    void SetTextureProperties( aiMaterial* out_mat, const LayeredTextureMap& layeredTextures, const MeshGeometry* const mesh );

    // ------------------------------------------------------------------------------------------------
    aiColor3D GetColorPropertyFromMaterial( const PropertyTable& props, const std::string& baseName,
        bool& result );

    // ------------------------------------------------------------------------------------------------
    void SetShadingPropertiesCommon( aiMaterial* out_mat, const PropertyTable& props );

    // ------------------------------------------------------------------------------------------------
    // get the number of fps for a FrameRate enumerated value
    static double FrameRateToDouble( FileGlobalSettings::FrameRate fp, double customFPSVal = -1.0 );

    // ------------------------------------------------------------------------------------------------
    // convert animation data to aiAnimation et al
    void ConvertAnimations();

    // ------------------------------------------------------------------------------------------------
    // rename a node already partially converted. fixed_name is a string previously returned by
    // FixNodeName, new_name specifies the string FixNodeName should return on all further invocations
    // which would previously have returned the old value.
    //
    // this also updates names in node animations, cameras and light sources and is thus slow.
    //
    // NOTE: the caller is responsible for ensuring that the new name is unique and does
    // not collide with any other identifiers. The best way to ensure this is to only
    // append to the old name, which is guaranteed to match these requirements.
    void RenameNode( const std::string& fixed_name, const std::string& new_name );

    // ------------------------------------------------------------------------------------------------
    // takes a fbx node name and returns the identifier to be used in the assimp output scene.
    // the function is guaranteed to provide consistent results over multiple invocations
    // UNLESS RenameNode() is called for a particular node name.
    std::string FixNodeName( const std::string& name );

    typedef std::map<const AnimationCurveNode*, const AnimationLayer*> LayerMap;

    // XXX: better use multi_map ..
    typedef std::map<std::string, std::vector<const AnimationCurveNode*> > NodeMap;


    // ------------------------------------------------------------------------------------------------
    void ConvertAnimationStack( const AnimationStack& st );

    // ------------------------------------------------------------------------------------------------
    void GenerateNodeAnimations( std::vector<aiNodeAnim*>& node_anims,
        const std::string& fixed_name,
        const std::vector<const AnimationCurveNode*>& curves,
        const LayerMap& layer_map,
        int64_t start, int64_t stop,
        double& max_time,
        double& min_time );

    // ------------------------------------------------------------------------------------------------
    bool IsRedundantAnimationData( const Model& target,
        TransformationComp comp,
        const std::vector<const AnimationCurveNode*>& curves );

    // ------------------------------------------------------------------------------------------------
    aiNodeAnim* GenerateRotationNodeAnim( const std::string& name,
        const Model& target,
        const std::vector<const AnimationCurveNode*>& curves,
        const LayerMap& layer_map,
        int64_t start, int64_t stop,
        double& max_time,
        double& min_time );

    // ------------------------------------------------------------------------------------------------
    aiNodeAnim* GenerateScalingNodeAnim( const std::string& name,
        const Model& /*target*/,
        const std::vector<const AnimationCurveNode*>& curves,
        const LayerMap& layer_map,
        int64_t start, int64_t stop,
        double& max_time,
        double& min_time );

    // ------------------------------------------------------------------------------------------------
    aiNodeAnim* GenerateTranslationNodeAnim( const std::string& name,
        const Model& /*target*/,
        const std::vector<const AnimationCurveNode*>& curves,
        const LayerMap& layer_map,
        int64_t start, int64_t stop,
        double& max_time,
        double& min_time,
        bool inverse = false );

    // ------------------------------------------------------------------------------------------------
    // generate node anim, extracting only Rotation, Scaling and Translation from the given chain
    aiNodeAnim* GenerateSimpleNodeAnim( const std::string& name,
        const Model& target,
        NodeMap::const_iterator chain[ TransformationComp_MAXIMUM ],
        NodeMap::const_iterator iter_end,
        const LayerMap& layer_map,
        int64_t start, int64_t stop,
        double& max_time,
        double& min_time,
        bool reverse_order = false );

    // key (time), value, mapto (component index)
    typedef std::tuple<std::shared_ptr<KeyTimeList>, std::shared_ptr<KeyValueList>, unsigned int > KeyFrameList;
    typedef std::vector<KeyFrameList> KeyFrameListList;



    // ------------------------------------------------------------------------------------------------
    KeyFrameListList GetKeyframeList( const std::vector<const AnimationCurveNode*>& nodes, int64_t start, int64_t stop );

    // ------------------------------------------------------------------------------------------------
    KeyTimeList GetKeyTimeList( const KeyFrameListList& inputs );

    // ------------------------------------------------------------------------------------------------
    void InterpolateKeys( aiVectorKey* valOut, const KeyTimeList& keys, const KeyFrameListList& inputs,
        const aiVector3D& def_value,
        double& max_time,
        double& min_time );

    // ------------------------------------------------------------------------------------------------
    void InterpolateKeys( aiQuatKey* valOut, const KeyTimeList& keys, const KeyFrameListList& inputs,
        const aiVector3D& def_value,
        double& maxTime,
        double& minTime,
        Model::RotOrder order );

    // ------------------------------------------------------------------------------------------------
    void ConvertTransformOrder_TRStoSRT( aiQuatKey* out_quat, aiVectorKey* out_scale,
        aiVectorKey* out_translation,
        const KeyFrameListList& scaling,
        const KeyFrameListList& translation,
        const KeyFrameListList& rotation,
        const KeyTimeList& times,
        double& maxTime,
        double& minTime,
        Model::RotOrder order,
        const aiVector3D& def_scale,
        const aiVector3D& def_translate,
        const aiVector3D& def_rotation );

    // ------------------------------------------------------------------------------------------------
    // euler xyz -> quat
    aiQuaternion EulerToQuaternion( const aiVector3D& rot, Model::RotOrder order );

    // ------------------------------------------------------------------------------------------------
    void ConvertScaleKeys( aiNodeAnim* na, const std::vector<const AnimationCurveNode*>& nodes, const LayerMap& /*layers*/,
        int64_t start, int64_t stop,
        double& maxTime,
        double& minTime );

    // ------------------------------------------------------------------------------------------------
    void ConvertTranslationKeys( aiNodeAnim* na, const std::vector<const AnimationCurveNode*>& nodes,
        const LayerMap& /*layers*/,
        int64_t start, int64_t stop,
        double& maxTime,
        double& minTime );

    // ------------------------------------------------------------------------------------------------
    void ConvertRotationKeys( aiNodeAnim* na, const std::vector<const AnimationCurveNode*>& nodes,
        const LayerMap& /*layers*/,
        int64_t start, int64_t stop,
        double& maxTime,
        double& minTime,
        Model::RotOrder order );

    // ------------------------------------------------------------------------------------------------
    // copy generated meshes, animations, lights, cameras and textures to the output scene
    void TransferDataToScene();

private:

    // 0: not assigned yet, others: index is value - 1
    unsigned int defaultMaterialIndex;

    std::vector<aiMesh*> meshes;
    std::vector<aiMaterial*> materials;
    std::vector<aiAnimation*> animations;
    std::vector<aiLight*> lights;
    std::vector<aiCamera*> cameras;
    std::vector<aiTexture*> textures;

    typedef std::map<const Material*, unsigned int> MaterialMap;
    MaterialMap materials_converted;

    typedef std::map<const Video*, unsigned int> VideoMap;
    VideoMap textures_converted;

    typedef std::map<const Geometry*, std::vector<unsigned int> > MeshMap;
    MeshMap meshes_converted;

    // fixed node name -> which trafo chain components have animations?
    typedef std::map<std::string, unsigned int> NodeAnimBitMap;
    NodeAnimBitMap node_anim_chain_bits;

    // name -> has had its prefix_stripped?
    typedef std::map<std::string, bool> NodeNameMap;
    NodeNameMap node_names;

    typedef std::map<std::string, std::string> NameNameMap;
    NameNameMap renamed_nodes;

    double anim_fps;

    aiScene* const out;
    const FBX::Document& doc;
};

Converter::Converter( aiScene* out, const Document& doc )
    : defaultMaterialIndex()
    , out( out )
    , doc( doc )
{
    // animations need to be converted first since this will
    // populate the node_anim_chain_bits map, which is needed
    // to determine which nodes need to be generated.
    ConvertAnimations();
    ConvertRootNode();

    if ( doc.Settings().readAllMaterials ) {
        // unfortunately this means we have to evaluate all objects
        for( const ObjectMap::value_type& v : doc.Objects() ) {

            const Object* ob = v.second->Get();
            if ( !ob ) {
                continue;
            }

            const Material* mat = dynamic_cast<const Material*>( ob );
            if ( mat ) {

                if ( materials_converted.find( mat ) == materials_converted.end() ) {
                    ConvertMaterial( *mat, 0 );
                }
            }
        }
    }

    TransferDataToScene();

    // if we didn't read any meshes set the AI_SCENE_FLAGS_INCOMPLETE
    // to make sure the scene passes assimp's validation. FBX files
    // need not contain geometry (i.e. camera animations, raw armatures).
    if ( out->mNumMeshes == 0 ) {
        out->mFlags |= AI_SCENE_FLAGS_INCOMPLETE;
    }
}


Converter::~Converter()
{
    std::for_each( meshes.begin(), meshes.end(), Util::delete_fun<aiMesh>() );
    std::for_each( materials.begin(), materials.end(), Util::delete_fun<aiMaterial>() );
    std::for_each( animations.begin(), animations.end(), Util::delete_fun<aiAnimation>() );
    std::for_each( lights.begin(), lights.end(), Util::delete_fun<aiLight>() );
    std::for_each( cameras.begin(), cameras.end(), Util::delete_fun<aiCamera>() );
    std::for_each( textures.begin(), textures.end(), Util::delete_fun<aiTexture>() );
}

void Converter::ConvertRootNode()
{
    out->mRootNode = new aiNode();
    out->mRootNode->mName.Set( "RootNode" );

    // root has ID 0
    ConvertNodes( 0L, *out->mRootNode );
}


void Converter::ConvertNodes( uint64_t id, aiNode& parent, const aiMatrix4x4& parent_transform )
{
    const std::vector<const Connection*>& conns = doc.GetConnectionsByDestinationSequenced( id, "Model" );

    std::vector<aiNode*> nodes;
    nodes.reserve( conns.size() );

    std::vector<aiNode*> nodes_chain;

    try {
        for( const Connection* con : conns ) {

            // ignore object-property links
            if ( con->PropertyName().length() ) {
                continue;
            }

            const Object* const object = con->SourceObject();
            if ( !object ) {
                FBXImporter::LogWarn( "failed to convert source object for Model link" );
                continue;
            }

            const Model* const model = dynamic_cast<const Model*>( object );

            if ( model ) {
                nodes_chain.clear();

                aiMatrix4x4 new_abs_transform = parent_transform;

                // even though there is only a single input node, the design of
                // assimp (or rather: the complicated transformation chain that
                // is employed by fbx) means that we may need multiple aiNode's
                // to represent a fbx node's transformation.
                GenerateTransformationNodeChain( *model, nodes_chain );

                ai_assert( nodes_chain.size() );

                const std::string& original_name = FixNodeName( model->Name() );

                // check if any of the nodes in the chain has the name the fbx node
                // is supposed to have. If there is none, add another node to
                // preserve the name - people might have scripts etc. that rely
                // on specific node names.
                aiNode* name_carrier = NULL;
                for( aiNode* prenode : nodes_chain ) {
                    if ( !strcmp( prenode->mName.C_Str(), original_name.c_str() ) ) {
                        name_carrier = prenode;
                        break;
                    }
                }

                if ( !name_carrier ) {
                    nodes_chain.push_back( new aiNode( original_name ) );
                    name_carrier = nodes_chain.back();
                }

                //setup metadata on newest node
                SetupNodeMetadata( *model, *nodes_chain.back() );

                // link all nodes in a row
                aiNode* last_parent = &parent;
                for( aiNode* prenode : nodes_chain ) {
                    ai_assert( prenode );

                    if ( last_parent != &parent ) {
                        last_parent->mNumChildren = 1;
                        last_parent->mChildren = new aiNode*[ 1 ];
                        last_parent->mChildren[ 0 ] = prenode;
                    }

                    prenode->mParent = last_parent;
                    last_parent = prenode;

                    new_abs_transform *= prenode->mTransformation;
                }

                // attach geometry
                ConvertModel( *model, *nodes_chain.back(), new_abs_transform );

                // attach sub-nodes
                ConvertNodes( model->ID(), *nodes_chain.back(), new_abs_transform );

                if ( doc.Settings().readLights ) {
                    ConvertLights( *model );
                }

                if ( doc.Settings().readCameras ) {
                    ConvertCameras( *model );
                }

                nodes.push_back( nodes_chain.front() );
                nodes_chain.clear();
            }
        }

        if ( nodes.size() ) {
            parent.mChildren = new aiNode*[ nodes.size() ]();
            parent.mNumChildren = static_cast<unsigned int>( nodes.size() );

            std::swap_ranges( nodes.begin(), nodes.end(), parent.mChildren );
        }
    }
    catch ( std::exception& ) {
        Util::delete_fun<aiNode> deleter;
        std::for_each( nodes.begin(), nodes.end(), deleter );
        std::for_each( nodes_chain.begin(), nodes_chain.end(), deleter );
    }
}


void Converter::ConvertLights( const Model& model )
{
    const std::vector<const NodeAttribute*>& node_attrs = model.GetAttributes();
    for( const NodeAttribute* attr : node_attrs ) {
        const Light* const light = dynamic_cast<const Light*>( attr );
        if ( light ) {
            ConvertLight( model, *light );
        }
    }
}

void Converter::ConvertCameras( const Model& model )
{
    const std::vector<const NodeAttribute*>& node_attrs = model.GetAttributes();
    for( const NodeAttribute* attr : node_attrs ) {
        const Camera* const cam = dynamic_cast<const Camera*>( attr );
        if ( cam ) {
            ConvertCamera( model, *cam );
        }
    }
}


void Converter::ConvertLight( const Model& model, const Light& light )
{
    lights.push_back( new aiLight() );
    aiLight* const out_light = lights.back();

    out_light->mName.Set( FixNodeName( model.Name() ) );

    const float intensity = light.Intensity();
    const aiVector3D& col = light.Color();

    out_light->mColorDiffuse = aiColor3D( col.x, col.y, col.z );
    out_light->mColorDiffuse.r *= intensity;
    out_light->mColorDiffuse.g *= intensity;
    out_light->mColorDiffuse.b *= intensity;

    out_light->mColorSpecular = out_light->mColorDiffuse;

    switch ( light.LightType() )
    {
    case Light::Type_Point:
        out_light->mType = aiLightSource_POINT;
        break;

    case Light::Type_Directional:
        out_light->mType = aiLightSource_DIRECTIONAL;
        break;

    case Light::Type_Spot:
        out_light->mType = aiLightSource_SPOT;
        out_light->mAngleOuterCone = AI_DEG_TO_RAD( light.OuterAngle() );
        out_light->mAngleInnerCone = AI_DEG_TO_RAD( light.InnerAngle() );
        break;

    case Light::Type_Area:
        FBXImporter::LogWarn( "cannot represent area light, set to UNDEFINED" );
        out_light->mType = aiLightSource_UNDEFINED;
        break;

    case Light::Type_Volume:
        FBXImporter::LogWarn( "cannot represent volume light, set to UNDEFINED" );
        out_light->mType = aiLightSource_UNDEFINED;
        break;
    default:
        ai_assert( false );
    }

    // XXX: how to best convert the near and far decay ranges?
    switch ( light.DecayType() )
    {
    case Light::Decay_None:
        out_light->mAttenuationConstant = 1.0f;
        break;
    case Light::Decay_Linear:
        out_light->mAttenuationLinear = 1.0f;
        break;
    case Light::Decay_Quadratic:
        out_light->mAttenuationQuadratic = 1.0f;
        break;
    case Light::Decay_Cubic:
        FBXImporter::LogWarn( "cannot represent cubic attenuation, set to Quadratic" );
        out_light->mAttenuationQuadratic = 1.0f;
        break;
    default:
        ai_assert( false );
    }
}

void Converter::ConvertCamera( const Model& model, const Camera& cam )
{
    cameras.push_back( new aiCamera() );
    aiCamera* const out_camera = cameras.back();

    out_camera->mName.Set( FixNodeName( model.Name() ) );

    out_camera->mAspect = cam.AspectWidth() / cam.AspectHeight();
    out_camera->mPosition = cam.Position();
    out_camera->mUp = cam.UpVector();
    out_camera->mLookAt = cam.InterestPosition() - out_camera->mPosition;
    out_camera->mHorizontalFOV = AI_DEG_TO_RAD( cam.FieldOfView() );
}


const char* Converter::NameTransformationComp( TransformationComp comp )
{
    switch ( comp )
    {
    case TransformationComp_Translation:
        return "Translation";
    case TransformationComp_RotationOffset:
        return "RotationOffset";
    case TransformationComp_RotationPivot:
        return "RotationPivot";
    case TransformationComp_PreRotation:
        return "PreRotation";
    case TransformationComp_Rotation:
        return "Rotation";
    case TransformationComp_PostRotation:
        return "PostRotation";
    case TransformationComp_RotationPivotInverse:
        return "RotationPivotInverse";
    case TransformationComp_ScalingOffset:
        return "ScalingOffset";
    case TransformationComp_ScalingPivot:
        return "ScalingPivot";
    case TransformationComp_Scaling:
        return "Scaling";
    case TransformationComp_ScalingPivotInverse:
        return "ScalingPivotInverse";
    case TransformationComp_GeometricScaling:
        return "GeometricScaling";
    case TransformationComp_GeometricRotation:
        return "GeometricRotation";
    case TransformationComp_GeometricTranslation:
        return "GeometricTranslation";
    case TransformationComp_MAXIMUM: // this is to silence compiler warnings
    default:
        break;
    }

    ai_assert( false );
    return NULL;
}


const char* Converter::NameTransformationCompProperty( TransformationComp comp )
{
    switch ( comp )
    {
    case TransformationComp_Translation:
        return "Lcl Translation";
    case TransformationComp_RotationOffset:
        return "RotationOffset";
    case TransformationComp_RotationPivot:
        return "RotationPivot";
    case TransformationComp_PreRotation:
        return "PreRotation";
    case TransformationComp_Rotation:
        return "Lcl Rotation";
    case TransformationComp_PostRotation:
        return "PostRotation";
    case TransformationComp_RotationPivotInverse:
        return "RotationPivotInverse";
    case TransformationComp_ScalingOffset:
        return "ScalingOffset";
    case TransformationComp_ScalingPivot:
        return "ScalingPivot";
    case TransformationComp_Scaling:
        return "Lcl Scaling";
    case TransformationComp_ScalingPivotInverse:
        return "ScalingPivotInverse";
    case TransformationComp_GeometricScaling:
        return "GeometricScaling";
    case TransformationComp_GeometricRotation:
        return "GeometricRotation";
    case TransformationComp_GeometricTranslation:
        return "GeometricTranslation";
    case TransformationComp_MAXIMUM: // this is to silence compiler warnings
        break;
    }

    ai_assert( false );
    return NULL;
}

aiVector3D Converter::TransformationCompDefaultValue( TransformationComp comp )
{
    // XXX a neat way to solve the never-ending special cases for scaling
    // would be to do everything in log space!
    return comp == TransformationComp_Scaling ? aiVector3D( 1.f, 1.f, 1.f ) : aiVector3D();
}

void Converter::GetRotationMatrix( Model::RotOrder mode, const aiVector3D& rotation, aiMatrix4x4& out )
{
    if ( mode == Model::RotOrder_SphericXYZ ) {
        FBXImporter::LogError( "Unsupported RotationMode: SphericXYZ" );
        out = aiMatrix4x4();
        return;
    }

    const float angle_epsilon = 1e-6f;

    out = aiMatrix4x4();

    bool is_id[ 3 ] = { true, true, true };

    aiMatrix4x4 temp[ 3 ];
    if ( std::fabs( rotation.z ) > angle_epsilon ) {
        aiMatrix4x4::RotationZ( AI_DEG_TO_RAD( rotation.z ), temp[ 2 ] );
        is_id[ 2 ] = false;
    }
    if ( std::fabs( rotation.y ) > angle_epsilon ) {
        aiMatrix4x4::RotationY( AI_DEG_TO_RAD( rotation.y ), temp[ 1 ] );
        is_id[ 1 ] = false;
    }
    if ( std::fabs( rotation.x ) > angle_epsilon ) {
        aiMatrix4x4::RotationX( AI_DEG_TO_RAD( rotation.x ), temp[ 0 ] );
        is_id[ 0 ] = false;
    }

    int order[ 3 ] = { -1, -1, -1 };

    // note: rotation order is inverted since we're left multiplying as is usual in assimp
    switch ( mode )
    {
    case Model::RotOrder_EulerXYZ:
        order[ 0 ] = 2;
        order[ 1 ] = 1;
        order[ 2 ] = 0;
        break;

    case Model::RotOrder_EulerXZY:
        order[ 0 ] = 1;
        order[ 1 ] = 2;
        order[ 2 ] = 0;
        break;

    case Model::RotOrder_EulerYZX:
        order[ 0 ] = 0;
        order[ 1 ] = 2;
        order[ 2 ] = 1;
        break;

    case Model::RotOrder_EulerYXZ:
        order[ 0 ] = 2;
        order[ 1 ] = 0;
        order[ 2 ] = 1;
        break;

    case Model::RotOrder_EulerZXY:
        order[ 0 ] = 1;
        order[ 1 ] = 0;
        order[ 2 ] = 2;
        break;

    case Model::RotOrder_EulerZYX:
        order[ 0 ] = 0;
        order[ 1 ] = 1;
        order[ 2 ] = 2;
        break;

    default:
        ai_assert( false );
    }

    ai_assert( ( order[ 0 ] >= 0 ) && ( order[ 0 ] <= 2 ) );
    ai_assert( ( order[ 1 ] >= 0 ) && ( order[ 1 ] <= 2 ) );
    ai_assert( ( order[ 2 ] >= 0 ) && ( order[ 2 ] <= 2 ) );

    if ( !is_id[ order[ 0 ] ] ) {
        out = temp[ order[ 0 ] ];
    }

    if ( !is_id[ order[ 1 ] ] ) {
        out = out * temp[ order[ 1 ] ];
    }

    if ( !is_id[ order[ 2 ] ] ) {
        out = out * temp[ order[ 2 ] ];
    }
}


bool Converter::NeedsComplexTransformationChain( const Model& model )
{
    const PropertyTable& props = model.Props();
    bool ok;

    const float zero_epsilon = 1e-6f;
    for ( size_t i = 0; i < TransformationComp_MAXIMUM; ++i ) {
        const TransformationComp comp = static_cast< TransformationComp >( i );

        if ( comp == TransformationComp_Rotation || comp == TransformationComp_Scaling || comp == TransformationComp_Translation ||
            comp == TransformationComp_GeometricScaling || comp == TransformationComp_GeometricRotation || comp == TransformationComp_GeometricTranslation ) {
            continue;
        }

        const aiVector3D& v = PropertyGet<aiVector3D>( props, NameTransformationCompProperty( comp ), ok );
        if ( ok && v.SquareLength() > zero_epsilon ) {
            return true;
        }
    }

    return false;
}


std::string Converter::NameTransformationChainNode( const std::string& name, TransformationComp comp )
{
    return name + std::string( MAGIC_NODE_TAG ) + "_" + NameTransformationComp( comp );
}

void Converter::GenerateTransformationNodeChain( const Model& model,
    std::vector<aiNode*>& output_nodes )
{
    const PropertyTable& props = model.Props();
    const Model::RotOrder rot = model.RotationOrder();

    bool ok;

    aiMatrix4x4 chain[ TransformationComp_MAXIMUM ];
    std::fill_n( chain, static_cast<unsigned int>( TransformationComp_MAXIMUM ), aiMatrix4x4() );

    // generate transformation matrices for all the different transformation components
    const float zero_epsilon = 1e-6f;
    bool is_complex = false;

    const aiVector3D& PreRotation = PropertyGet<aiVector3D>( props, "PreRotation", ok );
    if ( ok && PreRotation.SquareLength() > zero_epsilon ) {
        is_complex = true;

        GetRotationMatrix( rot, PreRotation, chain[ TransformationComp_PreRotation ] );
    }

    const aiVector3D& PostRotation = PropertyGet<aiVector3D>( props, "PostRotation", ok );
    if ( ok && PostRotation.SquareLength() > zero_epsilon ) {
        is_complex = true;

        GetRotationMatrix( rot, PostRotation, chain[ TransformationComp_PostRotation ] );
    }

    const aiVector3D& RotationPivot = PropertyGet<aiVector3D>( props, "RotationPivot", ok );
    if ( ok && RotationPivot.SquareLength() > zero_epsilon ) {
        is_complex = true;

        aiMatrix4x4::Translation( RotationPivot, chain[ TransformationComp_RotationPivot ] );
        aiMatrix4x4::Translation( -RotationPivot, chain[ TransformationComp_RotationPivotInverse ] );
    }

    const aiVector3D& RotationOffset = PropertyGet<aiVector3D>( props, "RotationOffset", ok );
    if ( ok && RotationOffset.SquareLength() > zero_epsilon ) {
        is_complex = true;

        aiMatrix4x4::Translation( RotationOffset, chain[ TransformationComp_RotationOffset ] );
    }

    const aiVector3D& ScalingOffset = PropertyGet<aiVector3D>( props, "ScalingOffset", ok );
    if ( ok && ScalingOffset.SquareLength() > zero_epsilon ) {
        is_complex = true;

        aiMatrix4x4::Translation( ScalingOffset, chain[ TransformationComp_ScalingOffset ] );
    }

    const aiVector3D& ScalingPivot = PropertyGet<aiVector3D>( props, "ScalingPivot", ok );
    if ( ok && ScalingPivot.SquareLength() > zero_epsilon ) {
        is_complex = true;

        aiMatrix4x4::Translation( ScalingPivot, chain[ TransformationComp_ScalingPivot ] );
        aiMatrix4x4::Translation( -ScalingPivot, chain[ TransformationComp_ScalingPivotInverse ] );
    }

    const aiVector3D& Translation = PropertyGet<aiVector3D>( props, "Lcl Translation", ok );
    if ( ok && Translation.SquareLength() > zero_epsilon ) {
        aiMatrix4x4::Translation( Translation, chain[ TransformationComp_Translation ] );
    }

    const aiVector3D& Scaling = PropertyGet<aiVector3D>( props, "Lcl Scaling", ok );
    if ( ok && std::fabs( Scaling.SquareLength() - 1.0f ) > zero_epsilon ) {
        aiMatrix4x4::Scaling( Scaling, chain[ TransformationComp_Scaling ] );
    }

    const aiVector3D& Rotation = PropertyGet<aiVector3D>( props, "Lcl Rotation", ok );
    if ( ok && Rotation.SquareLength() > zero_epsilon ) {
        GetRotationMatrix( rot, Rotation, chain[ TransformationComp_Rotation ] );
    }

    const aiVector3D& GeometricScaling = PropertyGet<aiVector3D>( props, "GeometricScaling", ok );
    if ( ok && std::fabs( GeometricScaling.SquareLength() - 1.0f ) > zero_epsilon ) {
        aiMatrix4x4::Scaling( GeometricScaling, chain[ TransformationComp_GeometricScaling ] );
    }

    const aiVector3D& GeometricRotation = PropertyGet<aiVector3D>( props, "GeometricRotation", ok );
    if ( ok && GeometricRotation.SquareLength() > zero_epsilon ) {
        GetRotationMatrix( rot, GeometricRotation, chain[ TransformationComp_GeometricRotation ] );
    }

    const aiVector3D& GeometricTranslation = PropertyGet<aiVector3D>( props, "GeometricTranslation", ok );
    if ( ok && GeometricTranslation.SquareLength() > zero_epsilon ) {
        aiMatrix4x4::Translation( GeometricTranslation, chain[ TransformationComp_GeometricTranslation ] );
    }

    // is_complex needs to be consistent with NeedsComplexTransformationChain()
    // or the interplay between this code and the animation converter would
    // not be guaranteed.
    ai_assert( NeedsComplexTransformationChain( model ) == is_complex );

    const std::string& name = FixNodeName( model.Name() );

    // now, if we have more than just Translation, Scaling and Rotation,
    // we need to generate a full node chain to accommodate for assimp's
    // lack to express pivots and offsets.
    if ( is_complex && doc.Settings().preservePivots ) {
        FBXImporter::LogInfo( "generating full transformation chain for node: " + name );

        // query the anim_chain_bits dictionary to find out which chain elements
        // have associated node animation channels. These can not be dropped
        // even if they have identity transform in bind pose.
        NodeAnimBitMap::const_iterator it = node_anim_chain_bits.find( name );
        const unsigned int anim_chain_bitmask = ( it == node_anim_chain_bits.end() ? 0 : ( *it ).second );

        unsigned int bit = 0x1;
        for ( size_t i = 0; i < TransformationComp_MAXIMUM; ++i, bit <<= 1 ) {
            const TransformationComp comp = static_cast<TransformationComp>( i );

            if ( chain[ i ].IsIdentity() && ( anim_chain_bitmask & bit ) == 0 ) {
                continue;
            }

            aiNode* nd = new aiNode();
            output_nodes.push_back( nd );

            nd->mName.Set( NameTransformationChainNode( name, comp ) );
            nd->mTransformation = chain[ i ];
        }

        ai_assert( output_nodes.size() );
        return;
    }

    // else, we can just multiply the matrices together
    aiNode* nd = new aiNode();
    output_nodes.push_back( nd );

    nd->mName.Set( name );

    for (const auto &transform : chain) {
        nd->mTransformation = nd->mTransformation * transform;
    }
}


void Converter::SetupNodeMetadata( const Model& model, aiNode& nd )
{
    const PropertyTable& props = model.Props();
    DirectPropertyMap unparsedProperties = props.GetUnparsedProperties();

    // create metadata on node
    std::size_t numStaticMetaData = 2;
    aiMetadata* data = new aiMetadata();
    data->mNumProperties = unparsedProperties.size() + numStaticMetaData;
    data->mKeys = new aiString[ data->mNumProperties ]();
    data->mValues = new aiMetadataEntry[ data->mNumProperties ]();
    nd.mMetaData = data;
    int index = 0;

    // find user defined properties (3ds Max)
    data->Set( index++, "UserProperties", aiString( PropertyGet<std::string>( props, "UDP3DSMAX", "" ) ) );
    // preserve the info that a node was marked as Null node in the original file.
    data->Set( index++, "IsNull", model.IsNull() ? true : false );

    // add unparsed properties to the node's metadata
    for( const DirectPropertyMap::value_type& prop : unparsedProperties ) {

        // Interpret the property as a concrete type
        if ( const TypedProperty<bool>* interpreted = prop.second->As<TypedProperty<bool> >() )
            data->Set( index++, prop.first, interpreted->Value() );
        else if ( const TypedProperty<int>* interpreted = prop.second->As<TypedProperty<int> >() )
            data->Set( index++, prop.first, interpreted->Value() );
        else if ( const TypedProperty<uint64_t>* interpreted = prop.second->As<TypedProperty<uint64_t> >() )
            data->Set( index++, prop.first, interpreted->Value() );
        else if ( const TypedProperty<float>* interpreted = prop.second->As<TypedProperty<float> >() )
            data->Set( index++, prop.first, interpreted->Value() );
        else if ( const TypedProperty<std::string>* interpreted = prop.second->As<TypedProperty<std::string> >() )
            data->Set( index++, prop.first, aiString( interpreted->Value() ) );
        else if ( const TypedProperty<aiVector3D>* interpreted = prop.second->As<TypedProperty<aiVector3D> >() )
            data->Set( index++, prop.first, interpreted->Value() );
        else
            assert( false );
    }
}

void Converter::ConvertModel( const Model& model, aiNode& nd, const aiMatrix4x4& node_global_transform )
{
    const std::vector<const Geometry*>& geos = model.GetGeometry();

    std::vector<unsigned int> meshes;
    meshes.reserve( geos.size() );

    for( const Geometry* geo : geos ) {

        const MeshGeometry* const mesh = dynamic_cast< const MeshGeometry* >( geo );
        if ( mesh ) {
            const std::vector<unsigned int>& indices = ConvertMesh( *mesh, model, node_global_transform );
            std::copy( indices.begin(), indices.end(), std::back_inserter( meshes ) );
        }
        else {
            FBXImporter::LogWarn( "ignoring unrecognized geometry: " + geo->Name() );
        }
    }

    if ( meshes.size() ) {
        nd.mMeshes = new unsigned int[ meshes.size() ]();
        nd.mNumMeshes = static_cast< unsigned int >( meshes.size() );

        std::swap_ranges( meshes.begin(), meshes.end(), nd.mMeshes );
    }
}


std::vector<unsigned int> Converter::ConvertMesh( const MeshGeometry& mesh, const Model& model,
    const aiMatrix4x4& node_global_transform )
{
    std::vector<unsigned int> temp;

    MeshMap::const_iterator it = meshes_converted.find( &mesh );
    if ( it != meshes_converted.end() ) {
        std::copy( ( *it ).second.begin(), ( *it ).second.end(), std::back_inserter( temp ) );
        return temp;
    }

    const std::vector<aiVector3D>& vertices = mesh.GetVertices();
    const std::vector<unsigned int>& faces = mesh.GetFaceIndexCounts();
    if ( vertices.empty() || faces.empty() ) {
        FBXImporter::LogWarn( "ignoring empty geometry: " + mesh.Name() );
        return temp;
    }

    // one material per mesh maps easily to aiMesh. Multiple material
    // meshes need to be split.
    const MatIndexArray& mindices = mesh.GetMaterialIndices();
    if ( doc.Settings().readMaterials && !mindices.empty() ) {
        const MatIndexArray::value_type base = mindices[ 0 ];
        for( MatIndexArray::value_type index : mindices ) {
            if ( index != base ) {
                return ConvertMeshMultiMaterial( mesh, model, node_global_transform );
            }
        }
    }

    // faster code-path, just copy the data
    temp.push_back( ConvertMeshSingleMaterial( mesh, model, node_global_transform ) );
    return temp;
}


aiMesh* Converter::SetupEmptyMesh( const MeshGeometry& mesh )
{
    aiMesh* const out_mesh = new aiMesh();
    meshes.push_back( out_mesh );
    meshes_converted[ &mesh ].push_back( static_cast<unsigned int>( meshes.size() - 1 ) );

    // set name
    std::string name = mesh.Name();
    if ( name.substr( 0, 10 ) == "Geometry::" ) {
        name = name.substr( 10 );
    }

    if ( name.length() ) {
        out_mesh->mName.Set( name );
    }

    return out_mesh;
}


unsigned int Converter::ConvertMeshSingleMaterial( const MeshGeometry& mesh, const Model& model,
    const aiMatrix4x4& node_global_transform )
{
    const MatIndexArray& mindices = mesh.GetMaterialIndices();
    aiMesh* const out_mesh = SetupEmptyMesh( mesh );

    const std::vector<aiVector3D>& vertices = mesh.GetVertices();
    const std::vector<unsigned int>& faces = mesh.GetFaceIndexCounts();

    // copy vertices
    out_mesh->mNumVertices = static_cast<unsigned int>( vertices.size() );
    out_mesh->mVertices = new aiVector3D[ vertices.size() ];
    std::copy( vertices.begin(), vertices.end(), out_mesh->mVertices );

    // generate dummy faces
    out_mesh->mNumFaces = static_cast<unsigned int>( faces.size() );
    aiFace* fac = out_mesh->mFaces = new aiFace[ faces.size() ]();

    unsigned int cursor = 0;
    for( unsigned int pcount : faces ) {
        aiFace& f = *fac++;
        f.mNumIndices = pcount;
        f.mIndices = new unsigned int[ pcount ];
        switch ( pcount )
        {
        case 1:
            out_mesh->mPrimitiveTypes |= aiPrimitiveType_POINT;
            break;
        case 2:
            out_mesh->mPrimitiveTypes |= aiPrimitiveType_LINE;
            break;
        case 3:
            out_mesh->mPrimitiveTypes |= aiPrimitiveType_TRIANGLE;
            break;
        default:
            out_mesh->mPrimitiveTypes |= aiPrimitiveType_POLYGON;
            break;
        }
        for ( unsigned int i = 0; i < pcount; ++i ) {
            f.mIndices[ i ] = cursor++;
        }
    }

    // copy normals
    const std::vector<aiVector3D>& normals = mesh.GetNormals();
    if ( normals.size() ) {
        ai_assert( normals.size() == vertices.size() );

        out_mesh->mNormals = new aiVector3D[ vertices.size() ];
        std::copy( normals.begin(), normals.end(), out_mesh->mNormals );
    }

    // copy tangents - assimp requires both tangents and bitangents (binormals)
    // to be present, or neither of them. Compute binormals from normals
    // and tangents if needed.
    const std::vector<aiVector3D>& tangents = mesh.GetTangents();
    const std::vector<aiVector3D>* binormals = &mesh.GetBinormals();

    if ( tangents.size() ) {
        std::vector<aiVector3D> tempBinormals;
        if ( !binormals->size() ) {
            if ( normals.size() ) {
                tempBinormals.resize( normals.size() );
                for ( unsigned int i = 0; i < tangents.size(); ++i ) {
                    tempBinormals[ i ] = normals[ i ] ^ tangents[ i ];
                }

                binormals = &tempBinormals;
            }
            else {
                binormals = NULL;
            }
        }

        if ( binormals ) {
            ai_assert( tangents.size() == vertices.size() );
            ai_assert( binormals->size() == vertices.size() );

            out_mesh->mTangents = new aiVector3D[ vertices.size() ];
            std::copy( tangents.begin(), tangents.end(), out_mesh->mTangents );

            out_mesh->mBitangents = new aiVector3D[ vertices.size() ];
            std::copy( binormals->begin(), binormals->end(), out_mesh->mBitangents );
        }
    }

    // copy texture coords
    for ( unsigned int i = 0; i < AI_MAX_NUMBER_OF_TEXTURECOORDS; ++i ) {
        const std::vector<aiVector2D>& uvs = mesh.GetTextureCoords( i );
        if ( uvs.empty() ) {
            break;
        }

        aiVector3D* out_uv = out_mesh->mTextureCoords[ i ] = new aiVector3D[ vertices.size() ];
        for( const aiVector2D& v : uvs ) {
            *out_uv++ = aiVector3D( v.x, v.y, 0.0f );
        }

        out_mesh->mNumUVComponents[ i ] = 2;
    }

    // copy vertex colors
    for ( unsigned int i = 0; i < AI_MAX_NUMBER_OF_COLOR_SETS; ++i ) {
        const std::vector<aiColor4D>& colors = mesh.GetVertexColors( i );
        if ( colors.empty() ) {
            break;
        }

        out_mesh->mColors[ i ] = new aiColor4D[ vertices.size() ];
        std::copy( colors.begin(), colors.end(), out_mesh->mColors[ i ] );
    }

    if ( !doc.Settings().readMaterials || mindices.empty() ) {
        FBXImporter::LogError( "no material assigned to mesh, setting default material" );
        out_mesh->mMaterialIndex = GetDefaultMaterial();
    }
    else {
        ConvertMaterialForMesh( out_mesh, model, mesh, mindices[ 0 ] );
    }

    if ( doc.Settings().readWeights && mesh.DeformerSkin() != NULL ) {
        ConvertWeights( out_mesh, model, mesh, node_global_transform, NO_MATERIAL_SEPARATION );
    }

    return static_cast<unsigned int>( meshes.size() - 1 );
}

std::vector<unsigned int> Converter::ConvertMeshMultiMaterial( const MeshGeometry& mesh, const Model& model,
    const aiMatrix4x4& node_global_transform )
{
    const MatIndexArray& mindices = mesh.GetMaterialIndices();
    ai_assert( mindices.size() );

    std::set<MatIndexArray::value_type> had;
    std::vector<unsigned int> indices;

    for( MatIndexArray::value_type index : mindices ) {
        if ( had.find( index ) == had.end() ) {

            indices.push_back( ConvertMeshMultiMaterial( mesh, model, index, node_global_transform ) );
            had.insert( index );
        }
    }

    return indices;
}

unsigned int Converter::ConvertMeshMultiMaterial( const MeshGeometry& mesh, const Model& model,
    MatIndexArray::value_type index,
    const aiMatrix4x4& node_global_transform )
{
    aiMesh* const out_mesh = SetupEmptyMesh( mesh );

    const MatIndexArray& mindices = mesh.GetMaterialIndices();
    const std::vector<aiVector3D>& vertices = mesh.GetVertices();
    const std::vector<unsigned int>& faces = mesh.GetFaceIndexCounts();

    const bool process_weights = doc.Settings().readWeights && mesh.DeformerSkin() != NULL;

    unsigned int count_faces = 0;
    unsigned int count_vertices = 0;

    // count faces
    std::vector<unsigned int>::const_iterator itf = faces.begin();
    for ( MatIndexArray::const_iterator it = mindices.begin(),
        end = mindices.end(); it != end; ++it, ++itf )
    {
        if ( ( *it ) != index ) {
            continue;
        }
        ++count_faces;
        count_vertices += *itf;
    }

    ai_assert( count_faces );
    ai_assert( count_vertices );

    // mapping from output indices to DOM indexing, needed to resolve weights
    std::vector<unsigned int> reverseMapping;

    if ( process_weights ) {
        reverseMapping.resize( count_vertices );
    }

    // allocate output data arrays, but don't fill them yet
    out_mesh->mNumVertices = count_vertices;
    out_mesh->mVertices = new aiVector3D[ count_vertices ];

    out_mesh->mNumFaces = count_faces;
    aiFace* fac = out_mesh->mFaces = new aiFace[ count_faces ]();


    // allocate normals
    const std::vector<aiVector3D>& normals = mesh.GetNormals();
    if ( normals.size() ) {
        ai_assert( normals.size() == vertices.size() );
        out_mesh->mNormals = new aiVector3D[ vertices.size() ];
    }

    // allocate tangents, binormals.
    const std::vector<aiVector3D>& tangents = mesh.GetTangents();
    const std::vector<aiVector3D>* binormals = &mesh.GetBinormals();

    if ( tangents.size() ) {
        std::vector<aiVector3D> tempBinormals;
        if ( !binormals->size() ) {
            if ( normals.size() ) {
                // XXX this computes the binormals for the entire mesh, not only
                // the part for which we need them.
                tempBinormals.resize( normals.size() );
                for ( unsigned int i = 0; i < tangents.size(); ++i ) {
                    tempBinormals[ i ] = normals[ i ] ^ tangents[ i ];
                }

                binormals = &tempBinormals;
            }
            else {
                binormals = NULL;
            }
        }

        if ( binormals ) {
            ai_assert( tangents.size() == vertices.size() && binormals->size() == vertices.size() );

            out_mesh->mTangents = new aiVector3D[ vertices.size() ];
            out_mesh->mBitangents = new aiVector3D[ vertices.size() ];
        }
    }

    // allocate texture coords
    unsigned int num_uvs = 0;
    for ( unsigned int i = 0; i < AI_MAX_NUMBER_OF_TEXTURECOORDS; ++i, ++num_uvs ) {
        const std::vector<aiVector2D>& uvs = mesh.GetTextureCoords( i );
        if ( uvs.empty() ) {
            break;
        }

        out_mesh->mTextureCoords[ i ] = new aiVector3D[ vertices.size() ];
        out_mesh->mNumUVComponents[ i ] = 2;
    }

    // allocate vertex colors
    unsigned int num_vcs = 0;
    for ( unsigned int i = 0; i < AI_MAX_NUMBER_OF_COLOR_SETS; ++i, ++num_vcs ) {
        const std::vector<aiColor4D>& colors = mesh.GetVertexColors( i );
        if ( colors.empty() ) {
            break;
        }

        out_mesh->mColors[ i ] = new aiColor4D[ vertices.size() ];
    }

    unsigned int cursor = 0, in_cursor = 0;

    itf = faces.begin();
    for ( MatIndexArray::const_iterator it = mindices.begin(),
        end = mindices.end(); it != end; ++it, ++itf )
    {
        const unsigned int pcount = *itf;
        if ( ( *it ) != index ) {
            in_cursor += pcount;
            continue;
        }

        aiFace& f = *fac++;

        f.mNumIndices = pcount;
        f.mIndices = new unsigned int[ pcount ];
        switch ( pcount )
        {
        case 1:
            out_mesh->mPrimitiveTypes |= aiPrimitiveType_POINT;
            break;
        case 2:
            out_mesh->mPrimitiveTypes |= aiPrimitiveType_LINE;
            break;
        case 3:
            out_mesh->mPrimitiveTypes |= aiPrimitiveType_TRIANGLE;
            break;
        default:
            out_mesh->mPrimitiveTypes |= aiPrimitiveType_POLYGON;
            break;
        }
        for ( unsigned int i = 0; i < pcount; ++i, ++cursor, ++in_cursor ) {
            f.mIndices[ i ] = cursor;

            if ( reverseMapping.size() ) {
                reverseMapping[ cursor ] = in_cursor;
            }

            out_mesh->mVertices[ cursor ] = vertices[ in_cursor ];

            if ( out_mesh->mNormals ) {
                out_mesh->mNormals[ cursor ] = normals[ in_cursor ];
            }

            if ( out_mesh->mTangents ) {
                out_mesh->mTangents[ cursor ] = tangents[ in_cursor ];
                out_mesh->mBitangents[ cursor ] = ( *binormals )[ in_cursor ];
            }

            for ( unsigned int i = 0; i < num_uvs; ++i ) {
                const std::vector<aiVector2D>& uvs = mesh.GetTextureCoords( i );
                out_mesh->mTextureCoords[ i ][ cursor ] = aiVector3D( uvs[ in_cursor ].x, uvs[ in_cursor ].y, 0.0f );
            }

            for ( unsigned int i = 0; i < num_vcs; ++i ) {
                const std::vector<aiColor4D>& cols = mesh.GetVertexColors( i );
                out_mesh->mColors[ i ][ cursor ] = cols[ in_cursor ];
            }
        }
    }

    ConvertMaterialForMesh( out_mesh, model, mesh, index );

    if ( process_weights ) {
        ConvertWeights( out_mesh, model, mesh, node_global_transform, index, &reverseMapping );
    }

    return static_cast<unsigned int>( meshes.size() - 1 );
}


void Converter::ConvertWeights( aiMesh* out, const Model& model, const MeshGeometry& geo,
    const aiMatrix4x4& node_global_transform ,
    unsigned int materialIndex,
    std::vector<unsigned int>* outputVertStartIndices  )
{
    ai_assert( geo.DeformerSkin() );

    std::vector<size_t> out_indices;
    std::vector<size_t> index_out_indices;
    std::vector<size_t> count_out_indices;

    const Skin& sk = *geo.DeformerSkin();

    std::vector<aiBone*> bones;
    bones.reserve( sk.Clusters().size() );

    const bool no_mat_check = materialIndex == NO_MATERIAL_SEPARATION;
    ai_assert( no_mat_check || outputVertStartIndices );

    try {

        for( const Cluster* cluster : sk.Clusters() ) {
            ai_assert( cluster );

            const WeightIndexArray& indices = cluster->GetIndices();

            if ( indices.empty() ) {
                continue;
            }

            const MatIndexArray& mats = geo.GetMaterialIndices();

            bool ok = false;

            const size_t no_index_sentinel = std::numeric_limits<size_t>::max();

            count_out_indices.clear();
            index_out_indices.clear();
            out_indices.clear();

            // now check if *any* of these weights is contained in the output mesh,
            // taking notes so we don't need to do it twice.
            for( WeightIndexArray::value_type index : indices ) {

                unsigned int count = 0;
                const unsigned int* const out_idx = geo.ToOutputVertexIndex( index, count );
                // ToOutputVertexIndex only returns NULL if index is out of bounds
                // which should never happen
                ai_assert( out_idx != NULL );

                index_out_indices.push_back( no_index_sentinel );
                count_out_indices.push_back( 0 );

                for ( unsigned int i = 0; i < count; ++i ) {
                    if ( no_mat_check || static_cast<size_t>( mats[ geo.FaceForVertexIndex( out_idx[ i ] ) ] ) == materialIndex ) {

                        if ( index_out_indices.back() == no_index_sentinel ) {
                            index_out_indices.back() = out_indices.size();

                        }

                        if ( no_mat_check ) {
                            out_indices.push_back( out_idx[ i ] );
                        }
                        else {
                            // this extra lookup is in O(logn), so the entire algorithm becomes O(nlogn)
                            const std::vector<unsigned int>::iterator it = std::lower_bound(
                                outputVertStartIndices->begin(),
                                outputVertStartIndices->end(),
                                out_idx[ i ]
                                );

                            out_indices.push_back( std::distance( outputVertStartIndices->begin(), it ) );
                        }

                        ++count_out_indices.back();
                        ok = true;
                    }
                }
            }

            // if we found at least one, generate the output bones
            // XXX this could be heavily simplified by collecting the bone
            // data in a single step.
            if ( ok ) {
                ConvertCluster( bones, model, *cluster, out_indices, index_out_indices,
                    count_out_indices, node_global_transform );
            }
        }
    }
    catch ( std::exception& ) {
        std::for_each( bones.begin(), bones.end(), Util::delete_fun<aiBone>() );
        throw;
    }

    if ( bones.empty() ) {
        return;
    }

    out->mBones = new aiBone*[ bones.size() ]();
    out->mNumBones = static_cast<unsigned int>( bones.size() );

    std::swap_ranges( bones.begin(), bones.end(), out->mBones );
}

void Converter::ConvertCluster( std::vector<aiBone*>& bones, const Model& /*model*/, const Cluster& cl,
        std::vector<size_t>& out_indices,
        std::vector<size_t>& index_out_indices,
        std::vector<size_t>& count_out_indices,
        const aiMatrix4x4& node_global_transform )
{

    aiBone* const bone = new aiBone();
    bones.push_back( bone );

    bone->mName = FixNodeName( cl.TargetNode()->Name() );

    bone->mOffsetMatrix = cl.TransformLink();
    bone->mOffsetMatrix.Inverse();

    bone->mOffsetMatrix = bone->mOffsetMatrix * node_global_transform;

    bone->mNumWeights = static_cast<unsigned int>( out_indices.size() );
    aiVertexWeight* cursor = bone->mWeights = new aiVertexWeight[ out_indices.size() ];

    const size_t no_index_sentinel = std::numeric_limits<size_t>::max();
    const WeightArray& weights = cl.GetWeights();

    const size_t c = index_out_indices.size();
    for ( size_t i = 0; i < c; ++i ) {
        const size_t index_index = index_out_indices[ i ];

        if ( index_index == no_index_sentinel ) {
            continue;
        }

        const size_t cc = count_out_indices[ i ];
        for ( size_t j = 0; j < cc; ++j ) {
            aiVertexWeight& out_weight = *cursor++;

            out_weight.mVertexId = static_cast<unsigned int>( out_indices[ index_index + j ] );
            out_weight.mWeight = weights[ i ];
        }
    }
}


void Converter::ConvertMaterialForMesh( aiMesh* out, const Model& model, const MeshGeometry& geo,
    MatIndexArray::value_type materialIndex )
{
    // locate source materials for this mesh
    const std::vector<const Material*>& mats = model.GetMaterials();
    if ( static_cast<unsigned int>( materialIndex ) >= mats.size() || materialIndex < 0 ) {
        FBXImporter::LogError( "material index out of bounds, setting default material" );
        out->mMaterialIndex = GetDefaultMaterial();
        return;
    }

    const Material* const mat = mats[ materialIndex ];
    MaterialMap::const_iterator it = materials_converted.find( mat );
    if ( it != materials_converted.end() ) {
        out->mMaterialIndex = ( *it ).second;
        return;
    }

    out->mMaterialIndex = ConvertMaterial( *mat, &geo );
    materials_converted[ mat ] = out->mMaterialIndex;
}

unsigned int Converter::GetDefaultMaterial()
{
    if ( defaultMaterialIndex ) {
        return defaultMaterialIndex - 1;
    }

    aiMaterial* out_mat = new aiMaterial();
    materials.push_back( out_mat );

    const aiColor3D diffuse = aiColor3D( 0.8f, 0.8f, 0.8f );
    out_mat->AddProperty( &diffuse, 1, AI_MATKEY_COLOR_DIFFUSE );

    aiString s;
    s.Set( AI_DEFAULT_MATERIAL_NAME );

    out_mat->AddProperty( &s, AI_MATKEY_NAME );

    defaultMaterialIndex = static_cast< unsigned int >( materials.size() );
    return defaultMaterialIndex - 1;
}


unsigned int Converter::ConvertMaterial( const Material& material, const MeshGeometry* const mesh )
{
    const PropertyTable& props = material.Props();

    // generate empty output material
    aiMaterial* out_mat = new aiMaterial();
    materials_converted[ &material ] = static_cast<unsigned int>( materials.size() );

    materials.push_back( out_mat );

    aiString str;

    // stip Material:: prefix
    std::string name = material.Name();
    if ( name.substr( 0, 10 ) == "Material::" ) {
        name = name.substr( 10 );
    }

    // set material name if not empty - this could happen
    // and there should be no key for it in this case.
    if ( name.length() ) {
        str.Set( name );
        out_mat->AddProperty( &str, AI_MATKEY_NAME );
    }

    // shading stuff and colors
    SetShadingPropertiesCommon( out_mat, props );

    // texture assignments
    SetTextureProperties( out_mat, material.Textures(), mesh );
    SetTextureProperties( out_mat, material.LayeredTextures(), mesh );

    return static_cast<unsigned int>( materials.size() - 1 );
}

unsigned int Converter::ConvertVideo( const Video& video )
{
    // generate empty output texture
    aiTexture* out_tex = new aiTexture();
    textures.push_back( out_tex );

    // assuming the texture is compressed
    out_tex->mWidth = static_cast<unsigned int>( video.ContentLength() ); // total data size
    out_tex->mHeight = 0; // fixed to 0

                            // steal the data from the Video to avoid an additional copy
    out_tex->pcData = reinterpret_cast<aiTexel*>( const_cast<Video&>( video ).RelinquishContent() );

    // try to extract a hint from the file extension
    const std::string& filename = video.FileName().empty() ? video.RelativeFilename() : video.FileName();
    std::string ext = BaseImporter::GetExtension( filename );

    if ( ext == "jpeg" ) {
        ext = "jpg";
    }

    if ( ext.size() <= 3 ) {
        memcpy( out_tex->achFormatHint, ext.c_str(), ext.size() );
    }

    return static_cast<unsigned int>( textures.size() - 1 );
}

void Converter::TrySetTextureProperties( aiMaterial* out_mat, const TextureMap& textures,
    const std::string& propName,
    aiTextureType target, const MeshGeometry* const mesh )
{
    TextureMap::const_iterator it = textures.find( propName );
    if ( it == textures.end() ) {
        return;
    }

    const Texture* const tex = ( *it ).second;
    if ( tex != 0 )
    {
        aiString path;
        path.Set( tex->RelativeFilename() );

        const Video* media = tex->Media();
        if ( media != 0 && media->ContentLength() > 0 ) {
            unsigned int index;

            VideoMap::const_iterator it = textures_converted.find( media );
            if ( it != textures_converted.end() ) {
                index = ( *it ).second;
            }
            else {
                index = ConvertVideo( *media );
                textures_converted[ media ] = index;
            }

            // setup texture reference string (copied from ColladaLoader::FindFilenameForEffectTexture)
            path.data[ 0 ] = '*';
            path.length = 1 + ASSIMP_itoa10( path.data + 1, MAXLEN - 1, index );
        }

        out_mat->AddProperty( &path, _AI_MATKEY_TEXTURE_BASE, target, 0 );

        aiUVTransform uvTrafo;
        // XXX handle all kinds of UV transformations
        uvTrafo.mScaling = tex->UVScaling();
        uvTrafo.mTranslation = tex->UVTranslation();
        out_mat->AddProperty( &uvTrafo, 1, _AI_MATKEY_UVTRANSFORM_BASE, target, 0 );

        const PropertyTable& props = tex->Props();

        int uvIndex = 0;

        bool ok;
        const std::string& uvSet = PropertyGet<std::string>( props, "UVSet", ok );
        if ( ok ) {
            // "default" is the name which usually appears in the FbxFileTexture template
            if ( uvSet != "default" && uvSet.length() ) {
                // this is a bit awkward - we need to find a mesh that uses this
                // material and scan its UV channels for the given UV name because
                // assimp references UV channels by index, not by name.

                // XXX: the case that UV channels may appear in different orders
                // in meshes is unhandled. A possible solution would be to sort
                // the UV channels alphabetically, but this would have the side
                // effect that the primary (first) UV channel would sometimes
                // be moved, causing trouble when users read only the first
                // UV channel and ignore UV channel assignments altogether.

                const unsigned int matIndex = static_cast<unsigned int>( std::distance( materials.begin(),
                    std::find( materials.begin(), materials.end(), out_mat )
                    ) );


                uvIndex = -1;
                if ( !mesh )
                {
                    for( const MeshMap::value_type& v : meshes_converted ) {
                        const MeshGeometry* const mesh = dynamic_cast<const MeshGeometry*> ( v.first );
                        if ( !mesh ) {
                            continue;
                        }

                        const MatIndexArray& mats = mesh->GetMaterialIndices();
                        if ( std::find( mats.begin(), mats.end(), matIndex ) == mats.end() ) {
                            continue;
                        }

                        int index = -1;
                        for ( unsigned int i = 0; i < AI_MAX_NUMBER_OF_TEXTURECOORDS; ++i ) {
                            if ( mesh->GetTextureCoords( i ).empty() ) {
                                break;
                            }
                            const std::string& name = mesh->GetTextureCoordChannelName( i );
                            if ( name == uvSet ) {
                                index = static_cast<int>( i );
                                break;
                            }
                        }
                        if ( index == -1 ) {
                            FBXImporter::LogWarn( "did not find UV channel named " + uvSet + " in a mesh using this material" );
                            continue;
                        }

                        if ( uvIndex == -1 ) {
                            uvIndex = index;
                        }
                        else {
                            FBXImporter::LogWarn( "the UV channel named " + uvSet +
                                " appears at different positions in meshes, results will be wrong" );
                        }
                    }
                }
                else
                {
                    int index = -1;
                    for ( unsigned int i = 0; i < AI_MAX_NUMBER_OF_TEXTURECOORDS; ++i ) {
                        if ( mesh->GetTextureCoords( i ).empty() ) {
                            break;
                        }
                        const std::string& name = mesh->GetTextureCoordChannelName( i );
                        if ( name == uvSet ) {
                            index = static_cast<int>( i );
                            break;
                        }
                    }
                    if ( index == -1 ) {
                        FBXImporter::LogWarn( "did not find UV channel named " + uvSet + " in a mesh using this material" );
                    }

                    if ( uvIndex == -1 ) {
                        uvIndex = index;
                    }
                }

                if ( uvIndex == -1 ) {
                    FBXImporter::LogWarn( "failed to resolve UV channel " + uvSet + ", using first UV channel" );
                    uvIndex = 0;
                }
            }
        }

        out_mat->AddProperty( &uvIndex, 1, _AI_MATKEY_UVWSRC_BASE, target, 0 );
    }
}

void Converter::TrySetTextureProperties( aiMaterial* out_mat, const LayeredTextureMap& layeredTextures,
    const std::string& propName,
    aiTextureType target, const MeshGeometry* const mesh )
{
    LayeredTextureMap::const_iterator it = layeredTextures.find( propName );
    if ( it == layeredTextures.end() ) {
        return;
    }

    const Texture* const tex = ( *it ).second->getTexture();

    aiString path;
    path.Set( tex->RelativeFilename() );

    out_mat->AddProperty( &path, _AI_MATKEY_TEXTURE_BASE, target, 0 );

    aiUVTransform uvTrafo;
    // XXX handle all kinds of UV transformations
    uvTrafo.mScaling = tex->UVScaling();
    uvTrafo.mTranslation = tex->UVTranslation();
    out_mat->AddProperty( &uvTrafo, 1, _AI_MATKEY_UVTRANSFORM_BASE, target, 0 );

    const PropertyTable& props = tex->Props();

    int uvIndex = 0;

    bool ok;
    const std::string& uvSet = PropertyGet<std::string>( props, "UVSet", ok );
    if ( ok ) {
        // "default" is the name which usually appears in the FbxFileTexture template
        if ( uvSet != "default" && uvSet.length() ) {
            // this is a bit awkward - we need to find a mesh that uses this
            // material and scan its UV channels for the given UV name because
            // assimp references UV channels by index, not by name.

            // XXX: the case that UV channels may appear in different orders
            // in meshes is unhandled. A possible solution would be to sort
            // the UV channels alphabetically, but this would have the side
            // effect that the primary (first) UV channel would sometimes
            // be moved, causing trouble when users read only the first
            // UV channel and ignore UV channel assignments altogether.

            const unsigned int matIndex = static_cast<unsigned int>( std::distance( materials.begin(),
                std::find( materials.begin(), materials.end(), out_mat )
                ) );

            uvIndex = -1;
            if ( !mesh )
            {
                for( const MeshMap::value_type& v : meshes_converted ) {
                    const MeshGeometry* const mesh = dynamic_cast<const MeshGeometry*> ( v.first );
                    if ( !mesh ) {
                        continue;
                    }

                    const MatIndexArray& mats = mesh->GetMaterialIndices();
                    if ( std::find( mats.begin(), mats.end(), matIndex ) == mats.end() ) {
                        continue;
                    }

                    int index = -1;
                    for ( unsigned int i = 0; i < AI_MAX_NUMBER_OF_TEXTURECOORDS; ++i ) {
                        if ( mesh->GetTextureCoords( i ).empty() ) {
                            break;
                        }
                        const std::string& name = mesh->GetTextureCoordChannelName( i );
                        if ( name == uvSet ) {
                            index = static_cast<int>( i );
                            break;
                        }
                    }
                    if ( index == -1 ) {
                        FBXImporter::LogWarn( "did not find UV channel named " + uvSet + " in a mesh using this material" );
                        continue;
                    }

                    if ( uvIndex == -1 ) {
                        uvIndex = index;
                    }
                    else {
                        FBXImporter::LogWarn( "the UV channel named " + uvSet +
                            " appears at different positions in meshes, results will be wrong" );
                    }
                }
            }
            else
            {
                int index = -1;
                for ( unsigned int i = 0; i < AI_MAX_NUMBER_OF_TEXTURECOORDS; ++i ) {
                    if ( mesh->GetTextureCoords( i ).empty() ) {
                        break;
                    }
                    const std::string& name = mesh->GetTextureCoordChannelName( i );
                    if ( name == uvSet ) {
                        index = static_cast<int>( i );
                        break;
                    }
                }
                if ( index == -1 ) {
                    FBXImporter::LogWarn( "did not find UV channel named " + uvSet + " in a mesh using this material" );
                }

                if ( uvIndex == -1 ) {
                    uvIndex = index;
                }
            }

            if ( uvIndex == -1 ) {
                FBXImporter::LogWarn( "failed to resolve UV channel " + uvSet + ", using first UV channel" );
                uvIndex = 0;
            }
        }
    }

    out_mat->AddProperty( &uvIndex, 1, _AI_MATKEY_UVWSRC_BASE, target, 0 );
}

void Converter::SetTextureProperties( aiMaterial* out_mat, const TextureMap& textures, const MeshGeometry* const mesh )
{
    TrySetTextureProperties( out_mat, textures, "DiffuseColor", aiTextureType_DIFFUSE, mesh );
    TrySetTextureProperties( out_mat, textures, "AmbientColor", aiTextureType_AMBIENT, mesh );
    TrySetTextureProperties( out_mat, textures, "EmissiveColor", aiTextureType_EMISSIVE, mesh );
    TrySetTextureProperties( out_mat, textures, "SpecularColor", aiTextureType_SPECULAR, mesh );
    TrySetTextureProperties( out_mat, textures, "TransparentColor", aiTextureType_OPACITY, mesh );
    TrySetTextureProperties( out_mat, textures, "ReflectionColor", aiTextureType_REFLECTION, mesh );
    TrySetTextureProperties( out_mat, textures, "DisplacementColor", aiTextureType_DISPLACEMENT, mesh );
    TrySetTextureProperties( out_mat, textures, "NormalMap", aiTextureType_NORMALS, mesh );
    TrySetTextureProperties( out_mat, textures, "Bump", aiTextureType_HEIGHT, mesh );
    TrySetTextureProperties( out_mat, textures, "ShininessExponent", aiTextureType_SHININESS, mesh );
}

void Converter::SetTextureProperties( aiMaterial* out_mat, const LayeredTextureMap& layeredTextures, const MeshGeometry* const mesh )
{
    TrySetTextureProperties( out_mat, layeredTextures, "DiffuseColor", aiTextureType_DIFFUSE, mesh );
    TrySetTextureProperties( out_mat, layeredTextures, "AmbientColor", aiTextureType_AMBIENT, mesh );
    TrySetTextureProperties( out_mat, layeredTextures, "EmissiveColor", aiTextureType_EMISSIVE, mesh );
    TrySetTextureProperties( out_mat, layeredTextures, "SpecularColor", aiTextureType_SPECULAR, mesh );
    TrySetTextureProperties( out_mat, layeredTextures, "TransparentColor", aiTextureType_OPACITY, mesh );
    TrySetTextureProperties( out_mat, layeredTextures, "ReflectionColor", aiTextureType_REFLECTION, mesh );
    TrySetTextureProperties( out_mat, layeredTextures, "DisplacementColor", aiTextureType_DISPLACEMENT, mesh );
    TrySetTextureProperties( out_mat, layeredTextures, "NormalMap", aiTextureType_NORMALS, mesh );
    TrySetTextureProperties( out_mat, layeredTextures, "Bump", aiTextureType_HEIGHT, mesh );
    TrySetTextureProperties( out_mat, layeredTextures, "ShininessExponent", aiTextureType_SHININESS, mesh );
}

aiColor3D Converter::GetColorPropertyFromMaterial( const PropertyTable& props, const std::string& baseName,
    bool& result )
{
    result = true;

    bool ok;
    const aiVector3D& Diffuse = PropertyGet<aiVector3D>( props, baseName, ok );
    if ( ok ) {
        return aiColor3D( Diffuse.x, Diffuse.y, Diffuse.z );
    }
    else {
        aiVector3D DiffuseColor = PropertyGet<aiVector3D>( props, baseName + "Color", ok );
        if ( ok ) {
            float DiffuseFactor = PropertyGet<float>( props, baseName + "Factor", ok );
            if ( ok ) {
                DiffuseColor *= DiffuseFactor;
            }

            return aiColor3D( DiffuseColor.x, DiffuseColor.y, DiffuseColor.z );
        }
    }
    result = false;
    return aiColor3D( 0.0f, 0.0f, 0.0f );
}


void Converter::SetShadingPropertiesCommon( aiMaterial* out_mat, const PropertyTable& props )
{
    // set shading properties. There are various, redundant ways in which FBX materials
    // specify their shading settings (depending on shading models, prop
    // template etc.). No idea which one is right in a particular context.
    // Just try to make sense of it - there's no spec to verify this against,
    // so why should we.
    bool ok;
    const aiColor3D& Diffuse = GetColorPropertyFromMaterial( props, "Diffuse", ok );
    if ( ok ) {
        out_mat->AddProperty( &Diffuse, 1, AI_MATKEY_COLOR_DIFFUSE );
    }

    const aiColor3D& Emissive = GetColorPropertyFromMaterial( props, "Emissive", ok );
    if ( ok ) {
        out_mat->AddProperty( &Emissive, 1, AI_MATKEY_COLOR_EMISSIVE );
    }

    const aiColor3D& Ambient = GetColorPropertyFromMaterial( props, "Ambient", ok );
    if ( ok ) {
        out_mat->AddProperty( &Ambient, 1, AI_MATKEY_COLOR_AMBIENT );
    }

    const aiColor3D& Specular = GetColorPropertyFromMaterial( props, "Specular", ok );
    if ( ok ) {
        out_mat->AddProperty( &Specular, 1, AI_MATKEY_COLOR_SPECULAR );
    }

    const float Opacity = PropertyGet<float>( props, "Opacity", ok );
    if ( ok ) {
        out_mat->AddProperty( &Opacity, 1, AI_MATKEY_OPACITY );
    }

    const float Reflectivity = PropertyGet<float>( props, "Reflectivity", ok );
    if ( ok ) {
        out_mat->AddProperty( &Reflectivity, 1, AI_MATKEY_REFLECTIVITY );
    }

    const float Shininess = PropertyGet<float>( props, "Shininess", ok );
    if ( ok ) {
        out_mat->AddProperty( &Shininess, 1, AI_MATKEY_SHININESS_STRENGTH );
    }

    const float ShininessExponent = PropertyGet<float>( props, "ShininessExponent", ok );
    if ( ok ) {
        out_mat->AddProperty( &ShininessExponent, 1, AI_MATKEY_SHININESS );
    }
}


double Converter::FrameRateToDouble( FileGlobalSettings::FrameRate fp, double customFPSVal )
{
    switch ( fp ) {
    case FileGlobalSettings::FrameRate_DEFAULT:
        return 1.0;

    case FileGlobalSettings::FrameRate_120:
        return 120.0;

    case FileGlobalSettings::FrameRate_100:
        return 100.0;

    case FileGlobalSettings::FrameRate_60:
        return 60.0;

    case FileGlobalSettings::FrameRate_50:
        return 50.0;

    case FileGlobalSettings::FrameRate_48:
        return 48.0;

    case FileGlobalSettings::FrameRate_30:
    case FileGlobalSettings::FrameRate_30_DROP:
        return 30.0;

    case FileGlobalSettings::FrameRate_NTSC_DROP_FRAME:
    case FileGlobalSettings::FrameRate_NTSC_FULL_FRAME:
        return 29.9700262;

    case FileGlobalSettings::FrameRate_PAL:
        return 25.0;

    case FileGlobalSettings::FrameRate_CINEMA:
        return 24.0;

    case FileGlobalSettings::FrameRate_1000:
        return 1000.0;

    case FileGlobalSettings::FrameRate_CINEMA_ND:
        return 23.976;

    case FileGlobalSettings::FrameRate_CUSTOM:
        return customFPSVal;

    case FileGlobalSettings::FrameRate_MAX: // this is to silence compiler warnings
        break;
    }

    ai_assert( false );
    return -1.0f;
}


void Converter::ConvertAnimations()
{
    // first of all determine framerate
    const FileGlobalSettings::FrameRate fps = doc.GlobalSettings().TimeMode();
    const float custom = doc.GlobalSettings().CustomFrameRate();
    anim_fps = FrameRateToDouble( fps, custom );

    const std::vector<const AnimationStack*>& animations = doc.AnimationStacks();
    for( const AnimationStack* stack : animations ) {
        ConvertAnimationStack( *stack );
    }
}


void Converter::RenameNode( const std::string& fixed_name, const std::string& new_name )
{
    ai_assert( node_names.find( fixed_name ) != node_names.end() );
    ai_assert( node_names.find( new_name ) == node_names.end() );

    renamed_nodes[ fixed_name ] = new_name;

    const aiString fn( fixed_name );

    for( aiCamera* cam : cameras ) {
        if ( cam->mName == fn ) {
            cam->mName.Set( new_name );
            break;
        }
    }

    for( aiLight* light : lights ) {
        if ( light->mName == fn ) {
            light->mName.Set( new_name );
            break;
        }
    }

    for( aiAnimation* anim : animations ) {
        for ( unsigned int i = 0; i < anim->mNumChannels; ++i ) {
            aiNodeAnim* const na = anim->mChannels[ i ];
            if ( na->mNodeName == fn ) {
                na->mNodeName.Set( new_name );
                break;
            }
        }
    }
}


std::string Converter::FixNodeName( const std::string& name )
{
    // strip Model:: prefix, avoiding ambiguities (i.e. don't strip if
    // this causes ambiguities, well possible between empty identifiers,
    // such as "Model::" and ""). Make sure the behaviour is consistent
    // across multiple calls to FixNodeName().
    if ( name.substr( 0, 7 ) == "Model::" ) {
        std::string temp = name.substr( 7 );

        const NodeNameMap::const_iterator it = node_names.find( temp );
        if ( it != node_names.end() ) {
            if ( !( *it ).second ) {
                return FixNodeName( name + "_" );
            }
        }
        node_names[ temp ] = true;

        const NameNameMap::const_iterator rit = renamed_nodes.find( temp );
        return rit == renamed_nodes.end() ? temp : ( *rit ).second;
    }

    const NodeNameMap::const_iterator it = node_names.find( name );
    if ( it != node_names.end() ) {
        if ( ( *it ).second ) {
            return FixNodeName( name + "_" );
        }
    }
    node_names[ name ] = false;

    const NameNameMap::const_iterator rit = renamed_nodes.find( name );
    return rit == renamed_nodes.end() ? name : ( *rit ).second;
}

void Converter::ConvertAnimationStack( const AnimationStack& st )
{
    const AnimationLayerList& layers = st.Layers();
    if ( layers.empty() ) {
        return;
    }

    aiAnimation* const anim = new aiAnimation();
    animations.push_back( anim );

    // strip AnimationStack:: prefix
    std::string name = st.Name();
    if ( name.substr( 0, 16 ) == "AnimationStack::" ) {
        name = name.substr( 16 );
    }
    else if ( name.substr( 0, 11 ) == "AnimStack::" ) {
        name = name.substr( 11 );
    }

    anim->mName.Set( name );

    // need to find all nodes for which we need to generate node animations -
    // it may happen that we need to merge multiple layers, though.
    NodeMap node_map;

    // reverse mapping from curves to layers, much faster than querying
    // the FBX DOM for it.
    LayerMap layer_map;

    const char* prop_whitelist[] = {
        "Lcl Scaling",
        "Lcl Rotation",
        "Lcl Translation"
    };

    for( const AnimationLayer* layer : layers ) {
        ai_assert( layer );

        const AnimationCurveNodeList& nodes = layer->Nodes( prop_whitelist, 3 );
        for( const AnimationCurveNode* node : nodes ) {
            ai_assert( node );

            const Model* const model = dynamic_cast<const Model*>( node->Target() );
            // this can happen - it could also be a NodeAttribute (i.e. for camera animations)
            if ( !model ) {
                continue;
            }

            const std::string& name = FixNodeName( model->Name() );
            node_map[ name ].push_back( node );

            layer_map[ node ] = layer;
        }
    }

    // generate node animations
    std::vector<aiNodeAnim*> node_anims;

    double min_time = 1e10;
    double max_time = -1e10;

    int64_t start_time = st.LocalStart();
    int64_t stop_time = st.LocalStop();
    double start_timeF = CONVERT_FBX_TIME( start_time );
    double stop_timeF = CONVERT_FBX_TIME( stop_time );

    try {
        for( const NodeMap::value_type& kv : node_map ) {
            GenerateNodeAnimations( node_anims,
                kv.first,
                kv.second,
                layer_map,
                start_time, stop_time,
                max_time,
                min_time );
        }
    }
    catch ( std::exception& ) {
        std::for_each( node_anims.begin(), node_anims.end(), Util::delete_fun<aiNodeAnim>() );
        throw;
    }

    if ( node_anims.size() ) {
        anim->mChannels = new aiNodeAnim*[ node_anims.size() ]();
        anim->mNumChannels = static_cast<unsigned int>( node_anims.size() );

        std::swap_ranges( node_anims.begin(), node_anims.end(), anim->mChannels );
    }
    else {
        // empty animations would fail validation, so drop them
        delete anim;
        animations.pop_back();
        FBXImporter::LogInfo( "ignoring empty AnimationStack (using IK?): " + name );
        return;
    }

    //adjust relative timing for animation
    {
        double start_fps = start_timeF * anim_fps;

        for ( unsigned int c = 0; c < anim->mNumChannels; c++ )
        {
            aiNodeAnim* channel = anim->mChannels[ c ];
            for ( uint32_t i = 0; i < channel->mNumPositionKeys; i++ )
                channel->mPositionKeys[ i ].mTime -= start_fps;
            for ( uint32_t i = 0; i < channel->mNumRotationKeys; i++ )
                channel->mRotationKeys[ i ].mTime -= start_fps;
            for ( uint32_t i = 0; i < channel->mNumScalingKeys; i++ )
                channel->mScalingKeys[ i ].mTime -= start_fps;
        }

        max_time -= min_time;
    }

    // for some mysterious reason, mDuration is simply the maximum key -- the
    // validator always assumes animations to start at zero.
    anim->mDuration = ( stop_timeF - start_timeF ) * anim_fps;
    anim->mTicksPerSecond = anim_fps;
}

// ------------------------------------------------------------------------------------------------
// sanity check whether the input is ok
static void validateAnimCurveNodes( const std::vector<const AnimationCurveNode*>& curves,
    bool strictMode ) {
    const Object* target( NULL );
    for( const AnimationCurveNode* node : curves ) {
        if ( !target ) {
            target = node->Target();
        }
        if ( node->Target() != target ) {
            FBXImporter::LogWarn( "Node target is nullptr type." );
        }
        if ( strictMode ) {
            ai_assert( node->Target() == target );
        }
    }
}

// ------------------------------------------------------------------------------------------------
void Converter::GenerateNodeAnimations( std::vector<aiNodeAnim*>& node_anims,
    const std::string& fixed_name,
    const std::vector<const AnimationCurveNode*>& curves,
    const LayerMap& layer_map,
    int64_t start, int64_t stop,
    double& max_time,
    double& min_time )
{

    NodeMap node_property_map;
    ai_assert( curves.size() );

#ifdef ASSIMP_BUILD_DEBUG
    validateAnimCurveNodes( curves, doc.Settings().strictMode );
#endif
    const AnimationCurveNode* curve_node = NULL;
    for( const AnimationCurveNode* node : curves ) {
        ai_assert( node );

        if ( node->TargetProperty().empty() ) {
            FBXImporter::LogWarn( "target property for animation curve not set: " + node->Name() );
            continue;
        }

        curve_node = node;
        if ( node->Curves().empty() ) {
            FBXImporter::LogWarn( "no animation curves assigned to AnimationCurveNode: " + node->Name() );
            continue;
        }

        node_property_map[ node->TargetProperty() ].push_back( node );
    }

    ai_assert( curve_node );
    ai_assert( curve_node->TargetAsModel() );

    const Model& target = *curve_node->TargetAsModel();

    // check for all possible transformation components
    NodeMap::const_iterator chain[ TransformationComp_MAXIMUM ];

    bool has_any = false;
    bool has_complex = false;

    for ( size_t i = 0; i < TransformationComp_MAXIMUM; ++i ) {
        const TransformationComp comp = static_cast<TransformationComp>( i );

        // inverse pivots don't exist in the input, we just generate them
        if ( comp == TransformationComp_RotationPivotInverse || comp == TransformationComp_ScalingPivotInverse ) {
            chain[ i ] = node_property_map.end();
            continue;
        }

        chain[ i ] = node_property_map.find( NameTransformationCompProperty( comp ) );
        if ( chain[ i ] != node_property_map.end() ) {

            // check if this curves contains redundant information by looking
            // up the corresponding node's transformation chain.
            if ( doc.Settings().optimizeEmptyAnimationCurves &&
                IsRedundantAnimationData( target, comp, ( *chain[ i ] ).second ) ) {

                FBXImporter::LogDebug( "dropping redundant animation channel for node " + target.Name() );
                continue;
            }

            has_any = true;

            if ( comp != TransformationComp_Rotation && comp != TransformationComp_Scaling && comp != TransformationComp_Translation &&
                comp != TransformationComp_GeometricScaling && comp != TransformationComp_GeometricRotation && comp != TransformationComp_GeometricTranslation )
            {
                has_complex = true;
            }
        }
    }

    if ( !has_any ) {
        FBXImporter::LogWarn( "ignoring node animation, did not find any transformation key frames" );
        return;
    }

    // this needs to play nicely with GenerateTransformationNodeChain() which will
    // be invoked _later_ (animations come first). If this node has only rotation,
    // scaling and translation _and_ there are no animated other components either,
    // we can use a single node and also a single node animation channel.
    if ( !has_complex && !NeedsComplexTransformationChain( target ) ) {

        aiNodeAnim* const nd = GenerateSimpleNodeAnim( fixed_name, target, chain,
            node_property_map.end(),
            layer_map,
            start, stop,
            max_time,
            min_time,
            true // input is TRS order, assimp is SRT
            );

        ai_assert( nd );
        if ( nd->mNumPositionKeys == 0 && nd->mNumRotationKeys == 0 && nd->mNumScalingKeys == 0 ) {
            delete nd;
        }
        else {
            node_anims.push_back( nd );
        }
        return;
    }

    // otherwise, things get gruesome and we need separate animation channels
    // for each part of the transformation chain. Remember which channels
    // we generated and pass this information to the node conversion
    // code to avoid nodes that have identity transform, but non-identity
    // animations, being dropped.
    unsigned int flags = 0, bit = 0x1;
    for ( size_t i = 0; i < TransformationComp_MAXIMUM; ++i, bit <<= 1 ) {
        const TransformationComp comp = static_cast<TransformationComp>( i );

        if ( chain[ i ] != node_property_map.end() ) {
            flags |= bit;

            ai_assert( comp != TransformationComp_RotationPivotInverse );
            ai_assert( comp != TransformationComp_ScalingPivotInverse );

            const std::string& chain_name = NameTransformationChainNode( fixed_name, comp );

            aiNodeAnim* na = nullptr;
            switch ( comp )
            {
            case TransformationComp_Rotation:
            case TransformationComp_PreRotation:
            case TransformationComp_PostRotation:
            case TransformationComp_GeometricRotation:
                na = GenerateRotationNodeAnim( chain_name,
                    target,
                    ( *chain[ i ] ).second,
                    layer_map,
                    start, stop,
                    max_time,
                    min_time );

                break;

            case TransformationComp_RotationOffset:
            case TransformationComp_RotationPivot:
            case TransformationComp_ScalingOffset:
            case TransformationComp_ScalingPivot:
            case TransformationComp_Translation:
            case TransformationComp_GeometricTranslation:
                na = GenerateTranslationNodeAnim( chain_name,
                    target,
                    ( *chain[ i ] ).second,
                    layer_map,
                    start, stop,
                    max_time,
                    min_time );

                // pivoting requires us to generate an implicit inverse channel to undo the pivot translation
                if ( comp == TransformationComp_RotationPivot ) {
                    const std::string& invName = NameTransformationChainNode( fixed_name,
                        TransformationComp_RotationPivotInverse );

                    aiNodeAnim* const inv = GenerateTranslationNodeAnim( invName,
                        target,
                        ( *chain[ i ] ).second,
                        layer_map,
                        start, stop,
                        max_time,
                        min_time,
                        true );

                    ai_assert( inv );
                    if ( inv->mNumPositionKeys == 0 && inv->mNumRotationKeys == 0 && inv->mNumScalingKeys == 0 ) {
                        delete inv;
                    }
                    else {
                        node_anims.push_back( inv );
                    }

                    ai_assert( TransformationComp_RotationPivotInverse > i );
                    flags |= bit << ( TransformationComp_RotationPivotInverse - i );
                }
                else if ( comp == TransformationComp_ScalingPivot ) {
                    const std::string& invName = NameTransformationChainNode( fixed_name,
                        TransformationComp_ScalingPivotInverse );

                    aiNodeAnim* const inv = GenerateTranslationNodeAnim( invName,
                        target,
                        ( *chain[ i ] ).second,
                        layer_map,
                        start, stop,
                        max_time,
                        min_time,
                        true );

                    ai_assert( inv );
                    if ( inv->mNumPositionKeys == 0 && inv->mNumRotationKeys == 0 && inv->mNumScalingKeys == 0 ) {
                        delete inv;
                    }
                    else {
                        node_anims.push_back( inv );
                    }

                    ai_assert( TransformationComp_RotationPivotInverse > i );
                    flags |= bit << ( TransformationComp_RotationPivotInverse - i );
                }

                break;

            case TransformationComp_Scaling:
            case TransformationComp_GeometricScaling:
                na = GenerateScalingNodeAnim( chain_name,
                    target,
                    ( *chain[ i ] ).second,
                    layer_map,
                    start, stop,
                    max_time,
                    min_time );

                break;

            default:
                ai_assert( false );
            }

            ai_assert( na );
            if ( na->mNumPositionKeys == 0 && na->mNumRotationKeys == 0 && na->mNumScalingKeys == 0 ) {
                delete na;
            }
            else {
                node_anims.push_back( na );
            }
            continue;
        }
    }

    node_anim_chain_bits[ fixed_name ] = flags;
}

bool Converter::IsRedundantAnimationData( const Model& target,
    TransformationComp comp,
    const std::vector<const AnimationCurveNode*>& curves )
{
    ai_assert( curves.size() );

    // look for animation nodes with
    //  * sub channels for all relevant components set
    //  * one key/value pair per component
    //  * combined values match up the corresponding value in the bind pose node transformation
    // only such nodes are 'redundant' for this function.

    if ( curves.size() > 1 ) {
        return false;
    }

    const AnimationCurveNode& nd = *curves.front();
    const AnimationCurveMap& sub_curves = nd.Curves();

    const AnimationCurveMap::const_iterator dx = sub_curves.find( "d|X" );
    const AnimationCurveMap::const_iterator dy = sub_curves.find( "d|Y" );
    const AnimationCurveMap::const_iterator dz = sub_curves.find( "d|Z" );

    if ( dx == sub_curves.end() || dy == sub_curves.end() || dz == sub_curves.end() ) {
        return false;
    }

    const KeyValueList& vx = ( *dx ).second->GetValues();
    const KeyValueList& vy = ( *dy ).second->GetValues();
    const KeyValueList& vz = ( *dz ).second->GetValues();

    if ( vx.size() != 1 || vy.size() != 1 || vz.size() != 1 ) {
        return false;
    }

    const aiVector3D dyn_val = aiVector3D( vx[ 0 ], vy[ 0 ], vz[ 0 ] );
    const aiVector3D& static_val = PropertyGet<aiVector3D>( target.Props(),
        NameTransformationCompProperty( comp ),
        TransformationCompDefaultValue( comp )
        );

    const float epsilon = 1e-6f;
    return ( dyn_val - static_val ).SquareLength() < epsilon;
}


aiNodeAnim* Converter::GenerateRotationNodeAnim( const std::string& name,
    const Model& target,
    const std::vector<const AnimationCurveNode*>& curves,
    const LayerMap& layer_map,
    int64_t start, int64_t stop,
    double& max_time,
    double& min_time )
{
    ScopeGuard<aiNodeAnim> na( new aiNodeAnim() );
    na->mNodeName.Set( name );

    ConvertRotationKeys( na, curves, layer_map, start, stop, max_time, min_time, target.RotationOrder() );

    // dummy scaling key
    na->mScalingKeys = new aiVectorKey[ 1 ];
    na->mNumScalingKeys = 1;

    na->mScalingKeys[ 0 ].mTime = 0.;
    na->mScalingKeys[ 0 ].mValue = aiVector3D( 1.0f, 1.0f, 1.0f );

    // dummy position key
    na->mPositionKeys = new aiVectorKey[ 1 ];
    na->mNumPositionKeys = 1;

    na->mPositionKeys[ 0 ].mTime = 0.;
    na->mPositionKeys[ 0 ].mValue = aiVector3D();

    return na.dismiss();
}

aiNodeAnim* Converter::GenerateScalingNodeAnim( const std::string& name,
    const Model& /*target*/,
    const std::vector<const AnimationCurveNode*>& curves,
    const LayerMap& layer_map,
    int64_t start, int64_t stop,
    double& max_time,
    double& min_time )
{
    ScopeGuard<aiNodeAnim> na( new aiNodeAnim() );
    na->mNodeName.Set( name );

    ConvertScaleKeys( na, curves, layer_map, start, stop, max_time, min_time );

    // dummy rotation key
    na->mRotationKeys = new aiQuatKey[ 1 ];
    na->mNumRotationKeys = 1;

    na->mRotationKeys[ 0 ].mTime = 0.;
    na->mRotationKeys[ 0 ].mValue = aiQuaternion();

    // dummy position key
    na->mPositionKeys = new aiVectorKey[ 1 ];
    na->mNumPositionKeys = 1;

    na->mPositionKeys[ 0 ].mTime = 0.;
    na->mPositionKeys[ 0 ].mValue = aiVector3D();

    return na.dismiss();
}


aiNodeAnim* Converter::GenerateTranslationNodeAnim( const std::string& name,
    const Model& /*target*/,
    const std::vector<const AnimationCurveNode*>& curves,
    const LayerMap& layer_map,
    int64_t start, int64_t stop,
    double& max_time,
    double& min_time,
    bool inverse )
{
    ScopeGuard<aiNodeAnim> na( new aiNodeAnim() );
    na->mNodeName.Set( name );

    ConvertTranslationKeys( na, curves, layer_map, start, stop, max_time, min_time );

    if ( inverse ) {
        for ( unsigned int i = 0; i < na->mNumPositionKeys; ++i ) {
            na->mPositionKeys[ i ].mValue *= -1.0f;
        }
    }

    // dummy scaling key
    na->mScalingKeys = new aiVectorKey[ 1 ];
    na->mNumScalingKeys = 1;

    na->mScalingKeys[ 0 ].mTime = 0.;
    na->mScalingKeys[ 0 ].mValue = aiVector3D( 1.0f, 1.0f, 1.0f );

    // dummy rotation key
    na->mRotationKeys = new aiQuatKey[ 1 ];
    na->mNumRotationKeys = 1;

    na->mRotationKeys[ 0 ].mTime = 0.;
    na->mRotationKeys[ 0 ].mValue = aiQuaternion();

    return na.dismiss();
}

aiNodeAnim* Converter::GenerateSimpleNodeAnim( const std::string& name,
    const Model& target,
    NodeMap::const_iterator chain[ TransformationComp_MAXIMUM ],
    NodeMap::const_iterator iter_end,
    const LayerMap& layer_map,
    int64_t start, int64_t stop,
    double& max_time,
    double& min_time,
    bool reverse_order )

{
    ScopeGuard<aiNodeAnim> na( new aiNodeAnim() );
    na->mNodeName.Set( name );

    const PropertyTable& props = target.Props();

    // need to convert from TRS order to SRT?
    if ( reverse_order ) {

        aiVector3D def_scale = PropertyGet( props, "Lcl Scaling", aiVector3D( 1.f, 1.f, 1.f ) );
        aiVector3D def_translate = PropertyGet( props, "Lcl Translation", aiVector3D( 0.f, 0.f, 0.f ) );
        aiVector3D def_rot = PropertyGet( props, "Lcl Rotation", aiVector3D( 0.f, 0.f, 0.f ) );

        KeyFrameListList scaling;
        KeyFrameListList translation;
        KeyFrameListList rotation;

        if ( chain[ TransformationComp_Scaling ] != iter_end ) {
            scaling = GetKeyframeList( ( *chain[ TransformationComp_Scaling ] ).second, start, stop );
        }

        if ( chain[ TransformationComp_Translation ] != iter_end ) {
            translation = GetKeyframeList( ( *chain[ TransformationComp_Translation ] ).second, start, stop );
        }

        if ( chain[ TransformationComp_Rotation ] != iter_end ) {
            rotation = GetKeyframeList( ( *chain[ TransformationComp_Rotation ] ).second, start, stop );
        }

        KeyFrameListList joined;
        joined.insert( joined.end(), scaling.begin(), scaling.end() );
        joined.insert( joined.end(), translation.begin(), translation.end() );
        joined.insert( joined.end(), rotation.begin(), rotation.end() );

        const KeyTimeList& times = GetKeyTimeList( joined );

        aiQuatKey* out_quat = new aiQuatKey[ times.size() ];
        aiVectorKey* out_scale = new aiVectorKey[ times.size() ];
        aiVectorKey* out_translation = new aiVectorKey[ times.size() ];

        if ( times.size() )
        {
            ConvertTransformOrder_TRStoSRT( out_quat, out_scale, out_translation,
                scaling,
                translation,
                rotation,
                times,
                max_time,
                min_time,
                target.RotationOrder(),
                def_scale,
                def_translate,
                def_rot );
        }

        // XXX remove duplicates / redundant keys which this operation did
        // likely produce if not all three channels were equally dense.

        na->mNumScalingKeys = static_cast<unsigned int>( times.size() );
        na->mNumRotationKeys = na->mNumScalingKeys;
        na->mNumPositionKeys = na->mNumScalingKeys;

        na->mScalingKeys = out_scale;
        na->mRotationKeys = out_quat;
        na->mPositionKeys = out_translation;
    }
    else {

        // if a particular transformation is not given, grab it from
        // the corresponding node to meet the semantics of aiNodeAnim,
        // which requires all of rotation, scaling and translation
        // to be set.
        if ( chain[ TransformationComp_Scaling ] != iter_end ) {
            ConvertScaleKeys( na, ( *chain[ TransformationComp_Scaling ] ).second,
                layer_map,
                start, stop,
                max_time,
                min_time );
        }
        else {
            na->mScalingKeys = new aiVectorKey[ 1 ];
            na->mNumScalingKeys = 1;

            na->mScalingKeys[ 0 ].mTime = 0.;
            na->mScalingKeys[ 0 ].mValue = PropertyGet( props, "Lcl Scaling",
                aiVector3D( 1.f, 1.f, 1.f ) );
        }

        if ( chain[ TransformationComp_Rotation ] != iter_end ) {
            ConvertRotationKeys( na, ( *chain[ TransformationComp_Rotation ] ).second,
                layer_map,
                start, stop,
                max_time,
                min_time,
                target.RotationOrder() );
        }
        else {
            na->mRotationKeys = new aiQuatKey[ 1 ];
            na->mNumRotationKeys = 1;

            na->mRotationKeys[ 0 ].mTime = 0.;
            na->mRotationKeys[ 0 ].mValue = EulerToQuaternion(
                PropertyGet( props, "Lcl Rotation", aiVector3D( 0.f, 0.f, 0.f ) ),
                target.RotationOrder() );
        }

        if ( chain[ TransformationComp_Translation ] != iter_end ) {
            ConvertTranslationKeys( na, ( *chain[ TransformationComp_Translation ] ).second,
                layer_map,
                start, stop,
                max_time,
                min_time );
        }
        else {
            na->mPositionKeys = new aiVectorKey[ 1 ];
            na->mNumPositionKeys = 1;

            na->mPositionKeys[ 0 ].mTime = 0.;
            na->mPositionKeys[ 0 ].mValue = PropertyGet( props, "Lcl Translation",
                aiVector3D( 0.f, 0.f, 0.f ) );
        }

    }
    return na.dismiss();
}

Converter::KeyFrameListList Converter::GetKeyframeList( const std::vector<const AnimationCurveNode*>& nodes, int64_t start, int64_t stop )
{
    KeyFrameListList inputs;
    inputs.reserve( nodes.size() * 3 );

    //give some breathing room for rounding errors
    int64_t adj_start = start - 10000;
    int64_t adj_stop = stop + 10000;

    for( const AnimationCurveNode* node : nodes ) {
        ai_assert( node );

        const AnimationCurveMap& curves = node->Curves();
        for( const AnimationCurveMap::value_type& kv : curves ) {

            unsigned int mapto;
            if ( kv.first == "d|X" ) {
                mapto = 0;
            }
            else if ( kv.first == "d|Y" ) {
                mapto = 1;
            }
            else if ( kv.first == "d|Z" ) {
                mapto = 2;
            }
            else {
                FBXImporter::LogWarn( "ignoring scale animation curve, did not recognize target component" );
                continue;
            }

            const AnimationCurve* const curve = kv.second;
            ai_assert( curve->GetKeys().size() == curve->GetValues().size() && curve->GetKeys().size() );

            //get values within the start/stop time window
            std::shared_ptr<KeyTimeList> Keys( new KeyTimeList() );
            std::shared_ptr<KeyValueList> Values( new KeyValueList() );
            const int count = curve->GetKeys().size();
            Keys->reserve( count );
            Values->reserve( count );
            for ( int n = 0; n < count; n++ )
            {
                int64_t k = curve->GetKeys().at( n );
                if ( k >= adj_start && k <= adj_stop )
                {
                    Keys->push_back( k );
                    Values->push_back( curve->GetValues().at( n ) );
                }
            }

            inputs.push_back( std::make_tuple( Keys, Values, mapto ) );
        }
    }
    return inputs; // pray for NRVO :-)
}


KeyTimeList Converter::GetKeyTimeList( const KeyFrameListList& inputs )
{
    ai_assert( inputs.size() );

    // reserve some space upfront - it is likely that the keyframe lists
    // have matching time values, so max(of all keyframe lists) should
    // be a good estimate.
    KeyTimeList keys;

    size_t estimate = 0;
    for( const KeyFrameList& kfl : inputs ) {
        estimate = std::max( estimate, std::get<0>(kfl)->size() );
    }

    keys.reserve( estimate );

    std::vector<unsigned int> next_pos;
    next_pos.resize( inputs.size(), 0 );

    const size_t count = inputs.size();
    while ( true ) {

        int64_t min_tick = std::numeric_limits<int64_t>::max();
        for ( size_t i = 0; i < count; ++i ) {
            const KeyFrameList& kfl = inputs[ i ];

            if ( std::get<0>(kfl)->size() > next_pos[ i ] && std::get<0>(kfl)->at( next_pos[ i ] ) < min_tick ) {
                min_tick = std::get<0>(kfl)->at( next_pos[ i ] );
            }
        }

        if ( min_tick == std::numeric_limits<int64_t>::max() ) {
            break;
        }
        keys.push_back( min_tick );

        for ( size_t i = 0; i < count; ++i ) {
            const KeyFrameList& kfl = inputs[ i ];


            while ( std::get<0>(kfl)->size() > next_pos[ i ] && std::get<0>(kfl)->at( next_pos[ i ] ) == min_tick ) {
                ++next_pos[ i ];
            }
        }
    }

    return keys;
}

void Converter::InterpolateKeys( aiVectorKey* valOut, const KeyTimeList& keys, const KeyFrameListList& inputs,
    const aiVector3D& def_value,
    double& max_time,
    double& min_time )

{
    ai_assert( keys.size() );
    ai_assert( valOut );

    std::vector<unsigned int> next_pos;
    const size_t count = inputs.size();

    next_pos.resize( inputs.size(), 0 );

    for( KeyTimeList::value_type time : keys ) {
        float result[ 3 ] = { def_value.x, def_value.y, def_value.z };

        for ( size_t i = 0; i < count; ++i ) {
            const KeyFrameList& kfl = inputs[ i ];

            const size_t ksize = std::get<0>(kfl)->size();
            if ( ksize > next_pos[ i ] && std::get<0>(kfl)->at( next_pos[ i ] ) == time ) {
                ++next_pos[ i ];
            }

            const size_t id0 = next_pos[ i ]>0 ? next_pos[ i ] - 1 : 0;
            const size_t id1 = next_pos[ i ] == ksize ? ksize - 1 : next_pos[ i ];

            // use lerp for interpolation
            const KeyValueList::value_type valueA = std::get<1>(kfl)->at( id0 );
            const KeyValueList::value_type valueB = std::get<1>(kfl)->at( id1 );

            const KeyTimeList::value_type timeA = std::get<0>(kfl)->at( id0 );
            const KeyTimeList::value_type timeB = std::get<0>(kfl)->at( id1 );

            // do the actual interpolation in double-precision arithmetics
            // because it is a bit sensitive to rounding errors.
            const double factor = timeB == timeA ? 0. : static_cast<double>( ( time - timeA ) / ( timeB - timeA ) );
            const float interpValue = static_cast<float>( valueA + ( valueB - valueA ) * factor );

            result[ std::get<2>(kfl) ] = interpValue;
        }

        // magic value to convert fbx times to seconds
        valOut->mTime = CONVERT_FBX_TIME( time ) * anim_fps;

        min_time = std::min( min_time, valOut->mTime );
        max_time = std::max( max_time, valOut->mTime );

        valOut->mValue.x = result[ 0 ];
        valOut->mValue.y = result[ 1 ];
        valOut->mValue.z = result[ 2 ];

        ++valOut;
    }
}


void Converter::InterpolateKeys( aiQuatKey* valOut, const KeyTimeList& keys, const KeyFrameListList& inputs,
    const aiVector3D& def_value,
    double& maxTime,
    double& minTime,
    Model::RotOrder order )
{
    ai_assert( keys.size() );
    ai_assert( valOut );

    std::unique_ptr<aiVectorKey[]> temp( new aiVectorKey[ keys.size() ] );
    InterpolateKeys( temp.get(), keys, inputs, def_value, maxTime, minTime );

    aiMatrix4x4 m;

    aiQuaternion lastq;

    for ( size_t i = 0, c = keys.size(); i < c; ++i ) {

        valOut[ i ].mTime = temp[ i ].mTime;


        GetRotationMatrix( order, temp[ i ].mValue, m );
        aiQuaternion quat = aiQuaternion( aiMatrix3x3( m ) );

        // take shortest path by checking the inner product
        // http://www.3dkingdoms.com/weekly/weekly.php?a=36
        if ( quat.x * lastq.x + quat.y * lastq.y + quat.z * lastq.z + quat.w * lastq.w < 0 )
        {
            quat.x = -quat.x;
            quat.y = -quat.y;
            quat.z = -quat.z;
            quat.w = -quat.w;
        }
        lastq = quat;

        valOut[ i ].mValue = quat;
    }
}


void Converter::ConvertTransformOrder_TRStoSRT( aiQuatKey* out_quat, aiVectorKey* out_scale,
    aiVectorKey* out_translation,
    const KeyFrameListList& scaling,
    const KeyFrameListList& translation,
    const KeyFrameListList& rotation,
    const KeyTimeList& times,
    double& maxTime,
    double& minTime,
    Model::RotOrder order,
    const aiVector3D& def_scale,
    const aiVector3D& def_translate,
    const aiVector3D& def_rotation )
{
    if ( rotation.size() ) {
        InterpolateKeys( out_quat, times, rotation, def_rotation, maxTime, minTime, order );
    }
    else {
        for ( size_t i = 0; i < times.size(); ++i ) {
            out_quat[ i ].mTime = CONVERT_FBX_TIME( times[ i ] ) * anim_fps;
            out_quat[ i ].mValue = EulerToQuaternion( def_rotation, order );
        }
    }

    if ( scaling.size() ) {
        InterpolateKeys( out_scale, times, scaling, def_scale, maxTime, minTime );
    }
    else {
        for ( size_t i = 0; i < times.size(); ++i ) {
            out_scale[ i ].mTime = CONVERT_FBX_TIME( times[ i ] ) * anim_fps;
            out_scale[ i ].mValue = def_scale;
        }
    }

    if ( translation.size() ) {
        InterpolateKeys( out_translation, times, translation, def_translate, maxTime, minTime );
    }
    else {
        for ( size_t i = 0; i < times.size(); ++i ) {
            out_translation[ i ].mTime = CONVERT_FBX_TIME( times[ i ] ) * anim_fps;
            out_translation[ i ].mValue = def_translate;
        }
    }

    const size_t count = times.size();
    for ( size_t i = 0; i < count; ++i ) {
        aiQuaternion& r = out_quat[ i ].mValue;
        aiVector3D& s = out_scale[ i ].mValue;
        aiVector3D& t = out_translation[ i ].mValue;

        aiMatrix4x4 mat, temp;
        aiMatrix4x4::Translation( t, mat );
        mat *= aiMatrix4x4( r.GetMatrix() );
        mat *= aiMatrix4x4::Scaling( s, temp );

        mat.Decompose( s, r, t );
    }
}


aiQuaternion Converter::EulerToQuaternion( const aiVector3D& rot, Model::RotOrder order )
{
    aiMatrix4x4 m;
    GetRotationMatrix( order, rot, m );

    return aiQuaternion( aiMatrix3x3( m ) );
}


void Converter::ConvertScaleKeys( aiNodeAnim* na, const std::vector<const AnimationCurveNode*>& nodes, const LayerMap& /*layers*/,
    int64_t start, int64_t stop,
    double& maxTime,
    double& minTime )
{
    ai_assert( nodes.size() );

    // XXX for now, assume scale should be blended geometrically (i.e. two
    // layers should be multiplied with each other). There is a FBX
    // property in the layer to specify the behaviour, though.

    const KeyFrameListList& inputs = GetKeyframeList( nodes, start, stop );
    const KeyTimeList& keys = GetKeyTimeList( inputs );

    na->mNumScalingKeys = static_cast<unsigned int>( keys.size() );
    na->mScalingKeys = new aiVectorKey[ keys.size() ];
    if ( keys.size() > 0 )
        InterpolateKeys( na->mScalingKeys, keys, inputs, aiVector3D( 1.0f, 1.0f, 1.0f ), maxTime, minTime );
}


void Converter::ConvertTranslationKeys( aiNodeAnim* na, const std::vector<const AnimationCurveNode*>& nodes,
    const LayerMap& /*layers*/,
    int64_t start, int64_t stop,
    double& maxTime,
    double& minTime )
{
    ai_assert( nodes.size() );

    // XXX see notes in ConvertScaleKeys()
    const KeyFrameListList& inputs = GetKeyframeList( nodes, start, stop );
    const KeyTimeList& keys = GetKeyTimeList( inputs );

    na->mNumPositionKeys = static_cast<unsigned int>( keys.size() );
    na->mPositionKeys = new aiVectorKey[ keys.size() ];
    if ( keys.size() > 0 )
        InterpolateKeys( na->mPositionKeys, keys, inputs, aiVector3D( 0.0f, 0.0f, 0.0f ), maxTime, minTime );
}


void Converter::ConvertRotationKeys( aiNodeAnim* na, const std::vector<const AnimationCurveNode*>& nodes,
    const LayerMap& /*layers*/,
    int64_t start, int64_t stop,
    double& maxTime,
    double& minTime,
    Model::RotOrder order )
{
    ai_assert( nodes.size() );

    // XXX see notes in ConvertScaleKeys()
    const std::vector< KeyFrameList >& inputs = GetKeyframeList( nodes, start, stop );
    const KeyTimeList& keys = GetKeyTimeList( inputs );

    na->mNumRotationKeys = static_cast<unsigned int>( keys.size() );
    na->mRotationKeys = new aiQuatKey[ keys.size() ];
    if ( keys.size() > 0 )
        InterpolateKeys( na->mRotationKeys, keys, inputs, aiVector3D( 0.0f, 0.0f, 0.0f ), maxTime, minTime, order );
}

void Converter::TransferDataToScene()
{
    ai_assert( !out->mMeshes && !out->mNumMeshes );

    // note: the trailing () ensures initialization with NULL - not
    // many C++ users seem to know this, so pointing it out to avoid
    // confusion why this code works.

    if ( meshes.size() ) {
        out->mMeshes = new aiMesh*[ meshes.size() ]();
        out->mNumMeshes = static_cast<unsigned int>( meshes.size() );

        std::swap_ranges( meshes.begin(), meshes.end(), out->mMeshes );
    }

    if ( materials.size() ) {
        out->mMaterials = new aiMaterial*[ materials.size() ]();
        out->mNumMaterials = static_cast<unsigned int>( materials.size() );

        std::swap_ranges( materials.begin(), materials.end(), out->mMaterials );
    }

    if ( animations.size() ) {
        out->mAnimations = new aiAnimation*[ animations.size() ]();
        out->mNumAnimations = static_cast<unsigned int>( animations.size() );

        std::swap_ranges( animations.begin(), animations.end(), out->mAnimations );
    }

    if ( lights.size() ) {
        out->mLights = new aiLight*[ lights.size() ]();
        out->mNumLights = static_cast<unsigned int>( lights.size() );

        std::swap_ranges( lights.begin(), lights.end(), out->mLights );
    }

    if ( cameras.size() ) {
        out->mCameras = new aiCamera*[ cameras.size() ]();
        out->mNumCameras = static_cast<unsigned int>( cameras.size() );

        std::swap_ranges( cameras.begin(), cameras.end(), out->mCameras );
    }

    if ( textures.size() ) {
        out->mTextures = new aiTexture*[ textures.size() ]();
        out->mNumTextures = static_cast<unsigned int>( textures.size() );

        std::swap_ranges( textures.begin(), textures.end(), out->mTextures );
    }
}

//} // !anon

// ------------------------------------------------------------------------------------------------
void ConvertToAssimpScene(aiScene* out, const Document& doc)
{
    Converter converter(out,doc);
}

} // !FBX
} // !Assimp

#endif

/***********************************************************************
FBXIMPORT\FBXDEFORMER.CPP
***********************************************************************/
/*
Open Asset Import Library (assimp)
----------------------------------------------------------------------

Copyright (c) 2006-2016, assimp team
All rights reserved.

Redistribution and use of this software in source and binary forms,
with or without modification, are permitted provided that the
following conditions are met:

* Redistributions of source code must retain the above
  copyright notice, this list of conditions and the
  following disclaimer.

* Redistributions in binary form must reproduce the above
  copyright notice, this list of conditions and the
  following disclaimer in the documentation and/or other
  materials provided with the distribution.

* Neither the name of the assimp team, nor the names of its
  contributors may be used to endorse or promote products
  derived from this software without specific prior
  written permission of the assimp team.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
"AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

----------------------------------------------------------------------
*/

/** @file  FBXNoteAttribute.cpp
 *  @brief Assimp::FBX::NodeAttribute (and subclasses) implementation
 */

#ifndef ASSIMP_BUILD_NO_FBX_IMPORTER


namespace Assimp {
namespace FBX {

    using namespace Util;

// ------------------------------------------------------------------------------------------------
Deformer::Deformer(uint64_t id, const Element& element, const Document& doc, const std::string& name)
    : Object(id,element,name)
{
    const Scope& sc = GetRequiredScope(element);

    const std::string& classname = ParseTokenAsString(GetRequiredToken(element,2));
    props = GetPropertyTable(doc,"Deformer.Fbx" + classname,element,sc,true);
}


// ------------------------------------------------------------------------------------------------
Deformer::~Deformer()
{

}


// ------------------------------------------------------------------------------------------------
Cluster::Cluster(uint64_t id, const Element& element, const Document& doc, const std::string& name)
: Deformer(id,element,doc,name)
, node()
{
    const Scope& sc = GetRequiredScope(element);

    const Element* const Indexes = sc["Indexes"];
    const Element* const Weights = sc["Weights"];

    const Element& Transform = GetRequiredElement(sc,"Transform",&element);
    const Element& TransformLink = GetRequiredElement(sc,"TransformLink",&element);

    transform = ReadMatrix(Transform);
    transformLink = ReadMatrix(TransformLink);

    // it is actually possible that there be Deformer's with no weights
    if (!!Indexes != !!Weights) {
        DOMError("either Indexes or Weights are missing from Cluster",&element);
    }

    if(Indexes) {
        ParseVectorDataArray(indices,*Indexes);
        ParseVectorDataArray(weights,*Weights);
    }

    if(indices.size() != weights.size()) {
        DOMError("sizes of index and weight array don't match up",&element);
    }

    // read assigned node
    const std::vector<const Connection*>& conns = doc.GetConnectionsByDestinationSequenced(ID(),"Model");
    for(const Connection* con : conns) {
        const Model* const mod = ProcessSimpleConnection<Model>(*con, false, "Model -> Cluster", element);
        if(mod) {
            node = mod;
            break;
        }
    }

    if (!node) {
        DOMError("failed to read target Node for Cluster",&element);
    }
}


// ------------------------------------------------------------------------------------------------
Cluster::~Cluster()
{

}


// ------------------------------------------------------------------------------------------------
Skin::Skin(uint64_t id, const Element& element, const Document& doc, const std::string& name)
: Deformer(id,element,doc,name)
, accuracy( 0.0f ) {
    const Scope& sc = GetRequiredScope(element);

    const Element* const Link_DeformAcuracy = sc["Link_DeformAcuracy"];
    if(Link_DeformAcuracy) {
        accuracy = ParseTokenAsFloat(GetRequiredToken(*Link_DeformAcuracy,0));
    }

    // resolve assigned clusters
    const std::vector<const Connection*>& conns = doc.GetConnectionsByDestinationSequenced(ID(),"Deformer");

    clusters.reserve(conns.size());
    for(const Connection* con : conns) {

        const Cluster* const cluster = ProcessSimpleConnection<Cluster>(*con, false, "Cluster -> Skin", element);
        if(cluster) {
            clusters.push_back(cluster);
            continue;
        }
    }
}


// ------------------------------------------------------------------------------------------------
Skin::~Skin()
{

}



}
}

#endif


/***********************************************************************
FBXIMPORT\FBXDOCUMENT.CPP
***********************************************************************/
/*
Open Asset Import Library (assimp)
----------------------------------------------------------------------

Copyright (c) 2006-2016, assimp team
All rights reserved.

Redistribution and use of this software in source and binary forms,
with or without modification, are permitted provided that the
following conditions are met:

* Redistributions of source code must retain the above
  copyright notice, this list of conditions and the
  following disclaimer.

* Redistributions in binary form must reproduce the above
  copyright notice, this list of conditions and the*
  following disclaimer in the documentation and/or other
  materials provided with the distribution.

* Neither the name of the assimp team, nor the names of its
  contributors may be used to endorse or promote products
  derived from this software without specific prior
  written permission of the assimp team.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
"AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

----------------------------------------------------------------------
*/

/** @file  FBXDocument.cpp
 *  @brief Implementation of the FBX DOM classes
 */

#ifndef ASSIMP_BUILD_NO_FBX_IMPORTER




namespace Assimp {
namespace FBX {

using namespace Util;

// ------------------------------------------------------------------------------------------------
LazyObject::LazyObject(uint64_t id, const Element& element, const Document& doc)
: doc(doc)
, element(element)
, id(id)
, flags()
{

}

// ------------------------------------------------------------------------------------------------
LazyObject::~LazyObject()
{

}

// ------------------------------------------------------------------------------------------------
static void dumpObjectClassInfo( const char* obtype, const std::string &classtag ) {
    DefaultLogger::get()->debug( "obtype: " + std::string(obtype ));
    DefaultLogger::get()->debug( "Classtag: " + classtag );
}

// ------------------------------------------------------------------------------------------------
const Object* LazyObject::Get(bool dieOnError)
{
    if(IsBeingConstructed() || FailedToConstruct()) {
        return NULL;
    }

    if (object.get()) {
        return object.get();
    }

    // if this is the root object, we return a dummy since there
    // is no root object int he fbx file - it is just referenced
    // with id 0.
    if(id == 0L) {
        object.reset(new Object(id, element, "Model::RootNode"));
        return object.get();
    }

    const Token& key = element.KeyToken();
    const TokenList& tokens = element.Tokens();

    if(tokens.size() < 3) {
        DOMError("expected at least 3 tokens: id, name and class tag",&element);
    }

    const char* err;
    std::string name = ParseTokenAsString(*tokens[1],err);
    if (err) {
        DOMError(err,&element);
    }

    // small fix for binary reading: binary fbx files don't use
    // prefixes such as Model:: in front of their names. The
    // loading code expects this at many places, though!
    // so convert the binary representation (a 0x0001) to the
    // double colon notation.
    if(tokens[1]->IsBinary()) {
        for (size_t i = 0; i < name.length(); ++i) {
            if (name[i] == 0x0 && name[i+1] == 0x1) {
                name = name.substr(i+2) + "::" + name.substr(0,i);
            }
        }
    }

    const std::string classtag = ParseTokenAsString(*tokens[2],err);
    if (err) {
        DOMError(err,&element);
    }

    // prevent recursive calls
    flags |= BEING_CONSTRUCTED;

    try {
        // this needs to be relatively fast since it happens a lot,
        // so avoid constructing strings all the time.
        const char* obtype = key.begin();
        const size_t length = static_cast<size_t>(key.end()-key.begin());

        // For debugging
        //dumpObjectClassInfo( objtype, classtag );

        if (!strncmp(obtype,"Geometry",length)) {
            if (!strcmp(classtag.c_str(),"Mesh")) {
                object.reset(new MeshGeometry(id,element,name,doc));
            }
        }
        else if (!strncmp(obtype,"NodeAttribute",length)) {
            if (!strcmp(classtag.c_str(),"Camera")) {
                object.reset(new Camera(id,element,doc,name));
            }
            else if (!strcmp(classtag.c_str(),"CameraSwitcher")) {
                object.reset(new CameraSwitcher(id,element,doc,name));
            }
            else if (!strcmp(classtag.c_str(),"Light")) {
                object.reset(new Light(id,element,doc,name));
            }
            else if (!strcmp(classtag.c_str(),"Null")) {
                object.reset(new Null(id,element,doc,name));
            }
            else if (!strcmp(classtag.c_str(),"LimbNode")) {
                object.reset(new LimbNode(id,element,doc,name));
            }
        }
        else if (!strncmp(obtype,"Deformer",length)) {
            if (!strcmp(classtag.c_str(),"Cluster")) {
                object.reset(new Cluster(id,element,doc,name));
            }
            else if (!strcmp(classtag.c_str(),"Skin")) {
                object.reset(new Skin(id,element,doc,name));
            }
        }
        else if ( !strncmp( obtype, "Model", length ) ) {
            // FK and IK effectors are not supported
            if ( strcmp( classtag.c_str(), "IKEffector" ) && strcmp( classtag.c_str(), "FKEffector" ) ) {
                object.reset( new Model( id, element, doc, name ) );
            }
        }
        else if (!strncmp(obtype,"Material",length)) {
            object.reset(new Material(id,element,doc,name));
        }
        else if (!strncmp(obtype,"Texture",length)) {
            object.reset(new Texture(id,element,doc,name));
        }
        else if (!strncmp(obtype,"LayeredTexture",length)) {
            object.reset(new LayeredTexture(id,element,doc,name));
        }
        else if (!strncmp(obtype,"Video",length)) {
            object.reset(new Video(id,element,doc,name));
        }
        else if (!strncmp(obtype,"AnimationStack",length)) {
            object.reset(new AnimationStack(id,element,name,doc));
        }
        else if (!strncmp(obtype,"AnimationLayer",length)) {
            object.reset(new AnimationLayer(id,element,name,doc));
        }
        // note: order matters for these two
        else if (!strncmp(obtype,"AnimationCurve",length)) {
            object.reset(new AnimationCurve(id,element,name,doc));
        }
        else if (!strncmp(obtype,"AnimationCurveNode",length)) {
            object.reset(new AnimationCurveNode(id,element,name,doc));
        }
    }
    catch(std::exception& ex) {
        flags &= ~BEING_CONSTRUCTED;
        flags |= FAILED_TO_CONSTRUCT;

        if(dieOnError || doc.Settings().strictMode) {
            throw;
        }

        // note: the error message is already formatted, so raw logging is ok
        if(!DefaultLogger::isNullLogger()) {
            DefaultLogger::get()->error(ex.what());
        }
        return NULL;
    }

    if (!object.get()) {
        //DOMError("failed to convert element to DOM object, class: " + classtag + ", name: " + name,&element);
    }

    flags &= ~BEING_CONSTRUCTED;
    return object.get();
}

// ------------------------------------------------------------------------------------------------
Object::Object(uint64_t id, const Element& element, const std::string& name)
: element(element)
, name(name)
, id(id)
{

}

// ------------------------------------------------------------------------------------------------
Object::~Object()
{

}


// ------------------------------------------------------------------------------------------------
FileGlobalSettings::FileGlobalSettings(const Document& doc, std::shared_ptr<const PropertyTable> props)
: props(props)
, doc(doc)
{

}


// ------------------------------------------------------------------------------------------------
FileGlobalSettings::~FileGlobalSettings()
{

}


// ------------------------------------------------------------------------------------------------
Document::Document(const Parser& parser, const ImportSettings& settings)
: settings(settings)
, parser(parser)
{
    // Cannot use array default initialization syntax because vc8 fails on it
    for (auto &timeStamp : creationTimeStamp) {
        timeStamp = 0;
    }

    ReadHeader();
    ReadPropertyTemplates();

    ReadGlobalSettings();

    // This order is important, connections need parsed objects to check
    // whether connections are ok or not. Objects may not be evaluated yet,
    // though, since this may require valid connections.
    ReadObjects();
    ReadConnections();
}


// ------------------------------------------------------------------------------------------------
Document::~Document()
{
    for(ObjectMap::value_type& v : objects) {
        delete v.second;
    }

    for(ConnectionMap::value_type& v : src_connections) {
        delete v.second;
    }
    // |dest_connections| contain the same Connection objects as the |src_connections|
}

// ------------------------------------------------------------------------------------------------
static const int LowerSupportedVersion = 7100;
static const int UpperSupportedVersion = 7400;

void Document::ReadHeader()
{
    // Read ID objects from "Objects" section
    const Scope& sc = parser.GetRootScope();
    const Element* const ehead = sc["FBXHeaderExtension"];
    if(!ehead || !ehead->Compound()) {
        DOMError("no FBXHeaderExtension dictionary found");
    }

    const Scope& shead = *ehead->Compound();
    fbxVersion = ParseTokenAsInt(GetRequiredToken(GetRequiredElement(shead,"FBXVersion",ehead),0));

    // While we maye have some success with newer files, we don't support
    // the older 6.n fbx format
    if(fbxVersion < LowerSupportedVersion ) {
        DOMError("unsupported, old format version, supported are only FBX 2011, FBX 2012 and FBX 2013");
    }
    if(fbxVersion > UpperSupportedVersion ) {
        if(Settings().strictMode) {
            DOMError("unsupported, newer format version, supported are only FBX 2011, FBX 2012 and FBX 2013"
                " (turn off strict mode to try anyhow) ");
        }
        else {
            DOMWarning("unsupported, newer format version, supported are only FBX 2011, FBX 2012 and FBX 2013,"
                " trying to read it nevertheless");
        }
    }


    const Element* const ecreator = shead["Creator"];
    if(ecreator) {
        creator = ParseTokenAsString(GetRequiredToken(*ecreator,0));
    }

    const Element* const etimestamp = shead["CreationTimeStamp"];
    if(etimestamp && etimestamp->Compound()) {
        const Scope& stimestamp = *etimestamp->Compound();
        creationTimeStamp[0] = ParseTokenAsInt(GetRequiredToken(GetRequiredElement(stimestamp,"Year"),0));
        creationTimeStamp[1] = ParseTokenAsInt(GetRequiredToken(GetRequiredElement(stimestamp,"Month"),0));
        creationTimeStamp[2] = ParseTokenAsInt(GetRequiredToken(GetRequiredElement(stimestamp,"Day"),0));
        creationTimeStamp[3] = ParseTokenAsInt(GetRequiredToken(GetRequiredElement(stimestamp,"Hour"),0));
        creationTimeStamp[4] = ParseTokenAsInt(GetRequiredToken(GetRequiredElement(stimestamp,"Minute"),0));
        creationTimeStamp[5] = ParseTokenAsInt(GetRequiredToken(GetRequiredElement(stimestamp,"Second"),0));
        creationTimeStamp[6] = ParseTokenAsInt(GetRequiredToken(GetRequiredElement(stimestamp,"Millisecond"),0));
    }
}

// ------------------------------------------------------------------------------------------------
void Document::ReadGlobalSettings()
{
    const Scope& sc = parser.GetRootScope();
    const Element* const ehead = sc["GlobalSettings"];
    if(!ehead || !ehead->Compound()) {
        DOMWarning("no GlobalSettings dictionary found");

        globals.reset(new FileGlobalSettings(*this, std::make_shared<const PropertyTable>()));
        return;
    }

    std::shared_ptr<const PropertyTable> props = GetPropertyTable(*this, "", *ehead, *ehead->Compound(), true);

    if(!props) {
        DOMError("GlobalSettings dictionary contains no property table");
    }

    globals.reset(new FileGlobalSettings(*this, props));
}


// ------------------------------------------------------------------------------------------------
void Document::ReadObjects()
{
    // read ID objects from "Objects" section
    const Scope& sc = parser.GetRootScope();
    const Element* const eobjects = sc["Objects"];
    if(!eobjects || !eobjects->Compound()) {
        DOMError("no Objects dictionary found");
    }

    // add a dummy entry to represent the Model::RootNode object (id 0),
    // which is only indirectly defined in the input file
    objects[0] = new LazyObject(0L, *eobjects, *this);

    const Scope& sobjects = *eobjects->Compound();
    for(const ElementMap::value_type& el : sobjects.Elements()) {

        // extract ID
        const TokenList& tok = el.second->Tokens();

        if (tok.empty()) {
            DOMError("expected ID after object key",el.second);
        }

        const char* err;

        const uint64_t id = ParseTokenAsID(*tok[0], err);
        if(err) {
            DOMError(err,el.second);
        }

        // id=0 is normally implicit
        if(id == 0L) {
            DOMError("encountered object with implicitly defined id 0",el.second);
        }

        if(objects.find(id) != objects.end()) {
            DOMWarning("encountered duplicate object id, ignoring first occurrence",el.second);
        }

        objects[id] = new LazyObject(id, *el.second, *this);

        // grab all animation stacks upfront since there is no listing of them
        if(!strcmp(el.first.c_str(),"AnimationStack")) {
            animationStacks.push_back(id);
        }
    }
}

// ------------------------------------------------------------------------------------------------
void Document::ReadPropertyTemplates()
{
    const Scope& sc = parser.GetRootScope();
    // read property templates from "Definitions" section
    const Element* const edefs = sc["Definitions"];
    if(!edefs || !edefs->Compound()) {
        DOMWarning("no Definitions dictionary found");
        return;
    }

    const Scope& sdefs = *edefs->Compound();
    const ElementCollection otypes = sdefs.GetCollection("ObjectType");
    for(ElementMap::const_iterator it = otypes.first; it != otypes.second; ++it) {
        const Element& el = *(*it).second;
        const Scope* sc = el.Compound();
        if(!sc) {
            DOMWarning("expected nested scope in ObjectType, ignoring",&el);
            continue;
        }

        const TokenList& tok = el.Tokens();
        if(tok.empty()) {
            DOMWarning("expected name for ObjectType element, ignoring",&el);
            continue;
        }

        const std::string& oname = ParseTokenAsString(*tok[0]);

        const ElementCollection templs = sc->GetCollection("PropertyTemplate");
        for(ElementMap::const_iterator it = templs.first; it != templs.second; ++it) {
            const Element& el = *(*it).second;
            const Scope* sc = el.Compound();
            if(!sc) {
                DOMWarning("expected nested scope in PropertyTemplate, ignoring",&el);
                continue;
            }

            const TokenList& tok = el.Tokens();
            if(tok.empty()) {
                DOMWarning("expected name for PropertyTemplate element, ignoring",&el);
                continue;
            }

            const std::string& pname = ParseTokenAsString(*tok[0]);

            const Element* Properties70 = (*sc)["Properties70"];
            if(Properties70) {
                std::shared_ptr<const PropertyTable> props = std::make_shared<const PropertyTable>(
                    *Properties70,std::shared_ptr<const PropertyTable>(static_cast<const PropertyTable*>(NULL))
                );

                templates[oname+"."+pname] = props;
            }
        }
    }
}



// ------------------------------------------------------------------------------------------------
void Document::ReadConnections()
{
    const Scope& sc = parser.GetRootScope();
    // read property templates from "Definitions" section
    const Element* const econns = sc["Connections"];
    if(!econns || !econns->Compound()) {
        DOMError("no Connections dictionary found");
    }

    uint64_t insertionOrder = 0l;

    const Scope& sconns = *econns->Compound();
    const ElementCollection conns = sconns.GetCollection("C");
    for(ElementMap::const_iterator it = conns.first; it != conns.second; ++it) {
        const Element& el = *(*it).second;
        const std::string& type = ParseTokenAsString(GetRequiredToken(el,0));

        // PP = property-property connection, ignored for now
        // (tokens: "PP", ID1, "Property1", ID2, "Property2")
        if(type == "PP") continue;

        const uint64_t src = ParseTokenAsID(GetRequiredToken(el,1));
        const uint64_t dest = ParseTokenAsID(GetRequiredToken(el,2));

        // OO = object-object connection
        // OP = object-property connection, in which case the destination property follows the object ID
        const std::string& prop = (type == "OP" ? ParseTokenAsString(GetRequiredToken(el,3)) : "");

        if(objects.find(src) == objects.end()) {
            DOMWarning("source object for connection does not exist",&el);
            continue;
        }

        // dest may be 0 (root node) but we added a dummy object before
        if(objects.find(dest) == objects.end()) {
            DOMWarning("destination object for connection does not exist",&el);
            continue;
        }

        // add new connection
        const Connection* const c = new Connection(insertionOrder++,src,dest,prop,*this);
        src_connections.insert(ConnectionMap::value_type(src,c));
        dest_connections.insert(ConnectionMap::value_type(dest,c));
    }
}


// ------------------------------------------------------------------------------------------------
const std::vector<const AnimationStack*>& Document::AnimationStacks() const
{
    if (!animationStacksResolved.empty() || !animationStacks.size()) {
        return animationStacksResolved;
    }

    animationStacksResolved.reserve(animationStacks.size());
    for(uint64_t id : animationStacks) {
        LazyObject* const lazy = GetObject(id);
        const AnimationStack* stack;
        if(!lazy || !(stack = lazy->Get<AnimationStack>())) {
            DOMWarning("failed to read AnimationStack object");
            continue;
        }
        animationStacksResolved.push_back(stack);
    }

    return animationStacksResolved;
}


// ------------------------------------------------------------------------------------------------
LazyObject* Document::GetObject(uint64_t id) const
{
    ObjectMap::const_iterator it = objects.find(id);
    return it == objects.end() ? NULL : (*it).second;
}

#define MAX_CLASSNAMES 6

// ------------------------------------------------------------------------------------------------
std::vector<const Connection*> Document::GetConnectionsSequenced(uint64_t id,
    const ConnectionMap& conns) const
{
    std::vector<const Connection*> temp;

    const std::pair<ConnectionMap::const_iterator,ConnectionMap::const_iterator> range =
        conns.equal_range(id);

    temp.reserve(std::distance(range.first,range.second));
    for (ConnectionMap::const_iterator it = range.first; it != range.second; ++it) {
        temp.push_back((*it).second);
    }

    std::sort(temp.begin(), temp.end(), std::mem_fun(&Connection::Compare));

    return temp; // NRVO should handle this
}


// ------------------------------------------------------------------------------------------------
std::vector<const Connection*> Document::GetConnectionsSequenced(uint64_t id, bool is_src,
    const ConnectionMap& conns,
    const char* const* classnames,
    size_t count) const

{
    ai_assert(classnames);
    ai_assert(count != 0 && count <= MAX_CLASSNAMES);

    size_t lenghts[MAX_CLASSNAMES];

    const size_t c = count;
    for (size_t i = 0; i < c; ++i) {
        lenghts[i] = strlen(classnames[i]);
    }

    std::vector<const Connection*> temp;

    const std::pair<ConnectionMap::const_iterator,ConnectionMap::const_iterator> range =
        conns.equal_range(id);

    temp.reserve(std::distance(range.first,range.second));
    for (ConnectionMap::const_iterator it = range.first; it != range.second; ++it) {
        const Token& key = (is_src
            ? (*it).second->LazyDestinationObject()
            : (*it).second->LazySourceObject()
        ).GetElement().KeyToken();

        const char* obtype = key.begin();

        for (size_t i = 0; i < c; ++i) {
            ai_assert(classnames[i]);
            if(static_cast<size_t>(std::distance(key.begin(),key.end())) == lenghts[i] && !strncmp(classnames[i],obtype,lenghts[i])) {
                obtype = NULL;
                break;
            }
        }

        if(obtype) {
            continue;
        }

        temp.push_back((*it).second);
    }

    std::sort(temp.begin(), temp.end(), std::mem_fun(&Connection::Compare));
    return temp; // NRVO should handle this
}


// ------------------------------------------------------------------------------------------------
std::vector<const Connection*> Document::GetConnectionsBySourceSequenced(uint64_t source) const
{
    return GetConnectionsSequenced(source, ConnectionsBySource());
}



// ------------------------------------------------------------------------------------------------
std::vector<const Connection*> Document::GetConnectionsBySourceSequenced(uint64_t dest,
    const char* classname) const
{
    const char* arr[] = {classname};
    return GetConnectionsBySourceSequenced(dest, arr,1);
}



// ------------------------------------------------------------------------------------------------
std::vector<const Connection*> Document::GetConnectionsBySourceSequenced(uint64_t source,
    const char* const* classnames, size_t count) const
{
    return GetConnectionsSequenced(source, true, ConnectionsBySource(),classnames, count);
}


// ------------------------------------------------------------------------------------------------
std::vector<const Connection*> Document::GetConnectionsByDestinationSequenced(uint64_t dest,
    const char* classname) const
{
    const char* arr[] = {classname};
    return GetConnectionsByDestinationSequenced(dest, arr,1);
}


// ------------------------------------------------------------------------------------------------
std::vector<const Connection*> Document::GetConnectionsByDestinationSequenced(uint64_t dest) const
{
    return GetConnectionsSequenced(dest, ConnectionsByDestination());
}


// ------------------------------------------------------------------------------------------------
std::vector<const Connection*> Document::GetConnectionsByDestinationSequenced(uint64_t dest,
    const char* const* classnames, size_t count) const

{
    return GetConnectionsSequenced(dest, false, ConnectionsByDestination(),classnames, count);
}


// ------------------------------------------------------------------------------------------------
Connection::Connection(uint64_t insertionOrder,  uint64_t src, uint64_t dest, const std::string& prop,
    const Document& doc)

: insertionOrder(insertionOrder)
, prop(prop)
, src(src)
, dest(dest)
, doc(doc)
{
    ai_assert(doc.Objects().find(src) != doc.Objects().end());
    // dest may be 0 (root node)
    ai_assert(!dest || doc.Objects().find(dest) != doc.Objects().end());
}


// ------------------------------------------------------------------------------------------------
Connection::~Connection()
{

}


// ------------------------------------------------------------------------------------------------
LazyObject& Connection::LazySourceObject() const
{
    LazyObject* const lazy = doc.GetObject(src);
    ai_assert(lazy);
    return *lazy;
}


// ------------------------------------------------------------------------------------------------
LazyObject& Connection::LazyDestinationObject() const
{
    LazyObject* const lazy = doc.GetObject(dest);
    ai_assert(lazy);
    return *lazy;
}


// ------------------------------------------------------------------------------------------------
const Object* Connection::SourceObject() const
{
    LazyObject* const lazy = doc.GetObject(src);
    ai_assert(lazy);
    return lazy->Get();
}


// ------------------------------------------------------------------------------------------------
const Object* Connection::DestinationObject() const
{
    LazyObject* const lazy = doc.GetObject(dest);
    ai_assert(lazy);
    return lazy->Get();
}

} // !FBX
} // !Assimp

#endif


/***********************************************************************
FBXIMPORT\FBXDOCUMENTUTIL.CPP
***********************************************************************/
/*
Open Asset Import Library (assimp)
----------------------------------------------------------------------

Copyright (c) 2006-2016, assimp team
All rights reserved.

Redistribution and use of this software in source and binary forms,
with or without modification, are permitted provided that the
following conditions are met:

* Redistributions of source code must retain the above
  copyright notice, this list of conditions and the
  following disclaimer.

* Redistributions in binary form must reproduce the above
  copyright notice, this list of conditions and the
  following disclaimer in the documentation and/or other
  materials provided with the distribution.

* Neither the name of the assimp team, nor the names of its
  contributors may be used to endorse or promote products
  derived from this software without specific prior
  written permission of the assimp team.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
"AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

----------------------------------------------------------------------
*/

/** @file  FBXDocumentUtil.cpp
 *  @brief Implementation of the FBX DOM utility functions declared in FBXDocumentUtil.h
 */

#ifndef ASSIMP_BUILD_NO_FBX_IMPORTER



namespace Assimp {
namespace FBX {
namespace Util {

// ------------------------------------------------------------------------------------------------
// signal DOM construction error, this is always unrecoverable. Throws DeadlyImportError.
void DOMError(const std::string& message, const Token& token)
{
    throw DeadlyImportError(Util::AddTokenText("FBX-DOM",message,&token));
}

// ------------------------------------------------------------------------------------------------
void DOMError(const std::string& message, const Element* element /*= NULL*/)
{
    if(element) {
        DOMError(message,element->KeyToken());
    }
    throw DeadlyImportError("FBX-DOM " + message);
}


// ------------------------------------------------------------------------------------------------
// print warning, do return
void DOMWarning(const std::string& message, const Token& token)
{
    if(DefaultLogger::get()) {
        DefaultLogger::get()->warn(Util::AddTokenText("FBX-DOM",message,&token));
    }
}

// ------------------------------------------------------------------------------------------------
void DOMWarning(const std::string& message, const Element* element /*= NULL*/)
{
    if(element) {
        DOMWarning(message,element->KeyToken());
        return;
    }
    if(DefaultLogger::get()) {
        DefaultLogger::get()->warn("FBX-DOM: " + message);
    }
}


// ------------------------------------------------------------------------------------------------
// fetch a property table and the corresponding property template
std::shared_ptr<const PropertyTable> GetPropertyTable(const Document& doc,
    const std::string& templateName,
    const Element &element,
    const Scope& sc,
    bool no_warn /*= false*/)
{
    const Element* const Properties70 = sc["Properties70"];
    std::shared_ptr<const PropertyTable> templateProps = std::shared_ptr<const PropertyTable>(
        static_cast<const PropertyTable*>(NULL));

    if(templateName.length()) {
        PropertyTemplateMap::const_iterator it = doc.Templates().find(templateName);
        if(it != doc.Templates().end()) {
            templateProps = (*it).second;
        }
    }

    if(!Properties70) {
        if(!no_warn) {
            DOMWarning("property table (Properties70) not found",&element);
        }
        if(templateProps) {
            return templateProps;
        }
        else {
            return std::make_shared<const PropertyTable>();
        }
    }
    return std::make_shared<const PropertyTable>(*Properties70,templateProps);
}
} // !Util
} // !FBX
} // !Assimp

#endif

/***********************************************************************
FBXIMPORT\FBXIMPORTER.CPP
***********************************************************************/
/*
Open Asset Import Library (assimp)
----------------------------------------------------------------------

Copyright (c) 2006-2016, assimp team
All rights reserved.

Redistribution and use of this software in source and binary forms,
with or without modification, are permitted provided that the
following conditions are met:

* Redistributions of source code must retain the above
  copyright notice, this list of conditions and the
  following disclaimer.
r
* Redistributions in binary form must reproduce the above
  copyright notice, this list of conditions and the
  following disclaimer in the documentation and/or other
  materials provided with the distribution.

* Neither the name of the assimp team, nor the names of its
  contributors may be used to endorse or promote products
  derived from this software without specific prior
  written permission of the assimp team.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
"AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

----------------------------------------------------------------------
*/

/** @file  FBXImporter.cpp
 *  @brief Implementation of the FBX importer.
 */

#ifndef ASSIMP_BUILD_NO_FBX_IMPORTER

#include <exception>




namespace Assimp {
    template<> const std::string LogFunctions<FBXImporter>::log_prefix = "FBX: ";
}

using namespace Assimp;
using namespace Assimp::Formatter;
using namespace Assimp::FBX;

namespace {
static const aiImporterDesc desc = {
    "Autodesk FBX Importer",
    "",
    "",
    "",
    aiImporterFlags_SupportTextFlavour,
    0,
    0,
    0,
    0,
    "fbx"
};
}

// ------------------------------------------------------------------------------------------------
// Constructor to be privately used by #Importer
FBXImporter::FBXImporter()
{
}

// ------------------------------------------------------------------------------------------------
// Destructor, private as well
FBXImporter::~FBXImporter()
{
}

// ------------------------------------------------------------------------------------------------
// Returns whether the class can handle the format of the given file.
bool FBXImporter::CanRead( const std::string& pFile, IOSystem* pIOHandler, bool checkSig) const
{
    const std::string& extension = GetExtension(pFile);
    if (extension == "fbx") {
        return true;
    }

    else if ((!extension.length() || checkSig) && pIOHandler)   {
        // at least ASCII-FBX files usually have a 'FBX' somewhere in their head
        const char* tokens[] = {"fbx"};
        return SearchFileHeaderForToken(pIOHandler,pFile,tokens,1);
    }
    return false;
}

// ------------------------------------------------------------------------------------------------
// List all extensions handled by this loader
const aiImporterDesc* FBXImporter::GetInfo () const
{
    return &desc;
}


// ------------------------------------------------------------------------------------------------
// Setup configuration properties for the loader
void FBXImporter::SetupProperties(const Importer* pImp)
{
    settings.readAllLayers = pImp->GetPropertyBool(AI_CONFIG_IMPORT_FBX_READ_ALL_GEOMETRY_LAYERS, true);
    settings.readAllMaterials = pImp->GetPropertyBool(AI_CONFIG_IMPORT_FBX_READ_ALL_MATERIALS, false);
    settings.readMaterials = pImp->GetPropertyBool(AI_CONFIG_IMPORT_FBX_READ_MATERIALS, true);
    settings.readTextures = pImp->GetPropertyBool(AI_CONFIG_IMPORT_FBX_READ_TEXTURES, true);
    settings.readCameras = pImp->GetPropertyBool(AI_CONFIG_IMPORT_FBX_READ_CAMERAS, true);
    settings.readLights = pImp->GetPropertyBool(AI_CONFIG_IMPORT_FBX_READ_LIGHTS, true);
    settings.readAnimations = pImp->GetPropertyBool(AI_CONFIG_IMPORT_FBX_READ_ANIMATIONS, true);
    settings.strictMode = pImp->GetPropertyBool(AI_CONFIG_IMPORT_FBX_STRICT_MODE, false);
    settings.preservePivots = pImp->GetPropertyBool(AI_CONFIG_IMPORT_FBX_PRESERVE_PIVOTS, true);
    settings.optimizeEmptyAnimationCurves = pImp->GetPropertyBool(AI_CONFIG_IMPORT_FBX_OPTIMIZE_EMPTY_ANIMATION_CURVES, true);
}


// ------------------------------------------------------------------------------------------------
// Imports the given file into the given scene structure.
void FBXImporter::InternReadFile( const std::string& pFile,
    aiScene* pScene, IOSystem* pIOHandler)
{
    std::unique_ptr<IOStream> stream(pIOHandler->Open(pFile,"rb"));
    if (!stream) {
        ThrowException("Could not open file for reading");
    }

    // read entire file into memory - no streaming for this, fbx
    // files can grow large, but the assimp output data structure
    // then becomes very large, too. Assimp doesn't support
    // streaming for its output data structures so the net win with
    // streaming input data would be very low.
    std::vector<char> contents;
    contents.resize(stream->FileSize()+1);
    stream->Read( &*contents.begin(), 1, contents.size()-1 );
    contents[ contents.size() - 1 ] = 0;
    const char* const begin = &*contents.begin();

    // broadphase tokenizing pass in which we identify the core
    // syntax elements of FBX (brackets, commas, key:value mappings)
    TokenList tokens;
    try {

        bool is_binary = false;
        if (!strncmp(begin,"Kaydara FBX Binary",18)) {
            is_binary = true;
            TokenizeBinary(tokens,begin,contents.size());
        }
        else {
            Tokenize(tokens,begin);
        }

        // use this information to construct a very rudimentary
        // parse-tree representing the FBX scope structure
        Parser parser(tokens, is_binary);

        // take the raw parse-tree and convert it to a FBX DOM
        Document doc(parser,settings);

        // convert the FBX DOM to aiScene
        ConvertToAssimpScene(pScene,doc);

        std::for_each(tokens.begin(),tokens.end(),Util::delete_fun<Token>());
    }
    catch(std::exception&) {
        std::for_each(tokens.begin(),tokens.end(),Util::delete_fun<Token>());
        throw;
    }
}

#endif // !ASSIMP_BUILD_NO_FBX_IMPORTER

/***********************************************************************
FBXIMPORT\FBXMATERIAL.CPP
***********************************************************************/
/*
Open Asset Import Library (assimp)
----------------------------------------------------------------------

Copyright (c) 2006-2016, assimp team
All rights reserved.

Redistribution and use of this software in source and binary forms,
with or without modification, are permitted provided that the
following conditions are met:

* Redistributions of source code must retain the above
  copyright notice, this list of conditions and the
  following disclaimer.

* Redistributions in binary form must reproduce the above
  copyright notice, this list of conditions and the
  following disclaimer in the documentation and/or other
  materials provided with the distribution.

* Neither the name of the assimp team, nor the names of its
  contributors may be used to endorse or promote products
  derived from this software without specific prior
  written permission of the assimp team.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
"AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

----------------------------------------------------------------------
*/

/** @file  FBXMaterial.cpp
 *  @brief Assimp::FBX::Material and Assimp::FBX::Texture implementation
 */

#ifndef ASSIMP_BUILD_NO_FBX_IMPORTER


namespace Assimp {
namespace FBX {

    using namespace Util;

// ------------------------------------------------------------------------------------------------
Material::Material(uint64_t id, const Element& element, const Document& doc, const std::string& name)
: Object(id,element,name)
{
    const Scope& sc = GetRequiredScope(element);

    const Element* const ShadingModel = sc["ShadingModel"];
    const Element* const MultiLayer = sc["MultiLayer"];

    if(MultiLayer) {
        multilayer = !!ParseTokenAsInt(GetRequiredToken(*MultiLayer,0));
    }

    if(ShadingModel) {
        shading = ParseTokenAsString(GetRequiredToken(*ShadingModel,0));
    }
    else {
        DOMWarning("shading mode not specified, assuming phong",&element);
        shading = "phong";
    }

    std::string templateName;

    const char* const sh = shading.c_str();
    if(!strcmp(sh,"phong")) {
        templateName = "Material.FbxSurfacePhong";
    }
    else if(!strcmp(sh,"lambert")) {
        templateName = "Material.FbxSurfaceLambert";
    }
    else {
        DOMWarning("shading mode not recognized: " + shading,&element);
    }

    props = GetPropertyTable(doc,templateName,element,sc);

    // resolve texture links
    const std::vector<const Connection*>& conns = doc.GetConnectionsByDestinationSequenced(ID());
    for(const Connection* con : conns) {

        // texture link to properties, not objects
        if (!con->PropertyName().length()) {
            continue;
        }

        const Object* const ob = con->SourceObject();
        if(!ob) {
            DOMWarning("failed to read source object for texture link, ignoring",&element);
            continue;
        }

        const Texture* const tex = dynamic_cast<const Texture*>(ob);
        if(!tex) {
            const LayeredTexture* const layeredTexture = dynamic_cast<const LayeredTexture*>(ob);
            if(!layeredTexture) {
                DOMWarning("source object for texture link is not a texture or layered texture, ignoring",&element);
                continue;
            }
            const std::string& prop = con->PropertyName();
            if (layeredTextures.find(prop) != layeredTextures.end()) {
                DOMWarning("duplicate layered texture link: " + prop,&element);
            }

            layeredTextures[prop] = layeredTexture;
            ((LayeredTexture*)layeredTexture)->fillTexture(doc);
        }
        else
        {
            const std::string& prop = con->PropertyName();
            if (textures.find(prop) != textures.end()) {
                DOMWarning("duplicate texture link: " + prop,&element);
            }

            textures[prop] = tex;
        }

    }
}


// ------------------------------------------------------------------------------------------------
Material::~Material()
{
}


// ------------------------------------------------------------------------------------------------
Texture::Texture(uint64_t id, const Element& element, const Document& doc, const std::string& name)
: Object(id,element,name)
, uvScaling(1.0f,1.0f)
, media(0)
{
    const Scope& sc = GetRequiredScope(element);

    const Element* const Type = sc["Type"];
    const Element* const FileName = sc["FileName"];
    const Element* const RelativeFilename = sc["RelativeFilename"];
    const Element* const ModelUVTranslation = sc["ModelUVTranslation"];
    const Element* const ModelUVScaling = sc["ModelUVScaling"];
    const Element* const Texture_Alpha_Source = sc["Texture_Alpha_Source"];
    const Element* const Cropping = sc["Cropping"];

    if(Type) {
        type = ParseTokenAsString(GetRequiredToken(*Type,0));
    }

    if(FileName) {
        fileName = ParseTokenAsString(GetRequiredToken(*FileName,0));
    }

    if(RelativeFilename) {
        relativeFileName = ParseTokenAsString(GetRequiredToken(*RelativeFilename,0));
    }

    if(ModelUVTranslation) {
        uvTrans = aiVector2D(ParseTokenAsFloat(GetRequiredToken(*ModelUVTranslation,0)),
            ParseTokenAsFloat(GetRequiredToken(*ModelUVTranslation,1))
        );
    }

    if(ModelUVScaling) {
        uvScaling = aiVector2D(ParseTokenAsFloat(GetRequiredToken(*ModelUVScaling,0)),
            ParseTokenAsFloat(GetRequiredToken(*ModelUVScaling,1))
        );
    }

    if(Cropping) {
        crop[0] = ParseTokenAsInt(GetRequiredToken(*Cropping,0));
        crop[1] = ParseTokenAsInt(GetRequiredToken(*Cropping,1));
        crop[2] = ParseTokenAsInt(GetRequiredToken(*Cropping,2));
        crop[3] = ParseTokenAsInt(GetRequiredToken(*Cropping,3));
    }
    else {
        // vc8 doesn't support the crop() syntax in initialization lists
        // (and vc9 WARNS about the new (i.e. compliant) behaviour).
        crop[0] = crop[1] = crop[2] = crop[3] = 0;
    }

    if(Texture_Alpha_Source) {
        alphaSource = ParseTokenAsString(GetRequiredToken(*Texture_Alpha_Source,0));
    }

    props = GetPropertyTable(doc,"Texture.FbxFileTexture",element,sc);

    // resolve video links
    if(doc.Settings().readTextures) {
        const std::vector<const Connection*>& conns = doc.GetConnectionsByDestinationSequenced(ID());
        for(const Connection* con : conns) {
            const Object* const ob = con->SourceObject();
            if(!ob) {
                DOMWarning("failed to read source object for texture link, ignoring",&element);
                continue;
            }

            const Video* const video = dynamic_cast<const Video*>(ob);
            if(video) {
                media = video;
            }
        }
    }
}


Texture::~Texture()
{

}

LayeredTexture::LayeredTexture(uint64_t id, const Element& element, const Document& /*doc*/, const std::string& name)
: Object(id,element,name)
,texture(0)
,blendMode(BlendMode_Modulate)
,alpha(1)
{
    const Scope& sc = GetRequiredScope(element);

    const Element* const BlendModes = sc["BlendModes"];
    const Element* const Alphas = sc["Alphas"];


    if(BlendModes!=0)
    {
        blendMode = (BlendMode)ParseTokenAsInt(GetRequiredToken(*BlendModes,0));
    }
    if(Alphas!=0)
    {
        alpha = ParseTokenAsFloat(GetRequiredToken(*Alphas,0));
    }
}

LayeredTexture::~LayeredTexture()
{

}

void LayeredTexture::fillTexture(const Document& doc)
{
    const std::vector<const Connection*>& conns = doc.GetConnectionsByDestinationSequenced(ID());
    for(size_t i = 0; i < conns.size();++i)
    {
        const Connection* con = conns.at(i);

        const Object* const ob = con->SourceObject();
        if(!ob) {
            DOMWarning("failed to read source object for texture link, ignoring",&element);
            continue;
        }

        const Texture* const tex = dynamic_cast<const Texture*>(ob);

        texture = tex;
    }
}


// ------------------------------------------------------------------------------------------------
Video::Video(uint64_t id, const Element& element, const Document& doc, const std::string& name)
: Object(id,element,name)
, contentLength(0)
, content(0)
{
    const Scope& sc = GetRequiredScope(element);

    const Element* const Type = sc["Type"];
    const Element* const FileName = sc["FileName"];
    const Element* const RelativeFilename = sc["RelativeFilename"];
    const Element* const Content = sc["Content"];

    if(Type) {
        type = ParseTokenAsString(GetRequiredToken(*Type,0));
    }

    if(FileName) {
        fileName = ParseTokenAsString(GetRequiredToken(*FileName,0));
    }

    if(RelativeFilename) {
        relativeFileName = ParseTokenAsString(GetRequiredToken(*RelativeFilename,0));
    }

    if(Content) {
        const Token& token = GetRequiredToken(*Content, 0);
        const char* data = token.begin();
        if(!token.IsBinary()) {
            DOMWarning("video content is not binary data, ignoring", &element);
        }
        else if(static_cast<size_t>(token.end() - data) < 5) {
            DOMError("binary data array is too short, need five (5) bytes for type signature and element count", &element);
        }
        else if(*data != 'R') {
            DOMWarning("video content is not raw binary data, ignoring", &element);
        }
        else {
            // read number of elements
            uint32_t len = 0;
            ::memcpy(&len, data + 1, sizeof(len));
            AI_SWAP4(len);

            contentLength = len;

            content = new uint8_t[len];
            ::memcpy(content, data + 5, len);
        }
    }

    props = GetPropertyTable(doc,"Video.FbxVideo",element,sc);
}


Video::~Video()
{
    if(content) {
        delete[] content;
    }
}

} //!FBX
} //!Assimp

#endif

/***********************************************************************
FBXIMPORT\FBXMESHGEOMETRY.CPP
***********************************************************************/
/*
Open Asset Import Library (assimp)
----------------------------------------------------------------------

Copyright (c) 2006-2016, assimp team
All rights reserved.

Redistribution and use of this software in source and binary forms,
with or without modification, are permitted provided that the
following conditions are met:

* Redistributions of source code must retain the above
  copyright notice, this list of conditions and the
  following disclaimer.

* Redistributions in binary form must reproduce the above
  copyright notice, this list of conditions and the
  following disclaimer in the documentation and/or other
  materials provided with the distribution.

* Neither the name of the assimp team, nor the names of its
  contributors may be used to endorse or promote products
  derived from this software without specific prior
  written permission of the assimp team.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
"AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

----------------------------------------------------------------------
*/

/** @file  FBXMeshGeometry.cpp
 *  @brief Assimp::FBX::MeshGeometry implementation
 */

#ifndef ASSIMP_BUILD_NO_FBX_IMPORTER




namespace Assimp {
namespace FBX {

using namespace Util;

// ------------------------------------------------------------------------------------------------
Geometry::Geometry(uint64_t id, const Element& element, const std::string& name, const Document& doc)
    : Object(id, element,name)
    , skin()
{
    const std::vector<const Connection*>& conns = doc.GetConnectionsByDestinationSequenced(ID(),"Deformer");
    for(const Connection* con : conns) {
        const Skin* const sk = ProcessSimpleConnection<Skin>(*con, false, "Skin -> Geometry", element);
        if(sk) {
            skin = sk;
            break;
        }
    }
}


// ------------------------------------------------------------------------------------------------
Geometry::~Geometry()
{

}

const Skin* Geometry::DeformerSkin() const {
    return skin;
}


// ------------------------------------------------------------------------------------------------
MeshGeometry::MeshGeometry(uint64_t id, const Element& element, const std::string& name, const Document& doc)
: Geometry(id, element,name, doc)
{
    const Scope* sc = element.Compound();
    if (!sc) {
        DOMError("failed to read Geometry object (class: Mesh), no data scope found");
    }

    // must have Mesh elements:
    const Element& Vertices = GetRequiredElement(*sc,"Vertices",&element);
    const Element& PolygonVertexIndex = GetRequiredElement(*sc,"PolygonVertexIndex",&element);

    // optional Mesh elements:
    const ElementCollection& Layer = sc->GetCollection("Layer");

    std::vector<aiVector3D> tempVerts;
    ParseVectorDataArray(tempVerts,Vertices);

    if(tempVerts.empty()) {
        FBXImporter::LogWarn("encountered mesh with no vertices");
        return;
    }

    std::vector<int> tempFaces;
    ParseVectorDataArray(tempFaces,PolygonVertexIndex);

    if(tempFaces.empty()) {
        FBXImporter::LogWarn("encountered mesh with no faces");
        return;
    }

    vertices.reserve(tempFaces.size());
    faces.reserve(tempFaces.size() / 3);

    mapping_offsets.resize(tempVerts.size());
    mapping_counts.resize(tempVerts.size(),0);
    mappings.resize(tempFaces.size());

    const size_t vertex_count = tempVerts.size();

    // generate output vertices, computing an adjacency table to
    // preserve the mapping from fbx indices to *this* indexing.
    unsigned int count = 0;
    for(int index : tempFaces) {
        const int absi = index < 0 ? (-index - 1) : index;
        if(static_cast<size_t>(absi) >= vertex_count) {
            DOMError("polygon vertex index out of range",&PolygonVertexIndex);
        }

        vertices.push_back(tempVerts[absi]);
        ++count;

        ++mapping_counts[absi];

        if (index < 0) {
            faces.push_back(count);
            count = 0;
        }
    }

    unsigned int cursor = 0;
    for (size_t i = 0, e = tempVerts.size(); i < e; ++i) {
        mapping_offsets[i] = cursor;
        cursor += mapping_counts[i];

        mapping_counts[i] = 0;
    }

    cursor = 0;
    for(int index : tempFaces) {
        const int absi = index < 0 ? (-index - 1) : index;
        mappings[mapping_offsets[absi] + mapping_counts[absi]++] = cursor++;
    }

    // if settings.readAllLayers is true:
    //  * read all layers, try to load as many vertex channels as possible
    // if settings.readAllLayers is false:
    //  * read only the layer with index 0, but warn about any further layers
    for (ElementMap::const_iterator it = Layer.first; it != Layer.second; ++it) {
        const TokenList& tokens = (*it).second->Tokens();

        const char* err;
        const int index = ParseTokenAsInt(*tokens[0], err);
        if(err) {
            DOMError(err,&element);
        }

        if(doc.Settings().readAllLayers || index == 0) {
            const Scope& layer = GetRequiredScope(*(*it).second);
            ReadLayer(layer);
        }
        else {
            FBXImporter::LogWarn("ignoring additional geometry layers");
        }
    }
}

// ------------------------------------------------------------------------------------------------
MeshGeometry::~MeshGeometry()
{

}

// ------------------------------------------------------------------------------------------------
const std::vector<aiVector3D>& MeshGeometry::GetVertices() const {
    return vertices;
}

// ------------------------------------------------------------------------------------------------
const std::vector<aiVector3D>& MeshGeometry::GetNormals() const {
    return normals;
}

// ------------------------------------------------------------------------------------------------
const std::vector<aiVector3D>& MeshGeometry::GetTangents() const {
    return tangents;
}

// ------------------------------------------------------------------------------------------------
const std::vector<aiVector3D>& MeshGeometry::GetBinormals() const {
    return binormals;
}

// ------------------------------------------------------------------------------------------------
const std::vector<unsigned int>& MeshGeometry::GetFaceIndexCounts() const {
    return faces;
}

// ------------------------------------------------------------------------------------------------
const std::vector<aiVector2D>& MeshGeometry::GetTextureCoords( unsigned int index ) const {
    static const std::vector<aiVector2D> empty;
    return index >= AI_MAX_NUMBER_OF_TEXTURECOORDS ? empty : uvs[ index ];
}

std::string MeshGeometry::GetTextureCoordChannelName( unsigned int index ) const {
    return index >= AI_MAX_NUMBER_OF_TEXTURECOORDS ? "" : uvNames[ index ];
}

const std::vector<aiColor4D>& MeshGeometry::GetVertexColors( unsigned int index ) const {
    static const std::vector<aiColor4D> empty;
    return index >= AI_MAX_NUMBER_OF_COLOR_SETS ? empty : colors[ index ];
}

const MatIndexArray& MeshGeometry::GetMaterialIndices() const {
    return materials;
}

// ------------------------------------------------------------------------------------------------
const unsigned int* MeshGeometry::ToOutputVertexIndex( unsigned int in_index, unsigned int& count ) const {
    if ( in_index >= mapping_counts.size() ) {
        return NULL;
    }

    ai_assert( mapping_counts.size() == mapping_offsets.size() );
    count = mapping_counts[ in_index ];

    ai_assert( count != 0 );
    ai_assert( mapping_offsets[ in_index ] + count <= mappings.size() );

    return &mappings[ mapping_offsets[ in_index ] ];
}

// ------------------------------------------------------------------------------------------------
unsigned int MeshGeometry::FaceForVertexIndex( unsigned int in_index ) const {
    ai_assert( in_index < vertices.size() );

    // in the current conversion pattern this will only be needed if
    // weights are present, so no need to always pre-compute this table
    if ( facesVertexStartIndices.empty() ) {
        facesVertexStartIndices.resize( faces.size() + 1, 0 );

        std::partial_sum( faces.begin(), faces.end(), facesVertexStartIndices.begin() + 1 );
        facesVertexStartIndices.pop_back();
    }

    ai_assert( facesVertexStartIndices.size() == faces.size() );
    const std::vector<unsigned int>::iterator it = std::upper_bound(
        facesVertexStartIndices.begin(),
        facesVertexStartIndices.end(),
        in_index
        );

    return static_cast< unsigned int >( std::distance( facesVertexStartIndices.begin(), it - 1 ) );
}

// ------------------------------------------------------------------------------------------------
void MeshGeometry::ReadLayer(const Scope& layer)
{
    const ElementCollection& LayerElement = layer.GetCollection("LayerElement");
    for (ElementMap::const_iterator eit = LayerElement.first; eit != LayerElement.second; ++eit) {
        const Scope& elayer = GetRequiredScope(*(*eit).second);

        ReadLayerElement(elayer);
    }
}


// ------------------------------------------------------------------------------------------------
void MeshGeometry::ReadLayerElement(const Scope& layerElement)
{
    const Element& Type = GetRequiredElement(layerElement,"Type");
    const Element& TypedIndex = GetRequiredElement(layerElement,"TypedIndex");

    const std::string& type = ParseTokenAsString(GetRequiredToken(Type,0));
    const int typedIndex = ParseTokenAsInt(GetRequiredToken(TypedIndex,0));

    const Scope& top = GetRequiredScope(element);
    const ElementCollection candidates = top.GetCollection(type);

    for (ElementMap::const_iterator it = candidates.first; it != candidates.second; ++it) {
        const int index = ParseTokenAsInt(GetRequiredToken(*(*it).second,0));
        if(index == typedIndex) {
            ReadVertexData(type,typedIndex,GetRequiredScope(*(*it).second));
            return;
        }
    }

    FBXImporter::LogError(Formatter::format("failed to resolve vertex layer element: ")
        << type << ", index: " << typedIndex);
}


// ------------------------------------------------------------------------------------------------
void MeshGeometry::ReadVertexData(const std::string& type, int index, const Scope& source)
{
    const std::string& MappingInformationType = ParseTokenAsString(GetRequiredToken(
        GetRequiredElement(source,"MappingInformationType"),0)
    );

    const std::string& ReferenceInformationType = ParseTokenAsString(GetRequiredToken(
        GetRequiredElement(source,"ReferenceInformationType"),0)
    );

    if (type == "LayerElementUV") {
        if(index >= AI_MAX_NUMBER_OF_TEXTURECOORDS) {
            FBXImporter::LogError(Formatter::format("ignoring UV layer, maximum number of UV channels exceeded: ")
                << index << " (limit is " << AI_MAX_NUMBER_OF_TEXTURECOORDS << ")" );
            return;
        }

        const Element* Name = source["Name"];
        uvNames[index] = "";
        if(Name) {
            uvNames[index] = ParseTokenAsString(GetRequiredToken(*Name,0));
        }

        ReadVertexDataUV(uvs[index],source,
            MappingInformationType,
            ReferenceInformationType
        );
    }
    else if (type == "LayerElementMaterial") {
        if (materials.size() > 0) {
            FBXImporter::LogError("ignoring additional material layer");
            return;
        }

        std::vector<int> temp_materials;

        ReadVertexDataMaterials(temp_materials,source,
            MappingInformationType,
            ReferenceInformationType
        );

        // sometimes, there will be only negative entries. Drop the material
        // layer in such a case (I guess it means a default material should
        // be used). This is what the converter would do anyway, and it
        // avoids losing the material if there are more material layers
        // coming of which at least one contains actual data (did observe
        // that with one test file).
        const size_t count_neg = std::count_if(temp_materials.begin(),temp_materials.end(),std::bind2nd(std::less<int>(),0));
        if(count_neg == temp_materials.size()) {
            FBXImporter::LogWarn("ignoring dummy material layer (all entries -1)");
            return;
        }

        std::swap(temp_materials, materials);
    }
    else if (type == "LayerElementNormal") {
        if (normals.size() > 0) {
            FBXImporter::LogError("ignoring additional normal layer");
            return;
        }

        ReadVertexDataNormals(normals,source,
            MappingInformationType,
            ReferenceInformationType
        );
    }
    else if (type == "LayerElementTangent") {
        if (tangents.size() > 0) {
            FBXImporter::LogError("ignoring additional tangent layer");
            return;
        }

        ReadVertexDataTangents(tangents,source,
            MappingInformationType,
            ReferenceInformationType
        );
    }
    else if (type == "LayerElementBinormal") {
        if (binormals.size() > 0) {
            FBXImporter::LogError("ignoring additional binormal layer");
            return;
        }

        ReadVertexDataBinormals(binormals,source,
            MappingInformationType,
            ReferenceInformationType
        );
    }
    else if (type == "LayerElementColor") {
        if(index >= AI_MAX_NUMBER_OF_COLOR_SETS) {
            FBXImporter::LogError(Formatter::format("ignoring vertex color layer, maximum number of color sets exceeded: ")
                << index << " (limit is " << AI_MAX_NUMBER_OF_COLOR_SETS << ")" );
            return;
        }

        ReadVertexDataColors(colors[index],source,
            MappingInformationType,
            ReferenceInformationType
        );
    }
}


// ------------------------------------------------------------------------------------------------
// Lengthy utility function to read and resolve a FBX vertex data array - that is, the
// output is in polygon vertex order. This logic is used for reading normals, UVs, colors,
// tangents ..
template <typename T>
void ResolveVertexDataArray(std::vector<T>& data_out, const Scope& source,
    const std::string& MappingInformationType,
    const std::string& ReferenceInformationType,
    const char* dataElementName,
    const char* indexDataElementName,
    size_t vertex_count,
    const std::vector<unsigned int>& mapping_counts,
    const std::vector<unsigned int>& mapping_offsets,
    const std::vector<unsigned int>& mappings)
{


    // handle permutations of Mapping and Reference type - it would be nice to
    // deal with this more elegantly and with less redundancy, but right
    // now it seems unavoidable.
    if (MappingInformationType == "ByVertice" && ReferenceInformationType == "Direct") {
		std::vector<T> tempData;
		ParseVectorDataArray(tempData, GetRequiredElement(source, dataElementName));

        data_out.resize(vertex_count);
		for (size_t i = 0, e = tempData.size(); i < e; ++i) {

            const unsigned int istart = mapping_offsets[i], iend = istart + mapping_counts[i];
            for (unsigned int j = istart; j < iend; ++j) {
				data_out[mappings[j]] = tempData[i];
            }
        }
    }
    else if (MappingInformationType == "ByVertice" && ReferenceInformationType == "IndexToDirect") {
		std::vector<T> tempData;
		ParseVectorDataArray(tempData, GetRequiredElement(source, dataElementName));

        data_out.resize(vertex_count);

        std::vector<int> uvIndices;
        ParseVectorDataArray(uvIndices,GetRequiredElement(source,indexDataElementName));

        for (size_t i = 0, e = uvIndices.size(); i < e; ++i) {

            const unsigned int istart = mapping_offsets[i], iend = istart + mapping_counts[i];
            for (unsigned int j = istart; j < iend; ++j) {
				if (static_cast<size_t>(uvIndices[i]) >= tempData.size()) {
                    DOMError("index out of range",&GetRequiredElement(source,indexDataElementName));
                }
				data_out[mappings[j]] = tempData[uvIndices[i]];
            }
        }
    }
    else if (MappingInformationType == "ByPolygonVertex" && ReferenceInformationType == "Direct") {
		std::vector<T> tempData;
		ParseVectorDataArray(tempData, GetRequiredElement(source, dataElementName));

		if (tempData.size() != vertex_count) {
            FBXImporter::LogError(Formatter::format("length of input data unexpected for ByPolygon mapping: ")
				<< tempData.size() << ", expected " << vertex_count
            );
            return;
        }

		data_out.swap(tempData);
    }
    else if (MappingInformationType == "ByPolygonVertex" && ReferenceInformationType == "IndexToDirect") {
		std::vector<T> tempData;
		ParseVectorDataArray(tempData, GetRequiredElement(source, dataElementName));

        data_out.resize(vertex_count);

        std::vector<int> uvIndices;
        ParseVectorDataArray(uvIndices,GetRequiredElement(source,indexDataElementName));

        if (uvIndices.size() != vertex_count) {
            FBXImporter::LogError("length of input data unexpected for ByPolygonVertex mapping");
            return;
        }

        unsigned int next = 0;
        for(int i : uvIndices) {
			if (static_cast<size_t>(i) >= tempData.size()) {
                DOMError("index out of range",&GetRequiredElement(source,indexDataElementName));
            }

			data_out[next++] = tempData[i];
        }
    }
    else {
        FBXImporter::LogError(Formatter::format("ignoring vertex data channel, access type not implemented: ")
            << MappingInformationType << "," << ReferenceInformationType);
    }
}

// ------------------------------------------------------------------------------------------------
void MeshGeometry::ReadVertexDataNormals(std::vector<aiVector3D>& normals_out, const Scope& source,
    const std::string& MappingInformationType,
    const std::string& ReferenceInformationType)
{
    ResolveVertexDataArray(normals_out,source,MappingInformationType,ReferenceInformationType,
        "Normals",
        "NormalsIndex",
        vertices.size(),
        mapping_counts,
        mapping_offsets,
        mappings);
}


// ------------------------------------------------------------------------------------------------
void MeshGeometry::ReadVertexDataUV(std::vector<aiVector2D>& uv_out, const Scope& source,
    const std::string& MappingInformationType,
    const std::string& ReferenceInformationType)
{
    ResolveVertexDataArray(uv_out,source,MappingInformationType,ReferenceInformationType,
        "UV",
        "UVIndex",
        vertices.size(),
        mapping_counts,
        mapping_offsets,
        mappings);
}


// ------------------------------------------------------------------------------------------------
void MeshGeometry::ReadVertexDataColors(std::vector<aiColor4D>& colors_out, const Scope& source,
    const std::string& MappingInformationType,
    const std::string& ReferenceInformationType)
{
    ResolveVertexDataArray(colors_out,source,MappingInformationType,ReferenceInformationType,
        "Colors",
        "ColorIndex",
        vertices.size(),
        mapping_counts,
        mapping_offsets,
        mappings);
}

// ------------------------------------------------------------------------------------------------
static const std::string TangentIndexToken = "TangentIndex";
static const std::string TangentsIndexToken = "TangentsIndex";

void MeshGeometry::ReadVertexDataTangents(std::vector<aiVector3D>& tangents_out, const Scope& source,
    const std::string& MappingInformationType,
    const std::string& ReferenceInformationType)
{
    const char * str = source.Elements().count( "Tangents" ) > 0 ? "Tangents" : "Tangent";
    const char * strIdx = source.Elements().count( "Tangents" ) > 0 ? TangentsIndexToken.c_str() : TangentIndexToken.c_str();
    ResolveVertexDataArray(tangents_out,source,MappingInformationType,ReferenceInformationType,
        str,
        strIdx,
        vertices.size(),
        mapping_counts,
        mapping_offsets,
        mappings);
}

// ------------------------------------------------------------------------------------------------
static const std::string BinormalIndexToken = "BinormalIndex";
static const std::string BinormalsIndexToken = "BinormalsIndex";

void MeshGeometry::ReadVertexDataBinormals(std::vector<aiVector3D>& binormals_out, const Scope& source,
    const std::string& MappingInformationType,
    const std::string& ReferenceInformationType)
{
    const char * str = source.Elements().count( "Binormals" ) > 0 ? "Binormals" : "Binormal";
    const char * strIdx = source.Elements().count( "Binormals" ) > 0 ? BinormalsIndexToken.c_str() : BinormalIndexToken.c_str();
    ResolveVertexDataArray(binormals_out,source,MappingInformationType,ReferenceInformationType,
        str,
        strIdx,
        vertices.size(),
        mapping_counts,
        mapping_offsets,
        mappings);
}


// ------------------------------------------------------------------------------------------------
void MeshGeometry::ReadVertexDataMaterials(std::vector<int>& materials_out, const Scope& source,
    const std::string& MappingInformationType,
    const std::string& ReferenceInformationType)
{
    const size_t face_count = faces.size();
    ai_assert(face_count);

    // materials are handled separately. First of all, they are assigned per-face
    // and not per polyvert. Secondly, ReferenceInformationType=IndexToDirect
    // has a slightly different meaning for materials.
    ParseVectorDataArray(materials_out,GetRequiredElement(source,"Materials"));

    if (MappingInformationType == "AllSame") {
        // easy - same material for all faces
        if (materials_out.empty()) {
            FBXImporter::LogError(Formatter::format("expected material index, ignoring"));
            return;
        }
        else if (materials_out.size() > 1) {
            FBXImporter::LogWarn(Formatter::format("expected only a single material index, ignoring all except the first one"));
            materials_out.clear();
        }

        materials.assign(vertices.size(),materials_out[0]);
    }
    else if (MappingInformationType == "ByPolygon" && ReferenceInformationType == "IndexToDirect") {
        materials.resize(face_count);

        if(materials_out.size() != face_count) {
            FBXImporter::LogError(Formatter::format("length of input data unexpected for ByPolygon mapping: ")
                << materials_out.size() << ", expected " << face_count
            );
            return;
        }
    }
    else {
        FBXImporter::LogError(Formatter::format("ignoring material assignments, access type not implemented: ")
            << MappingInformationType << "," << ReferenceInformationType);
    }
}

} // !FBX
} // !Assimp

#endif


/***********************************************************************
FBXIMPORT\FBXMODEL.CPP
***********************************************************************/
/*
Open Asset Import Library (assimp)
----------------------------------------------------------------------

Copyright (c) 2006-2016, assimp team
All rights reserved.

Redistribution and use of this software in source and binary forms,
with or without modification, are permitted provided that the
following conditions are met:

* Redistributions of source code must retain the above
  copyright notice, this list of conditions and the
  following disclaimer.

* Redistributions in binary form must reproduce the above
  copyright notice, this list of conditions and the
  following disclaimer in the documentation and/or other
  materials provided with the distribution.

* Neither the name of the assimp team, nor the names of its
  contributors may be used to endorse or promote products
  derived from this software without specific prior
  written permission of the assimp team.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
"AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

----------------------------------------------------------------------
*/

/** @file  FBXModel.cpp
 *  @brief Assimp::FBX::Model implementation
 */

#ifndef ASSIMP_BUILD_NO_FBX_IMPORTER


namespace Assimp {
namespace FBX {

using namespace Util;

// ------------------------------------------------------------------------------------------------
Model::Model(uint64_t id, const Element& element, const Document& doc, const std::string& name)
    : Object(id,element,name)
    , shading("Y")
{
    const Scope& sc = GetRequiredScope(element);
    const Element* const Shading = sc["Shading"];
    const Element* const Culling = sc["Culling"];

    if(Shading) {
        shading = GetRequiredToken(*Shading,0).StringContents();
    }

    if (Culling) {
        culling = ParseTokenAsString(GetRequiredToken(*Culling,0));
    }

    props = GetPropertyTable(doc,"Model.FbxNode",element,sc);
    ResolveLinks(element,doc);
}


// ------------------------------------------------------------------------------------------------
Model::~Model()
{

}


// ------------------------------------------------------------------------------------------------
void Model::ResolveLinks(const Element& element, const Document& doc)
{
    const char* const arr[] = {"Geometry","Material","NodeAttribute"};

    // resolve material
    const std::vector<const Connection*>& conns = doc.GetConnectionsByDestinationSequenced(ID(),arr, 3);

    materials.reserve(conns.size());
    geometry.reserve(conns.size());
    attributes.reserve(conns.size());
    for(const Connection* con : conns) {

        // material and geometry links should be Object-Object connections
        if (con->PropertyName().length()) {
            continue;
        }

        const Object* const ob = con->SourceObject();
        if(!ob) {
            DOMWarning("failed to read source object for incoming Model link, ignoring",&element);
            continue;
        }

        const Material* const mat = dynamic_cast<const Material*>(ob);
        if(mat) {
            materials.push_back(mat);
            continue;
        }

        const Geometry* const geo = dynamic_cast<const Geometry*>(ob);
        if(geo) {
            geometry.push_back(geo);
            continue;
        }

        const NodeAttribute* const att = dynamic_cast<const NodeAttribute*>(ob);
        if(att) {
            attributes.push_back(att);
            continue;
        }

        DOMWarning("source object for model link is neither Material, NodeAttribute nor Geometry, ignoring",&element);
        continue;
    }
}


// ------------------------------------------------------------------------------------------------
bool Model::IsNull() const
{
    const std::vector<const NodeAttribute*>& attrs = GetAttributes();
    for(const NodeAttribute* att : attrs) {

        const Null* null_tag = dynamic_cast<const Null*>(att);
        if(null_tag) {
            return true;
        }
    }

    return false;
}


} //!FBX
} //!Assimp

#endif

/***********************************************************************
FBXIMPORT\FBXNODEATTRIBUTE.CPP
***********************************************************************/
/*
Open Asset Import Library (assimp)
----------------------------------------------------------------------

Copyright (c) 2006-2016, assimp team
All rights reserved.

Redistribution and use of this software in source and binary forms,
with or without modification, are permitted provided that the
following conditions are met:

* Redistributions of source code must retain the above
  copyright notice, this list of conditions and the
  following disclaimer.

* Redistributions in binary form must reproduce the above
  copyright notice, this list of conditions and the
  following disclaimer in the documentation and/or other
  materials provided with the distribution.

* Neither the name of the assimp team, nor the names of its
  contributors may be used to endorse or promote products
  derived from this software without specific prior
  written permission of the assimp team.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
"AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

----------------------------------------------------------------------
*/

/** @file  FBXNoteAttribute.cpp
 *  @brief Assimp::FBX::NodeAttribute (and subclasses) implementation
 */

#ifndef ASSIMP_BUILD_NO_FBX_IMPORTER


namespace Assimp {
namespace FBX {

    using namespace Util;

// ------------------------------------------------------------------------------------------------
NodeAttribute::NodeAttribute(uint64_t id, const Element& element, const Document& doc, const std::string& name)
: Object(id,element,name)
, props()
{
    const Scope& sc = GetRequiredScope(element);

    const std::string& classname = ParseTokenAsString(GetRequiredToken(element,2));

    // hack on the deriving type but Null/LimbNode attributes are the only case in which
    // the property table is by design absent and no warning should be generated
    // for it.
    const bool is_null_or_limb = !strcmp(classname.c_str(), "Null") || !strcmp(classname.c_str(), "LimbNode");
    props = GetPropertyTable(doc,"NodeAttribute.Fbx" + classname,element,sc, is_null_or_limb);
}


// ------------------------------------------------------------------------------------------------
NodeAttribute::~NodeAttribute()
{

}


// ------------------------------------------------------------------------------------------------
CameraSwitcher::CameraSwitcher(uint64_t id, const Element& element, const Document& doc, const std::string& name)
    : NodeAttribute(id,element,doc,name)
{
    const Scope& sc = GetRequiredScope(element);
    const Element* const CameraId = sc["CameraId"];
    const Element* const CameraName = sc["CameraName"];
    const Element* const CameraIndexName = sc["CameraIndexName"];

    if(CameraId) {
        cameraId = ParseTokenAsInt(GetRequiredToken(*CameraId,0));
    }

    if(CameraName) {
        cameraName = GetRequiredToken(*CameraName,0).StringContents();
    }

    if(CameraIndexName && CameraIndexName->Tokens().size()) {
        cameraIndexName = GetRequiredToken(*CameraIndexName,0).StringContents();
    }
}


// ------------------------------------------------------------------------------------------------
CameraSwitcher::~CameraSwitcher()
{

}


// ------------------------------------------------------------------------------------------------
Camera::Camera(uint64_t id, const Element& element, const Document& doc, const std::string& name)
: NodeAttribute(id,element,doc,name)
{

}


// ------------------------------------------------------------------------------------------------
Camera::~Camera()
{
}


// ------------------------------------------------------------------------------------------------
Light::Light(uint64_t id, const Element& element, const Document& doc, const std::string& name)
: NodeAttribute(id,element,doc,name)
{

}


// ------------------------------------------------------------------------------------------------
Light::~Light()
{
}


// ------------------------------------------------------------------------------------------------
Null::Null(uint64_t id, const Element& element, const Document& doc, const std::string& name)
: NodeAttribute(id,element,doc,name)
{

}


// ------------------------------------------------------------------------------------------------
Null::~Null()
{

}


// ------------------------------------------------------------------------------------------------
LimbNode::LimbNode(uint64_t id, const Element& element, const Document& doc, const std::string& name)
: NodeAttribute(id,element,doc,name)
{

}


// ------------------------------------------------------------------------------------------------
LimbNode::~LimbNode()
{

}

}
}

#endif

/***********************************************************************
FBXIMPORT\FBXPARSER.CPP
***********************************************************************/
/*
Open Asset Import Library (assimp)
----------------------------------------------------------------------

Copyright (c) 2006-2016, assimp team
All rights reserved.

Redistribution and use of this software in source and binary forms,
with or without modification, are permitted provided that the
following conditions are met:

* Redistributions of source code must retain the above
  copyright notice, this list of conditions and the
  following disclaimer.

* Redistributions in binary form must reproduce the above
  copyright notice, this list of conditions and the
  following disclaimer in the documentation and/or other
  materials provided with the distribution.

* Neither the name of the assimp team, nor the names of its
  contributors may be used to endorse or promote products
  derived from this software without specific prior
  written permission of the assimp team.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
"AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

----------------------------------------------------------------------
*/

/** @file  FBXParser.cpp
 *  @brief Implementation of the FBX parser and the rudimentary DOM that we use
 */





using namespace Assimp;
using namespace Assimp::FBX;

namespace {


    // ------------------------------------------------------------------------------------------------
    // signal parse error, this is always unrecoverable. Throws DeadlyImportError.
    AI_WONT_RETURN void ParseError(const std::string& message, const Token& token) AI_WONT_RETURN_SUFFIX;
    AI_WONT_RETURN void ParseError(const std::string& message, const Token& token)
    {
        throw DeadlyImportError(Util::AddTokenText("FBX-Parser",message,&token));
    }

    // ------------------------------------------------------------------------------------------------
    AI_WONT_RETURN void ParseError(const std::string& message, const Element* element = NULL) AI_WONT_RETURN_SUFFIX;
    AI_WONT_RETURN void ParseError(const std::string& message, const Element* element)
    {
        if(element) {
            ParseError(message,element->KeyToken());
        }
        throw DeadlyImportError("FBX-Parser " + message);
    }


    // ------------------------------------------------------------------------------------------------
    void ParseError(const std::string& message, TokenPtr token)
    {
        if(token) {
            ParseError(message, *token);
        }
        ParseError(message);
    }

    // Initially, we did reinterpret_cast, breaking strict aliasing rules.
    // This actually caused trouble on Android, so let's be safe this time.
    // https://github.com/assimp/assimp/issues/24
    template <typename T>
    T SafeParse(const char* data, const char* end) {
        // Actual size validation happens during Tokenization so
        // this is valid as an assertion.
        ai_assert(static_cast<size_t>(end - data) >= sizeof(T));
        T result = static_cast<T>(0);
        ::memcpy(&result, data, sizeof(T));
        return result;
    }
}

namespace Assimp {
namespace FBX {

// ------------------------------------------------------------------------------------------------
Element::Element(const Token& key_token, Parser& parser)
: key_token(key_token)
{
    TokenPtr n = NULL;
    do {
        n = parser.AdvanceToNextToken();
        if(!n) {
            ParseError("unexpected end of file, expected closing bracket",parser.LastToken());
        }

        if (n->Type() == TokenType_DATA) {
            tokens.push_back(n);
			TokenPtr prev = n;
            n = parser.AdvanceToNextToken();
            if(!n) {
                ParseError("unexpected end of file, expected bracket, comma or key",parser.LastToken());
            }

			const TokenType ty = n->Type();

			// some exporters are missing a comma on the next line
			if (ty == TokenType_DATA && prev->Type() == TokenType_DATA && (n->Line() == prev->Line() + 1)) {
				tokens.push_back(n);
				continue;
			}

            if (ty != TokenType_OPEN_BRACKET && ty != TokenType_CLOSE_BRACKET && ty != TokenType_COMMA && ty != TokenType_KEY) {
                ParseError("unexpected token; expected bracket, comma or key",n);
            }
        }

        if (n->Type() == TokenType_OPEN_BRACKET) {
            compound.reset(new Scope(parser));

            // current token should be a TOK_CLOSE_BRACKET
            n = parser.CurrentToken();
            ai_assert(n);

            if (n->Type() != TokenType_CLOSE_BRACKET) {
                ParseError("expected closing bracket",n);
            }

            parser.AdvanceToNextToken();
            return;
        }
    }
    while(n->Type() != TokenType_KEY && n->Type() != TokenType_CLOSE_BRACKET);
}

// ------------------------------------------------------------------------------------------------
Element::~Element()
{
     // no need to delete tokens, they are owned by the parser
}

// ------------------------------------------------------------------------------------------------
Scope::Scope(Parser& parser,bool topLevel)
{
    if(!topLevel) {
        TokenPtr t = parser.CurrentToken();
        if (t->Type() != TokenType_OPEN_BRACKET) {
            ParseError("expected open bracket",t);
        }
    }

    TokenPtr n = parser.AdvanceToNextToken();
    if(n == NULL) {
        ParseError("unexpected end of file");
    }

    // note: empty scopes are allowed
    while(n->Type() != TokenType_CLOSE_BRACKET) {
        if (n->Type() != TokenType_KEY) {
            ParseError("unexpected token, expected TOK_KEY",n);
        }

        const std::string& str = n->StringContents();
        elements.insert(ElementMap::value_type(str,new_Element(*n,parser)));

        // Element() should stop at the next Key token (or right after a Close token)
        n = parser.CurrentToken();
        if(n == NULL) {
            if (topLevel) {
                return;
            }
            ParseError("unexpected end of file",parser.LastToken());
        }
    }
}

// ------------------------------------------------------------------------------------------------
Scope::~Scope()
{
    for(ElementMap::value_type& v : elements) {
        delete v.second;
    }
}


// ------------------------------------------------------------------------------------------------
Parser::Parser (const TokenList& tokens, bool is_binary)
: tokens(tokens)
, last()
, current()
, cursor(tokens.begin())
, is_binary(is_binary)
{
    root.reset(new Scope(*this,true));
}


// ------------------------------------------------------------------------------------------------
Parser::~Parser()
{
}


// ------------------------------------------------------------------------------------------------
TokenPtr Parser::AdvanceToNextToken()
{
    last = current;
    if (cursor == tokens.end()) {
        current = NULL;
    }
    else {
        current = *cursor++;
    }
    return current;
}


// ------------------------------------------------------------------------------------------------
TokenPtr Parser::CurrentToken() const
{
    return current;
}


// ------------------------------------------------------------------------------------------------
TokenPtr Parser::LastToken() const
{
    return last;
}


// ------------------------------------------------------------------------------------------------
uint64_t ParseTokenAsID(const Token& t, const char*& err_out)
{
    err_out = NULL;

    if (t.Type() != TokenType_DATA) {
        err_out = "expected TOK_DATA token";
        return 0L;
    }

    if(t.IsBinary())
    {
        const char* data = t.begin();
        if (data[0] != 'L') {
            err_out = "failed to parse ID, unexpected data type, expected L(ong) (binary)";
            return 0L;
        }

        BE_NCONST uint64_t id = SafeParse<uint64_t>(data+1, t.end());
        AI_SWAP8(id);
        return id;
    }

    // XXX: should use size_t here
    unsigned int length = static_cast<unsigned int>(t.end() - t.begin());
    ai_assert(length > 0);

    const char* out;
    const uint64_t id = strtoul10_64(t.begin(),&out,&length);
    if (out > t.end()) {
        err_out = "failed to parse ID (text)";
        return 0L;
    }

    return id;
}


// ------------------------------------------------------------------------------------------------
size_t ParseTokenAsDim(const Token& t, const char*& err_out)
{
    // same as ID parsing, except there is a trailing asterisk
    err_out = NULL;

    if (t.Type() != TokenType_DATA) {
        err_out = "expected TOK_DATA token";
        return 0;
    }

    if(t.IsBinary())
    {
        const char* data = t.begin();
        if (data[0] != 'L') {
            err_out = "failed to parse ID, unexpected data type, expected L(ong) (binary)";
            return 0;
        }

        BE_NCONST uint64_t id = SafeParse<uint64_t>(data+1, t.end());
        AI_SWAP8(id);
        return static_cast<size_t>(id);
    }

    if(*t.begin() != '*') {
        err_out = "expected asterisk before array dimension";
        return 0;
    }

    // XXX: should use size_t here
    unsigned int length = static_cast<unsigned int>(t.end() - t.begin());
    if(length == 0) {
        err_out = "expected valid integer number after asterisk";
        return 0;
    }

    const char* out;
    const size_t id = static_cast<size_t>(strtoul10_64(t.begin() + 1,&out,&length));
    if (out > t.end()) {
        err_out = "failed to parse ID";
        return 0;
    }

    return id;
}


// ------------------------------------------------------------------------------------------------
float ParseTokenAsFloat(const Token& t, const char*& err_out)
{
    err_out = NULL;

    if (t.Type() != TokenType_DATA) {
        err_out = "expected TOK_DATA token";
        return 0.0f;
    }

    if(t.IsBinary())
    {
        const char* data = t.begin();
        if (data[0] != 'F' && data[0] != 'D') {
            err_out = "failed to parse F(loat) or D(ouble), unexpected data type (binary)";
            return 0.0f;
        }

        if (data[0] == 'F') {
            return SafeParse<float>(data+1, t.end());
        }
        else {
            return static_cast<float>( SafeParse<double>(data+1, t.end()) );
        }
    }

    // need to copy the input string to a temporary buffer
    // first - next in the fbx token stream comes ',',
    // which fast_atof could interpret as decimal point.
#define MAX_FLOAT_LENGTH 31
    char temp[MAX_FLOAT_LENGTH + 1];
    const size_t length = static_cast<size_t>(t.end()-t.begin());
    std::copy(t.begin(),t.end(),temp);
    temp[std::min(static_cast<size_t>(MAX_FLOAT_LENGTH),length)] = '\0';

    return fast_atof(temp);
}


// ------------------------------------------------------------------------------------------------
int ParseTokenAsInt(const Token& t, const char*& err_out)
{
    err_out = NULL;

    if (t.Type() != TokenType_DATA) {
        err_out = "expected TOK_DATA token";
        return 0;
    }

    if(t.IsBinary())
    {
        const char* data = t.begin();
        if (data[0] != 'I') {
            err_out = "failed to parse I(nt), unexpected data type (binary)";
            return 0;
        }

        BE_NCONST int32_t ival = SafeParse<int32_t>(data+1, t.end());
        AI_SWAP4(ival);
        return static_cast<int>(ival);
    }

    ai_assert(static_cast<size_t>(t.end() - t.begin()) > 0);

    const char* out;
    const int intval = strtol10(t.begin(),&out);
    if (out != t.end()) {
        err_out = "failed to parse ID";
        return 0;
    }

    return intval;
}


// ------------------------------------------------------------------------------------------------
int64_t ParseTokenAsInt64(const Token& t, const char*& err_out)
{
    err_out = NULL;

    if (t.Type() != TokenType_DATA) {
        err_out = "expected TOK_DATA token";
        return 0L;
    }

    if (t.IsBinary())
    {
        const char* data = t.begin();
        if (data[0] != 'L') {
            err_out = "failed to parse Int64, unexpected data type";
            return 0L;
        }

        BE_NCONST int64_t id = SafeParse<int64_t>(data + 1, t.end());
        AI_SWAP8(id);
        return id;
    }

    // XXX: should use size_t here
    unsigned int length = static_cast<unsigned int>(t.end() - t.begin());
    ai_assert(length > 0);

    const char* out;
    const int64_t id = strtol10_64(t.begin(), &out, &length);
    if (out > t.end()) {
        err_out = "failed to parse Int64 (text)";
        return 0L;
    }

    return id;
}

// ------------------------------------------------------------------------------------------------
std::string ParseTokenAsString(const Token& t, const char*& err_out)
{
    err_out = NULL;

    if (t.Type() != TokenType_DATA) {
        err_out = "expected TOK_DATA token";
        return "";
    }

    if(t.IsBinary())
    {
        const char* data = t.begin();
        if (data[0] != 'S') {
            err_out = "failed to parse S(tring), unexpected data type (binary)";
            return "";
        }

        // read string length
        BE_NCONST int32_t len = SafeParse<int32_t>(data+1, t.end());
        AI_SWAP4(len);

        ai_assert(t.end() - data == 5 + len);
        return std::string(data + 5, len);
    }

    const size_t length = static_cast<size_t>(t.end() - t.begin());
    if(length < 2) {
        err_out = "token is too short to hold a string";
        return "";
    }

    const char* s = t.begin(), *e = t.end() - 1;
    if (*s != '\"' || *e != '\"') {
        err_out = "expected double quoted string";
        return "";
    }

    return std::string(s+1,length-2);
}


namespace {

// ------------------------------------------------------------------------------------------------
// read the type code and element count of a binary data array and stop there
void ReadBinaryDataArrayHead(const char*& data, const char* end, char& type, uint32_t& count,
    const Element& el)
{
    if (static_cast<size_t>(end-data) < 5) {
        ParseError("binary data array is too short, need five (5) bytes for type signature and element count",&el);
    }

    // data type
    type = *data;

    // read number of elements
    BE_NCONST uint32_t len = SafeParse<uint32_t>(data+1, end);
    AI_SWAP4(len);

    count = len;
    data += 5;
}


// ------------------------------------------------------------------------------------------------
// read binary data array, assume cursor points to the 'compression mode' field (i.e. behind the header)
void ReadBinaryDataArray(char type, uint32_t count, const char*& data, const char* end,
    std::vector<char>& buff,
    const Element& /*el*/)
{
    BE_NCONST uint32_t encmode = SafeParse<uint32_t>(data, end);
    AI_SWAP4(encmode);
    data += 4;

    // next comes the compressed length
    BE_NCONST uint32_t comp_len = SafeParse<uint32_t>(data, end);
    AI_SWAP4(comp_len);
    data += 4;

    ai_assert(data + comp_len == end);

    // determine the length of the uncompressed data by looking at the type signature
    uint32_t stride = 0;
    switch(type)
    {
    case 'f':
    case 'i':
        stride = 4;
        break;

    case 'd':
    case 'l':
        stride = 8;
        break;

    default:
        ai_assert(false);
    };

    const uint32_t full_length = stride * count;
    buff.resize(full_length);

    if(encmode == 0) {
        ai_assert(full_length == comp_len);

        // plain data, no compression
        std::copy(data, end, buff.begin());
    }
    else if(encmode == 1) {
        // zlib/deflate, next comes ZIP head (0x78 0x01)
        // see http://www.ietf.org/rfc/rfc1950.txt

        z_stream zstream;
        zstream.opaque = Z_NULL;
        zstream.zalloc = Z_NULL;
        zstream.zfree  = Z_NULL;
        zstream.data_type = Z_BINARY;

        // http://hewgill.com/journal/entries/349-how-to-decompress-gzip-stream-with-zlib
        if(Z_OK != inflateInit(&zstream)) {
            ParseError("failure initializing zlib");
        }

        zstream.next_in   = reinterpret_cast<Bytef*>( const_cast<char*>(data) );
        zstream.avail_in  = comp_len;

        zstream.avail_out = buff.size();
        zstream.next_out = reinterpret_cast<Bytef*>(&*buff.begin());
        const int ret = inflate(&zstream, Z_FINISH);

        if (ret != Z_STREAM_END && ret != Z_OK) {
            ParseError("failure decompressing compressed data section");
        }

        // terminate zlib
        inflateEnd(&zstream);
    }
#ifdef ASSIMP_BUILD_DEBUG
    else {
        // runtime check for this happens at tokenization stage
        ai_assert(false);
    }
#endif

    data += comp_len;
    ai_assert(data == end);
}

} // !anon


// ------------------------------------------------------------------------------------------------
// read an array of float3 tuples
void ParseVectorDataArray(std::vector<aiVector3D>& out, const Element& el)
{
    out.resize( 0 );

    const TokenList& tok = el.Tokens();
    if(tok.empty()) {
        ParseError("unexpected empty element",&el);
    }

    if(tok[0]->IsBinary()) {
        const char* data = tok[0]->begin(), *end = tok[0]->end();

        char type;
        uint32_t count;
        ReadBinaryDataArrayHead(data, end, type, count, el);

        if(count % 3 != 0) {
            ParseError("number of floats is not a multiple of three (3) (binary)",&el);
        }

        if(!count) {
            return;
        }

        if (type != 'd' && type != 'f') {
            ParseError("expected float or double array (binary)",&el);
        }

        std::vector<char> buff;
        ReadBinaryDataArray(type, count, data, end, buff, el);

        ai_assert(data == end);
        ai_assert(buff.size() == count * (type == 'd' ? 8 : 4));

        const uint32_t count3 = count / 3;
        out.reserve(count3);

        if (type == 'd') {
            const double* d = reinterpret_cast<const double*>(&buff[0]);
            for (unsigned int i = 0; i < count3; ++i, d += 3) {
                out.push_back(aiVector3D(static_cast<float>(d[0]),
                    static_cast<float>(d[1]),
                    static_cast<float>(d[2])));
            }
            // for debugging
            /*for ( size_t i = 0; i < out.size(); i++ ) {
                aiVector3D vec3( out[ i ] );
                std::stringstream stream;
                stream << " vec3.x = " << vec3.x << " vec3.y = " << vec3.y << " vec3.z = " << vec3.z << std::endl;
                DefaultLogger::get()->info( stream.str() );
            }*/
        }
        else if (type == 'f') {
            const float* f = reinterpret_cast<const float*>(&buff[0]);
            for (unsigned int i = 0; i < count3; ++i, f += 3) {
                out.push_back(aiVector3D(f[0],f[1],f[2]));
            }
        }

        return;
    }

    const size_t dim = ParseTokenAsDim(*tok[0]);

    // may throw bad_alloc if the input is rubbish, but this need
    // not to be prevented - importing would fail but we wouldn't
    // crash since assimp handles this case properly.
    out.reserve(dim);

    const Scope& scope = GetRequiredScope(el);
    const Element& a = GetRequiredElement(scope,"a",&el);

    if (a.Tokens().size() % 3 != 0) {
        ParseError("number of floats is not a multiple of three (3)",&el);
    }
    for (TokenList::const_iterator it = a.Tokens().begin(), end = a.Tokens().end(); it != end; ) {
        aiVector3D v;
        v.x = ParseTokenAsFloat(**it++);
        v.y = ParseTokenAsFloat(**it++);
        v.z = ParseTokenAsFloat(**it++);

        out.push_back(v);
    }
}


// ------------------------------------------------------------------------------------------------
// read an array of color4 tuples
void ParseVectorDataArray(std::vector<aiColor4D>& out, const Element& el)
{
    out.resize( 0 );
    const TokenList& tok = el.Tokens();
    if(tok.empty()) {
        ParseError("unexpected empty element",&el);
    }

    if(tok[0]->IsBinary()) {
        const char* data = tok[0]->begin(), *end = tok[0]->end();

        char type;
        uint32_t count;
        ReadBinaryDataArrayHead(data, end, type, count, el);

        if(count % 4 != 0) {
            ParseError("number of floats is not a multiple of four (4) (binary)",&el);
        }

        if(!count) {
            return;
        }

        if (type != 'd' && type != 'f') {
            ParseError("expected float or double array (binary)",&el);
        }

        std::vector<char> buff;
        ReadBinaryDataArray(type, count, data, end, buff, el);

        ai_assert(data == end);
        ai_assert(buff.size() == count * (type == 'd' ? 8 : 4));

        const uint32_t count4 = count / 4;
        out.reserve(count4);

        if (type == 'd') {
            const double* d = reinterpret_cast<const double*>(&buff[0]);
            for (unsigned int i = 0; i < count4; ++i, d += 4) {
                out.push_back(aiColor4D(static_cast<float>(d[0]),
                    static_cast<float>(d[1]),
                    static_cast<float>(d[2]),
                    static_cast<float>(d[3])));
            }
        }
        else if (type == 'f') {
            const float* f = reinterpret_cast<const float*>(&buff[0]);
            for (unsigned int i = 0; i < count4; ++i, f += 4) {
                out.push_back(aiColor4D(f[0],f[1],f[2],f[3]));
            }
        }
        return;
    }

    const size_t dim = ParseTokenAsDim(*tok[0]);

    //  see notes in ParseVectorDataArray() above
    out.reserve(dim);

    const Scope& scope = GetRequiredScope(el);
    const Element& a = GetRequiredElement(scope,"a",&el);

    if (a.Tokens().size() % 4 != 0) {
        ParseError("number of floats is not a multiple of four (4)",&el);
    }
    for (TokenList::const_iterator it = a.Tokens().begin(), end = a.Tokens().end(); it != end; ) {
        aiColor4D v;
        v.r = ParseTokenAsFloat(**it++);
        v.g = ParseTokenAsFloat(**it++);
        v.b = ParseTokenAsFloat(**it++);
        v.a = ParseTokenAsFloat(**it++);

        out.push_back(v);
    }
}


// ------------------------------------------------------------------------------------------------
// read an array of float2 tuples
void ParseVectorDataArray(std::vector<aiVector2D>& out, const Element& el)
{
    out.resize( 0 );
    const TokenList& tok = el.Tokens();
    if(tok.empty()) {
        ParseError("unexpected empty element",&el);
    }

    if(tok[0]->IsBinary()) {
        const char* data = tok[0]->begin(), *end = tok[0]->end();

        char type;
        uint32_t count;
        ReadBinaryDataArrayHead(data, end, type, count, el);

        if(count % 2 != 0) {
            ParseError("number of floats is not a multiple of two (2) (binary)",&el);
        }

        if(!count) {
            return;
        }

        if (type != 'd' && type != 'f') {
            ParseError("expected float or double array (binary)",&el);
        }

        std::vector<char> buff;
        ReadBinaryDataArray(type, count, data, end, buff, el);

        ai_assert(data == end);
        ai_assert(buff.size() == count * (type == 'd' ? 8 : 4));

        const uint32_t count2 = count / 2;
        out.reserve(count2);

        if (type == 'd') {
            const double* d = reinterpret_cast<const double*>(&buff[0]);
            for (unsigned int i = 0; i < count2; ++i, d += 2) {
                out.push_back(aiVector2D(static_cast<float>(d[0]),
                    static_cast<float>(d[1])));
            }
        }
        else if (type == 'f') {
            const float* f = reinterpret_cast<const float*>(&buff[0]);
            for (unsigned int i = 0; i < count2; ++i, f += 2) {
                out.push_back(aiVector2D(f[0],f[1]));
            }
        }

        return;
    }

    const size_t dim = ParseTokenAsDim(*tok[0]);

    // see notes in ParseVectorDataArray() above
    out.reserve(dim);

    const Scope& scope = GetRequiredScope(el);
    const Element& a = GetRequiredElement(scope,"a",&el);

    if (a.Tokens().size() % 2 != 0) {
        ParseError("number of floats is not a multiple of two (2)",&el);
    }
    for (TokenList::const_iterator it = a.Tokens().begin(), end = a.Tokens().end(); it != end; ) {
        aiVector2D v;
        v.x = ParseTokenAsFloat(**it++);
        v.y = ParseTokenAsFloat(**it++);

        out.push_back(v);
    }
}


// ------------------------------------------------------------------------------------------------
// read an array of ints
void ParseVectorDataArray(std::vector<int>& out, const Element& el)
{
    out.resize( 0 );
    const TokenList& tok = el.Tokens();
    if(tok.empty()) {
        ParseError("unexpected empty element",&el);
    }

    if(tok[0]->IsBinary()) {
        const char* data = tok[0]->begin(), *end = tok[0]->end();

        char type;
        uint32_t count;
        ReadBinaryDataArrayHead(data, end, type, count, el);

        if(!count) {
            return;
        }

        if (type != 'i') {
            ParseError("expected int array (binary)",&el);
        }

        std::vector<char> buff;
        ReadBinaryDataArray(type, count, data, end, buff, el);

        ai_assert(data == end);
        ai_assert(buff.size() == count * 4);

        out.reserve(count);

        const int32_t* ip = reinterpret_cast<const int32_t*>(&buff[0]);
        for (unsigned int i = 0; i < count; ++i, ++ip) {
            BE_NCONST int32_t val = *ip;
            AI_SWAP4(val);
            out.push_back(val);
        }

        return;
    }

    const size_t dim = ParseTokenAsDim(*tok[0]);

    // see notes in ParseVectorDataArray()
    out.reserve(dim);

    const Scope& scope = GetRequiredScope(el);
    const Element& a = GetRequiredElement(scope,"a",&el);

    for (TokenList::const_iterator it = a.Tokens().begin(), end = a.Tokens().end(); it != end; ) {
        const int ival = ParseTokenAsInt(**it++);
        out.push_back(ival);
    }
}


// ------------------------------------------------------------------------------------------------
// read an array of floats
void ParseVectorDataArray(std::vector<float>& out, const Element& el)
{
    out.resize( 0 );
    const TokenList& tok = el.Tokens();
    if(tok.empty()) {
        ParseError("unexpected empty element",&el);
    }

    if(tok[0]->IsBinary()) {
        const char* data = tok[0]->begin(), *end = tok[0]->end();

        char type;
        uint32_t count;
        ReadBinaryDataArrayHead(data, end, type, count, el);

        if(!count) {
            return;
        }

        if (type != 'd' && type != 'f') {
            ParseError("expected float or double array (binary)",&el);
        }

        std::vector<char> buff;
        ReadBinaryDataArray(type, count, data, end, buff, el);

        ai_assert(data == end);
        ai_assert(buff.size() == count * (type == 'd' ? 8 : 4));

        if (type == 'd') {
            const double* d = reinterpret_cast<const double*>(&buff[0]);
            for (unsigned int i = 0; i < count; ++i, ++d) {
                out.push_back(static_cast<float>(*d));
            }
        }
        else if (type == 'f') {
            const float* f = reinterpret_cast<const float*>(&buff[0]);
            for (unsigned int i = 0; i < count; ++i, ++f) {
                out.push_back(*f);
            }
        }

        return;
    }

    const size_t dim = ParseTokenAsDim(*tok[0]);

    // see notes in ParseVectorDataArray()
    out.reserve(dim);

    const Scope& scope = GetRequiredScope(el);
    const Element& a = GetRequiredElement(scope,"a",&el);

    for (TokenList::const_iterator it = a.Tokens().begin(), end = a.Tokens().end(); it != end; ) {
        const float ival = ParseTokenAsFloat(**it++);
        out.push_back(ival);
    }
}


// ------------------------------------------------------------------------------------------------
// read an array of uints
void ParseVectorDataArray(std::vector<unsigned int>& out, const Element& el)
{
    out.resize( 0 );
    const TokenList& tok = el.Tokens();
    if(tok.empty()) {
        ParseError("unexpected empty element",&el);
    }

    if(tok[0]->IsBinary()) {
        const char* data = tok[0]->begin(), *end = tok[0]->end();

        char type;
        uint32_t count;
        ReadBinaryDataArrayHead(data, end, type, count, el);

        if(!count) {
            return;
        }

        if (type != 'i') {
            ParseError("expected (u)int array (binary)",&el);
        }

        std::vector<char> buff;
        ReadBinaryDataArray(type, count, data, end, buff, el);

        ai_assert(data == end);
        ai_assert(buff.size() == count * 4);

        out.reserve(count);

        const int32_t* ip = reinterpret_cast<const int32_t*>(&buff[0]);
        for (unsigned int i = 0; i < count; ++i, ++ip) {
            BE_NCONST int32_t val = *ip;
            if(val < 0) {
                ParseError("encountered negative integer index (binary)");
            }

            AI_SWAP4(val);
            out.push_back(val);
        }

        return;
    }

    const size_t dim = ParseTokenAsDim(*tok[0]);

    // see notes in ParseVectorDataArray()
    out.reserve(dim);

    const Scope& scope = GetRequiredScope(el);
    const Element& a = GetRequiredElement(scope,"a",&el);

    for (TokenList::const_iterator it = a.Tokens().begin(), end = a.Tokens().end(); it != end; ) {
        const int ival = ParseTokenAsInt(**it++);
        if(ival < 0) {
            ParseError("encountered negative integer index");
        }
        out.push_back(static_cast<unsigned int>(ival));
    }
}


// ------------------------------------------------------------------------------------------------
// read an array of uint64_ts
void ParseVectorDataArray(std::vector<uint64_t>& out, const Element& el)
{
    out.resize( 0 );
    const TokenList& tok = el.Tokens();
    if(tok.empty()) {
        ParseError("unexpected empty element",&el);
    }

    if(tok[0]->IsBinary()) {
        const char* data = tok[0]->begin(), *end = tok[0]->end();

        char type;
        uint32_t count;
        ReadBinaryDataArrayHead(data, end, type, count, el);

        if(!count) {
            return;
        }

        if (type != 'l') {
            ParseError("expected long array (binary)",&el);
        }

        std::vector<char> buff;
        ReadBinaryDataArray(type, count, data, end, buff, el);

        ai_assert(data == end);
        ai_assert(buff.size() == count * 8);

        out.reserve(count);

        const uint64_t* ip = reinterpret_cast<const uint64_t*>(&buff[0]);
        for (unsigned int i = 0; i < count; ++i, ++ip) {
            BE_NCONST uint64_t val = *ip;
            AI_SWAP8(val);
            out.push_back(val);
        }

        return;
    }

    const size_t dim = ParseTokenAsDim(*tok[0]);

    // see notes in ParseVectorDataArray()
    out.reserve(dim);

    const Scope& scope = GetRequiredScope(el);
    const Element& a = GetRequiredElement(scope,"a",&el);

    for (TokenList::const_iterator it = a.Tokens().begin(), end = a.Tokens().end(); it != end; ) {
        const uint64_t ival = ParseTokenAsID(**it++);

        out.push_back(ival);
    }
}

// ------------------------------------------------------------------------------------------------
// read an array of int64_ts
void ParseVectorDataArray(std::vector<int64_t>& out, const Element& el)
{
    out.resize( 0 );
    const TokenList& tok = el.Tokens();
    if (tok.empty()) {
        ParseError("unexpected empty element", &el);
    }

    if (tok[0]->IsBinary()) {
        const char* data = tok[0]->begin(), *end = tok[0]->end();

        char type;
        uint32_t count;
        ReadBinaryDataArrayHead(data, end, type, count, el);

        if (!count) {
            return;
        }

        if (type != 'l') {
            ParseError("expected long array (binary)", &el);
        }

        std::vector<char> buff;
        ReadBinaryDataArray(type, count, data, end, buff, el);

        ai_assert(data == end);
        ai_assert(buff.size() == count * 8);

        out.reserve(count);

        const int64_t* ip = reinterpret_cast<const int64_t*>(&buff[0]);
        for (unsigned int i = 0; i < count; ++i, ++ip) {
            BE_NCONST int64_t val = *ip;
            AI_SWAP8(val);
            out.push_back(val);
        }

        return;
    }

    const size_t dim = ParseTokenAsDim(*tok[0]);

    // see notes in ParseVectorDataArray()
    out.reserve(dim);

    const Scope& scope = GetRequiredScope(el);
    const Element& a = GetRequiredElement(scope, "a", &el);

    for (TokenList::const_iterator it = a.Tokens().begin(), end = a.Tokens().end(); it != end;) {
        const int64_t ival = ParseTokenAsInt64(**it++);

        out.push_back(ival);
    }
}

// ------------------------------------------------------------------------------------------------
aiMatrix4x4 ReadMatrix(const Element& element)
{
    std::vector<float> values;
    ParseVectorDataArray(values,element);

    if(values.size() != 16) {
        ParseError("expected 16 matrix elements");
    }

    aiMatrix4x4 result;


    result.a1 = values[0];
    result.a2 = values[1];
    result.a3 = values[2];
    result.a4 = values[3];

    result.b1 = values[4];
    result.b2 = values[5];
    result.b3 = values[6];
    result.b4 = values[7];

    result.c1 = values[8];
    result.c2 = values[9];
    result.c3 = values[10];
    result.c4 = values[11];

    result.d1 = values[12];
    result.d2 = values[13];
    result.d3 = values[14];
    result.d4 = values[15];

    result.Transpose();
    return result;
}


// ------------------------------------------------------------------------------------------------
// wrapper around ParseTokenAsString() with ParseError handling
std::string ParseTokenAsString(const Token& t)
{
    const char* err;
    const std::string& i = ParseTokenAsString(t,err);
    if(err) {
        ParseError(err,t);
    }
    return i;
}


// ------------------------------------------------------------------------------------------------
// extract a required element from a scope, abort if the element cannot be found
const Element& GetRequiredElement(const Scope& sc, const std::string& index, const Element* element /*= NULL*/)
{
    const Element* el = sc[index];
    if(!el) {
        ParseError("did not find required element \"" + index + "\"",element);
    }
    return *el;
}


// ------------------------------------------------------------------------------------------------
// extract required compound scope
const Scope& GetRequiredScope(const Element& el)
{
    const Scope* const s = el.Compound();
    if(!s) {
        ParseError("expected compound scope",&el);
    }

    return *s;
}


// ------------------------------------------------------------------------------------------------
// get token at a particular index
const Token& GetRequiredToken(const Element& el, unsigned int index)
{
    const TokenList& t = el.Tokens();
    if(index >= t.size()) {
        ParseError(Formatter::format( "missing token at index " ) << index,&el);
    }

    return *t[index];
}


// ------------------------------------------------------------------------------------------------
// wrapper around ParseTokenAsID() with ParseError handling
uint64_t ParseTokenAsID(const Token& t)
{
    const char* err;
    const uint64_t i = ParseTokenAsID(t,err);
    if(err) {
        ParseError(err,t);
    }
    return i;
}


// ------------------------------------------------------------------------------------------------
// wrapper around ParseTokenAsDim() with ParseError handling
size_t ParseTokenAsDim(const Token& t)
{
    const char* err;
    const size_t i = ParseTokenAsDim(t,err);
    if(err) {
        ParseError(err,t);
    }
    return i;
}


// ------------------------------------------------------------------------------------------------
// wrapper around ParseTokenAsFloat() with ParseError handling
float ParseTokenAsFloat(const Token& t)
{
    const char* err;
    const float i = ParseTokenAsFloat(t,err);
    if(err) {
        ParseError(err,t);
    }
    return i;
}


// ------------------------------------------------------------------------------------------------
// wrapper around ParseTokenAsInt() with ParseError handling
int ParseTokenAsInt(const Token& t)
{
    const char* err;
    const int i = ParseTokenAsInt(t,err);
    if(err) {
        ParseError(err,t);
    }
    return i;
}



// ------------------------------------------------------------------------------------------------
// wrapper around ParseTokenAsInt64() with ParseError handling
int64_t ParseTokenAsInt64(const Token& t)
{
    const char* err;
    const int64_t i = ParseTokenAsInt64(t, err);
    if (err) {
        ParseError(err, t);
    }
    return i;
}

} // !FBX
} // !Assimp

/***********************************************************************
FBXIMPORT\FBXPROPERTIES.CPP
***********************************************************************/
/*
Open Asset Import Library (assimp)
----------------------------------------------------------------------

Copyright (c) 2006-2016, assimp team
All rights reserved.

Redistribution and use of this software in source and binary forms,
with or without modification, are permitted provided that the
following conditions are met:

* Redistributions of source code must retain the above
  copyright notice, this list of conditions and the
  following disclaimer.

* Redistributions in binary form must reproduce the above
  copyright notice, this list of conditions and the
  following disclaimer in the documentation and/or other
  materials provided with the distribution.

* Neither the name of the assimp team, nor the names of its
  contributors may be used to endorse or promote products
  derived from this software without specific prior
  written permission of the assimp team.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
"AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

----------------------------------------------------------------------
*/

/** @file  FBXProperties.cpp
 *  @brief Implementation of the FBX dynamic properties system
 */

#ifndef ASSIMP_BUILD_NO_FBX_IMPORTER


namespace Assimp {
namespace FBX {

    using namespace Util;

// ------------------------------------------------------------------------------------------------
Property::Property()
{
}

// ------------------------------------------------------------------------------------------------
Property::~Property()
{
}

namespace {

// ------------------------------------------------------------------------------------------------
// read a typed property out of a FBX element. The return value is NULL if the property cannot be read.
Property* ReadTypedProperty(const Element& element)
{
    ai_assert(element.KeyToken().StringContents() == "P");

    const TokenList& tok = element.Tokens();
    ai_assert(tok.size() >= 5);

    const std::string& s = ParseTokenAsString(*tok[1]);
    const char* const cs = s.c_str();
    if (!strcmp(cs,"KString")) {
        return new TypedProperty<std::string>(ParseTokenAsString(*tok[4]));
    }
    else if (!strcmp(cs,"bool") || !strcmp(cs,"Bool")) {
        return new TypedProperty<bool>(ParseTokenAsInt(*tok[4]) != 0);
    }
    else if (!strcmp(cs, "int") || !strcmp(cs, "Int") || !strcmp(cs, "enum") || !strcmp(cs, "Enum")) {
        return new TypedProperty<int>(ParseTokenAsInt(*tok[4]));
    }
    else if (!strcmp(cs, "ULongLong")) {
        return new TypedProperty<uint64_t>(ParseTokenAsID(*tok[4]));
    }
    else if (!strcmp(cs, "KTime")) {
        return new TypedProperty<int64_t>(ParseTokenAsInt64(*tok[4]));
    }
    else if (!strcmp(cs,"Vector3D") ||
        !strcmp(cs,"ColorRGB") ||
        !strcmp(cs,"Vector") ||
        !strcmp(cs,"Color") ||
        !strcmp(cs,"Lcl Translation") ||
        !strcmp(cs,"Lcl Rotation") ||
        !strcmp(cs,"Lcl Scaling")
        ) {
        return new TypedProperty<aiVector3D>(aiVector3D(
            ParseTokenAsFloat(*tok[4]),
            ParseTokenAsFloat(*tok[5]),
            ParseTokenAsFloat(*tok[6]))
        );
    }
    else if (!strcmp(cs,"double") || !strcmp(cs,"Number") || !strcmp(cs,"Float") || !strcmp(cs,"FieldOfView")) {
        return new TypedProperty<float>(ParseTokenAsFloat(*tok[4]));
    }
    return NULL;
}


// ------------------------------------------------------------------------------------------------
// peek into an element and check if it contains a FBX property, if so return its name.
std::string PeekPropertyName(const Element& element)
{
    ai_assert(element.KeyToken().StringContents() == "P");
    const TokenList& tok = element.Tokens();
    if(tok.size() < 4) {
        return "";
    }

    return ParseTokenAsString(*tok[0]);
}

} //! anon


// ------------------------------------------------------------------------------------------------
PropertyTable::PropertyTable()
: templateProps()
, element()
{
}


// ------------------------------------------------------------------------------------------------
PropertyTable::PropertyTable(const Element& element, std::shared_ptr<const PropertyTable> templateProps)
: templateProps(templateProps)
, element(&element)
{
    const Scope& scope = GetRequiredScope(element);
    for(const ElementMap::value_type& v : scope.Elements()) {
        if(v.first != "P") {
            DOMWarning("expected only P elements in property table",v.second);
            continue;
        }

        const std::string& name = PeekPropertyName(*v.second);
        if(!name.length()) {
            DOMWarning("could not read property name",v.second);
            continue;
        }

        LazyPropertyMap::const_iterator it = lazyProps.find(name);
        if (it != lazyProps.end()) {
            DOMWarning("duplicate property name, will hide previous value: " + name,v.second);
            continue;
        }

        lazyProps[name] = v.second;
    }
}


// ------------------------------------------------------------------------------------------------
PropertyTable::~PropertyTable()
{
    for(PropertyMap::value_type& v : props) {
        delete v.second;
    }
}


// ------------------------------------------------------------------------------------------------
const Property* PropertyTable::Get(const std::string& name) const
{
    PropertyMap::const_iterator it = props.find(name);
    if (it == props.end()) {
        // hasn't been parsed yet?
        LazyPropertyMap::const_iterator lit = lazyProps.find(name);
        if(lit != lazyProps.end()) {
            props[name] = ReadTypedProperty(*(*lit).second);
            it = props.find(name);

            ai_assert(it != props.end());
        }

        if (it == props.end()) {
            // check property template
            if(templateProps) {
                return templateProps->Get(name);
            }

            return NULL;
        }
    }

    return (*it).second;
}

DirectPropertyMap PropertyTable::GetUnparsedProperties() const
{
    DirectPropertyMap result;

    // Loop through all the lazy properties (which is all the properties)
    for(const LazyPropertyMap::value_type& element : lazyProps) {

        // Skip parsed properties
        if (props.end() != props.find(element.first)) continue;

        // Read the element's value.
        // Wrap the naked pointer (since the call site is required to acquire ownership)
        // std::unique_ptr from C++11 would be preferred both as a wrapper and a return value.
        std::shared_ptr<Property> prop = std::shared_ptr<Property>(ReadTypedProperty(*element.second));

        // Element could not be read. Skip it.
        if (!prop) continue;

        // Add to result
        result[element.first] = prop;
    }

    return result;
}



} //! FBX
} //! Assimp

#endif

/***********************************************************************
FBXIMPORT\FBXTOKENIZER.CPP
***********************************************************************/
/*
Open Asset Import Library (assimp)
----------------------------------------------------------------------

Copyright (c) 2006-2016, assimp team
All rights reserved.

Redistribution and use of this software in source and binary forms,
with or without modification, are permitted provided that the
following conditions are met:

* Redistributions of source code must retain the above
  copyright notice, this list of conditions and the
  following disclaimer.

* Redistributions in binary form must reproduce the above
  copyright notice, this list of conditions and the
  following disclaimer in the documentation and/or other
  materials provided with the distribution.

* Neither the name of the assimp team, nor the names of its
  contributors may be used to endorse or promote products
  derived from this software without specific prior
  written permission of the assimp team.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
"AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

----------------------------------------------------------------------
*/

/** @file  FBXTokenizer.cpp
 *  @brief Implementation of the FBX broadphase lexer
 */

#ifndef ASSIMP_BUILD_NO_FBX_IMPORTER

// tab width for logging columns
#define ASSIMP_FBX_TAB_WIDTH 4



namespace Assimp {
namespace FBX {

// ------------------------------------------------------------------------------------------------
Token::Token(const char* sbegin, const char* send, TokenType type, unsigned int line, unsigned int column)
    :
#ifdef DEBUG
    contents(sbegin, static_cast<size_t>(send-sbegin)),
#endif
    sbegin(sbegin)
    , send(send)
    , type(type)
    , line(line)
    , column(column)
{
    ai_assert(sbegin);
    ai_assert(send);

    // tokens must be of non-zero length
    ai_assert(static_cast<size_t>(send-sbegin) > 0);
}


// ------------------------------------------------------------------------------------------------
Token::~Token()
{
}


namespace {

// ------------------------------------------------------------------------------------------------
// signal tokenization error, this is always unrecoverable. Throws DeadlyImportError.
AI_WONT_RETURN void TokenizeError(const std::string& message, unsigned int line, unsigned int column) AI_WONT_RETURN_SUFFIX;
AI_WONT_RETURN void TokenizeError(const std::string& message, unsigned int line, unsigned int column)
{
    throw DeadlyImportError(Util::AddLineAndColumn("FBX-Tokenize",message,line,column));
}


// process a potential data token up to 'cur', adding it to 'output_tokens'.
// ------------------------------------------------------------------------------------------------
void ProcessDataToken( TokenList& output_tokens, const char*& start, const char*& end,
                      unsigned int line,
                      unsigned int column,
                      TokenType type = TokenType_DATA,
                      bool must_have_token = false)
{
    if (start && end) {
        // sanity check:
        // tokens should have no whitespace outside quoted text and [start,end] should
        // properly delimit the valid range.
        bool in_double_quotes = false;
        for (const char* c = start; c != end + 1; ++c) {
            if (*c == '\"') {
                in_double_quotes = !in_double_quotes;
            }

            if (!in_double_quotes && IsSpaceOrNewLine(*c)) {
                TokenizeError("unexpected whitespace in token", line, column);
            }
        }

        if (in_double_quotes) {
            TokenizeError("non-terminated double quotes", line, column);
        }

        output_tokens.push_back(new_Token(start,end + 1,type,line,column));
    }
    else if (must_have_token) {
        TokenizeError("unexpected character, expected data token", line, column);
    }

    start = end = NULL;
}

}

// ------------------------------------------------------------------------------------------------
void Tokenize(TokenList& output_tokens, const char* input)
{
    ai_assert(input);

    // line and column numbers numbers are one-based
    unsigned int line = 1;
    unsigned int column = 1;

    bool comment = false;
    bool in_double_quotes = false;
    bool pending_data_token = false;

    const char* token_begin = NULL, *token_end = NULL;
    for (const char* cur = input;*cur;column += (*cur == '\t' ? ASSIMP_FBX_TAB_WIDTH : 1), ++cur) {
        const char c = *cur;

        if (IsLineEnd(c)) {
            comment = false;

            column = 0;
            ++line;
        }

        if(comment) {
            continue;
        }

        if(in_double_quotes) {
            if (c == '\"') {
                in_double_quotes = false;
                token_end = cur;

                ProcessDataToken(output_tokens,token_begin,token_end,line,column);
                pending_data_token = false;
            }
            continue;
        }

        switch(c)
        {
        case '\"':
            if (token_begin) {
                TokenizeError("unexpected double-quote", line, column);
            }
            token_begin = cur;
            in_double_quotes = true;
            continue;

        case ';':
            ProcessDataToken(output_tokens,token_begin,token_end,line,column);
            comment = true;
            continue;

        case '{':
            ProcessDataToken(output_tokens,token_begin,token_end, line, column);
            output_tokens.push_back(new_Token(cur,cur+1,TokenType_OPEN_BRACKET,line,column));
            continue;

        case '}':
            ProcessDataToken(output_tokens,token_begin,token_end,line,column);
            output_tokens.push_back(new_Token(cur,cur+1,TokenType_CLOSE_BRACKET,line,column));
            continue;

        case ',':
            if (pending_data_token) {
                ProcessDataToken(output_tokens,token_begin,token_end,line,column,TokenType_DATA,true);
            }
            output_tokens.push_back(new_Token(cur,cur+1,TokenType_COMMA,line,column));
            continue;

        case ':':
            if (pending_data_token) {
                ProcessDataToken(output_tokens,token_begin,token_end,line,column,TokenType_KEY,true);
            }
            else {
                TokenizeError("unexpected colon", line, column);
            }
            continue;
        }

        if (IsSpaceOrNewLine(c)) {

            if (token_begin) {
                // peek ahead and check if the next token is a colon in which
                // case this counts as KEY token.
                TokenType type = TokenType_DATA;
                for (const char* peek = cur;  *peek && IsSpaceOrNewLine(*peek); ++peek) {
                    if (*peek == ':') {
                        type = TokenType_KEY;
                        cur = peek;
                        break;
                    }
                }

                ProcessDataToken(output_tokens,token_begin,token_end,line,column,type);
            }

            pending_data_token = false;
        }
        else {
            token_end = cur;
            if (!token_begin) {
                token_begin = cur;
            }

            pending_data_token = true;
        }
    }
}

} // !FBX
} // !Assimp

#endif

/***********************************************************************
FBXIMPORT\FBXUTIL.CPP
***********************************************************************/
/*
Open Asset Import Library (assimp)
----------------------------------------------------------------------

Copyright (c) 2006-2016, assimp team
All rights reserved.

Redistribution and use of this software in source and binary forms,
with or without modification, are permitted provided that the
following conditions are met:

* Redistributions of source code must retain the above
  copyright notice, this list of conditions and the
  following disclaimer.

* Redistributions in binary form must reproduce the above
  copyright notice, this list of conditions and the
  following disclaimer in the documentation and/or other
  materials provided with the distribution.

* Neither the name of the assimp team, nor the names of its
  contributors may be used to endorse or promote products
  derived from this software without specific prior
  written permission of the assimp team.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
"AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

----------------------------------------------------------------------
*/

/** @file  FBXUtil.cpp
 *  @brief Implementation of internal FBX utility functions
 */



#ifndef ASSIMP_BUILD_NO_FBX_IMPORTER

namespace Assimp {
namespace FBX {
namespace Util {

// ------------------------------------------------------------------------------------------------
const char* TokenTypeString(TokenType t)
{
    switch(t) {
        case TokenType_OPEN_BRACKET:
            return "TOK_OPEN_BRACKET";

        case TokenType_CLOSE_BRACKET:
            return "TOK_CLOSE_BRACKET";

        case TokenType_DATA:
            return "TOK_DATA";

        case TokenType_COMMA:
            return "TOK_COMMA";

        case TokenType_KEY:
            return "TOK_KEY";

        case TokenType_BINARY_DATA:
            return "TOK_BINARY_DATA";
    }

    ai_assert(false);
    return "";
}


// ------------------------------------------------------------------------------------------------
std::string AddOffset(const std::string& prefix, const std::string& text, unsigned int offset)
{
    return static_cast<std::string>( (Formatter::format() << prefix << " (offset 0x" << std::hex << offset << ") " << text) );
}

// ------------------------------------------------------------------------------------------------
std::string AddLineAndColumn(const std::string& prefix, const std::string& text, unsigned int line, unsigned int column)
{
    return static_cast<std::string>( (Formatter::format() << prefix << " (line " << line << " <<  col " << column << ") " << text) );
}

// ------------------------------------------------------------------------------------------------
std::string AddTokenText(const std::string& prefix, const std::string& text, const Token* tok)
{
    if(tok->IsBinary()) {
        return static_cast<std::string>( (Formatter::format() << prefix <<
            " (" << TokenTypeString(tok->Type()) <<
            ", offset 0x" << std::hex << tok->Offset() << ") " <<
            text) );
    }

    return static_cast<std::string>( (Formatter::format() << prefix <<
        " (" << TokenTypeString(tok->Type()) <<
        ", line " << tok->Line() <<
        ", col " << tok->Column() << ") " <<
        text) );
}

} // !Util
} // !FBX
} // !Assimp

#endif

/***********************************************************************
FBXIMPORT\FINDDEGENERATES.CPP
***********************************************************************/
/*
---------------------------------------------------------------------------
Open Asset Import Library (assimp)
---------------------------------------------------------------------------

Copyright (c) 2006-2016, assimp team

All rights reserved.

Redistribution and use of this software in source and binary forms,
with or without modification, are permitted provided that the following
conditions are met:

* Redistributions of source code must retain the above
  copyright notice, this list of conditions and the
  following disclaimer.

* Redistributions in binary form must reproduce the above
  copyright notice, this list of conditions and the
  following disclaimer in the documentation and/or other
  materials provided with the distribution.

* Neither the name of the assimp team, nor the names of its
  contributors may be used to endorse or promote products
  derived from this software without specific prior
  written permission of the assimp team.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
"AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
---------------------------------------------------------------------------
*/

/** @file  FindDegenerates.cpp
 *  @brief Implementation of the FindDegenerates post-process step.
*/



// internal headers

using namespace Assimp;

// ------------------------------------------------------------------------------------------------
// Constructor to be privately used by Importer
FindDegeneratesProcess::FindDegeneratesProcess()
: configRemoveDegenerates (false)
{}

// ------------------------------------------------------------------------------------------------
// Destructor, private as well
FindDegeneratesProcess::~FindDegeneratesProcess()
{
    // nothing to do here
}

// ------------------------------------------------------------------------------------------------
// Returns whether the processing step is present in the given flag field.
bool FindDegeneratesProcess::IsActive( unsigned int pFlags) const
{
    return 0 != (pFlags & aiProcess_FindDegenerates);
}

// ------------------------------------------------------------------------------------------------
// Setup import configuration
void FindDegeneratesProcess::SetupProperties(const Importer* pImp)
{
    // Get the current value of AI_CONFIG_PP_FD_REMOVE
    configRemoveDegenerates = (0 != pImp->GetPropertyInteger(AI_CONFIG_PP_FD_REMOVE,0));
}

// ------------------------------------------------------------------------------------------------
// Executes the post processing step on the given imported data.
void FindDegeneratesProcess::Execute( aiScene* pScene)
{
    DefaultLogger::get()->debug("FindDegeneratesProcess begin");
    for (unsigned int i = 0; i < pScene->mNumMeshes;++i){
        ExecuteOnMesh( pScene->mMeshes[i]);
    }
    DefaultLogger::get()->debug("FindDegeneratesProcess finished");
}

// ------------------------------------------------------------------------------------------------
// Executes the post processing step on the given imported mesh
void FindDegeneratesProcess::ExecuteOnMesh( aiMesh* mesh)
{
    mesh->mPrimitiveTypes = 0;

    std::vector<bool> remove_me;
    if (configRemoveDegenerates)
        remove_me.resize(mesh->mNumFaces,false);

    unsigned int deg = 0, limit;
    for (unsigned int a = 0; a < mesh->mNumFaces; ++a)
    {
        aiFace& face = mesh->mFaces[a];
        bool first = true;

        // check whether the face contains degenerated entries
        for (unsigned int i = 0; i < face.mNumIndices; ++i)
        {
            // Polygons with more than 4 points are allowed to have double points, that is
            // simulating polygons with holes just with concave polygons. However,
            // double points may not come directly after another.
            limit = face.mNumIndices;
            if (face.mNumIndices > 4)
                limit = std::min(limit,i+2);

            for (unsigned int t = i+1; t < limit; ++t)
            {
                if (mesh->mVertices[face.mIndices[i]] == mesh->mVertices[face.mIndices[t]])
                {
                    // we have found a matching vertex position
                    // remove the corresponding index from the array
                    --face.mNumIndices;--limit;
                    for (unsigned int m = t; m < face.mNumIndices; ++m)
                    {
                        face.mIndices[m] = face.mIndices[m+1];
                    }
                    --t;

                    // NOTE: we set the removed vertex index to an unique value
                    // to make sure the developer gets notified when his
                    // application attemps to access this data.
                    face.mIndices[face.mNumIndices] = 0xdeadbeef;

                    if(first)
                    {
                        ++deg;
                        first = false;
                    }

                    if (configRemoveDegenerates) {
                        remove_me[a] = true;
                        goto evil_jump_outside; // hrhrhrh ... yeah, this rocks baby!
                    }
                }
            }
        }

        // We need to update the primitive flags array of the mesh.
        switch (face.mNumIndices)
        {
        case 1u:
            mesh->mPrimitiveTypes |= aiPrimitiveType_POINT;
            break;
        case 2u:
            mesh->mPrimitiveTypes |= aiPrimitiveType_LINE;
            break;
        case 3u:
            mesh->mPrimitiveTypes |= aiPrimitiveType_TRIANGLE;
            break;
        default:
            mesh->mPrimitiveTypes |= aiPrimitiveType_POLYGON;
            break;
        };
evil_jump_outside:
        continue;
    }

    // If AI_CONFIG_PP_FD_REMOVE is true, remove degenerated faces from the import
    if (configRemoveDegenerates && deg) {
        unsigned int n = 0;
        for (unsigned int a = 0; a < mesh->mNumFaces; ++a)
        {
            aiFace& face_src = mesh->mFaces[a];
            if (!remove_me[a]) {
                aiFace& face_dest = mesh->mFaces[n++];

                // Do a manual copy, keep the index array
                face_dest.mNumIndices = face_src.mNumIndices;
                face_dest.mIndices    = face_src.mIndices;

                if (&face_src != &face_dest) {
                    // clear source
                    face_src.mNumIndices = 0;
                    face_src.mIndices = NULL;
                }
            }
            else {
                // Otherwise delete it if we don't need this face
                delete[] face_src.mIndices;
                face_src.mIndices = NULL;
                face_src.mNumIndices = 0;
            }
        }
        // Just leave the rest of the array unreferenced, we don't care for now
        mesh->mNumFaces = n;
        if (!mesh->mNumFaces) {
            // WTF!?
            // OK ... for completeness and because I'm not yet tired,
            // let's write code that willl hopefully never be called
            // (famous last words)

            // OK ... bad idea.
            throw DeadlyImportError("Mesh is empty after removal of degenerated primitives ... WTF!?");
        }
    }

    if (deg && !DefaultLogger::isNullLogger())
    {
        char s[64];
        ASSIMP_itoa10(s,deg);
        DefaultLogger::get()->warn(std::string("Found ") + s + " degenerated primitives");
    }
}

/***********************************************************************
FBXIMPORT\FINDINSTANCESPROCESS.CPP
***********************************************************************/
/*
---------------------------------------------------------------------------
Open Asset Import Library (assimp)
---------------------------------------------------------------------------

Copyright (c) 2006-2016, assimp team

All rights reserved.

Redistribution and use of this software in source and binary forms,
with or without modification, are permitted provided that the following
conditions are met:

* Redistributions of source code must retain the above
  copyright notice, this list of conditions and the
  following disclaimer.

* Redistributions in binary form must reproduce the above
  copyright notice, this list of conditions and the
  following disclaimer in the documentation and/or other
  materials provided with the distribution.

* Neither the name of the assimp team, nor the names of its
  contributors may be used to endorse or promote products
  derived from this software without specific prior
  written permission of the assimp team.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
"AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
---------------------------------------------------------------------------
*/

/** @file  FindInstancesProcess.cpp
 *  @brief Implementation of the aiProcess_FindInstances postprocessing step
*/



using namespace Assimp;

// ------------------------------------------------------------------------------------------------
// Constructor to be privately used by Importer
FindInstancesProcess::FindInstancesProcess()
:   configSpeedFlag (false)
{}

// ------------------------------------------------------------------------------------------------
// Destructor, private as well
FindInstancesProcess::~FindInstancesProcess()
{}

// ------------------------------------------------------------------------------------------------
// Returns whether the processing step is present in the given flag field.
bool FindInstancesProcess::IsActive( unsigned int pFlags) const
{
    // FindInstances makes absolutely no sense together with PreTransformVertices
    // fixme: spawn error message somewhere else?
    return 0 != (pFlags & aiProcess_FindInstances) && 0 == (pFlags & aiProcess_PreTransformVertices);
}

// ------------------------------------------------------------------------------------------------
// Setup properties for the step
void FindInstancesProcess::SetupProperties(const Importer* pImp)
{
    // AI_CONFIG_FAVOUR_SPEED
    configSpeedFlag = (0 != pImp->GetPropertyInteger(AI_CONFIG_FAVOUR_SPEED,0));
}

// ------------------------------------------------------------------------------------------------
// Compare the bones of two meshes
bool CompareBones(const aiMesh* orig, const aiMesh* inst)
{
    for (unsigned int i = 0; i < orig->mNumBones;++i) {
        aiBone* aha = orig->mBones[i];
        aiBone* oha = inst->mBones[i];

        if (aha->mNumWeights   != oha->mNumWeights   ||
            aha->mOffsetMatrix != oha->mOffsetMatrix) {
            return false;
        }

        // compare weight per weight ---
        for (unsigned int n = 0; n < aha->mNumWeights;++n) {
            if  (aha->mWeights[n].mVertexId != oha->mWeights[n].mVertexId ||
                (aha->mWeights[n].mWeight - oha->mWeights[n].mWeight) < 10e-3f) {
                return false;
            }
        }
    }
    return true;
}

// ------------------------------------------------------------------------------------------------
// Update mesh indices in the node graph
void UpdateMeshIndices(aiNode* node, unsigned int* lookup)
{
    for (unsigned int n = 0; n < node->mNumMeshes;++n)
        node->mMeshes[n] = lookup[node->mMeshes[n]];

    for (unsigned int n = 0; n < node->mNumChildren;++n)
        UpdateMeshIndices(node->mChildren[n],lookup);
}

// ------------------------------------------------------------------------------------------------
// Executes the post processing step on the given imported data.
void FindInstancesProcess::Execute( aiScene* pScene)
{
    DefaultLogger::get()->debug("FindInstancesProcess begin");
    if (pScene->mNumMeshes) {

        // use a pseudo hash for all meshes in the scene to quickly find
        // the ones which are possibly equal. This step is executed early
        // in the pipeline, so we could, depending on the file format,
        // have several thousand small meshes. That's too much for a brute
        // everyone-against-everyone check involving up to 10 comparisons
        // each.
        std::unique_ptr<uint64_t[]> hashes (new uint64_t[pScene->mNumMeshes]);
        std::unique_ptr<unsigned int[]> remapping (new unsigned int[pScene->mNumMeshes]);

        unsigned int numMeshesOut = 0;
        for (unsigned int i = 0; i < pScene->mNumMeshes; ++i) {

            aiMesh* inst = pScene->mMeshes[i];
            hashes[i] = GetMeshHash(inst);

            for (int a = i-1; a >= 0; --a) {
                if (hashes[i] == hashes[a])
                {
                    aiMesh* orig = pScene->mMeshes[a];
                    if (!orig)
                        continue;

                    // check for hash collision .. we needn't check
                    // the vertex format, it *must* match due to the
                    // (brilliant) construction of the hash
                    if (orig->mNumBones       != inst->mNumBones      ||
                        orig->mNumFaces       != inst->mNumFaces      ||
                        orig->mNumVertices    != inst->mNumVertices   ||
                        orig->mMaterialIndex  != inst->mMaterialIndex ||
                        orig->mPrimitiveTypes != inst->mPrimitiveTypes)
                        continue;

                    // up to now the meshes are equal. find an appropriate
                    // epsilon to compare position differences against
                    float epsilon = ComputePositionEpsilon(inst);
                    epsilon *= epsilon;

                    // now compare vertex positions, normals,
                    // tangents and bitangents using this epsilon.
                    if (orig->HasPositions()) {
                        if(!CompareArrays(orig->mVertices,inst->mVertices,orig->mNumVertices,epsilon))
                            continue;
                    }
                    if (orig->HasNormals()) {
                        if(!CompareArrays(orig->mNormals,inst->mNormals,orig->mNumVertices,epsilon))
                            continue;
                    }
                    if (orig->HasTangentsAndBitangents()) {
                        if (!CompareArrays(orig->mTangents,inst->mTangents,orig->mNumVertices,epsilon) ||
                            !CompareArrays(orig->mBitangents,inst->mBitangents,orig->mNumVertices,epsilon))
                            continue;
                    }

                    // use a constant epsilon for colors and UV coordinates
                    static const float uvEpsilon = 10e-4f;
                    {
                        unsigned int i, end = orig->GetNumUVChannels();
                        for(i = 0; i < end; ++i) {
                            if (!orig->mTextureCoords[i]) {
                                continue;
                            }
                            if(!CompareArrays(orig->mTextureCoords[i],inst->mTextureCoords[i],orig->mNumVertices,uvEpsilon)) {
                                break;
                            }
                        }
                        if (i != end) {
                            continue;
                        }
                    }
                    {
                        unsigned int i, end = orig->GetNumColorChannels();
                        for(i = 0; i < end; ++i) {
                            if (!orig->mColors[i]) {
                                continue;
                            }
                            if(!CompareArrays(orig->mColors[i],inst->mColors[i],orig->mNumVertices,uvEpsilon)) {
                                break;
                            }
                        }
                        if (i != end) {
                            continue;
                        }
                    }

                    // These two checks are actually quite expensive and almost *never* required.
                    // Almost. That's why they're still here. But there's no reason to do them
                    // in speed-targeted imports.
                    if (!configSpeedFlag) {

                        // It seems to be strange, but we really need to check whether the
                        // bones are identical too. Although it's extremely unprobable
                        // that they're not if control reaches here, we need to deal
                        // with unprobable cases, too. It could still be that there are
                        // equal shapes which are deformed differently.
                        if (!CompareBones(orig,inst))
                            continue;

                        // For completeness ... compare even the index buffers for equality
                        // face order & winding order doesn't care. Input data is in verbose format.
                        std::unique_ptr<unsigned int[]> ftbl_orig(new unsigned int[orig->mNumVertices]);
                        std::unique_ptr<unsigned int[]> ftbl_inst(new unsigned int[orig->mNumVertices]);

                        for (unsigned int tt = 0; tt < orig->mNumFaces;++tt) {
                            aiFace& f = orig->mFaces[tt];
                            for (unsigned int nn = 0; nn < f.mNumIndices;++nn)
                                ftbl_orig[f.mIndices[nn]] = tt;

                            aiFace& f2 = inst->mFaces[tt];
                            for (unsigned int nn = 0; nn < f2.mNumIndices;++nn)
                                ftbl_inst[f2.mIndices[nn]] = tt;
                        }
                        if (0 != ::memcmp(ftbl_inst.get(),ftbl_orig.get(),orig->mNumVertices*sizeof(unsigned int)))
                            continue;
                    }

                    // We're still here. Or in other words: 'inst' is an instance of 'orig'.
                    // Place a marker in our list that we can easily update mesh indices.
                    remapping[i] = remapping[a];

                    // Delete the instanced mesh, we don't need it anymore
                    delete inst;
                    pScene->mMeshes[i] = NULL;
                    break;
                }
            }

            // If we didn't find a match for the current mesh: keep it
            if (pScene->mMeshes[i]) {
                remapping[i] = numMeshesOut++;
            }
        }
        ai_assert(0 != numMeshesOut);
        if (numMeshesOut != pScene->mNumMeshes) {

            // Collapse the meshes array by removing all NULL entries
            for (unsigned int real = 0, i = 0; real < numMeshesOut; ++i) {
                if (pScene->mMeshes[i])
                    pScene->mMeshes[real++] = pScene->mMeshes[i];
            }

            // And update the node graph with our nice lookup table
            UpdateMeshIndices(pScene->mRootNode,remapping.get());

            // write to log
            if (!DefaultLogger::isNullLogger()) {

                char buffer[512];
                ::ai_snprintf(buffer,512,"FindInstancesProcess finished. Found %i instances",pScene->mNumMeshes-numMeshesOut);
                DefaultLogger::get()->info(buffer);
            }
            pScene->mNumMeshes = numMeshesOut;
        }
        else DefaultLogger::get()->debug("FindInstancesProcess finished. No instanced meshes found");
    }
}

/***********************************************************************
FBXIMPORT\FINDINVALIDDATAPROCESS.CPP
***********************************************************************/
/*
---------------------------------------------------------------------------
Open Asset Import Library (assimp)
---------------------------------------------------------------------------

Copyright (c) 2006-2016, assimp team

All rights reserved.

Redistribution and use of this software in source and binary forms,
with or without modification, are permitted provided that the following
conditions are met:

* Redistributions of source code must retain the above
  copyright notice, this list of conditions and the
  following disclaimer.

* Redistributions in binary form must reproduce the above
  copyright notice, this list of conditions and the
  following disclaimer in the documentation and/or other
  materials provided with the distribution.

* Neither the name of the assimp team, nor the names of its
  contributors may be used to endorse or promote products
  derived from this software without specific prior
  written permission of the assimp team.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
"AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
---------------------------------------------------------------------------
*/

/** @file Defines a post processing step to search an importer's output
    for data that is obviously invalid  */



#ifndef ASSIMP_BUILD_NO_FINDINVALIDDATA_PROCESS

// internal headers

using namespace Assimp;

// ------------------------------------------------------------------------------------------------
// Constructor to be privately used by Importer
FindInvalidDataProcess::FindInvalidDataProcess()
    : configEpsilon(0.0f)
{
    // nothing to do here
}

// ------------------------------------------------------------------------------------------------
// Destructor, private as well
FindInvalidDataProcess::~FindInvalidDataProcess()
{
    // nothing to do here
}

// ------------------------------------------------------------------------------------------------
// Returns whether the processing step is present in the given flag field.
bool FindInvalidDataProcess::IsActive( unsigned int pFlags) const
{
    return 0 != (pFlags & aiProcess_FindInvalidData);
}

// ------------------------------------------------------------------------------------------------
// Setup import configuration
void FindInvalidDataProcess::SetupProperties(const Importer* pImp)
{
    // Get the current value of AI_CONFIG_PP_FID_ANIM_ACCURACY
    configEpsilon = (0 != pImp->GetPropertyFloat(AI_CONFIG_PP_FID_ANIM_ACCURACY,0.f));
}

// ------------------------------------------------------------------------------------------------
// Update mesh references in the node graph
void UpdateMeshReferences(aiNode* node, const std::vector<unsigned int>& meshMapping)
{
    if (node->mNumMeshes)   {
        unsigned int out = 0;
        for (unsigned int a = 0; a < node->mNumMeshes;++a)  {

            unsigned int ref = node->mMeshes[a];
            if (UINT_MAX != (ref = meshMapping[ref]))   {
                node->mMeshes[out++] = ref;
            }
        }
        // just let the members that are unused, that's much cheaper
        // than a full array realloc'n'copy party ...
        if(!(node->mNumMeshes = out))   {

            delete[] node->mMeshes;
            node->mMeshes = NULL;
        }
    }
    // recursively update all children
    for (unsigned int i = 0; i < node->mNumChildren;++i) {
        UpdateMeshReferences(node->mChildren[i],meshMapping);
    }
}

// ------------------------------------------------------------------------------------------------
// Executes the post processing step on the given imported data.
void FindInvalidDataProcess::Execute( aiScene* pScene)
{
    DefaultLogger::get()->debug("FindInvalidDataProcess begin");

    bool out = false;
    std::vector<unsigned int> meshMapping(pScene->mNumMeshes);
    unsigned int real = 0;

    // Process meshes
    for( unsigned int a = 0; a < pScene->mNumMeshes; a++)   {

        int result;
        if ((result = ProcessMesh( pScene->mMeshes[a])))    {
            out = true;

            if (2 == result)    {
                // remove this mesh
                delete pScene->mMeshes[a];
                AI_DEBUG_INVALIDATE_PTR(pScene->mMeshes[a]);

                meshMapping[a] = UINT_MAX;
                continue;
            }
        }
        pScene->mMeshes[real] = pScene->mMeshes[a];
        meshMapping[a] = real++;
    }

    // Process animations
    for (unsigned int a = 0; a < pScene->mNumAnimations;++a) {
        ProcessAnimation( pScene->mAnimations[a]);
    }


    if (out)    {
        if ( real != pScene->mNumMeshes)    {
            if (!real) {
                throw DeadlyImportError("No meshes remaining");
            }

            // we need to remove some meshes.
            // therefore we'll also need to remove all references
            // to them from the scenegraph
            UpdateMeshReferences(pScene->mRootNode,meshMapping);
            pScene->mNumMeshes = real;
        }

        DefaultLogger::get()->info("FindInvalidDataProcess finished. Found issues ...");
    }
    else DefaultLogger::get()->debug("FindInvalidDataProcess finished. Everything seems to be OK.");
}

// ------------------------------------------------------------------------------------------------
template <typename T>
inline const char* ValidateArrayContents(const T* arr, unsigned int size,
    const std::vector<bool>& dirtyMask, bool mayBeIdentical = false, bool mayBeZero = true)
{
    return NULL;
}

// ------------------------------------------------------------------------------------------------
template <>
inline const char* ValidateArrayContents<aiVector3D>(const aiVector3D* arr, unsigned int size,
    const std::vector<bool>& dirtyMask, bool mayBeIdentical , bool mayBeZero )
{
    bool b = false;
    unsigned int cnt = 0;
    for (unsigned int i = 0; i < size;++i)  {

        if (dirtyMask.size() && dirtyMask[i]) {
            continue;
        }
        ++cnt;

        const aiVector3D& v = arr[i];
        if (is_special_float(v.x) || is_special_float(v.y) || is_special_float(v.z))    {
            return "INF/NAN was found in a vector component";
        }
        if (!mayBeZero && !v.x && !v.y && !v.z )    {
            return "Found zero-length vector";
        }
        if (i && v != arr[i-1])b = true;
    }
    if (cnt > 1 && !b && !mayBeIdentical) {
        return "All vectors are identical";
    }
    return NULL;
}

// ------------------------------------------------------------------------------------------------
template <typename T>
inline bool ProcessArray(T*& in, unsigned int num,const char* name,
    const std::vector<bool>& dirtyMask, bool mayBeIdentical = false, bool mayBeZero = true)
{
    const char* err = ValidateArrayContents(in,num,dirtyMask,mayBeIdentical,mayBeZero);
    if (err)    {
        DefaultLogger::get()->error(std::string("FindInvalidDataProcess fails on mesh ") + name + ": " + err);

        delete[] in;
        in = NULL;
        return true;
    }
    return false;
}

// ------------------------------------------------------------------------------------------------
template <typename T>
AI_FORCE_INLINE bool EpsilonCompare(const T& n, const T& s, float epsilon);

// ------------------------------------------------------------------------------------------------
AI_FORCE_INLINE bool EpsilonCompare(float n, float s, float epsilon) {
    return std::fabs(n-s)>epsilon;
}

// ------------------------------------------------------------------------------------------------
template <>
bool EpsilonCompare<aiVectorKey>(const aiVectorKey& n, const aiVectorKey& s, float epsilon) {
    return
        EpsilonCompare(n.mValue.x,s.mValue.x,epsilon) &&
        EpsilonCompare(n.mValue.y,s.mValue.y,epsilon) &&
        EpsilonCompare(n.mValue.z,s.mValue.z,epsilon);
}

// ------------------------------------------------------------------------------------------------
template <>
bool EpsilonCompare<aiQuatKey>(const aiQuatKey& n, const aiQuatKey& s, float epsilon)   {
    return
        EpsilonCompare(n.mValue.x,s.mValue.x,epsilon) &&
        EpsilonCompare(n.mValue.y,s.mValue.y,epsilon) &&
        EpsilonCompare(n.mValue.z,s.mValue.z,epsilon) &&
        EpsilonCompare(n.mValue.w,s.mValue.w,epsilon);
}

// ------------------------------------------------------------------------------------------------
template <typename T>
inline bool AllIdentical(T* in, unsigned int num, float epsilon)
{
    if (num <= 1) {
        return true;
    }

    if (epsilon > 0.f) {
        for (unsigned int i = 0; i < num-1;++i) {

            if (!EpsilonCompare(in[i],in[i+1],epsilon)) {
                return false;
            }
        }
    }
    else {
        for (unsigned int i = 0; i < num-1;++i) {

            if (in[i] != in[i+1]) {
                return false;
            }
        }
    }
    return true;
}

// ------------------------------------------------------------------------------------------------
// Search an animation for invalid content
void FindInvalidDataProcess::ProcessAnimation (aiAnimation* anim)
{
    // Process all animation channels
    for (unsigned int a = 0; a < anim->mNumChannels;++a) {
        ProcessAnimationChannel( anim->mChannels[a]);
    }
}

// ------------------------------------------------------------------------------------------------
void FindInvalidDataProcess::ProcessAnimationChannel (aiNodeAnim* anim)
{
    int i = 0;

    // ScenePreprocessor's work ...
    ai_assert((0 != anim->mPositionKeys && 0 != anim->mRotationKeys && 0 != anim->mScalingKeys));

    // Check whether all values in a tracks are identical - in this case
    // we can remove al keys except one.
    // POSITIONS
    if (anim->mNumPositionKeys > 1 && AllIdentical(anim->mPositionKeys,anim->mNumPositionKeys,configEpsilon))
    {
        aiVectorKey v = anim->mPositionKeys[0];

        // Reallocate ... we need just ONE element, it makes no sense to reuse the array
        delete[] anim->mPositionKeys;
        anim->mPositionKeys = new aiVectorKey[anim->mNumPositionKeys = 1];
        anim->mPositionKeys[0] = v;
        i = 1;
    }

    // ROTATIONS
    if (anim->mNumRotationKeys > 1 && AllIdentical(anim->mRotationKeys,anim->mNumRotationKeys,configEpsilon))
    {
        aiQuatKey v = anim->mRotationKeys[0];

        // Reallocate ... we need just ONE element, it makes no sense to reuse the array
        delete[] anim->mRotationKeys;
        anim->mRotationKeys = new aiQuatKey[anim->mNumRotationKeys = 1];
        anim->mRotationKeys[0] = v;
        i = 1;
    }

    // SCALINGS
    if (anim->mNumScalingKeys > 1 && AllIdentical(anim->mScalingKeys,anim->mNumScalingKeys,configEpsilon))
    {
        aiVectorKey v = anim->mScalingKeys[0];

        // Reallocate ... we need just ONE element, it makes no sense to reuse the array
        delete[] anim->mScalingKeys;
        anim->mScalingKeys = new aiVectorKey[anim->mNumScalingKeys = 1];
        anim->mScalingKeys[0] = v;
        i = 1;
    }
    if (1 == i)
        DefaultLogger::get()->warn("Simplified dummy tracks with just one key");
}

// ------------------------------------------------------------------------------------------------
// Search a mesh for invalid contents
int FindInvalidDataProcess::ProcessMesh (aiMesh* pMesh)
{
    bool ret = false;
    std::vector<bool> dirtyMask(pMesh->mNumVertices,(pMesh->mNumFaces ? true : false));

    // Ignore elements that are not referenced by vertices.
    // (they are, for example, caused by the FindDegenerates step)
    for (unsigned int m = 0; m < pMesh->mNumFaces;++m)  {
        const aiFace& f = pMesh->mFaces[m];

        for (unsigned int i = 0; i < f.mNumIndices;++i) {
            dirtyMask[f.mIndices[i]] = false;
        }
    }

    // Process vertex positions
    if(pMesh->mVertices && ProcessArray(pMesh->mVertices,pMesh->mNumVertices,"positions",dirtyMask))    {
        DefaultLogger::get()->error("Deleting mesh: Unable to continue without vertex positions");
        return 2;
    }

    // process texture coordinates
    for (unsigned int i = 0; i < AI_MAX_NUMBER_OF_TEXTURECOORDS && pMesh->mTextureCoords[i];++i)    {
        if (ProcessArray(pMesh->mTextureCoords[i],pMesh->mNumVertices,"uvcoords",dirtyMask))    {

            // delete all subsequent texture coordinate sets.
            for (unsigned int a = i+1; a < AI_MAX_NUMBER_OF_TEXTURECOORDS;++a)  {
                delete[] pMesh->mTextureCoords[a]; pMesh->mTextureCoords[a] = NULL;
            }
            ret = true;
        }
    }

    // -- we don't validate vertex colors, it's difficult to say whether
    // they are invalid or not.

    // Normals and tangents are undefined for point and line faces.
    if (pMesh->mNormals || pMesh->mTangents)    {

        if (aiPrimitiveType_POINT & pMesh->mPrimitiveTypes ||
            aiPrimitiveType_LINE  & pMesh->mPrimitiveTypes)
        {
            if (aiPrimitiveType_TRIANGLE & pMesh->mPrimitiveTypes ||
                aiPrimitiveType_POLYGON  & pMesh->mPrimitiveTypes)
            {
                // We need to update the lookup-table
                for (unsigned int m = 0; m < pMesh->mNumFaces;++m)
                {
                    const aiFace& f = pMesh->mFaces[m];

                    if (f.mNumIndices < 3)  {
                        dirtyMask[f.mIndices[0]] = true;

                        if (f.mNumIndices == 2) {
                            dirtyMask[f.mIndices[1]] = true;
                        }
                    }
                }
            }
            // Normals, tangents and bitangents are undefined for
            // the whole mesh (and should not even be there)
            else return ret;
        }

        // Process mesh normals
        if (pMesh->mNormals && ProcessArray(pMesh->mNormals,pMesh->mNumVertices,
            "normals",dirtyMask,true,false))
            ret = true;

        // Process mesh tangents
        if (pMesh->mTangents && ProcessArray(pMesh->mTangents,pMesh->mNumVertices,"tangents",dirtyMask))    {
            delete[] pMesh->mBitangents; pMesh->mBitangents = NULL;
            ret = true;
        }

        // Process mesh bitangents
        if (pMesh->mBitangents && ProcessArray(pMesh->mBitangents,pMesh->mNumVertices,"bitangents",dirtyMask))  {
            delete[] pMesh->mTangents; pMesh->mTangents = NULL;
            ret = true;
        }
    }
    return ret ? 1 : 0;
}


#endif // !! ASSIMP_BUILD_NO_FINDINVALIDDATA_PROCESS

/***********************************************************************
FBXIMPORT\FIXNORMALSSTEP.CPP
***********************************************************************/
/*
---------------------------------------------------------------------------
Open Asset Import Library (assimp)
---------------------------------------------------------------------------

Copyright (c) 2006-2016, assimp team

All rights reserved.

Redistribution and use of this software in source and binary forms,
with or without modification, are permitted provided that the following
conditions are met:

* Redistributions of source code must retain the above
  copyright notice, this list of conditions and the
  following disclaimer.

* Redistributions in binary form must reproduce the above
  copyright notice, this list of conditions and the
  following disclaimer in the documentation and/or other
  materials provided with the distribution.

* Neither the name of the assimp team, nor the names of its
  contributors may be used to endorse or promote products
  derived from this software without specific prior
  written permission of the assimp team.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
"AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
---------------------------------------------------------------------------
*/

/** @file Implementation of the post processing step to invert
 * all normals in meshes with infacing normals.
 */

// internal headers


using namespace Assimp;


// ------------------------------------------------------------------------------------------------
// Constructor to be privately used by Importer
FixInfacingNormalsProcess::FixInfacingNormalsProcess()
{
    // nothing to do here
}

// ------------------------------------------------------------------------------------------------
// Destructor, private as well
FixInfacingNormalsProcess::~FixInfacingNormalsProcess()
{
    // nothing to do here
}

// ------------------------------------------------------------------------------------------------
// Returns whether the processing step is present in the given flag field.
bool FixInfacingNormalsProcess::IsActive( unsigned int pFlags) const
{
    return (pFlags & aiProcess_FixInfacingNormals) != 0;
}

// ------------------------------------------------------------------------------------------------
// Executes the post processing step on the given imported data.
void FixInfacingNormalsProcess::Execute( aiScene* pScene)
{
    DefaultLogger::get()->debug("FixInfacingNormalsProcess begin");

    bool bHas = false;
    for( unsigned int a = 0; a < pScene->mNumMeshes; a++)
        if(ProcessMesh( pScene->mMeshes[a],a))bHas = true;

    if (bHas)
         DefaultLogger::get()->debug("FixInfacingNormalsProcess finished. Found issues.");
    else DefaultLogger::get()->debug("FixInfacingNormalsProcess finished. No changes to the scene.");
}

// ------------------------------------------------------------------------------------------------
// Apply the step to the mesh
bool FixInfacingNormalsProcess::ProcessMesh( aiMesh* pcMesh, unsigned int index)
{
    ai_assert(NULL != pcMesh);

    // Nothing to do if there are no model normals
    if (!pcMesh->HasNormals())return false;

    // Compute the bounding box of both the model vertices + normals and
    // the umodified model vertices. Then check whether the first BB
    // is smaller than the second. In this case we can assume that the
    // normals need to be flipped, although there are a few special cases ..
    // convex, concave, planar models ...

    aiVector3D vMin0 (1e10f,1e10f,1e10f);
    aiVector3D vMin1 (1e10f,1e10f,1e10f);
    aiVector3D vMax0 (-1e10f,-1e10f,-1e10f);
    aiVector3D vMax1 (-1e10f,-1e10f,-1e10f);

    for (unsigned int i = 0; i < pcMesh->mNumVertices;++i)
    {
        vMin1.x = std::min(vMin1.x,pcMesh->mVertices[i].x);
        vMin1.y = std::min(vMin1.y,pcMesh->mVertices[i].y);
        vMin1.z = std::min(vMin1.z,pcMesh->mVertices[i].z);

        vMax1.x = std::max(vMax1.x,pcMesh->mVertices[i].x);
        vMax1.y = std::max(vMax1.y,pcMesh->mVertices[i].y);
        vMax1.z = std::max(vMax1.z,pcMesh->mVertices[i].z);

        const aiVector3D vWithNormal = pcMesh->mVertices[i] + pcMesh->mNormals[i];

        vMin0.x = std::min(vMin0.x,vWithNormal.x);
        vMin0.y = std::min(vMin0.y,vWithNormal.y);
        vMin0.z = std::min(vMin0.z,vWithNormal.z);

        vMax0.x = std::max(vMax0.x,vWithNormal.x);
        vMax0.y = std::max(vMax0.y,vWithNormal.y);
        vMax0.z = std::max(vMax0.z,vWithNormal.z);
    }

    const float fDelta0_x = (vMax0.x - vMin0.x);
    const float fDelta0_y = (vMax0.y - vMin0.y);
    const float fDelta0_z = (vMax0.z - vMin0.z);

    const float fDelta1_x = (vMax1.x - vMin1.x);
    const float fDelta1_y = (vMax1.y - vMin1.y);
    const float fDelta1_z = (vMax1.z - vMin1.z);

    // Check whether the boxes are overlapping
    if ((fDelta0_x > 0.0f) != (fDelta1_x > 0.0f))return false;
    if ((fDelta0_y > 0.0f) != (fDelta1_y > 0.0f))return false;
    if ((fDelta0_z > 0.0f) != (fDelta1_z > 0.0f))return false;

    // Check whether this is a planar surface
    const float fDelta1_yz = fDelta1_y * fDelta1_z;

    if (fDelta1_x < 0.05f * sqrtf( fDelta1_yz ))return false;
    if (fDelta1_y < 0.05f * sqrtf( fDelta1_z * fDelta1_x ))return false;
    if (fDelta1_z < 0.05f * sqrtf( fDelta1_y * fDelta1_x ))return false;

    // now compare the volumes of the bounding boxes
    if (std::fabs(fDelta0_x * fDelta0_y * fDelta0_z) <
        std::fabs(fDelta1_x * fDelta1_yz))
    {
        if (!DefaultLogger::isNullLogger())
        {
            char buffer[128]; // should be sufficiently large
            ai_snprintf(buffer,128,"Mesh %u: Normals are facing inwards (or the mesh is planar)",index);
            DefaultLogger::get()->info(buffer);
        }

        // Invert normals
        for (unsigned int i = 0; i < pcMesh->mNumVertices;++i)
            pcMesh->mNormals[i] *= -1.0f;

        // ... and flip faces
        for (unsigned int i = 0; i < pcMesh->mNumFaces;++i)
        {
            aiFace& face = pcMesh->mFaces[i];
            for( unsigned int b = 0; b < face.mNumIndices / 2; b++)
                std::swap( face.mIndices[b], face.mIndices[ face.mNumIndices - 1 - b]);
        }
        return true;
    }
    return false;
}

/***********************************************************************
FBXIMPORT\GENFACENORMALSPROCESS.CPP
***********************************************************************/
/*
---------------------------------------------------------------------------
Open Asset Import Library (assimp)
---------------------------------------------------------------------------

Copyright (c) 2006-2016, assimp team

All rights reserved.

Redistribution and use of this software in source and binary forms,
with or without modification, are permitted provided that the following
conditions are met:

* Redistributions of source code must retain the above
  copyright notice, this list of conditions and the
  following disclaimer.

* Redistributions in binary form must reproduce the above
  copyright notice, this list of conditions and the
  following disclaimer in the documentation and/or other
  materials provided with the distribution.

* Neither the name of the assimp team, nor the names of its
  contributors may be used to endorse or promote products
  derived from this software without specific prior
  written permission of the assimp team.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
"AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
---------------------------------------------------------------------------
*/

/** @file Implementation of the post processing step to generate face
* normals for all imported faces.
*/




using namespace Assimp;

// ------------------------------------------------------------------------------------------------
// Constructor to be privately used by Importer
GenFaceNormalsProcess::GenFaceNormalsProcess()
{
    // nothing to do here
}

// ------------------------------------------------------------------------------------------------
// Destructor, private as well
GenFaceNormalsProcess::~GenFaceNormalsProcess()
{
    // nothing to do here
}

// ------------------------------------------------------------------------------------------------
// Returns whether the processing step is present in the given flag field.
bool GenFaceNormalsProcess::IsActive( unsigned int pFlags) const
{
    return  (pFlags & aiProcess_GenNormals) != 0;
}

// ------------------------------------------------------------------------------------------------
// Executes the post processing step on the given imported data.
void GenFaceNormalsProcess::Execute( aiScene* pScene)
{
    DefaultLogger::get()->debug("GenFaceNormalsProcess begin");

    if (pScene->mFlags & AI_SCENE_FLAGS_NON_VERBOSE_FORMAT) {
        throw DeadlyImportError("Post-processing order mismatch: expecting pseudo-indexed (\"verbose\") vertices here");
    }

    bool bHas = false;
    for( unsigned int a = 0; a < pScene->mNumMeshes; a++)   {
        if(this->GenMeshFaceNormals( pScene->mMeshes[a])) {
            bHas = true;
        }
    }
    if (bHas)   {
        DefaultLogger::get()->info("GenFaceNormalsProcess finished. "
            "Face normals have been calculated");
    }
    else DefaultLogger::get()->debug("GenFaceNormalsProcess finished. "
        "Normals are already there");
}

// ------------------------------------------------------------------------------------------------
// Executes the post processing step on the given imported data.
bool GenFaceNormalsProcess::GenMeshFaceNormals (aiMesh* pMesh)
{
    if (NULL != pMesh->mNormals) {
        return false;
    }

    // If the mesh consists of lines and/or points but not of
    // triangles or higher-order polygons the normal vectors
    // are undefined.
    if (!(pMesh->mPrimitiveTypes & (aiPrimitiveType_TRIANGLE | aiPrimitiveType_POLYGON)))   {
        DefaultLogger::get()->info("Normal vectors are undefined for line and point meshes");
        return false;
    }

    // allocate an array to hold the output normals
    pMesh->mNormals = new aiVector3D[pMesh->mNumVertices];
    const float qnan = get_qnan();

    // iterate through all faces and compute per-face normals but store them per-vertex.
    for( unsigned int a = 0; a < pMesh->mNumFaces; a++) {
        const aiFace& face = pMesh->mFaces[a];
        if (face.mNumIndices < 3)   {
            // either a point or a line -> no well-defined normal vector
            for (unsigned int i = 0;i < face.mNumIndices;++i) {
                pMesh->mNormals[face.mIndices[i]] = aiVector3D(qnan);
            }
            continue;
        }

        const aiVector3D* pV1 = &pMesh->mVertices[face.mIndices[0]];
        const aiVector3D* pV2 = &pMesh->mVertices[face.mIndices[1]];
        const aiVector3D* pV3 = &pMesh->mVertices[face.mIndices[face.mNumIndices-1]];
        const aiVector3D vNor = ((*pV2 - *pV1) ^ (*pV3 - *pV1)).Normalize();

        for (unsigned int i = 0;i < face.mNumIndices;++i) {
            pMesh->mNormals[face.mIndices[i]] = vNor;
        }
    }
    return true;
}

/***********************************************************************
FBXIMPORT\GENVERTEXNORMALSPROCESS.CPP
***********************************************************************/
/*
---------------------------------------------------------------------------
Open Asset Import Library (assimp)
---------------------------------------------------------------------------

Copyright (c) 2006-2016, assimp team

All rights reserved.

Redistribution and use of this software in source and binary forms,
with or without modification, are permitted provided that the following
conditions are met:

* Redistributions of source code must retain the above
  copyright notice, this list of conditions and the
  following disclaimer.

* Redistributions in binary form must reproduce the above
  copyright notice, this list of conditions and the
  following disclaimer in the documentation and/or other
  materials provided with the distribution.

* Neither the name of the assimp team, nor the names of its
  contributors may be used to endorse or promote products
  derived from this software without specific prior
  written permission of the assimp team.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
"AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
---------------------------------------------------------------------------
*/

/** @file Implementation of the post processing step to generate face
* normals for all imported faces.
*/



// internal headers

using namespace Assimp;

// ------------------------------------------------------------------------------------------------
// Constructor to be privately used by Importer
GenVertexNormalsProcess::GenVertexNormalsProcess()
: configMaxAngle( AI_DEG_TO_RAD( 175.f ) ) {
    // empty
}

// ------------------------------------------------------------------------------------------------
// Destructor, private as well
GenVertexNormalsProcess::~GenVertexNormalsProcess() {
    // nothing to do here
}

// ------------------------------------------------------------------------------------------------
// Returns whether the processing step is present in the given flag field.
bool GenVertexNormalsProcess::IsActive( unsigned int pFlags) const
{
    return (pFlags & aiProcess_GenSmoothNormals) != 0;
}

// ------------------------------------------------------------------------------------------------
// Executes the post processing step on the given imported data.
void GenVertexNormalsProcess::SetupProperties(const Importer* pImp)
{
    // Get the current value of the AI_CONFIG_PP_GSN_MAX_SMOOTHING_ANGLE property
    configMaxAngle = pImp->GetPropertyFloat(AI_CONFIG_PP_GSN_MAX_SMOOTHING_ANGLE,175.f);
    configMaxAngle = AI_DEG_TO_RAD(std::max(std::min(configMaxAngle,175.0f),0.0f));
}

// ------------------------------------------------------------------------------------------------
// Executes the post processing step on the given imported data.
void GenVertexNormalsProcess::Execute( aiScene* pScene)
{
    DefaultLogger::get()->debug("GenVertexNormalsProcess begin");

    if (pScene->mFlags & AI_SCENE_FLAGS_NON_VERBOSE_FORMAT)
        throw DeadlyImportError("Post-processing order mismatch: expecting pseudo-indexed (\"verbose\") vertices here");

    bool bHas = false;
    for( unsigned int a = 0; a < pScene->mNumMeshes; a++)
    {
        if(GenMeshVertexNormals( pScene->mMeshes[a],a))
            bHas = true;
    }

    if (bHas)   {
        DefaultLogger::get()->info("GenVertexNormalsProcess finished. "
            "Vertex normals have been calculated");
    }
    else DefaultLogger::get()->debug("GenVertexNormalsProcess finished. "
        "Normals are already there");
}

// ------------------------------------------------------------------------------------------------
// Executes the post processing step on the given imported data.
bool GenVertexNormalsProcess::GenMeshVertexNormals (aiMesh* pMesh, unsigned int meshIndex)
{
    if (NULL != pMesh->mNormals)
        return false;

    // If the mesh consists of lines and/or points but not of
    // triangles or higher-order polygons the normal vectors
    // are undefined.
    if (!(pMesh->mPrimitiveTypes & (aiPrimitiveType_TRIANGLE | aiPrimitiveType_POLYGON)))
    {
        DefaultLogger::get()->info("Normal vectors are undefined for line and point meshes");
        return false;
    }

    // Allocate the array to hold the output normals
    const float qnan = std::numeric_limits<float>::quiet_NaN();
    pMesh->mNormals = new aiVector3D[pMesh->mNumVertices];

    // Compute per-face normals but store them per-vertex
    for( unsigned int a = 0; a < pMesh->mNumFaces; a++)
    {
        const aiFace& face = pMesh->mFaces[a];
        if (face.mNumIndices < 3)
        {
            // either a point or a line -> no normal vector
            for (unsigned int i = 0;i < face.mNumIndices;++i) {
                pMesh->mNormals[face.mIndices[i]] = aiVector3D(qnan);
            }

            continue;
        }

        const aiVector3D* pV1 = &pMesh->mVertices[face.mIndices[0]];
        const aiVector3D* pV2 = &pMesh->mVertices[face.mIndices[1]];
        const aiVector3D* pV3 = &pMesh->mVertices[face.mIndices[face.mNumIndices-1]];
        const aiVector3D vNor = ((*pV2 - *pV1) ^ (*pV3 - *pV1));

        for (unsigned int i = 0;i < face.mNumIndices;++i) {
            pMesh->mNormals[face.mIndices[i]] = vNor;
        }
    }

    // Set up a SpatialSort to quickly find all vertices close to a given position
    // check whether we can reuse the SpatialSort of a previous step.
    SpatialSort* vertexFinder = NULL;
    SpatialSort  _vertexFinder;
    float posEpsilon = 1e-5f;
    if (shared) {
        std::vector<std::pair<SpatialSort,float> >* avf;
        shared->GetProperty(AI_SPP_SPATIAL_SORT,avf);
        if (avf)
        {
            std::pair<SpatialSort,float>& blubb = avf->operator [] (meshIndex);
            vertexFinder = &blubb.first;
            posEpsilon = blubb.second;
        }
    }
    if (!vertexFinder)  {
        _vertexFinder.Fill(pMesh->mVertices, pMesh->mNumVertices, sizeof( aiVector3D));
        vertexFinder = &_vertexFinder;
        posEpsilon = ComputePositionEpsilon(pMesh);
    }
    std::vector<unsigned int> verticesFound;
    aiVector3D* pcNew = new aiVector3D[pMesh->mNumVertices];

    if (configMaxAngle >= AI_DEG_TO_RAD( 175.f ))   {
        // There is no angle limit. Thus all vertices with positions close
        // to each other will receive the same vertex normal. This allows us
        // to optimize the whole algorithm a little bit ...
        std::vector<bool> abHad(pMesh->mNumVertices,false);
        for (unsigned int i = 0; i < pMesh->mNumVertices;++i)   {
            if (abHad[i]) {
                continue;
            }

            // Get all vertices that share this one ...
            vertexFinder->FindPositions( pMesh->mVertices[i], posEpsilon, verticesFound);

            aiVector3D pcNor;
            for (unsigned int a = 0; a < verticesFound.size(); ++a) {
                const aiVector3D& v = pMesh->mNormals[verticesFound[a]];
                if (is_not_qnan(v.x))pcNor += v;
            }
            pcNor.NormalizeSafe();

            // Write the smoothed normal back to all affected normals
            for (unsigned int a = 0; a < verticesFound.size(); ++a)
            {
                unsigned int vidx = verticesFound[a];
                pcNew[vidx] = pcNor;
                abHad[vidx] = true;
            }
        }
    }
    // Slower code path if a smooth angle is set. There are many ways to achieve
    // the effect, this one is the most straightforward one.
    else    {
        const float fLimit = std::cos(configMaxAngle);
        for (unsigned int i = 0; i < pMesh->mNumVertices;++i)   {
            // Get all vertices that share this one ...
            vertexFinder->FindPositions( pMesh->mVertices[i] , posEpsilon, verticesFound);

            aiVector3D vr = pMesh->mNormals[i];
            float vrlen = vr.Length();

            aiVector3D pcNor;
            for (unsigned int a = 0; a < verticesFound.size(); ++a) {
                aiVector3D v = pMesh->mNormals[verticesFound[a]];

                // check whether the angle between the two normals is not too large
                // HACK: if v.x is qnan the dot product will become qnan, too
                //   therefore the comparison against fLimit should be false
                //   in every case.
                if (v * vr >= fLimit * vrlen * v.Length())
                    pcNor += v;
            }
            pcNew[i] = pcNor.NormalizeSafe();
        }
    }

    delete[] pMesh->mNormals;
    pMesh->mNormals = pcNew;

    return true;
}

/***********************************************************************
FBXIMPORT\IMPORTER.CPP
***********************************************************************/
/*
---------------------------------------------------------------------------
Open Asset Import Library (assimp)
---------------------------------------------------------------------------

Copyright (c) 2006-2016, assimp team

All rights reserved.

Redistribution and use of this software in source and binary forms,
with or without modification, are permitted provided that the following
conditions are met:

* Redistributions of source code must retain the above
  copyright notice, this list of conditions and the
  following disclaimer.

* Redistributions in binary form must reproduce the above
  copyright notice, this list of conditions and the
  following disclaimer in the documentation and/or other
  materials provided with the distribution.

* Neither the name of the assimp team, nor the names of its
  contributors may be used to endorse or promote products
  derived from this software without specific prior
  written permission of the assimp team.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
"AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
---------------------------------------------------------------------------
*/

/** @file  Importer.cpp
 *  @brief Implementation of the CPP-API class #Importer
 */


// ------------------------------------------------------------------------------------------------
/* Uncomment this line to prevent Assimp from catching unknown exceptions.
 *
 * Note that any Exception except DeadlyImportError may lead to
 * undefined behaviour -> loaders could remain in an unusable state and
 * further imports with the same Importer instance could fail/crash/burn ...
 */
// ------------------------------------------------------------------------------------------------
#ifndef ASSIMP_BUILD_DEBUG
#   define ASSIMP_CATCH_GLOBAL_EXCEPTIONS
#endif

// ------------------------------------------------------------------------------------------------
// Internal headers
// ------------------------------------------------------------------------------------------------


#ifndef ASSIMP_BUILD_NO_VALIDATEDS_PROCESS
#   include "ValidateDataStructure.h"
#endif

using namespace Assimp::Profiling;
using namespace Assimp::Formatter;

namespace Assimp {
    // ImporterRegistry.cpp
    void GetImporterInstanceList(std::vector< BaseImporter* >& out);
	void DeleteImporterInstanceList(std::vector< BaseImporter* >& out);

    // PostStepRegistry.cpp
    void GetPostProcessingStepInstanceList(std::vector< BaseProcess* >& out);
}

using namespace Assimp;
using namespace Assimp::Intern;

// ------------------------------------------------------------------------------------------------
// Intern::AllocateFromAssimpHeap serves as abstract base class. It overrides
// new and delete (and their array counterparts) of public API classes (e.g. Logger) to
// utilize our DLL heap.
// See http://www.gotw.ca/publications/mill15.htm
// ------------------------------------------------------------------------------------------------
void* AllocateFromAssimpHeap::operator new ( size_t num_bytes)  {
    return ::operator new(num_bytes);
}

void* AllocateFromAssimpHeap::operator new ( size_t num_bytes, const std::nothrow_t& ) throw()  {
    try {
        return AllocateFromAssimpHeap::operator new( num_bytes );
    }
    catch( ... )    {
        return NULL;
    }
}

void AllocateFromAssimpHeap::operator delete ( void* data)  {
    return ::operator delete(data);
}

void* AllocateFromAssimpHeap::operator new[] ( size_t num_bytes)    {
    return ::operator new[](num_bytes);
}

void* AllocateFromAssimpHeap::operator new[] ( size_t num_bytes, const std::nothrow_t& ) throw() {
    try {
        return AllocateFromAssimpHeap::operator new[]( num_bytes );
    }
    catch( ... )    {
        return NULL;
    }
}

void AllocateFromAssimpHeap::operator delete[] ( void* data)    {
    return ::operator delete[](data);
}

// ------------------------------------------------------------------------------------------------
// Importer constructor.
Importer::Importer()
 : pimpl( NULL ) {
    // allocate the pimpl first
    pimpl = new ImporterPimpl();

    pimpl->mScene = NULL;
    pimpl->mErrorString = "";

    // Allocate a default IO handler
    pimpl->mIOHandler = new DefaultIOSystem;
    pimpl->mIsDefaultHandler = true;
    pimpl->bExtraVerbose     = false; // disable extra verbose mode by default

    pimpl->mProgressHandler = new DefaultProgressHandler();
    pimpl->mIsDefaultProgressHandler = true;

    GetImporterInstanceList(pimpl->mImporter);
    GetPostProcessingStepInstanceList(pimpl->mPostProcessingSteps);

    // Allocate a SharedPostProcessInfo object and store pointers to it in all post-process steps in the list.
    pimpl->mPPShared = new SharedPostProcessInfo();
    for (std::vector<BaseProcess*>::iterator it =  pimpl->mPostProcessingSteps.begin();
        it != pimpl->mPostProcessingSteps.end();
        ++it)   {

        (*it)->SetSharedData(pimpl->mPPShared);
    }
}

// ------------------------------------------------------------------------------------------------
// Destructor of Importer
Importer::~Importer()
{
    // Delete all import plugins
	DeleteImporterInstanceList(pimpl->mImporter);

    // Delete all post-processing plug-ins
    for( unsigned int a = 0; a < pimpl->mPostProcessingSteps.size(); a++)
        delete pimpl->mPostProcessingSteps[a];

    // Delete the assigned IO and progress handler
    delete pimpl->mIOHandler;
    delete pimpl->mProgressHandler;

    // Kill imported scene. Destructors should do that recursivly
    delete pimpl->mScene;

    // Delete shared post-processing data
    delete pimpl->mPPShared;

    // and finally the pimpl itself
    delete pimpl;
}

// ------------------------------------------------------------------------------------------------
// Copy constructor - copies the config of another Importer, not the scene
Importer::Importer(const Importer &other)
	: pimpl(NULL) {
    new(this) Importer();

    pimpl->mIntProperties    = other.pimpl->mIntProperties;
    pimpl->mFloatProperties  = other.pimpl->mFloatProperties;
    pimpl->mStringProperties = other.pimpl->mStringProperties;
    pimpl->mMatrixProperties = other.pimpl->mMatrixProperties;
}

// ------------------------------------------------------------------------------------------------
// Register a custom post-processing step
aiReturn Importer::RegisterPPStep(BaseProcess* pImp)
{
    ai_assert(NULL != pImp);
    ASSIMP_BEGIN_EXCEPTION_REGION();

        pimpl->mPostProcessingSteps.push_back(pImp);
        DefaultLogger::get()->info("Registering custom post-processing step");

    ASSIMP_END_EXCEPTION_REGION(aiReturn);
    return AI_SUCCESS;
}

// ------------------------------------------------------------------------------------------------
// Register a custom loader plugin
aiReturn Importer::RegisterLoader(BaseImporter* pImp)
{
    ai_assert(NULL != pImp);
    ASSIMP_BEGIN_EXCEPTION_REGION();

    // --------------------------------------------------------------------
    // Check whether we would have two loaders for the same file extension
    // This is absolutely OK, but we should warn the developer of the new
    // loader that his code will probably never be called if the first
    // loader is a bit too lazy in his file checking.
    // --------------------------------------------------------------------
    std::set<std::string> st;
    std::string baked;
    pImp->GetExtensionList(st);

    for(std::set<std::string>::const_iterator it = st.begin(); it != st.end(); ++it) {

#ifdef ASSIMP_BUILD_DEBUG
        if (IsExtensionSupported(*it)) {
            DefaultLogger::get()->warn("The file extension " + *it + " is already in use");
        }
#endif
        baked += *it;
    }

    // add the loader
    pimpl->mImporter.push_back(pImp);
    DefaultLogger::get()->info("Registering custom importer for these file extensions: " + baked);
    ASSIMP_END_EXCEPTION_REGION(aiReturn);
    return AI_SUCCESS;
}

// ------------------------------------------------------------------------------------------------
// Unregister a custom loader plugin
aiReturn Importer::UnregisterLoader(BaseImporter* pImp)
{
    if(!pImp) {
        // unregistering a NULL importer is no problem for us ... really!
        return AI_SUCCESS;
    }

    ASSIMP_BEGIN_EXCEPTION_REGION();
    std::vector<BaseImporter*>::iterator it = std::find(pimpl->mImporter.begin(),
        pimpl->mImporter.end(),pImp);

    if (it != pimpl->mImporter.end())   {
        pimpl->mImporter.erase(it);

        std::set<std::string> st;
        pImp->GetExtensionList(st);

        DefaultLogger::get()->info("Unregistering custom importer: ");
        return AI_SUCCESS;
    }
    DefaultLogger::get()->warn("Unable to remove custom importer: I can't find you ...");
    ASSIMP_END_EXCEPTION_REGION(aiReturn);
    return AI_FAILURE;
}

// ------------------------------------------------------------------------------------------------
// Unregister a custom loader plugin
aiReturn Importer::UnregisterPPStep(BaseProcess* pImp)
{
    if(!pImp) {
        // unregistering a NULL ppstep is no problem for us ... really!
        return AI_SUCCESS;
    }

    ASSIMP_BEGIN_EXCEPTION_REGION();
    std::vector<BaseProcess*>::iterator it = std::find(pimpl->mPostProcessingSteps.begin(),
        pimpl->mPostProcessingSteps.end(),pImp);

    if (it != pimpl->mPostProcessingSteps.end())    {
        pimpl->mPostProcessingSteps.erase(it);
        DefaultLogger::get()->info("Unregistering custom post-processing step");
        return AI_SUCCESS;
    }
    DefaultLogger::get()->warn("Unable to remove custom post-processing step: I can't find you ..");
    ASSIMP_END_EXCEPTION_REGION(aiReturn);
    return AI_FAILURE;
}

// ------------------------------------------------------------------------------------------------
// Supplies a custom IO handler to the importer to open and access files.
void Importer::SetIOHandler( IOSystem* pIOHandler)
{
    ASSIMP_BEGIN_EXCEPTION_REGION();
    // If the new handler is zero, allocate a default IO implementation.
    if (!pIOHandler)
    {
        // Release pointer in the possession of the caller
        pimpl->mIOHandler = new DefaultIOSystem();
        pimpl->mIsDefaultHandler = true;
    }
    // Otherwise register the custom handler
    else if (pimpl->mIOHandler != pIOHandler)
    {
        delete pimpl->mIOHandler;
        pimpl->mIOHandler = pIOHandler;
        pimpl->mIsDefaultHandler = false;
    }
    ASSIMP_END_EXCEPTION_REGION(void);
}

// ------------------------------------------------------------------------------------------------
// Get the currently set IO handler
IOSystem* Importer::GetIOHandler() const
{
    return pimpl->mIOHandler;
}

// ------------------------------------------------------------------------------------------------
// Check whether a custom IO handler is currently set
bool Importer::IsDefaultIOHandler() const
{
    return pimpl->mIsDefaultHandler;
}

// ------------------------------------------------------------------------------------------------
// Supplies a custom progress handler to get regular callbacks during importing
void Importer::SetProgressHandler ( ProgressHandler* pHandler )
{
    ASSIMP_BEGIN_EXCEPTION_REGION();
    // If the new handler is zero, allocate a default implementation.
    if (!pHandler)
    {
        // Release pointer in the possession of the caller
        pimpl->mProgressHandler = new DefaultProgressHandler();
        pimpl->mIsDefaultProgressHandler = true;
    }
    // Otherwise register the custom handler
    else if (pimpl->mProgressHandler != pHandler)
    {
        delete pimpl->mProgressHandler;
        pimpl->mProgressHandler = pHandler;
        pimpl->mIsDefaultProgressHandler = false;
    }
    ASSIMP_END_EXCEPTION_REGION(void);
}

// ------------------------------------------------------------------------------------------------
// Get the currently set progress handler
ProgressHandler* Importer::GetProgressHandler() const
{
    return pimpl->mProgressHandler;
}

// ------------------------------------------------------------------------------------------------
// Check whether a custom progress handler is currently set
bool Importer::IsDefaultProgressHandler() const
{
    return pimpl->mIsDefaultProgressHandler;
}

// ------------------------------------------------------------------------------------------------
// Validate post process step flags
bool _ValidateFlags(unsigned int pFlags)
{
    if (pFlags & aiProcess_GenSmoothNormals && pFlags & aiProcess_GenNormals)   {
        DefaultLogger::get()->error("#aiProcess_GenSmoothNormals and #aiProcess_GenNormals are incompatible");
        return false;
    }
    if (pFlags & aiProcess_OptimizeGraph && pFlags & aiProcess_PreTransformVertices)    {
        DefaultLogger::get()->error("#aiProcess_OptimizeGraph and #aiProcess_PreTransformVertices are incompatible");
        return false;
    }
    return true;
}

// ------------------------------------------------------------------------------------------------
// Free the current scene
void Importer::FreeScene( )
{
    ASSIMP_BEGIN_EXCEPTION_REGION();
    delete pimpl->mScene;
    pimpl->mScene = NULL;

    pimpl->mErrorString = "";
    ASSIMP_END_EXCEPTION_REGION(void);
}

// ------------------------------------------------------------------------------------------------
// Get the current error string, if any
const char* Importer::GetErrorString() const
{
     /* Must remain valid as long as ReadFile() or FreeFile() are not called */
    return pimpl->mErrorString.c_str();
}

// ------------------------------------------------------------------------------------------------
// Enable extra-verbose mode
void Importer::SetExtraVerbose(bool bDo)
{
    pimpl->bExtraVerbose = bDo;
}

// ------------------------------------------------------------------------------------------------
// Get the current scene
const aiScene* Importer::GetScene() const
{
    return pimpl->mScene;
}

// ------------------------------------------------------------------------------------------------
// Orphan the current scene and return it.
aiScene* Importer::GetOrphanedScene()
{
    aiScene* s = pimpl->mScene;

    ASSIMP_BEGIN_EXCEPTION_REGION();
    pimpl->mScene = NULL;

    pimpl->mErrorString = ""; /* reset error string */
    ASSIMP_END_EXCEPTION_REGION(aiScene*);
    return s;
}

// ------------------------------------------------------------------------------------------------
// Validate post-processing flags
bool Importer::ValidateFlags(unsigned int pFlags) const
{
    ASSIMP_BEGIN_EXCEPTION_REGION();
    // run basic checks for mutually exclusive flags
    if(!_ValidateFlags(pFlags)) {
        return false;
    }

    // ValidateDS does not anymore occur in the pp list, it plays an awesome extra role ...
#ifdef ASSIMP_BUILD_NO_VALIDATEDS_PROCESS
    if (pFlags & aiProcess_ValidateDataStructure) {
        return false;
    }
#endif
    pFlags &= ~aiProcess_ValidateDataStructure;

    // Now iterate through all bits which are set in the flags and check whether we find at least
    // one pp plugin which handles it.
    for (unsigned int mask = 1; mask < (1u << (sizeof(unsigned int)*8-1));mask <<= 1) {

        if (pFlags & mask) {

            bool have = false;
            for( unsigned int a = 0; a < pimpl->mPostProcessingSteps.size(); a++)   {
                if (pimpl->mPostProcessingSteps[a]-> IsActive(mask) ) {

                    have = true;
                    break;
                }
            }
            if (!have) {
                return false;
            }
        }
    }
    ASSIMP_END_EXCEPTION_REGION(bool);
    return true;
}

// ------------------------------------------------------------------------------------------------
const aiScene* Importer::ReadFileFromMemory( const void* pBuffer,
    size_t pLength,
    unsigned int pFlags,
    const char* pHint /*= ""*/)
{
    ASSIMP_BEGIN_EXCEPTION_REGION();
    if (!pHint) {
        pHint = "";
    }

    if (!pBuffer || !pLength || strlen(pHint) > MaxLenHint ) {
        pimpl->mErrorString = "Invalid parameters passed to ReadFileFromMemory()";
        return NULL;
    }

    // prevent deletion of the previous IOHandler
    IOSystem* io = pimpl->mIOHandler;
    pimpl->mIOHandler = NULL;

    SetIOHandler(new MemoryIOSystem((const uint8_t*)pBuffer,pLength));

    // read the file and recover the previous IOSystem
    static const size_t BufferSize(Importer::MaxLenHint + 28);
    char fbuff[ BufferSize ];
    ai_snprintf(fbuff, BufferSize, "%s.%s",AI_MEMORYIO_MAGIC_FILENAME,pHint);

    ReadFile(fbuff,pFlags);
    SetIOHandler(io);

    ASSIMP_END_EXCEPTION_REGION(const aiScene*);
    return pimpl->mScene;
}

// ------------------------------------------------------------------------------------------------
void WriteLogOpening(const std::string& file)
{
    Logger* l = DefaultLogger::get();
    if (!l) {
        return;
    }
    l->info("Load " + file);

    // print a full version dump. This is nice because we don't
    // need to ask the authors of incoming bug reports for
    // the library version they're using - a log dump is
    // sufficient.
    const unsigned int flags = aiGetCompileFlags();
    l->debug(format()
        << "Assimp "
        << aiGetVersionMajor()
        << "."
        << aiGetVersionMinor()
        << "."
        << aiGetVersionRevision()

        << " "
#if defined(ASSIMP_BUILD_ARCHITECTURE)
        << ASSIMP_BUILD_ARCHITECTURE
#elif defined(_M_IX86) || defined(__x86_32__) || defined(__i386__)
        << "x86"
#elif defined(_M_X64) || defined(__x86_64__)
        << "amd64"
#elif defined(_M_IA64) || defined(__ia64__)
        << "itanium"
#elif defined(__ppc__) || defined(__powerpc__)
        << "ppc32"
#elif defined(__powerpc64__)
        << "ppc64"
#elif defined(__arm__)
        << "arm"
#else
    << "<unknown architecture>"
#endif

        << " "
#if defined(ASSIMP_BUILD_COMPILER)
        << ASSIMP_BUILD_COMPILER
#elif defined(_MSC_VER)
        << "msvc"
#elif defined(__GNUC__)
        << "gcc"
#else
        << "<unknown compiler>"
#endif

#ifdef ASSIMP_BUILD_DEBUG
        << " debug"
#endif

        << (flags & ASSIMP_CFLAGS_NOBOOST ? " noboost" : "")
        << (flags & ASSIMP_CFLAGS_SHARED  ? " shared" : "")
        << (flags & ASSIMP_CFLAGS_SINGLETHREADED  ? " singlethreaded" : "")
        );
}

// ------------------------------------------------------------------------------------------------
// Reads the given file and returns its contents if successful.
const aiScene* Importer::ReadFile( const char* _pFile, unsigned int pFlags)
{
    ASSIMP_BEGIN_EXCEPTION_REGION();
    const std::string pFile(_pFile);

    // ----------------------------------------------------------------------
    // Put a large try block around everything to catch all std::exception's
    // that might be thrown by STL containers or by new().
    // ImportErrorException's are throw by ourselves and caught elsewhere.
    //-----------------------------------------------------------------------

    WriteLogOpening(pFile);

#ifdef ASSIMP_CATCH_GLOBAL_EXCEPTIONS
    try
#endif // ! ASSIMP_CATCH_GLOBAL_EXCEPTIONS
    {
        // Check whether this Importer instance has already loaded
        // a scene. In this case we need to delete the old one
        if (pimpl->mScene)  {

            DefaultLogger::get()->debug("(Deleting previous scene)");
            FreeScene();
        }

        // First check if the file is accessible at all
        if( !pimpl->mIOHandler->Exists( pFile)) {

            pimpl->mErrorString = "Unable to open file \"" + pFile + "\".";
            DefaultLogger::get()->error(pimpl->mErrorString);
            return NULL;
        }

        std::unique_ptr<Profiler> profiler(GetPropertyInteger(AI_CONFIG_GLOB_MEASURE_TIME,0)?new Profiler():NULL);
        if (profiler) {
            profiler->BeginRegion("total");
        }

        // Find an worker class which can handle the file
        BaseImporter* imp = NULL;
        for( unsigned int a = 0; a < pimpl->mImporter.size(); a++)  {

            if( pimpl->mImporter[a]->CanRead( pFile, pimpl->mIOHandler, false)) {
                imp = pimpl->mImporter[a];
                break;
            }
        }

        if (!imp)   {
            // not so bad yet ... try format auto detection.
            const std::string::size_type s = pFile.find_last_of('.');
            if (s != std::string::npos) {
                DefaultLogger::get()->info("File extension not known, trying signature-based detection");
                for( unsigned int a = 0; a < pimpl->mImporter.size(); a++)  {

                    if( pimpl->mImporter[a]->CanRead( pFile, pimpl->mIOHandler, true)) {
                        imp = pimpl->mImporter[a];
                        break;
                    }
                }
            }
            // Put a proper error message if no suitable importer was found
            if( !imp)   {
                pimpl->mErrorString = "No suitable reader found for the file format of file \"" + pFile + "\".";
                DefaultLogger::get()->error(pimpl->mErrorString);
                return NULL;
            }
        }

        // Get file size for progress handler
        IOStream * fileIO = pimpl->mIOHandler->Open( pFile );
        uint32_t fileSize = 0;
        if (fileIO)
        {
            fileSize = fileIO->FileSize();
            pimpl->mIOHandler->Close( fileIO );
        }

        // Dispatch the reading to the worker class for this format
        const aiImporterDesc *desc( imp->GetInfo() );
        std::string ext( "unknown" );
        if ( NULL != desc ) {
            ext = desc->mName;
        }
        DefaultLogger::get()->info("Found a matching importer for this file format: " + ext + "." );
        pimpl->mProgressHandler->UpdateFileRead( 0, fileSize );

        if (profiler) {
            profiler->BeginRegion("import");
        }

        pimpl->mScene = imp->ReadFile( this, pFile, pimpl->mIOHandler);
        pimpl->mProgressHandler->UpdateFileRead( fileSize, fileSize );

        if (profiler) {
            profiler->EndRegion("import");
        }

        // If successful, apply all active post processing steps to the imported data
        if( pimpl->mScene)  {

#ifndef ASSIMP_BUILD_NO_VALIDATEDS_PROCESS
            // The ValidateDS process is an exception. It is executed first, even before ScenePreprocessor is called.
            if (pFlags & aiProcess_ValidateDataStructure)
            {
                ValidateDSProcess ds;
                ds.ExecuteOnScene (this);
                if (!pimpl->mScene) {
                    return NULL;
                }
            }
#endif // no validation

            // Preprocess the scene and prepare it for post-processing
            if (profiler) {
                profiler->BeginRegion("preprocess");
            }

            ScenePreprocessor pre(pimpl->mScene);
            pre.ProcessScene();

            if (profiler) {
                profiler->EndRegion("preprocess");
            }

            // Ensure that the validation process won't be called twice
            ApplyPostProcessing(pFlags & (~aiProcess_ValidateDataStructure));
        }
        // if failed, extract the error string
        else if( !pimpl->mScene) {
            pimpl->mErrorString = imp->GetErrorText();
        }

        // clear any data allocated by post-process steps
        pimpl->mPPShared->Clean();

        if (profiler) {
            profiler->EndRegion("total");
        }
    }
#ifdef ASSIMP_CATCH_GLOBAL_EXCEPTIONS
    catch (std::exception &e)
    {
#if (defined _MSC_VER) &&   (defined _CPPRTTI)
        // if we have RTTI get the full name of the exception that occurred
        pimpl->mErrorString = std::string(typeid( e ).name()) + ": " + e.what();
#else
        pimpl->mErrorString = std::string("std::exception: ") + e.what();
#endif

        DefaultLogger::get()->error(pimpl->mErrorString);
        delete pimpl->mScene; pimpl->mScene = NULL;
    }
#endif // ! ASSIMP_CATCH_GLOBAL_EXCEPTIONS

    // either successful or failure - the pointer expresses it anyways
    ASSIMP_END_EXCEPTION_REGION(const aiScene*);
    return pimpl->mScene;
}


// ------------------------------------------------------------------------------------------------
// Apply post-processing to the currently bound scene
const aiScene* Importer::ApplyPostProcessing(unsigned int pFlags)
{
    ASSIMP_BEGIN_EXCEPTION_REGION();
    // Return immediately if no scene is active
    if (!pimpl->mScene) {
        return NULL;
    }

    // If no flags are given, return the current scene with no further action
    if (!pFlags) {
        return pimpl->mScene;
    }

    // In debug builds: run basic flag validation
    ai_assert(_ValidateFlags(pFlags));
    DefaultLogger::get()->info("Entering post processing pipeline");

#ifndef ASSIMP_BUILD_NO_VALIDATEDS_PROCESS
    // The ValidateDS process plays an exceptional role. It isn't contained in the global
    // list of post-processing steps, so we need to call it manually.
    if (pFlags & aiProcess_ValidateDataStructure)
    {
        ValidateDSProcess ds;
        ds.ExecuteOnScene (this);
        if (!pimpl->mScene) {
            return NULL;
        }
    }
#endif // no validation
#ifdef ASSIMP_BUILD_DEBUG
    if (pimpl->bExtraVerbose)
    {
#ifdef ASSIMP_BUILD_NO_VALIDATEDS_PROCESS
        DefaultLogger::get()->error("Verbose Import is not available due to build settings");
#endif  // no validation
        pFlags |= aiProcess_ValidateDataStructure;
    }
#else
    if (pimpl->bExtraVerbose) {
        DefaultLogger::get()->warn("Not a debug build, ignoring extra verbose setting");
    }
#endif // ! DEBUG

    std::unique_ptr<Profiler> profiler(GetPropertyInteger(AI_CONFIG_GLOB_MEASURE_TIME,0)?new Profiler():NULL);
    for( unsigned int a = 0; a < pimpl->mPostProcessingSteps.size(); a++)   {

        BaseProcess* process = pimpl->mPostProcessingSteps[a];
        pimpl->mProgressHandler->UpdatePostProcess( a, pimpl->mPostProcessingSteps.size() );
        if( process->IsActive( pFlags)) {

            if (profiler) {
                profiler->BeginRegion("postprocess");
            }

            process->ExecuteOnScene ( this );

            if (profiler) {
                profiler->EndRegion("postprocess");
            }
        }
        if( !pimpl->mScene) {
            break;
        }
#ifdef ASSIMP_BUILD_DEBUG

#ifdef ASSIMP_BUILD_NO_VALIDATEDS_PROCESS
        continue;
#endif  // no validation

        // If the extra verbose mode is active, execute the ValidateDataStructureStep again - after each step
        if (pimpl->bExtraVerbose)   {
            DefaultLogger::get()->debug("Verbose Import: revalidating data structures");

            ValidateDSProcess ds;
            ds.ExecuteOnScene (this);
            if( !pimpl->mScene) {
                DefaultLogger::get()->error("Verbose Import: failed to revalidate data structures");
                break;
            }
        }
#endif // ! DEBUG
    }
    pimpl->mProgressHandler->UpdatePostProcess( pimpl->mPostProcessingSteps.size(), pimpl->mPostProcessingSteps.size() );

    // update private scene flags
  if( pimpl->mScene )
    ScenePriv(pimpl->mScene)->mPPStepsApplied |= pFlags;

    // clear any data allocated by post-process steps
    pimpl->mPPShared->Clean();
    DefaultLogger::get()->info("Leaving post processing pipeline");

    ASSIMP_END_EXCEPTION_REGION(const aiScene*);
    return pimpl->mScene;
}

// ------------------------------------------------------------------------------------------------
const aiScene* Importer::ApplyCustomizedPostProcessing( BaseProcess *rootProcess, bool requestValidation ) {
    ASSIMP_BEGIN_EXCEPTION_REGION();

    // Return immediately if no scene is active
    if ( NULL == pimpl->mScene ) {
        return NULL;
    }

    // If no flags are given, return the current scene with no further action
    if ( NULL == rootProcess ) {
        return pimpl->mScene;
    }

    // In debug builds: run basic flag validation
    DefaultLogger::get()->info( "Entering customized post processing pipeline" );

#ifndef ASSIMP_BUILD_NO_VALIDATEDS_PROCESS
    // The ValidateDS process plays an exceptional role. It isn't contained in the global
    // list of post-processing steps, so we need to call it manually.
    if ( requestValidation )
    {
        ValidateDSProcess ds;
        ds.ExecuteOnScene( this );
        if ( !pimpl->mScene ) {
            return NULL;
        }
    }
#endif // no validation
#ifdef ASSIMP_BUILD_DEBUG
    if ( pimpl->bExtraVerbose )
    {
#ifdef ASSIMP_BUILD_NO_VALIDATEDS_PROCESS
        DefaultLogger::get()->error( "Verbose Import is not available due to build settings" );
#endif  // no validation
    }
#else
    if ( pimpl->bExtraVerbose ) {
        DefaultLogger::get()->warn( "Not a debug build, ignoring extra verbose setting" );
    }
#endif // ! DEBUG

    std::unique_ptr<Profiler> profiler( GetPropertyInteger( AI_CONFIG_GLOB_MEASURE_TIME, 0 ) ? new Profiler() : NULL );

    if ( profiler ) {
        profiler->BeginRegion( "postprocess" );
    }

    rootProcess->ExecuteOnScene( this );

    if ( profiler ) {
        profiler->EndRegion( "postprocess" );
    }

    // If the extra verbose mode is active, execute the ValidateDataStructureStep again - after each step
    if ( pimpl->bExtraVerbose || requestValidation  ) {
        DefaultLogger::get()->debug( "Verbose Import: revalidating data structures" );

        ValidateDSProcess ds;
        ds.ExecuteOnScene( this );
        if ( !pimpl->mScene ) {
            DefaultLogger::get()->error( "Verbose Import: failed to revalidate data structures" );
        }
    }

    // clear any data allocated by post-process steps
    pimpl->mPPShared->Clean();
    DefaultLogger::get()->info( "Leaving customized post processing pipeline" );

    ASSIMP_END_EXCEPTION_REGION( const aiScene* );

    return pimpl->mScene;
}

// ------------------------------------------------------------------------------------------------
// Helper function to check whether an extension is supported by ASSIMP
bool Importer::IsExtensionSupported(const char* szExtension) const
{
    return NULL != GetImporter(szExtension);
}

// ------------------------------------------------------------------------------------------------
size_t Importer::GetImporterCount() const
{
    return pimpl->mImporter.size();
}

// ------------------------------------------------------------------------------------------------
const aiImporterDesc* Importer::GetImporterInfo(size_t index) const
{
    if (index >= pimpl->mImporter.size()) {
        return NULL;
    }
    return pimpl->mImporter[index]->GetInfo();
}


// ------------------------------------------------------------------------------------------------
BaseImporter* Importer::GetImporter (size_t index) const
{
    if (index >= pimpl->mImporter.size()) {
        return NULL;
    }
    return pimpl->mImporter[index];
}

// ------------------------------------------------------------------------------------------------
// Find a loader plugin for a given file extension
BaseImporter* Importer::GetImporter (const char* szExtension) const
{
    return GetImporter(GetImporterIndex(szExtension));
}

// ------------------------------------------------------------------------------------------------
// Find a loader plugin for a given file extension
size_t Importer::GetImporterIndex (const char* szExtension) const
{
    ai_assert(szExtension);
    ASSIMP_BEGIN_EXCEPTION_REGION();

    // skip over wildcard and dot characters at string head --
    for(;*szExtension == '*' || *szExtension == '.'; ++szExtension);

    std::string ext(szExtension);
    if (ext.empty()) {
        return static_cast<size_t>(-1);
    }
    std::transform(ext.begin(),ext.end(), ext.begin(), tolower);

    std::set<std::string> str;
    for (std::vector<BaseImporter*>::const_iterator i =  pimpl->mImporter.begin();i != pimpl->mImporter.end();++i)  {
        str.clear();

        (*i)->GetExtensionList(str);
        for (std::set<std::string>::const_iterator it = str.begin(); it != str.end(); ++it) {
            if (ext == *it) {
                return std::distance(static_cast< std::vector<BaseImporter*>::const_iterator >(pimpl->mImporter.begin()), i);
            }
        }
    }
    ASSIMP_END_EXCEPTION_REGION(size_t);
    return static_cast<size_t>(-1);
}

// ------------------------------------------------------------------------------------------------
// Helper function to build a list of all file extensions supported by ASSIMP
void Importer::GetExtensionList(aiString& szOut) const
{
    ASSIMP_BEGIN_EXCEPTION_REGION();
    std::set<std::string> str;
    for (std::vector<BaseImporter*>::const_iterator i =  pimpl->mImporter.begin();i != pimpl->mImporter.end();++i)  {
        (*i)->GetExtensionList(str);
    }

    for (std::set<std::string>::const_iterator it = str.begin();; ) {
        szOut.Append("*.");
        szOut.Append((*it).c_str());

        if (++it == str.end()) {
            break;
        }
        szOut.Append(";");
    }
    ASSIMP_END_EXCEPTION_REGION(void);
}

// ------------------------------------------------------------------------------------------------
// Set a configuration property
bool Importer::SetPropertyInteger(const char* szName, int iValue)
{
    bool existing;
    ASSIMP_BEGIN_EXCEPTION_REGION();
        existing = SetGenericProperty<int>(pimpl->mIntProperties, szName,iValue);
    ASSIMP_END_EXCEPTION_REGION(bool);
    return existing;
}

// ------------------------------------------------------------------------------------------------
// Set a configuration property
bool Importer::SetPropertyFloat(const char* szName, float iValue)
{
    bool exising;
    ASSIMP_BEGIN_EXCEPTION_REGION();
        exising = SetGenericProperty<float>(pimpl->mFloatProperties, szName,iValue);
    ASSIMP_END_EXCEPTION_REGION(bool);
    return exising;
}

// ------------------------------------------------------------------------------------------------
// Set a configuration property
bool Importer::SetPropertyString(const char* szName, const std::string& value)
{
    bool exising;
    ASSIMP_BEGIN_EXCEPTION_REGION();
        exising = SetGenericProperty<std::string>(pimpl->mStringProperties, szName,value);
    ASSIMP_END_EXCEPTION_REGION(bool);
    return exising;
}

// ------------------------------------------------------------------------------------------------
// Set a configuration property
bool Importer::SetPropertyMatrix(const char* szName, const aiMatrix4x4& value)
{
    bool exising;
    ASSIMP_BEGIN_EXCEPTION_REGION();
        exising = SetGenericProperty<aiMatrix4x4>(pimpl->mMatrixProperties, szName,value);
    ASSIMP_END_EXCEPTION_REGION(bool);
    return exising;
}

// ------------------------------------------------------------------------------------------------
// Get a configuration property
int Importer::GetPropertyInteger(const char* szName,
    int iErrorReturn /*= 0xffffffff*/) const
{
    return GetGenericProperty<int>(pimpl->mIntProperties,szName,iErrorReturn);
}

// ------------------------------------------------------------------------------------------------
// Get a configuration property
float Importer::GetPropertyFloat(const char* szName,
    float iErrorReturn /*= 10e10*/) const
{
    return GetGenericProperty<float>(pimpl->mFloatProperties,szName,iErrorReturn);
}

// ------------------------------------------------------------------------------------------------
// Get a configuration property
const std::string Importer::GetPropertyString(const char* szName,
    const std::string& iErrorReturn /*= ""*/) const
{
    return GetGenericProperty<std::string>(pimpl->mStringProperties,szName,iErrorReturn);
}

// ------------------------------------------------------------------------------------------------
// Get a configuration property
const aiMatrix4x4 Importer::GetPropertyMatrix(const char* szName,
    const aiMatrix4x4& iErrorReturn /*= aiMatrix4x4()*/) const
{
    return GetGenericProperty<aiMatrix4x4>(pimpl->mMatrixProperties,szName,iErrorReturn);
}

// ------------------------------------------------------------------------------------------------
// Get the memory requirements of a single node
inline void AddNodeWeight(unsigned int& iScene,const aiNode* pcNode)
{
    iScene += sizeof(aiNode);
    iScene += sizeof(unsigned int) * pcNode->mNumMeshes;
    iScene += sizeof(void*) * pcNode->mNumChildren;

    for (unsigned int i = 0; i < pcNode->mNumChildren;++i) {
        AddNodeWeight(iScene,pcNode->mChildren[i]);
    }
}

// ------------------------------------------------------------------------------------------------
// Get the memory requirements of the scene
void Importer::GetMemoryRequirements(aiMemoryInfo& in) const
{
    in = aiMemoryInfo();
    aiScene* mScene = pimpl->mScene;

    // return if we have no scene loaded
    if (!pimpl->mScene)
        return;


    in.total = sizeof(aiScene);

    // add all meshes
    for (unsigned int i = 0; i < mScene->mNumMeshes;++i)
    {
        in.meshes += sizeof(aiMesh);
        if (mScene->mMeshes[i]->HasPositions()) {
            in.meshes += sizeof(aiVector3D) * mScene->mMeshes[i]->mNumVertices;
        }

        if (mScene->mMeshes[i]->HasNormals()) {
            in.meshes += sizeof(aiVector3D) * mScene->mMeshes[i]->mNumVertices;
        }

        if (mScene->mMeshes[i]->HasTangentsAndBitangents()) {
            in.meshes += sizeof(aiVector3D) * mScene->mMeshes[i]->mNumVertices * 2;
        }

        for (unsigned int a = 0; a < AI_MAX_NUMBER_OF_COLOR_SETS;++a) {
            if (mScene->mMeshes[i]->HasVertexColors(a)) {
                in.meshes += sizeof(aiColor4D) * mScene->mMeshes[i]->mNumVertices;
            }
            else break;
        }
        for (unsigned int a = 0; a < AI_MAX_NUMBER_OF_TEXTURECOORDS;++a) {
            if (mScene->mMeshes[i]->HasTextureCoords(a)) {
                in.meshes += sizeof(aiVector3D) * mScene->mMeshes[i]->mNumVertices;
            }
            else break;
        }
        if (mScene->mMeshes[i]->HasBones()) {
            in.meshes += sizeof(void*) * mScene->mMeshes[i]->mNumBones;
            for (unsigned int p = 0; p < mScene->mMeshes[i]->mNumBones;++p) {
                in.meshes += sizeof(aiBone);
                in.meshes += mScene->mMeshes[i]->mBones[p]->mNumWeights * sizeof(aiVertexWeight);
            }
        }
        in.meshes += (sizeof(aiFace) + 3 * sizeof(unsigned int))*mScene->mMeshes[i]->mNumFaces;
    }
    in.total += in.meshes;

    // add all embedded textures
    for (unsigned int i = 0; i < mScene->mNumTextures;++i) {
        const aiTexture* pc = mScene->mTextures[i];
        in.textures += sizeof(aiTexture);
        if (pc->mHeight) {
            in.textures += 4 * pc->mHeight * pc->mWidth;
        }
        else in.textures += pc->mWidth;
    }
    in.total += in.textures;

    // add all animations
    for (unsigned int i = 0; i < mScene->mNumAnimations;++i) {
        const aiAnimation* pc = mScene->mAnimations[i];
        in.animations += sizeof(aiAnimation);

        // add all bone anims
        for (unsigned int a = 0; a < pc->mNumChannels; ++a) {
            const aiNodeAnim* pc2 = pc->mChannels[i];
            in.animations += sizeof(aiNodeAnim);
            in.animations += pc2->mNumPositionKeys * sizeof(aiVectorKey);
            in.animations += pc2->mNumScalingKeys * sizeof(aiVectorKey);
            in.animations += pc2->mNumRotationKeys * sizeof(aiQuatKey);
        }
    }
    in.total += in.animations;

    // add all cameras and all lights
    in.total += in.cameras = sizeof(aiCamera) *  mScene->mNumCameras;
    in.total += in.lights  = sizeof(aiLight)  *  mScene->mNumLights;

    // add all nodes
    AddNodeWeight(in.nodes,mScene->mRootNode);
    in.total += in.nodes;

    // add all materials
    for (unsigned int i = 0; i < mScene->mNumMaterials;++i) {
        const aiMaterial* pc = mScene->mMaterials[i];
        in.materials += sizeof(aiMaterial);
        in.materials += pc->mNumAllocated * sizeof(void*);

        for (unsigned int a = 0; a < pc->mNumProperties;++a) {
            in.materials += pc->mProperties[a]->mDataLength;
        }
    }
    in.total += in.materials;
}

/***********************************************************************
FBXIMPORT\IMPORTERREGISTRY.CPP
***********************************************************************/
/*
---------------------------------------------------------------------------
Open Asset Import Library (assimp)
---------------------------------------------------------------------------

Copyright (c) 2006-2016, assimp team

All rights reserved.

Redistribution and use of this software in source and binary forms,
with or without modification, are permitted provided that the following
conditions are met:

* Redistributions of source code must retain the above
  copyright notice, this list of conditions and the
  following disclaimer.

* Redistributions in binary form must reproduce the above
  copyright notice, this list of conditions and the
  following disclaimer in the documentation and/or other
  materials provided with the distribution.

* Neither the name of the assimp team, nor the names of its
  contributors may be used to endorse or promote products
  derived from this software without specific prior
  written permission of the assimp team.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
"AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
---------------------------------------------------------------------------
*/

/** @file ImporterRegistry.cpp

Central registry for all importers available. Do not edit this file
directly (unless you are adding new loaders), instead use the
corresponding preprocessor flag to selectively disable formats.
*/

// ------------------------------------------------------------------------------------------------
// Importers
// (include_new_importers_here)
// ------------------------------------------------------------------------------------------------
#ifndef ASSIMP_BUILD_NO_FBX_IMPORTER
#   include "FBXImporter.h"
#endif

namespace Assimp {

// ------------------------------------------------------------------------------------------------
void GetImporterInstanceList(std::vector< BaseImporter* >& out)
{
    // ----------------------------------------------------------------------------
    // Add an instance of each worker class here
    // (register_new_importers_here)
    // ----------------------------------------------------------------------------
    out.reserve(64);
#if ( !defined ASSIMP_BUILD_NO_FBX_IMPORTER )
    out.push_back( new FBXImporter() );
#endif
}

/** will delete all registered importers. */
void DeleteImporterInstanceList(std::vector< BaseImporter* >& deleteList){
	for(size_t i= 0; i<deleteList.size();++i){
		delete deleteList[i];
		deleteList[i]=NULL;
	}//for
}

} // namespace Assimp

/***********************************************************************
FBXIMPORT\IMPROVECACHELOCALITY.CPP
***********************************************************************/
/*
---------------------------------------------------------------------------
Open Asset Import Library (assimp)
---------------------------------------------------------------------------

Copyright (c) 2006-2016, assimp team

All rights reserved.

Redistribution and use of this software in source and binary forms,
with or without modification, are permitted provided that the following
conditions are met:

* Redistributions of source code must retain the above
  copyright notice, this list of conditions and the
  following disclaimer.

* Redistributions in binary form must reproduce the above
  copyright notice, this list of conditions and the
  following disclaimer in the documentation and/or other
  materials provided with the distribution.

* Neither the name of the assimp team, nor the names of its
  contributors may be used to endorse or promote products
  derived from this software without specific prior
  written permission of the assimp team.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
"AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
---------------------------------------------------------------------------
*/

/** @file Implementation of the post processing step to improve the cache locality of a mesh.
 * <br>
 * The algorithm is roughly basing on this paper:
 * http://www.cs.princeton.edu/gfx/pubs/Sander_2007_%3ETR/tipsy.pdf
 *   .. although overdraw rduction isn't implemented yet ...
 */



// internal headers
#include <stack>

using namespace Assimp;

// ------------------------------------------------------------------------------------------------
// Constructor to be privately used by Importer
ImproveCacheLocalityProcess::ImproveCacheLocalityProcess() {
    configCacheDepth = PP_ICL_PTCACHE_SIZE;
}

// ------------------------------------------------------------------------------------------------
// Destructor, private as well
ImproveCacheLocalityProcess::~ImproveCacheLocalityProcess()
{
    // nothing to do here
}

// ------------------------------------------------------------------------------------------------
// Returns whether the processing step is present in the given flag field.
bool ImproveCacheLocalityProcess::IsActive( unsigned int pFlags) const
{
    return (pFlags & aiProcess_ImproveCacheLocality) != 0;
}

// ------------------------------------------------------------------------------------------------
// Setup configuration
void ImproveCacheLocalityProcess::SetupProperties(const Importer* pImp)
{
    // AI_CONFIG_PP_ICL_PTCACHE_SIZE controls the target cache size for the optimizer
    configCacheDepth = pImp->GetPropertyInteger(AI_CONFIG_PP_ICL_PTCACHE_SIZE,PP_ICL_PTCACHE_SIZE);
}

// ------------------------------------------------------------------------------------------------
// Executes the post processing step on the given imported data.
void ImproveCacheLocalityProcess::Execute( aiScene* pScene)
{
    if (!pScene->mNumMeshes) {
        DefaultLogger::get()->debug("ImproveCacheLocalityProcess skipped; there are no meshes");
        return;
    }

    DefaultLogger::get()->debug("ImproveCacheLocalityProcess begin");

    float out = 0.f;
    unsigned int numf = 0, numm = 0;
    for( unsigned int a = 0; a < pScene->mNumMeshes; a++){
        const float res = ProcessMesh( pScene->mMeshes[a],a);
        if (res) {
            numf += pScene->mMeshes[a]->mNumFaces;
            out  += res;
            ++numm;
        }
    }
    if (!DefaultLogger::isNullLogger()) {
        char szBuff[128]; // should be sufficiently large in every case
        ai_snprintf(szBuff,128,"Cache relevant are %u meshes (%u faces). Average output ACMR is %f",
            numm,numf,out/numf);

        DefaultLogger::get()->info(szBuff);
        DefaultLogger::get()->debug("ImproveCacheLocalityProcess finished. ");
    }
}

// ------------------------------------------------------------------------------------------------
// Improves the cache coherency of a specific mesh
float ImproveCacheLocalityProcess::ProcessMesh( aiMesh* pMesh, unsigned int meshNum)
{
    // TODO: rewrite this to use std::vector or boost::shared_array
    ai_assert(NULL != pMesh);

    // Check whether the input data is valid
    // - there must be vertices and faces
    // - all faces must be triangulated or we can't operate on them
    if (!pMesh->HasFaces() || !pMesh->HasPositions())
        return 0.f;

    if (pMesh->mPrimitiveTypes != aiPrimitiveType_TRIANGLE) {
        DefaultLogger::get()->error("This algorithm works on triangle meshes only");
        return 0.f;
    }

    if(pMesh->mNumVertices <= configCacheDepth) {
        return 0.f;
    }

    float fACMR = 3.f;
    const aiFace* const pcEnd = pMesh->mFaces+pMesh->mNumFaces;

    // Input ACMR is for logging purposes only
    if (!DefaultLogger::isNullLogger())     {

        unsigned int* piFIFOStack = new unsigned int[configCacheDepth];
        memset(piFIFOStack,0xff,configCacheDepth*sizeof(unsigned int));
        unsigned int* piCur = piFIFOStack;
        const unsigned int* const piCurEnd = piFIFOStack + configCacheDepth;

        // count the number of cache misses
        unsigned int iCacheMisses = 0;
        for (const aiFace* pcFace = pMesh->mFaces;pcFace != pcEnd;++pcFace) {

            for (unsigned int qq = 0; qq < 3;++qq) {
                bool bInCache = false;

                for (unsigned int* pp = piFIFOStack;pp < piCurEnd;++pp) {
                    if (*pp == pcFace->mIndices[qq])    {
                        // the vertex is in cache
                        bInCache = true;
                        break;
                    }
                }
                if (!bInCache)  {
                    ++iCacheMisses;
                    if (piCurEnd == piCur) {
                        piCur = piFIFOStack;
                    }
                    *piCur++ = pcFace->mIndices[qq];
                }
            }
        }
        delete[] piFIFOStack;
        fACMR = (float)iCacheMisses / pMesh->mNumFaces;
        if (3.0 == fACMR)   {
            char szBuff[128]; // should be sufficiently large in every case

            // the JoinIdenticalVertices process has not been executed on this
            // mesh, otherwise this value would normally be at least minimally
            // smaller than 3.0 ...
            ai_snprintf(szBuff,128,"Mesh %u: Not suitable for vcache optimization",meshNum);
            DefaultLogger::get()->warn(szBuff);
            return 0.f;
        }
    }

    // first we need to build a vertex-triangle adjacency list
    VertexTriangleAdjacency adj(pMesh->mFaces,pMesh->mNumFaces, pMesh->mNumVertices,true);

    // build a list to store per-vertex caching time stamps
    unsigned int* const piCachingStamps = new unsigned int[pMesh->mNumVertices];
    memset(piCachingStamps,0x0,pMesh->mNumVertices*sizeof(unsigned int));

    // allocate an empty output index buffer. We store the output indices in one large array.
    // Since the number of triangles won't change the input faces can be reused. This is how
    // we save thousands of redundant mini allocations for aiFace::mIndices
    const unsigned int iIdxCnt = pMesh->mNumFaces*3;
    unsigned int* const piIBOutput = new unsigned int[iIdxCnt];
    unsigned int* piCSIter = piIBOutput;

    // allocate the flag array to hold the information
    // whether a face has already been emitted or not
    std::vector<bool> abEmitted(pMesh->mNumFaces,false);

    // dead-end vertex index stack
    std::stack<unsigned int, std::vector<unsigned int> > sDeadEndVStack;

    // create a copy of the piNumTriPtr buffer
    unsigned int* const piNumTriPtr = adj.mLiveTriangles;
    const std::vector<unsigned int> piNumTriPtrNoModify(piNumTriPtr, piNumTriPtr + pMesh->mNumVertices);

    // get the largest number of referenced triangles and allocate the "candidate buffer"
    unsigned int iMaxRefTris = 0; {
        const unsigned int* piCur = adj.mLiveTriangles;
        const unsigned int* const piCurEnd = adj.mLiveTriangles+pMesh->mNumVertices;
        for (;piCur != piCurEnd;++piCur) {
            iMaxRefTris = std::max(iMaxRefTris,*piCur);
        }
    }
    unsigned int* piCandidates = new unsigned int[iMaxRefTris*3];
    unsigned int iCacheMisses = 0;

    // ...................................................................................
    /** PSEUDOCODE for the algorithm

        A = Build-Adjacency(I) Vertex-triangle adjacency
        L = Get-Triangle-Counts(A) Per-vertex live triangle counts
        C = Zero(Vertex-Count(I)) Per-vertex caching time stamps
        D = Empty-Stack() Dead-end vertex stack
        E = False(Triangle-Count(I)) Per triangle emitted flag
        O = Empty-Index-Buffer() Empty output buffer
        f = 0 Arbitrary starting vertex
        s = k+1, i = 1 Time stamp and cursor
        while f >= 0 For all valid fanning vertices
            N = Empty-Set() 1-ring of next candidates
            for each Triangle t in Neighbors(A, f)
                if !Emitted(E,t)
                    for each Vertex v in t
                        Append(O,v) Output vertex
                        Push(D,v) Add to dead-end stack
                        Insert(N,v) Register as candidate
                        L[v] = L[v]-1 Decrease live triangle count
                        if s-C[v] > k If not in cache
                            C[v] = s Set time stamp
                            s = s+1 Increment time stamp
                    E[t] = true Flag triangle as emitted
            Select next fanning vertex
            f = Get-Next-Vertex(I,i,k,N,C,s,L,D)
        return O
        */
    // ...................................................................................

    int ivdx = 0;
    int ics = 1;
    int iStampCnt = configCacheDepth+1;
    while (ivdx >= 0)   {

        unsigned int icnt = piNumTriPtrNoModify[ivdx];
        unsigned int* piList = adj.GetAdjacentTriangles(ivdx);
        unsigned int* piCurCandidate = piCandidates;

        // get all triangles in the neighborhood
        for (unsigned int tri = 0; tri < icnt;++tri)    {

            // if they have not yet been emitted, add them to the output IB
            const unsigned int fidx = *piList++;
            if (!abEmitted[fidx])   {

                // so iterate through all vertices of the current triangle
                const aiFace* pcFace = &pMesh->mFaces[ fidx ];
                for (unsigned int* p = pcFace->mIndices, *p2 = pcFace->mIndices+3;p != p2;++p)  {
                    const unsigned int dp = *p;

                    // the current vertex won't have any free triangles after this step
                    if (ivdx != (int)dp) {
                        // append the vertex to the dead-end stack
                        sDeadEndVStack.push(dp);

                        // register as candidate for the next step
                        *piCurCandidate++ = dp;

                        // decrease the per-vertex triangle counts
                        piNumTriPtr[dp]--;
                    }

                    // append the vertex to the output index buffer
                    *piCSIter++ = dp;

                    // if the vertex is not yet in cache, set its cache count
                    if (iStampCnt-piCachingStamps[dp] > configCacheDepth) {
                        piCachingStamps[dp] = iStampCnt++;
                        ++iCacheMisses;
                    }
                }
                // flag triangle as emitted
                abEmitted[fidx] = true;
            }
        }

        // the vertex has now no living adjacent triangles anymore
        piNumTriPtr[ivdx] = 0;

        // get next fanning vertex
        ivdx = -1;
        int max_priority = -1;
        for (unsigned int* piCur = piCandidates;piCur != piCurCandidate;++piCur)    {
            const unsigned int dp = *piCur;

            // must have live triangles
            if (piNumTriPtr[dp] > 0)    {
                int priority = 0;

                // will the vertex be in cache, even after fanning occurs?
                unsigned int tmp;
                if ((tmp = iStampCnt-piCachingStamps[dp]) + 2*piNumTriPtr[dp] <= configCacheDepth) {
                    priority = tmp;
                }

                // keep best candidate
                if (priority > max_priority) {
                    max_priority = priority;
                    ivdx = dp;
                }
            }
        }
        // did we reach a dead end?
        if (-1 == ivdx) {
            // need to get a non-local vertex for which we have a good chance that it is still
            // in the cache ...
            while (!sDeadEndVStack.empty()) {
                unsigned int iCachedIdx = sDeadEndVStack.top();
                sDeadEndVStack.pop();
                if (piNumTriPtr[ iCachedIdx ] > 0)  {
                    ivdx = iCachedIdx;
                    break;
                }
            }

            if (-1 == ivdx) {
                // well, there isn't such a vertex. Simply get the next vertex in input order and
                // hope it is not too bad ...
                while (ics < (int)pMesh->mNumVertices)  {
                    ++ics;
                    if (piNumTriPtr[ics] > 0)   {
                        ivdx = ics;
                        break;
                    }
                }
            }
        }
    }
    float fACMR2 = 0.0f;
    if (!DefaultLogger::isNullLogger()) {
        fACMR2 = (float)iCacheMisses / pMesh->mNumFaces;

        // very intense verbose logging ... prepare for much text if there are many meshes
        if ( DefaultLogger::get()->getLogSeverity() == Logger::VERBOSE) {
            char szBuff[128]; // should be sufficiently large in every case

            ai_snprintf(szBuff,128,"Mesh %u | ACMR in: %f out: %f | ~%.1f%%",meshNum,fACMR,fACMR2,
                ((fACMR - fACMR2) / fACMR) * 100.f);
            DefaultLogger::get()->debug(szBuff);
        }

        fACMR2 *= pMesh->mNumFaces;
    }
    // sort the output index buffer back to the input array
    piCSIter = piIBOutput;
    for (aiFace* pcFace = pMesh->mFaces; pcFace != pcEnd;++pcFace)  {
        pcFace->mIndices[0] = *piCSIter++;
        pcFace->mIndices[1] = *piCSIter++;
        pcFace->mIndices[2] = *piCSIter++;
    }

    // delete temporary storage
    delete[] piCachingStamps;
    delete[] piIBOutput;
    delete[] piCandidates;

    return fACMR2;
}

/***********************************************************************
FBXIMPORT\JOINVERTICESPROCESS.CPP
***********************************************************************/
/*
---------------------------------------------------------------------------
Open Asset Import Library (assimp)
---------------------------------------------------------------------------

Copyright (c) 2006-2016, assimp team

All rights reserved.

Redistribution and use of this software in source and binary forms,
with or without modification, are permitted provided that the following
conditions are met:

* Redistributions of source code must retain the above
  copyright notice, this list of conditions and the
  following disclaimer.

* Redistributions in binary form must reproduce the above
  copyright notice, this list of conditions and the
  following disclaimer in the documentation and/or other
  materials provided with the distribution.

* Neither the name of the assimp team, nor the names of its
  contributors may be used to endorse or promote products
  derived from this software without specific prior
  written permission of the assimp team.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
"AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
---------------------------------------------------------------------------
*/

/** @file Implementation of the post processing step to join identical vertices
 * for all imported meshes
 */


#ifndef ASSIMP_BUILD_NO_JOINVERTICES_PROCESS


using namespace Assimp;
// ------------------------------------------------------------------------------------------------
// Constructor to be privately used by Importer
JoinVerticesProcess::JoinVerticesProcess()
{
    // nothing to do here
}

// ------------------------------------------------------------------------------------------------
// Destructor, private as well
JoinVerticesProcess::~JoinVerticesProcess()
{
    // nothing to do here
}

// ------------------------------------------------------------------------------------------------
// Returns whether the processing step is present in the given flag field.
bool JoinVerticesProcess::IsActive( unsigned int pFlags) const
{
    return (pFlags & aiProcess_JoinIdenticalVertices) != 0;
}
// ------------------------------------------------------------------------------------------------
// Executes the post processing step on the given imported data.
void JoinVerticesProcess::Execute( aiScene* pScene)
{
    DefaultLogger::get()->debug("JoinVerticesProcess begin");

    // get the total number of vertices BEFORE the step is executed
    int iNumOldVertices = 0;
    if (!DefaultLogger::isNullLogger()) {
        for( unsigned int a = 0; a < pScene->mNumMeshes; a++)   {
            iNumOldVertices +=  pScene->mMeshes[a]->mNumVertices;
        }
    }

    // execute the step
    int iNumVertices = 0;
    for( unsigned int a = 0; a < pScene->mNumMeshes; a++)
        iNumVertices += ProcessMesh( pScene->mMeshes[a],a);

    // if logging is active, print detailed statistics
    if (!DefaultLogger::isNullLogger())
    {
        if (iNumOldVertices == iNumVertices)
        {
            DefaultLogger::get()->debug("JoinVerticesProcess finished ");
        } else
        {
            char szBuff[128]; // should be sufficiently large in every case
            ::ai_snprintf(szBuff,128,"JoinVerticesProcess finished | Verts in: %i out: %i | ~%.1f%%",
                iNumOldVertices,
                iNumVertices,
                ((iNumOldVertices - iNumVertices) / (float)iNumOldVertices) * 100.f);
            DefaultLogger::get()->info(szBuff);
        }
    }

    pScene->mFlags |= AI_SCENE_FLAGS_NON_VERBOSE_FORMAT;
}

// ------------------------------------------------------------------------------------------------
// Unites identical vertices in the given mesh
int JoinVerticesProcess::ProcessMesh( aiMesh* pMesh, unsigned int meshIndex)
{
    static_assert( AI_MAX_NUMBER_OF_COLOR_SETS    == 8, "AI_MAX_NUMBER_OF_COLOR_SETS    == 8");
	static_assert( AI_MAX_NUMBER_OF_TEXTURECOORDS == 8, "AI_MAX_NUMBER_OF_TEXTURECOORDS == 8");

    // Return early if we don't have any positions
    if (!pMesh->HasPositions() || !pMesh->HasFaces()) {
        return 0;
    }

    // We'll never have more vertices afterwards.
    std::vector<Vertex> uniqueVertices;
    uniqueVertices.reserve( pMesh->mNumVertices);

    // For each vertex the index of the vertex it was replaced by.
    // Since the maximal number of vertices is 2^31-1, the most significand bit can be used to mark
    //  whether a new vertex was created for the index (true) or if it was replaced by an existing
    //  unique vertex (false). This saves an additional std::vector<bool> and greatly enhances
    //  branching performance.
    static_assert(AI_MAX_VERTICES == 0x7fffffff, "AI_MAX_VERTICES == 0x7fffffff");
    std::vector<unsigned int> replaceIndex( pMesh->mNumVertices, 0xffffffff);

    // A little helper to find locally close vertices faster.
    // Try to reuse the lookup table from the last step.
    const static float epsilon = 1e-5f;
    // float posEpsilonSqr;
    SpatialSort* vertexFinder = NULL;
    SpatialSort _vertexFinder;

    typedef std::pair<SpatialSort,float> SpatPair;
    if (shared) {
        std::vector<SpatPair >* avf;
        shared->GetProperty(AI_SPP_SPATIAL_SORT,avf);
        if (avf)    {
            SpatPair& blubb = (*avf)[meshIndex];
            vertexFinder  = &blubb.first;
            // posEpsilonSqr = blubb.second;
        }
    }
    if (!vertexFinder)  {
        // bad, need to compute it.
        _vertexFinder.Fill(pMesh->mVertices, pMesh->mNumVertices, sizeof( aiVector3D));
        vertexFinder = &_vertexFinder;
        // posEpsilonSqr = ComputePositionEpsilon(pMesh);
    }

    // Squared because we check against squared length of the vector difference
    static const float squareEpsilon = epsilon * epsilon;

    // Again, better waste some bytes than a realloc ...
    std::vector<unsigned int> verticesFound;
    verticesFound.reserve(10);

    // Run an optimized code path if we don't have multiple UVs or vertex colors.
    // This should yield false in more than 99% of all imports ...
    const bool complex = ( pMesh->GetNumColorChannels() > 0 || pMesh->GetNumUVChannels() > 1);

    // Now check each vertex if it brings something new to the table
    for( unsigned int a = 0; a < pMesh->mNumVertices; a++)  {
        // collect the vertex data
        Vertex v(pMesh,a);

        // collect all vertices that are close enough to the given position
        vertexFinder->FindIdenticalPositions( v.position, verticesFound);
        unsigned int matchIndex = 0xffffffff;

        // check all unique vertices close to the position if this vertex is already present among them
        for( unsigned int b = 0; b < verticesFound.size(); b++) {

            const unsigned int vidx = verticesFound[b];
            const unsigned int uidx = replaceIndex[ vidx];
            if( uidx & 0x80000000)
                continue;

            const Vertex& uv = uniqueVertices[ uidx];
            // Position mismatch is impossible - the vertex finder already discarded all non-matching positions

            // We just test the other attributes even if they're not present in the mesh.
            // In this case they're initialized to 0 so the comparison succeeds.
            // By this method the non-present attributes are effectively ignored in the comparison.
            if( (uv.normal - v.normal).SquareLength() > squareEpsilon)
                continue;
            if( (uv.texcoords[0] - v.texcoords[0]).SquareLength() > squareEpsilon)
                continue;
            if( (uv.tangent - v.tangent).SquareLength() > squareEpsilon)
                continue;
            if( (uv.bitangent - v.bitangent).SquareLength() > squareEpsilon)
                continue;

            // Usually we won't have vertex colors or multiple UVs, so we can skip from here
            // Actually this increases runtime performance slightly, at least if branch
            // prediction is on our side.
            if (complex){
                // manually unrolled because continue wouldn't work as desired in an inner loop,
                // also because some compilers seem to fail the task. Colors and UV coords
                // are interleaved since the higher entries are most likely to be
                // zero and thus useless. By interleaving the arrays, vertices are,
                // on average, rejected earlier.

                if( (uv.texcoords[1] - v.texcoords[1]).SquareLength() > squareEpsilon)
                    continue;
                if( GetColorDifference( uv.colors[0], v.colors[0]) > squareEpsilon)
                    continue;

                if( (uv.texcoords[2] - v.texcoords[2]).SquareLength() > squareEpsilon)
                    continue;
                if( GetColorDifference( uv.colors[1], v.colors[1]) > squareEpsilon)
                    continue;

                if( (uv.texcoords[3] - v.texcoords[3]).SquareLength() > squareEpsilon)
                    continue;
                if( GetColorDifference( uv.colors[2], v.colors[2]) > squareEpsilon)
                    continue;

                if( (uv.texcoords[4] - v.texcoords[4]).SquareLength() > squareEpsilon)
                    continue;
                if( GetColorDifference( uv.colors[3], v.colors[3]) > squareEpsilon)
                    continue;

                if( (uv.texcoords[5] - v.texcoords[5]).SquareLength() > squareEpsilon)
                    continue;
                if( GetColorDifference( uv.colors[4], v.colors[4]) > squareEpsilon)
                    continue;

                if( (uv.texcoords[6] - v.texcoords[6]).SquareLength() > squareEpsilon)
                    continue;
                if( GetColorDifference( uv.colors[5], v.colors[5]) > squareEpsilon)
                    continue;

                if( (uv.texcoords[7] - v.texcoords[7]).SquareLength() > squareEpsilon)
                    continue;
                if( GetColorDifference( uv.colors[6], v.colors[6]) > squareEpsilon)
                    continue;

                if( GetColorDifference( uv.colors[7], v.colors[7]) > squareEpsilon)
                    continue;
            }

            // we're still here -> this vertex perfectly matches our given vertex
            matchIndex = uidx;
            break;
        }

        // found a replacement vertex among the uniques?
        if( matchIndex != 0xffffffff)
        {
            // store where to found the matching unique vertex
            replaceIndex[a] = matchIndex | 0x80000000;
        }
        else
        {
            // no unique vertex matches it up to now -> so add it
            replaceIndex[a] = (unsigned int)uniqueVertices.size();
            uniqueVertices.push_back( v);
        }
    }

    if (!DefaultLogger::isNullLogger() && DefaultLogger::get()->getLogSeverity() == Logger::VERBOSE)    {
        DefaultLogger::get()->debug((Formatter::format(),
            "Mesh ",meshIndex,
            " (",
            (pMesh->mName.length ? pMesh->mName.data : "unnamed"),
            ") | Verts in: ",pMesh->mNumVertices,
            " out: ",
            uniqueVertices.size(),
            " | ~",
            ((pMesh->mNumVertices - uniqueVertices.size()) / (float)pMesh->mNumVertices) * 100.f,
            "%"
        ));
    }

    // replace vertex data with the unique data sets
    pMesh->mNumVertices = (unsigned int)uniqueVertices.size();

    // ----------------------------------------------------------------------------
    // NOTE - we're *not* calling Vertex::SortBack() because it would check for
    // presence of every single vertex component once PER VERTEX. And our CPU
    // dislikes branches, even if they're easily predictable.
    // ----------------------------------------------------------------------------

    // Position
    delete [] pMesh->mVertices;
    pMesh->mVertices = new aiVector3D[pMesh->mNumVertices];
    for( unsigned int a = 0; a < pMesh->mNumVertices; a++)
        pMesh->mVertices[a] = uniqueVertices[a].position;

    // Normals, if present
    if( pMesh->mNormals)
    {
        delete [] pMesh->mNormals;
        pMesh->mNormals = new aiVector3D[pMesh->mNumVertices];
        for( unsigned int a = 0; a < pMesh->mNumVertices; a++) {
            pMesh->mNormals[a] = uniqueVertices[a].normal;
        }
    }
    // Tangents, if present
    if( pMesh->mTangents)
    {
        delete [] pMesh->mTangents;
        pMesh->mTangents = new aiVector3D[pMesh->mNumVertices];
        for( unsigned int a = 0; a < pMesh->mNumVertices; a++) {
            pMesh->mTangents[a] = uniqueVertices[a].tangent;
        }
    }
    // Bitangents as well
    if( pMesh->mBitangents)
    {
        delete [] pMesh->mBitangents;
        pMesh->mBitangents = new aiVector3D[pMesh->mNumVertices];
        for( unsigned int a = 0; a < pMesh->mNumVertices; a++) {
            pMesh->mBitangents[a] = uniqueVertices[a].bitangent;
        }
    }
    // Vertex colors
    for( unsigned int a = 0; pMesh->HasVertexColors(a); a++)
    {
        delete [] pMesh->mColors[a];
        pMesh->mColors[a] = new aiColor4D[pMesh->mNumVertices];
        for( unsigned int b = 0; b < pMesh->mNumVertices; b++) {
            pMesh->mColors[a][b] = uniqueVertices[b].colors[a];
        }
    }
    // Texture coords
    for( unsigned int a = 0; pMesh->HasTextureCoords(a); a++)
    {
        delete [] pMesh->mTextureCoords[a];
        pMesh->mTextureCoords[a] = new aiVector3D[pMesh->mNumVertices];
        for( unsigned int b = 0; b < pMesh->mNumVertices; b++) {
            pMesh->mTextureCoords[a][b] = uniqueVertices[b].texcoords[a];
        }
    }

    // adjust the indices in all faces
    for( unsigned int a = 0; a < pMesh->mNumFaces; a++)
    {
        aiFace& face = pMesh->mFaces[a];
        for( unsigned int b = 0; b < face.mNumIndices; b++) {
            face.mIndices[b] = replaceIndex[face.mIndices[b]] & ~0x80000000;
        }
    }

    // adjust bone vertex weights.
    for( int a = 0; a < (int)pMesh->mNumBones; a++) {
        aiBone* bone = pMesh->mBones[a];
        std::vector<aiVertexWeight> newWeights;
        newWeights.reserve( bone->mNumWeights);

        if ( NULL != bone->mWeights ) {
            for ( unsigned int b = 0; b < bone->mNumWeights; b++ ) {
                const aiVertexWeight& ow = bone->mWeights[ b ];
                // if the vertex is a unique one, translate it
                if ( !( replaceIndex[ ow.mVertexId ] & 0x80000000 ) ) {
                    aiVertexWeight nw;
                    nw.mVertexId = replaceIndex[ ow.mVertexId ];
                    nw.mWeight = ow.mWeight;
                    newWeights.push_back( nw );
                }
            }
        } else {
            DefaultLogger::get()->error( "X-Export: aiBone shall contain weights, but pointer to them is NULL." );
        }

        if (newWeights.size() > 0) {
            // kill the old and replace them with the translated weights
            delete [] bone->mWeights;
            bone->mNumWeights = (unsigned int)newWeights.size();

            bone->mWeights = new aiVertexWeight[bone->mNumWeights];
            memcpy( bone->mWeights, &newWeights[0], bone->mNumWeights * sizeof( aiVertexWeight));
        }
        else {

            /*  NOTE:
             *
             *  In the algorithm above we're assuming that there are no vertices
             *  with a different bone weight setup at the same position. That wouldn't
             *  make sense, but it is not absolutely impossible. SkeletonMeshBuilder
             *  for example generates such input data if two skeleton points
             *  share the same position. Again this doesn't make sense but is
             *  reality for some model formats (MD5 for example uses these special
             *  nodes as attachment tags for its weapons).
             *
             *  Then it is possible that a bone has no weights anymore .... as a quick
             *  workaround, we're just removing these bones. If they're animated,
             *  model geometry might be modified but at least there's no risk of a crash.
             */
            delete bone;
            --pMesh->mNumBones;
            for (unsigned int n = a; n < pMesh->mNumBones; ++n)  {
                pMesh->mBones[n] = pMesh->mBones[n+1];
            }

            --a;
            DefaultLogger::get()->warn("Removing bone -> no weights remaining");
        }
    }
    return pMesh->mNumVertices;
}

#endif // !! ASSIMP_BUILD_NO_JOINVERTICES_PROCESS

/***********************************************************************
FBXIMPORT\LIMITBONEWEIGHTSPROCESS.CPP
***********************************************************************/
/*
Open Asset Import Library (assimp)
----------------------------------------------------------------------

Copyright (c) 2006-2016, assimp team
All rights reserved.

Redistribution and use of this software in source and binary forms,
with or without modification, are permitted provided that the
following conditions are met:

* Redistributions of source code must retain the above
  copyright notice, this list of conditions and the
  following disclaimer.

* Redistributions in binary form must reproduce the above
  copyright notice, this list of conditions and the
  following disclaimer in the documentation and/or other
  materials provided with the distribution.

* Neither the name of the assimp team, nor the names of its
  contributors may be used to endorse or promote products
  derived from this software without specific prior
  written permission of the assimp team.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
"AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

----------------------------------------------------------------------
*/

/** Implementation of the LimitBoneWeightsProcess post processing step */



using namespace Assimp;


// ------------------------------------------------------------------------------------------------
// Constructor to be privately used by Importer
LimitBoneWeightsProcess::LimitBoneWeightsProcess()
{
    mMaxWeights = AI_LMW_MAX_WEIGHTS;
}

// ------------------------------------------------------------------------------------------------
// Destructor, private as well
LimitBoneWeightsProcess::~LimitBoneWeightsProcess()
{
    // nothing to do here
}

// ------------------------------------------------------------------------------------------------
// Returns whether the processing step is present in the given flag field.
bool LimitBoneWeightsProcess::IsActive( unsigned int pFlags) const
{
    return (pFlags & aiProcess_LimitBoneWeights) != 0;
}

// ------------------------------------------------------------------------------------------------
// Executes the post processing step on the given imported data.
void LimitBoneWeightsProcess::Execute( aiScene* pScene)
{
    DefaultLogger::get()->debug("LimitBoneWeightsProcess begin");
    for( unsigned int a = 0; a < pScene->mNumMeshes; a++)
        ProcessMesh( pScene->mMeshes[a]);

    DefaultLogger::get()->debug("LimitBoneWeightsProcess end");
}

// ------------------------------------------------------------------------------------------------
// Executes the post processing step on the given imported data.
void LimitBoneWeightsProcess::SetupProperties(const Importer* pImp)
{
    // get the current value of the property
    this->mMaxWeights = pImp->GetPropertyInteger(AI_CONFIG_PP_LBW_MAX_WEIGHTS,AI_LMW_MAX_WEIGHTS);
}

// ------------------------------------------------------------------------------------------------
// Unites identical vertices in the given mesh
void LimitBoneWeightsProcess::ProcessMesh( aiMesh* pMesh)
{
    if( !pMesh->HasBones())
        return;

    // collect all bone weights per vertex
    typedef std::vector< std::vector< Weight > > WeightsPerVertex;
    WeightsPerVertex vertexWeights( pMesh->mNumVertices);

    // collect all weights per vertex
    for( unsigned int a = 0; a < pMesh->mNumBones; a++)
    {
        const aiBone* bone = pMesh->mBones[a];
        for( unsigned int b = 0; b < bone->mNumWeights; b++)
        {
            const aiVertexWeight& w = bone->mWeights[b];
            vertexWeights[w.mVertexId].push_back( Weight( a, w.mWeight));
        }
    }

    unsigned int removed = 0, old_bones = pMesh->mNumBones;

    // now cut the weight count if it exceeds the maximum
    bool bChanged = false;
    for( WeightsPerVertex::iterator vit = vertexWeights.begin(); vit != vertexWeights.end(); ++vit)
    {
        if( vit->size() <= mMaxWeights)
            continue;

        bChanged = true;

        // more than the defined maximum -> first sort by weight in descending order. That's
        // why we defined the < operator in such a weird way.
        std::sort( vit->begin(), vit->end());

        // now kill everything beyond the maximum count
        unsigned int m = vit->size();
        vit->erase( vit->begin() + mMaxWeights, vit->end());
        removed += m-vit->size();

        // and renormalize the weights
        float sum = 0.0f;
        for( std::vector<Weight>::const_iterator it = vit->begin(); it != vit->end(); ++it ) {
            sum += it->mWeight;
        }
        if( 0.0f != sum ) {
            const float invSum = 1.0f / sum;
            for( std::vector<Weight>::iterator it = vit->begin(); it != vit->end(); ++it ) {
                it->mWeight *= invSum;
            }
        }
    }

    if (bChanged)   {
        // rebuild the vertex weight array for all bones
        typedef std::vector< std::vector< aiVertexWeight > > WeightsPerBone;
        WeightsPerBone boneWeights( pMesh->mNumBones);
        for( unsigned int a = 0; a < vertexWeights.size(); a++)
        {
            const std::vector<Weight>& vw = vertexWeights[a];
            for( std::vector<Weight>::const_iterator it = vw.begin(); it != vw.end(); ++it)
                boneWeights[it->mBone].push_back( aiVertexWeight( a, it->mWeight));
        }

        // and finally copy the vertex weight list over to the mesh's bones
        std::vector<bool> abNoNeed(pMesh->mNumBones,false);
        bChanged = false;

        for( unsigned int a = 0; a < pMesh->mNumBones; a++)
        {
            const std::vector<aiVertexWeight>& bw = boneWeights[a];
            aiBone* bone = pMesh->mBones[a];

            if ( bw.empty() )
            {
                abNoNeed[a] = bChanged = true;
                continue;
            }

            // copy the weight list. should always be less weights than before, so we don't need a new allocation
            ai_assert( bw.size() <= bone->mNumWeights);
            bone->mNumWeights = static_cast<unsigned int>( bw.size() );
            ::memcpy( bone->mWeights, &bw[0], bw.size() * sizeof( aiVertexWeight));
        }

        if (bChanged)   {
            // the number of new bones is smaller than before, so we can reuse the old array
            aiBone** ppcCur = pMesh->mBones;aiBone** ppcSrc = ppcCur;

            for (std::vector<bool>::const_iterator iter  = abNoNeed.begin();iter != abNoNeed.end()  ;++iter)    {
                if (*iter)  {
                    delete *ppcSrc;
                    --pMesh->mNumBones;
                }
                else *ppcCur++ = *ppcSrc;
                ++ppcSrc;
            }
        }

        if (!DefaultLogger::isNullLogger()) {
            char buffer[1024];
            ai_snprintf(buffer,1024,"Removed %u weights. Input bones: %u. Output bones: %u",removed,old_bones,pMesh->mNumBones);
            DefaultLogger::get()->info(buffer);
        }
    }
}

/***********************************************************************
FBXIMPORT\MATERIALSYSTEM.CPP
***********************************************************************/
/*
Open Asset Import Library (assimp)
----------------------------------------------------------------------

Copyright (c) 2006-2016, assimp team
All rights reserved.

Redistribution and use of this software in source and binary forms,
with or without modification, are permitted provided that the
following conditions are met:

* Redistributions of source code must retain the above
  copyright notice, this list of conditions and the
  following disclaimer.

* Redistributions in binary form must reproduce the above
  copyright notice, this list of conditions and the
  following disclaimer in the documentation and/or other
  materials provided with the distribution.

* Neither the name of the assimp team, nor the names of its
  contributors may be used to endorse or promote products
  derived from this software without specific prior
  written permission of the assimp team.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
"AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

----------------------------------------------------------------------
*/

/** @file  MaterialSystem.cpp
 *  @brief Implementation of the material system of the library
 */




using namespace Assimp;

// ------------------------------------------------------------------------------------------------
// Get a specific property from a material
aiReturn aiGetMaterialProperty(const aiMaterial* pMat,
    const char* pKey,
    unsigned int type,
    unsigned int index,
    const aiMaterialProperty** pPropOut)
{
    ai_assert (pMat != NULL);
    ai_assert (pKey != NULL);
    ai_assert (pPropOut != NULL);

    /*  Just search for a property with exactly this name ..
     *  could be improved by hashing, but it's possibly
     *  no worth the effort (we're bound to C structures,
     *  thus std::map or derivates are not applicable. */
    for (unsigned int i = 0; i < pMat->mNumProperties;++i) {
        aiMaterialProperty* prop = pMat->mProperties[i];

        if (prop /* just for safety ... */
            && 0 == strcmp( prop->mKey.data, pKey )
            && (UINT_MAX == type  || prop->mSemantic == type) /* UINT_MAX is a wildcard, but this is undocumented :-) */
            && (UINT_MAX == index || prop->mIndex == index))
        {
            *pPropOut = pMat->mProperties[i];
            return AI_SUCCESS;
        }
    }
    *pPropOut = NULL;
    return AI_FAILURE;
}

// ------------------------------------------------------------------------------------------------
// Get an array of floating-point values from the material.
aiReturn aiGetMaterialFloatArray(const aiMaterial* pMat,
    const char* pKey,
    unsigned int type,
    unsigned int index,
    float* pOut,
    unsigned int* pMax)
{
    ai_assert (pOut != NULL);
    ai_assert (pMat != NULL);

    const aiMaterialProperty* prop;
    aiGetMaterialProperty(pMat,pKey,type,index, (const aiMaterialProperty**) &prop);
    if (!prop) {
        return AI_FAILURE;
    }

    // data is given in floats, simply copy it
    unsigned int iWrite = 0;
    if( aiPTI_Float == prop->mType || aiPTI_Buffer == prop->mType)  {
        iWrite = prop->mDataLength / sizeof(float);
        if (pMax) {
            iWrite = std::min(*pMax,iWrite); ;
        }
        for (unsigned int a = 0; a < iWrite;++a)    {
            pOut[a] = static_cast<float> ( reinterpret_cast<float*>(prop->mData)[a] );
        }
        if (pMax) {
            *pMax = iWrite;
        }
    }
    // data is given in ints, convert to float
    else if( aiPTI_Integer == prop->mType)  {
        iWrite = prop->mDataLength / sizeof(int32_t);
        if (pMax) {
            iWrite = std::min(*pMax,iWrite); ;
        }
        for (unsigned int a = 0; a < iWrite;++a)    {
            pOut[a] = static_cast<float> ( reinterpret_cast<int32_t*>(prop->mData)[a] );
        }
        if (pMax) {
            *pMax = iWrite;
        }
    }
    // a string ... read floats separated by spaces
    else {
        if (pMax) {
            iWrite = *pMax;
        }
        // strings are zero-terminated with a 32 bit length prefix, so this is safe
        const char* cur =  prop->mData+4;
        ai_assert(prop->mDataLength>=5 && !prop->mData[prop->mDataLength-1]);
        for (unsigned int a = 0; ;++a) {
            cur = fast_atoreal_move<float>(cur,pOut[a]);
            if(a==iWrite-1) {
                break;
            }
            if(!IsSpace(*cur)) {
                DefaultLogger::get()->error("Material property" + std::string(pKey) +
                    " is a string; failed to parse a float array out of it.");
                return AI_FAILURE;
            }
        }

        if (pMax) {
            *pMax = iWrite;
        }
    }
    return AI_SUCCESS;

}

// ------------------------------------------------------------------------------------------------
// Get an array if integers from the material
aiReturn aiGetMaterialIntegerArray(const aiMaterial* pMat,
    const char* pKey,
    unsigned int type,
    unsigned int index,
    int* pOut,
    unsigned int* pMax)
{
    ai_assert (pOut != NULL);
    ai_assert (pMat != NULL);

    const aiMaterialProperty* prop;
    aiGetMaterialProperty(pMat,pKey,type,index,(const aiMaterialProperty**) &prop);
    if (!prop) {
        return AI_FAILURE;
    }

    // data is given in ints, simply copy it
    unsigned int iWrite = 0;
    if( aiPTI_Integer == prop->mType || aiPTI_Buffer == prop->mType)    {
        iWrite = prop->mDataLength / sizeof(int32_t);
        if (pMax) {
            iWrite = std::min(*pMax,iWrite); ;
        }
        for (unsigned int a = 0; a < iWrite;++a) {
            pOut[a] = static_cast<int>(reinterpret_cast<int32_t*>(prop->mData)[a]);
        }
        if (pMax) {
            *pMax = iWrite;
        }
    }
    // data is given in floats convert to int
    else if( aiPTI_Float == prop->mType)    {
        iWrite = prop->mDataLength / sizeof(float);
        if (pMax) {
            iWrite = std::min(*pMax,iWrite); ;
        }
        for (unsigned int a = 0; a < iWrite;++a) {
            pOut[a] = static_cast<int>(reinterpret_cast<float*>(prop->mData)[a]);
        }
        if (pMax) {
            *pMax = iWrite;
        }
    }
    // it is a string ... no way to read something out of this
    else    {
        if (pMax) {
            iWrite = *pMax;
        }
        // strings are zero-terminated with a 32 bit length prefix, so this is safe
        const char* cur =  prop->mData+4;
        ai_assert(prop->mDataLength>=5 && !prop->mData[prop->mDataLength-1]);
        for (unsigned int a = 0; ;++a) {
            pOut[a] = strtol10(cur,&cur);
            if(a==iWrite-1) {
                break;
            }
            if(!IsSpace(*cur)) {
                DefaultLogger::get()->error("Material property" + std::string(pKey) +
                    " is a string; failed to parse an integer array out of it.");
                return AI_FAILURE;
            }
        }

        if (pMax) {
            *pMax = iWrite;
        }
    }
    return AI_SUCCESS;
}

// ------------------------------------------------------------------------------------------------
// Get a color (3 or 4 floats) from the material
aiReturn aiGetMaterialColor(const aiMaterial* pMat,
    const char* pKey,
    unsigned int type,
    unsigned int index,
    aiColor4D* pOut)
{
    unsigned int iMax = 4;
    const aiReturn eRet = aiGetMaterialFloatArray(pMat,pKey,type,index,(float*)pOut,&iMax);

    // if no alpha channel is defined: set it to 1.0
    if (3 == iMax) {
        pOut->a = 1.0f;
    }

    return eRet;
}

// ------------------------------------------------------------------------------------------------
// Get a aiUVTransform (4 floats) from the material
aiReturn aiGetMaterialUVTransform(const aiMaterial* pMat,
    const char* pKey,
    unsigned int type,
    unsigned int index,
    aiUVTransform* pOut)
{
    unsigned int iMax = 4;
    return  aiGetMaterialFloatArray(pMat,pKey,type,index,(float*)pOut,&iMax);
}

// ------------------------------------------------------------------------------------------------
// Get a string from the material
aiReturn aiGetMaterialString(const aiMaterial* pMat,
    const char* pKey,
    unsigned int type,
    unsigned int index,
    aiString* pOut)
{
    ai_assert (pOut != NULL);

    const aiMaterialProperty* prop;
    aiGetMaterialProperty(pMat,pKey,type,index,(const aiMaterialProperty**)&prop);
    if (!prop) {
        return AI_FAILURE;
    }

    if( aiPTI_String == prop->mType) {
        ai_assert(prop->mDataLength>=5);

        // The string is stored as 32 but length prefix followed by zero-terminated UTF8 data
        pOut->length = static_cast<unsigned int>(*reinterpret_cast<uint32_t*>(prop->mData));

        ai_assert(pOut->length+1+4==prop->mDataLength && !prop->mData[prop->mDataLength-1]);
        memcpy(pOut->data,prop->mData+4,pOut->length+1);
    }
    else {
        // TODO - implement lexical cast as well
        DefaultLogger::get()->error("Material property" + std::string(pKey) +
            " was found, but is no string" );
        return AI_FAILURE;
    }
    return AI_SUCCESS;
}

// ------------------------------------------------------------------------------------------------
// Get the number of textures on a particular texture stack
ASSIMP_API unsigned int aiGetMaterialTextureCount(const C_STRUCT aiMaterial* pMat,
    C_ENUM aiTextureType type)
{
    ai_assert (pMat != NULL);

    /* Textures are always stored with ascending indices (ValidateDS provides a check, so we don't need to do it again) */
    unsigned int max = 0;
    for (unsigned int i = 0; i < pMat->mNumProperties;++i) {
        aiMaterialProperty* prop = pMat->mProperties[i];

        if (prop /* just a sanity check ... */
            && 0 == strcmp( prop->mKey.data, _AI_MATKEY_TEXTURE_BASE )
            && prop->mSemantic == type) {

            max = std::max(max,prop->mIndex+1);
        }
    }
    return max;
}

// ------------------------------------------------------------------------------------------------
aiReturn aiGetMaterialTexture(const C_STRUCT aiMaterial* mat,
    aiTextureType type,
    unsigned int  index,
    C_STRUCT aiString* path,
    aiTextureMapping* _mapping  /*= NULL*/,
    unsigned int* uvindex       /*= NULL*/,
    float* blend                /*= NULL*/,
    aiTextureOp* op             /*= NULL*/,
    aiTextureMapMode* mapmode   /*= NULL*/,
    unsigned int* flags         /*= NULL*/
    )
{
    ai_assert(NULL != mat && NULL != path);

    // Get the path to the texture
    if (AI_SUCCESS != aiGetMaterialString(mat,AI_MATKEY_TEXTURE(type,index),path))  {
        return AI_FAILURE;
    }
    // Determine mapping type
    aiTextureMapping mapping = aiTextureMapping_UV;
    aiGetMaterialInteger(mat,AI_MATKEY_MAPPING(type,index),(int*)&mapping);
    if (_mapping)
        *_mapping = mapping;

    // Get UV index
    if (aiTextureMapping_UV == mapping && uvindex)  {
        aiGetMaterialInteger(mat,AI_MATKEY_UVWSRC(type,index),(int*)uvindex);
    }
    // Get blend factor
    if (blend)  {
        aiGetMaterialFloat(mat,AI_MATKEY_TEXBLEND(type,index),blend);
    }
    // Get texture operation
    if (op){
        aiGetMaterialInteger(mat,AI_MATKEY_TEXOP(type,index),(int*)op);
    }
    // Get texture mapping modes
    if (mapmode)    {
        aiGetMaterialInteger(mat,AI_MATKEY_MAPPINGMODE_U(type,index),(int*)&mapmode[0]);
        aiGetMaterialInteger(mat,AI_MATKEY_MAPPINGMODE_V(type,index),(int*)&mapmode[1]);
    }
    // Get texture flags
    if (flags){
        aiGetMaterialInteger(mat,AI_MATKEY_TEXFLAGS(type,index),(int*)flags);
    }
    return AI_SUCCESS;
}

// ------------------------------------------------------------------------------------------------
// Construction. Actually the one and only way to get an aiMaterial instance
aiMaterial::aiMaterial()
{
    // Allocate 5 entries by default
    mNumProperties = 0;
    mNumAllocated = 5;
    mProperties = new aiMaterialProperty*[5];
}

// ------------------------------------------------------------------------------------------------
aiMaterial::~aiMaterial()
{
    Clear();

    delete[] mProperties;
}

// ------------------------------------------------------------------------------------------------
void aiMaterial::Clear()
{
    for (unsigned int i = 0; i < mNumProperties;++i)    {
        // delete this entry
        delete mProperties[i];
        AI_DEBUG_INVALIDATE_PTR(mProperties[i]);
    }
    mNumProperties = 0;

    // The array remains allocated, we just invalidated its contents
}

// ------------------------------------------------------------------------------------------------
aiReturn aiMaterial::RemoveProperty (const char* pKey,unsigned int type,
    unsigned int index
    )
{
    ai_assert(NULL != pKey);

    for (unsigned int i = 0; i < mNumProperties;++i) {
        aiMaterialProperty* prop = mProperties[i];

        if (prop && !strcmp( prop->mKey.data, pKey ) &&
            prop->mSemantic == type && prop->mIndex == index)
        {
            // Delete this entry
            delete mProperties[i];

            // collapse the array behind --.
            --mNumProperties;
            for (unsigned int a = i; a < mNumProperties;++a)    {
                mProperties[a] = mProperties[a+1];
            }
            return AI_SUCCESS;
        }
    }

    return AI_FAILURE;
}

// ------------------------------------------------------------------------------------------------
aiReturn aiMaterial::AddBinaryProperty (const void* pInput,
    unsigned int pSizeInBytes,
    const char* pKey,
    unsigned int type,
    unsigned int index,
    aiPropertyTypeInfo pType
    )
{
    ai_assert (pInput != NULL);
    ai_assert (pKey != NULL);
    ai_assert (0 != pSizeInBytes);

    // first search the list whether there is already an entry with this key
    unsigned int iOutIndex = UINT_MAX;
    for (unsigned int i = 0; i < mNumProperties;++i)    {
        aiMaterialProperty* prop = mProperties[i];

        if (prop /* just for safety */ && !strcmp( prop->mKey.data, pKey ) &&
            prop->mSemantic == type && prop->mIndex == index){

            delete mProperties[i];
            iOutIndex = i;
        }
    }

    // Allocate a new material property
    aiMaterialProperty* pcNew = new aiMaterialProperty();

    // .. and fill it
    pcNew->mType = pType;
    pcNew->mSemantic = type;
    pcNew->mIndex = index;

    pcNew->mDataLength = pSizeInBytes;
    pcNew->mData = new char[pSizeInBytes];
    memcpy (pcNew->mData,pInput,pSizeInBytes);

    pcNew->mKey.length = ::strlen(pKey);
    ai_assert ( MAXLEN > pcNew->mKey.length);
    strcpy( pcNew->mKey.data, pKey );

    if (UINT_MAX != iOutIndex)  {
        mProperties[iOutIndex] = pcNew;
        return AI_SUCCESS;
    }

    // resize the array ... double the storage allocated
    if (mNumProperties == mNumAllocated)    {
        const unsigned int iOld = mNumAllocated;
        mNumAllocated *= 2;

        aiMaterialProperty** ppTemp;
        try {
            ppTemp = new aiMaterialProperty*[mNumAllocated];
        } catch (std::bad_alloc&) {
            delete pcNew;
            return AI_OUTOFMEMORY;
        }

        // just copy all items over; then replace the old array
        memcpy (ppTemp,mProperties,iOld * sizeof(void*));

        delete[] mProperties;
        mProperties = ppTemp;
    }
    // push back ...
    mProperties[mNumProperties++] = pcNew;
    return AI_SUCCESS;
}

// ------------------------------------------------------------------------------------------------
aiReturn aiMaterial::AddProperty (const aiString* pInput,
    const char* pKey,
    unsigned int type,
    unsigned int index)
{
    // We don't want to add the whole buffer .. write a 32 bit length
    // prefix followed by the zero-terminated UTF8 string.
    // (HACK) I don't want to break the ABI now, but we definitely
    // ought to change aiString::mLength to uint32_t one day.
    if (sizeof(size_t) == 8) {
        aiString copy = *pInput;
        uint32_t* s = reinterpret_cast<uint32_t*>(&copy.length);
        s[1] = static_cast<uint32_t>(pInput->length);

        return AddBinaryProperty(s+1,
            pInput->length+1+4,
            pKey,
            type,
            index,
            aiPTI_String);
    }
    ai_assert(sizeof(size_t)==4);
    return AddBinaryProperty(pInput,
        pInput->length+1+4,
        pKey,
        type,
        index,
        aiPTI_String);
}

// ------------------------------------------------------------------------------------------------
uint32_t Assimp :: ComputeMaterialHash(const aiMaterial* mat, bool includeMatName /*= false*/)
{
    uint32_t hash = 1503; // magic start value, chosen to be my birthday :-)
    for (unsigned int i = 0; i < mat->mNumProperties;++i)   {
        aiMaterialProperty* prop;

        // Exclude all properties whose first character is '?' from the hash
        // See doc for aiMaterialProperty.
        if ((prop = mat->mProperties[i]) && (includeMatName || prop->mKey.data[0] != '?'))  {

            hash = SuperFastHash(prop->mKey.data,(unsigned int)prop->mKey.length,hash);
            hash = SuperFastHash(prop->mData,prop->mDataLength,hash);

            // Combine the semantic and the index with the hash
            hash = SuperFastHash((const char*)&prop->mSemantic,sizeof(unsigned int),hash);
            hash = SuperFastHash((const char*)&prop->mIndex,sizeof(unsigned int),hash);
        }
    }
    return hash;
}

// ------------------------------------------------------------------------------------------------
void aiMaterial::CopyPropertyList(aiMaterial* pcDest,
    const aiMaterial* pcSrc
    )
{
    ai_assert(NULL != pcDest);
    ai_assert(NULL != pcSrc);

    unsigned int iOldNum = pcDest->mNumProperties;
    pcDest->mNumAllocated += pcSrc->mNumAllocated;
    pcDest->mNumProperties += pcSrc->mNumProperties;

    aiMaterialProperty** pcOld = pcDest->mProperties;
    pcDest->mProperties = new aiMaterialProperty*[pcDest->mNumAllocated];

    if (iOldNum && pcOld)   {
        for (unsigned int i = 0; i < iOldNum;++i) {
            pcDest->mProperties[i] = pcOld[i];
        }
    }

    if(pcOld)
    	delete[] pcOld;

    for (unsigned int i = iOldNum; i< pcDest->mNumProperties;++i)   {
        aiMaterialProperty* propSrc = pcSrc->mProperties[i];

        // search whether we have already a property with this name -> if yes, overwrite it
        aiMaterialProperty* prop;
        for (unsigned int q = 0; q < iOldNum;++q) {
            prop = pcDest->mProperties[q];
            if (prop /* just for safety */ && prop->mKey == propSrc->mKey && prop->mSemantic == propSrc->mSemantic
                && prop->mIndex == propSrc->mIndex) {
                delete prop;

                // collapse the whole array ...
                memmove(&pcDest->mProperties[q],&pcDest->mProperties[q+1],i-q);
                i--;
                pcDest->mNumProperties--;
            }
        }

        // Allocate the output property and copy the source property
        prop = pcDest->mProperties[i] = new aiMaterialProperty();
        prop->mKey = propSrc->mKey;
        prop->mDataLength = propSrc->mDataLength;
        prop->mType = propSrc->mType;
        prop->mSemantic = propSrc->mSemantic;
        prop->mIndex = propSrc->mIndex;

        prop->mData = new char[propSrc->mDataLength];
        memcpy(prop->mData,propSrc->mData,prop->mDataLength);
    }
    return;
}

/***********************************************************************
FBXIMPORT\OPTIMIZEGRAPH.CPP
***********************************************************************/
/*
---------------------------------------------------------------------------
Open Asset Import Library (assimp)
---------------------------------------------------------------------------

Copyright (c) 2006-2016, assimp team

All rights reserved.

Redistribution and use of this software in source and binary forms,
with or without modification, are permitted provided that the following
conditions are met:

* Redistributions of source code must retain the above
  copyright notice, this list of conditions and the
  following disclaimer.

* Redistributions in binary form must reproduce the above
  copyright notice, this list of conditions and the
  following disclaimer in the documentation and/or other
  materials provided with the distribution.

* Neither the name of the assimp team, nor the names of its
  contributors may be used to endorse or promote products
  derived from this software without specific prior
  written permission of the assimp team.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
"AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
---------------------------------------------------------------------------
*/

/** @file  OptimizeGraph.cpp
 *  @brief Implementation of the aiProcess_OptimizGraph step
 */


#ifndef ASSIMP_BUILD_NO_OPTIMIZEGRAPH_PROCESS


using namespace Assimp;

#define AI_RESERVED_NODE_NAME "$Reserved_And_Evil"

/* AI_OG_USE_HASHING enables the use of hashing to speed-up std::set lookups.
 * The unhashed variant should be faster, except for *very* large data sets
 */
#ifdef AI_OG_USE_HASHING
    // Use our standard hashing function to compute the hash
#   define AI_OG_GETKEY(str) SuperFastHash(str.data,str.length)
#else
    // Otherwise hope that std::string will utilize a static buffer
    // for shorter node names. This would avoid endless heap copying.
#   define AI_OG_GETKEY(str) std::string(str.data)
#endif

// ------------------------------------------------------------------------------------------------
// Constructor to be privately used by Importer
OptimizeGraphProcess::OptimizeGraphProcess()
    : mScene()
    , nodes_in()
    , nodes_out()
    , count_merged()
{}

// ------------------------------------------------------------------------------------------------
// Destructor, private as well
OptimizeGraphProcess::~OptimizeGraphProcess()
{}

// ------------------------------------------------------------------------------------------------
// Returns whether the processing step is present in the given flag field.
bool OptimizeGraphProcess::IsActive( unsigned int pFlags) const
{
    return (0 != (pFlags & aiProcess_OptimizeGraph));
}

// ------------------------------------------------------------------------------------------------
// Setup properties for the postprocessing step
void OptimizeGraphProcess::SetupProperties(const Importer* pImp)
{
    // Get value of AI_CONFIG_PP_OG_EXCLUDE_LIST
    std::string tmp = pImp->GetPropertyString(AI_CONFIG_PP_OG_EXCLUDE_LIST,"");
    AddLockedNodeList(tmp);
}

// ------------------------------------------------------------------------------------------------
// Collect new children
void OptimizeGraphProcess::CollectNewChildren(aiNode* nd, std::list<aiNode*>& nodes)
{
    nodes_in += nd->mNumChildren;

    // Process children
    std::list<aiNode*> child_nodes;
    for (unsigned int i = 0; i < nd->mNumChildren; ++i) {

        CollectNewChildren(nd->mChildren[i],child_nodes);
        nd->mChildren[i] = NULL;
    }

    // Check whether we need this node; if not we can replace it by our own children (warn, danger of incest).
    if (locked.find(AI_OG_GETKEY(nd->mName)) == locked.end() ) {
        for (std::list<aiNode*>::iterator it = child_nodes.begin(); it != child_nodes.end();) {

            if (locked.find(AI_OG_GETKEY((*it)->mName)) == locked.end()) {
                (*it)->mTransformation = nd->mTransformation * (*it)->mTransformation;
                nodes.push_back(*it);

                it = child_nodes.erase(it);
                continue;
            }
            ++it;
        }

        if (nd->mNumMeshes || !child_nodes.empty()) {
            nodes.push_back(nd);
        }
        else {
            delete nd; /* bye, node */
            return;
        }
    }
    else {

        // Retain our current position in the hierarchy
        nodes.push_back(nd);

        // Now check for possible optimizations in our list of child nodes. join as many as possible
        aiNode* join_master = NULL;
        aiMatrix4x4 inv;

        const LockedSetType::const_iterator end = locked.end();

        std::list<aiNode*> join;
        for (std::list<aiNode*>::iterator it = child_nodes.begin(); it != child_nodes.end();)   {
            aiNode* child = *it;
            if (child->mNumChildren == 0 && locked.find(AI_OG_GETKEY(child->mName)) == end) {

                // There may be no instanced meshes
                unsigned int n = 0;
                for (; n < child->mNumMeshes;++n) {
                    if (meshes[child->mMeshes[n]] > 1) {
                        break;
                    }
                }
                if (n == child->mNumMeshes) {

                    if (!join_master) {
                        join_master = child;
                        inv = join_master->mTransformation;
                        inv.Inverse();
                    }
                    else {

                        child->mTransformation = inv * child->mTransformation ;

                        join.push_back(child);
                        it = child_nodes.erase(it);
                        continue;
                    }
                }
            }
            ++it;
        }
        if (join_master && !join.empty()) {
            join_master->mName.length = ::ai_snprintf(join_master->mName.data, MAXLEN, "$MergedNode_%i",count_merged++);

            unsigned int out_meshes = 0;
            for (std::list<aiNode*>::iterator it = join.begin(); it != join.end(); ++it) {
                out_meshes += (*it)->mNumMeshes;
            }

            // copy all mesh references in one array
            if (out_meshes) {
                unsigned int* meshes = new unsigned int[out_meshes+join_master->mNumMeshes], *tmp = meshes;
                for (unsigned int n = 0; n < join_master->mNumMeshes;++n) {
                    *tmp++ = join_master->mMeshes[n];
                }

                for (std::list<aiNode*>::iterator it = join.begin(); it != join.end(); ++it) {
                    for (unsigned int n = 0; n < (*it)->mNumMeshes; ++n) {

                        *tmp = (*it)->mMeshes[n];
                        aiMesh* mesh = mScene->mMeshes[*tmp++];

                        // manually move the mesh into the right coordinate system
                        const aiMatrix3x3 IT = aiMatrix3x3( (*it)->mTransformation ).Inverse().Transpose();
                        for (unsigned int a = 0; a < mesh->mNumVertices; ++a) {

                            mesh->mVertices[a] *= (*it)->mTransformation;

                            if (mesh->HasNormals())
                                mesh->mNormals[a] *= IT;

                            if (mesh->HasTangentsAndBitangents()) {
                                mesh->mTangents[a] *= IT;
                                mesh->mBitangents[a] *= IT;
                            }
                        }
                    }
                    delete *it; // bye, node
                }
                delete[] join_master->mMeshes;
                join_master->mMeshes = meshes;
                join_master->mNumMeshes += out_meshes;
            }
        }
    }
    // reassign children if something changed
    if (child_nodes.empty() || child_nodes.size() > nd->mNumChildren) {

        delete[] nd->mChildren;

        if (!child_nodes.empty())
            nd->mChildren = new aiNode*[child_nodes.size()];
        else nd->mChildren = NULL;
    }

    nd->mNumChildren = child_nodes.size();

    aiNode** tmp = nd->mChildren;
    for (std::list<aiNode*>::iterator it = child_nodes.begin(); it != child_nodes.end(); ++it) {
        aiNode* node = *tmp++ = *it;
        node->mParent = nd;
    }

    nodes_out += child_nodes.size();
}

// ------------------------------------------------------------------------------------------------
// Execute the postprocessing step on the given scene
void OptimizeGraphProcess::Execute( aiScene* pScene)
{
    DefaultLogger::get()->debug("OptimizeGraphProcess begin");
    nodes_in = nodes_out = count_merged = 0;
    mScene = pScene;

    meshes.resize(pScene->mNumMeshes,0);
    FindInstancedMeshes(pScene->mRootNode);

    // build a blacklist of identifiers. If the name of a node matches one of these, we won't touch it
    locked.clear();
    for (std::list<std::string>::const_iterator it = locked_nodes.begin(); it != locked_nodes.end(); ++it) {
#ifdef AI_OG_USE_HASHING
        locked.insert(SuperFastHash((*it).c_str()));
#else
        locked.insert(*it);
#endif
    }

    for (unsigned int i = 0; i < pScene->mNumAnimations; ++i) {
        for (unsigned int a = 0; a < pScene->mAnimations[i]->mNumChannels; ++a) {

            aiNodeAnim* anim = pScene->mAnimations[i]->mChannels[a];
            locked.insert(AI_OG_GETKEY(anim->mNodeName));
        }
    }

    for (unsigned int i = 0; i < pScene->mNumMeshes; ++i) {
        for (unsigned int a = 0; a < pScene->mMeshes[i]->mNumBones; ++a) {

            aiBone* bone = pScene->mMeshes[i]->mBones[a];
            locked.insert(AI_OG_GETKEY(bone->mName));

            // HACK: Meshes referencing bones may not be transformed; we need to look them.
            // The easiest way to do this is to increase their reference counters ...
            meshes[i] += 2;
        }
    }

    for (unsigned int i = 0; i < pScene->mNumCameras; ++i) {
        aiCamera* cam = pScene->mCameras[i];
        locked.insert(AI_OG_GETKEY(cam->mName));
    }

    for (unsigned int i = 0; i < pScene->mNumLights; ++i) {
        aiLight* lgh = pScene->mLights[i];
        locked.insert(AI_OG_GETKEY(lgh->mName));
    }

    // Insert a dummy master node and make it read-only
    aiNode* dummy_root = new aiNode(AI_RESERVED_NODE_NAME);
    locked.insert(AI_OG_GETKEY(dummy_root->mName));

    const aiString prev = pScene->mRootNode->mName;
    pScene->mRootNode->mParent = dummy_root;

    dummy_root->mChildren = new aiNode*[dummy_root->mNumChildren = 1];
    dummy_root->mChildren[0] = pScene->mRootNode;

    // Do our recursive processing of scenegraph nodes. For each node collect
    // a fully new list of children and allow their children to place themselves
    // on the same hierarchy layer as their parents.
    std::list<aiNode*> nodes;
    CollectNewChildren (dummy_root,nodes);

    ai_assert(nodes.size() == 1);

    if (dummy_root->mNumChildren == 0) {
        pScene->mRootNode = NULL;
        throw DeadlyImportError("After optimizing the scene graph, no data remains");
    }

    if (dummy_root->mNumChildren > 1) {
        pScene->mRootNode = dummy_root;

        // Keep the dummy node but assign the name of the old root node to it
        pScene->mRootNode->mName = prev;
    }
    else {

        // Remove the dummy root node again.
        pScene->mRootNode = dummy_root->mChildren[0];

        dummy_root->mChildren[0] = NULL;
        delete dummy_root;
    }

    pScene->mRootNode->mParent = NULL;
    if (!DefaultLogger::isNullLogger()) {
        if ( nodes_in != nodes_out) {

            char buf[512];
            ::ai_snprintf(buf,512,"OptimizeGraphProcess finished; Input nodes: %u, Output nodes: %u",nodes_in,nodes_out);
            DefaultLogger::get()->info(buf);
        }
        else DefaultLogger::get()->debug("OptimizeGraphProcess finished");
    }
    meshes.clear();
    locked.clear();
}

// ------------------------------------------------------------------------------------------------
// Buidl a LUT of all instanced meshes
void OptimizeGraphProcess::FindInstancedMeshes (aiNode* pNode)
{
    for (unsigned int i = 0; i < pNode->mNumMeshes;++i) {
        ++meshes[pNode->mMeshes[i]];
    }

    for (unsigned int i = 0; i < pNode->mNumChildren; ++i)
        FindInstancedMeshes(pNode->mChildren[i]);
}

#endif // !! ASSIMP_BUILD_NO_OPTIMIZEGRAPH_PROCESS

/***********************************************************************
FBXIMPORT\OPTIMIZEMESHES.CPP
***********************************************************************/
/*
---------------------------------------------------------------------------
Open Asset Import Library (assimp)
---------------------------------------------------------------------------

Copyright (c) 2006-2016, assimp team

All rights reserved.

Redistribution and use of this software in source and binary forms,
with or without modification, are permitted provided that the following
conditions are met:

* Redistributions of source code must retain the above
  copyright notice, this list of conditions and the
  following disclaimer.

* Redistributions in binary form must reproduce the above
  copyright notice, this list of conditions and the
  following disclaimer in the documentation and/or other
  materials provided with the distribution.

* Neither the name of the assimp team, nor the names of its
  contributors may be used to endorse or promote products
  derived from this software without specific prior
  written permission of the assimp team.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
"AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
---------------------------------------------------------------------------
*/

/** @file  OptimizeMeshes.cpp
 *  @brief Implementation of the aiProcess_OptimizeMeshes step
 */


#ifndef ASSIMP_BUILD_NO_OPTIMIZEMESHES_PROCESS



using namespace Assimp;

static const unsigned int NotSet   = 0xffffffff;
static const unsigned int DeadBeef = 0xdeadbeef;

// ------------------------------------------------------------------------------------------------
// Constructor to be privately used by Importer
OptimizeMeshesProcess::OptimizeMeshesProcess()
    : mScene()
    , pts(false)
    , max_verts( NotSet )
    , max_faces( NotSet ) {
    // empty
}

// ------------------------------------------------------------------------------------------------
// Destructor, private as well
OptimizeMeshesProcess::~OptimizeMeshesProcess() {
    // empty
}

// ------------------------------------------------------------------------------------------------
// Returns whether the processing step is present in the given flag field.
bool OptimizeMeshesProcess::IsActive( unsigned int pFlags) const
{
    // Our behaviour needs to be different if the SortByPType or SplitLargeMeshes
    // steps are active. Thus we need to query their flags here and store the
    // information, although we're breaking const-correctness.
    // That's a serious design flaw, consider redesign.
    if( 0 != (pFlags & aiProcess_OptimizeMeshes) ) {
        pts = (0 != (pFlags & aiProcess_SortByPType));
        max_verts = ( 0 != ( pFlags & aiProcess_SplitLargeMeshes ) ) ? DeadBeef : max_verts;
        return true;
    }
    return false;
}

// ------------------------------------------------------------------------------------------------
// Setup properties for the post-processing step
void OptimizeMeshesProcess::SetupProperties(const Importer* pImp)
{
    if( max_verts == DeadBeef /* magic hack */ ) {
        max_faces = pImp->GetPropertyInteger(AI_CONFIG_PP_SLM_TRIANGLE_LIMIT,AI_SLM_DEFAULT_MAX_TRIANGLES);
        max_verts = pImp->GetPropertyInteger(AI_CONFIG_PP_SLM_VERTEX_LIMIT,AI_SLM_DEFAULT_MAX_VERTICES);
    }
}

// ------------------------------------------------------------------------------------------------
// Execute step
void OptimizeMeshesProcess::Execute( aiScene* pScene)
{
    const unsigned int num_old = pScene->mNumMeshes;
    if (num_old <= 1) {
        DefaultLogger::get()->debug("Skipping OptimizeMeshesProcess");
        return;
    }

    DefaultLogger::get()->debug("OptimizeMeshesProcess begin");
    mScene = pScene;

    // need to clear persistent members from previous runs
    merge_list.resize( 0 );
    output.resize( 0 );

    // ensure we have the right sizes
    merge_list.reserve(pScene->mNumMeshes);
    output.reserve(pScene->mNumMeshes);

    // Prepare lookup tables
    meshes.resize(pScene->mNumMeshes);
    FindInstancedMeshes(pScene->mRootNode);
    if( max_verts == DeadBeef ) /* undo the magic hack */
        max_verts = NotSet;

    // ... instanced meshes are immediately processed and added to the output list
    for (unsigned int i = 0, n = 0; i < pScene->mNumMeshes;++i) {
        meshes[i].vertex_format = GetMeshVFormatUnique(pScene->mMeshes[i]);

        if (meshes[i].instance_cnt > 1 && meshes[i].output_id == NotSet ) {
            meshes[i].output_id = n++;
            output.push_back(mScene->mMeshes[i]);
        }
    }

    // and process all nodes in the scenegraph recursively
    ProcessNode(pScene->mRootNode);
    if (!output.size()) {
        throw DeadlyImportError("OptimizeMeshes: No meshes remaining; there's definitely something wrong");
    }

    meshes.resize( 0 );
    ai_assert(output.size() <= num_old);

    mScene->mNumMeshes = output.size();
    std::copy(output.begin(),output.end(),mScene->mMeshes);

    if (output.size() != num_old) {
        char tmp[512];
        ::ai_snprintf(tmp,512,"OptimizeMeshesProcess finished. Input meshes: %u, Output meshes: %u",num_old,pScene->mNumMeshes);
        DefaultLogger::get()->info(tmp);
    } else {
        DefaultLogger::get()->debug( "OptimizeMeshesProcess finished" );
    }
}

// ------------------------------------------------------------------------------------------------
// Process meshes for a single node
void OptimizeMeshesProcess::ProcessNode( aiNode* pNode)
{
    for (unsigned int i = 0; i < pNode->mNumMeshes;++i) {
        unsigned int& im = pNode->mMeshes[i];

        if (meshes[im].instance_cnt > 1) {
            im = meshes[im].output_id;
        }
        else  {
            merge_list.resize( 0 );
            unsigned int verts = 0, faces = 0;

            // Find meshes to merge with us
            for (unsigned int a = i+1; a < pNode->mNumMeshes;++a) {
                unsigned int am = pNode->mMeshes[a];
                if (meshes[am].instance_cnt == 1 && CanJoin(im,am,verts,faces)) {

                    merge_list.push_back(mScene->mMeshes[am]);
                    verts += mScene->mMeshes[am]->mNumVertices;
                    faces += mScene->mMeshes[am]->mNumFaces;

                    --pNode->mNumMeshes;
                    for( unsigned int n = a; n < pNode->mNumMeshes; ++n ) {
                        pNode->mMeshes[ n ] = pNode->mMeshes[ n + 1 ];
                    }

                    --a;
                }
            }

            // and merge all meshes which we found, replace the old ones
            if (!merge_list.empty()) {
                merge_list.push_back(mScene->mMeshes[im]);

                aiMesh* out;
                SceneCombiner::MergeMeshes(&out,0,merge_list.begin(),merge_list.end());
                output.push_back(out);
            } else {
                output.push_back(mScene->mMeshes[im]);
            }
            im = output.size()-1;
        }
    }


    for( unsigned int i = 0; i < pNode->mNumChildren; ++i ) {
        ProcessNode( pNode->mChildren[ i ] );
    }
}

// ------------------------------------------------------------------------------------------------
// Check whether two meshes can be joined
bool OptimizeMeshesProcess::CanJoin ( unsigned int a, unsigned int b, unsigned int verts, unsigned int faces )
{
    if (meshes[a].vertex_format != meshes[b].vertex_format)
        return false;

    aiMesh* ma = mScene->mMeshes[a], *mb = mScene->mMeshes[b];

    if ((NotSet != max_verts && verts+mb->mNumVertices > max_verts) ||
        (NotSet != max_faces && faces+mb->mNumFaces    > max_faces)) {
        return false;
    }

    // Never merge unskinned meshes with skinned meshes
    if (ma->mMaterialIndex != mb->mMaterialIndex || ma->HasBones() != mb->HasBones())
        return false;

    // Never merge meshes with different kinds of primitives if SortByPType did already
    // do its work. We would destroy everything again ...
    if (pts && ma->mPrimitiveTypes != mb->mPrimitiveTypes)
        return false;

    // If both meshes are skinned, check whether we have many bones defined in both meshes.
    // If yes, we can join them.
    if (ma->HasBones()) {
        // TODO
        return false;
    }
    return true;
}

// ------------------------------------------------------------------------------------------------
// Build a LUT of all instanced meshes
void OptimizeMeshesProcess::FindInstancedMeshes (aiNode* pNode)
{
    for( unsigned int i = 0; i < pNode->mNumMeshes; ++i ) {
        ++meshes[ pNode->mMeshes[ i ] ].instance_cnt;
    }

    for( unsigned int i = 0; i < pNode->mNumChildren; ++i ) {
        FindInstancedMeshes( pNode->mChildren[ i ] );
    }
}

// ------------------------------------------------------------------------------------------------

#endif // !! ASSIMP_BUILD_NO_OPTIMIZEMESHES_PROCESS

/***********************************************************************
FBXIMPORT\POSTSTEPREGISTRY.CPP
***********************************************************************/
/*
---------------------------------------------------------------------------
Open Asset Import Library (assimp)
---------------------------------------------------------------------------

Copyright (c) 2006-2016, assimp team

All rights reserved.

Redistribution and use of this software in source and binary forms,
with or without modification, are permitted provided that the following
conditions are met:

* Redistributions of source code must retain the above
  copyright notice, this list of conditions and the
  following disclaimer.

* Redistributions in binary form must reproduce the above
  copyright notice, this list of conditions and the
  following disclaimer in the documentation and/or other
  materials provided with the distribution.

* Neither the name of the assimp team, nor the names of its
  contributors may be used to endorse or promote products
  derived from this software without specific prior
  written permission of the assimp team.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
"AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
---------------------------------------------------------------------------
*/

/** @file ImporterRegistry.cpp

Central registry for all postprocessing steps available. Do not edit this file
directly (unless you are adding new steps), instead use the
corresponding preprocessor flag to selectively disable steps.
*/


#ifndef ASSIMP_BUILD_NO_CALCTANGENTS_PROCESS
#   include "CalcTangentsProcess.h"
#endif
#ifndef ASSIMP_BUILD_NO_JOINVERTICES_PROCESS
#   include "JoinVerticesProcess.h"
#endif
#if !(defined ASSIMP_BUILD_NO_MAKELEFTHANDED_PROCESS && defined ASSIMP_BUILD_NO_FLIPUVS_PROCESS && defined ASSIMP_BUILD_NO_FLIPWINDINGORDER_PROCESS)
#   include "ConvertToLHProcess.h"
#endif
#ifndef ASSIMP_BUILD_NO_TRIANGULATE_PROCESS
#   include "TriangulateProcess.h"
#endif
#ifndef ASSIMP_BUILD_NO_GENFACENORMALS_PROCESS
#   include "GenFaceNormalsProcess.h"
#endif
#ifndef ASSIMP_BUILD_NO_GENVERTEXNORMALS_PROCESS
#   include "GenVertexNormalsProcess.h"
#endif
#ifndef ASSIMP_BUILD_NO_REMOVEVC_PROCESS
#   include "RemoveVCProcess.h"
#endif
#ifndef ASSIMP_BUILD_NO_SPLITLARGEMESHES_PROCESS
#   include "SplitLargeMeshes.h"
#endif
#ifndef ASSIMP_BUILD_NO_PRETRANSFORMVERTICES_PROCESS
#   include "PretransformVertices.h"
#endif
#ifndef ASSIMP_BUILD_NO_LIMITBONEWEIGHTS_PROCESS
#   include "LimitBoneWeightsProcess.h"
#endif
#ifndef ASSIMP_BUILD_NO_VALIDATEDS_PROCESS
#   include "ValidateDataStructure.h"
#endif
#ifndef ASSIMP_BUILD_NO_IMPROVECACHELOCALITY_PROCESS
#   include "ImproveCacheLocality.h"
#endif
#ifndef ASSIMP_BUILD_NO_FIXINFACINGNORMALS_PROCESS
#   include "FixNormalsStep.h"
#endif
#ifndef ASSIMP_BUILD_NO_REMOVE_REDUNDANTMATERIALS_PROCESS
#   include "RemoveRedundantMaterials.h"
#endif
#ifndef ASSIMP_BUILD_NO_FINDINVALIDDATA_PROCESS
#   include "FindInvalidDataProcess.h"
#endif
#ifndef ASSIMP_BUILD_NO_FINDDEGENERATES_PROCESS
#   include "FindDegenerates.h"
#endif
#ifndef ASSIMP_BUILD_NO_SORTBYPTYPE_PROCESS
#   include "SortByPTypeProcess.h"
#endif
#ifndef ASSIMP_BUILD_NO_GENUVCOORDS_PROCESS
#   include "ComputeUVMappingProcess.h"
#endif
#ifndef ASSIMP_BUILD_NO_TRANSFORMTEXCOORDS_PROCESS
#   include "TextureTransform.h"
#endif
#ifndef ASSIMP_BUILD_NO_FINDINSTANCES_PROCESS
#   include "FindInstancesProcess.h"
#endif
#ifndef ASSIMP_BUILD_NO_OPTIMIZEMESHES_PROCESS
#   include "OptimizeMeshes.h"
#endif
#ifndef ASSIMP_BUILD_NO_OPTIMIZEGRAPH_PROCESS
#   include "OptimizeGraph.h"
#endif
#ifndef ASSIMP_BUILD_NO_SPLITBYBONECOUNT_PROCESS
#   include "SplitByBoneCountProcess.h"
#endif
#ifndef ASSIMP_BUILD_NO_DEBONE_PROCESS
#   include "DeboneProcess.h"
#endif

namespace Assimp {

// ------------------------------------------------------------------------------------------------
void GetPostProcessingStepInstanceList(std::vector< BaseProcess* >& out)
{
    // ----------------------------------------------------------------------------
    // Add an instance of each post processing step here in the order
    // of sequence it is executed. Steps that are added here are not
    // validated - as RegisterPPStep() does - all dependencies must be given.
    // ----------------------------------------------------------------------------
    out.reserve(25);
#if (!defined ASSIMP_BUILD_NO_MAKELEFTHANDED_PROCESS)
    out.push_back( new MakeLeftHandedProcess());
#endif
#if (!defined ASSIMP_BUILD_NO_FLIPUVS_PROCESS)
    out.push_back( new FlipUVsProcess());
#endif
#if (!defined ASSIMP_BUILD_NO_FLIPWINDINGORDER_PROCESS)
    out.push_back( new FlipWindingOrderProcess());
#endif
#if (!defined ASSIMP_BUILD_NO_REMOVEVC_PROCESS)
    out.push_back( new RemoveVCProcess());
#endif
#if (!defined ASSIMP_BUILD_NO_REMOVE_REDUNDANTMATERIALS_PROCESS)
    out.push_back( new RemoveRedundantMatsProcess());
#endif
#if (!defined ASSIMP_BUILD_NO_FINDINSTANCES_PROCESS)
    out.push_back( new FindInstancesProcess());
#endif
#if (!defined ASSIMP_BUILD_NO_OPTIMIZEGRAPH_PROCESS)
    out.push_back( new OptimizeGraphProcess());
#endif
#if (!defined ASSIMP_BUILD_NO_FINDDEGENERATES_PROCESS)
    out.push_back( new FindDegeneratesProcess());
#endif
#ifndef ASSIMP_BUILD_NO_GENUVCOORDS_PROCESS
    out.push_back( new ComputeUVMappingProcess());
#endif
#ifndef ASSIMP_BUILD_NO_TRANSFORMTEXCOORDS_PROCESS
    out.push_back( new TextureTransformStep());
#endif
#if (!defined ASSIMP_BUILD_NO_PRETRANSFORMVERTICES_PROCESS)
    out.push_back( new PretransformVertices());
#endif
#if (!defined ASSIMP_BUILD_NO_TRIANGULATE_PROCESS)
    out.push_back( new TriangulateProcess());
#endif
#if (!defined ASSIMP_BUILD_NO_SORTBYPTYPE_PROCESS)
    out.push_back( new SortByPTypeProcess());
#endif
#if (!defined ASSIMP_BUILD_NO_FINDINVALIDDATA_PROCESS)
    out.push_back( new FindInvalidDataProcess());
#endif
#if (!defined ASSIMP_BUILD_NO_OPTIMIZEMESHES_PROCESS)
    out.push_back( new OptimizeMeshesProcess());
#endif
#if (!defined ASSIMP_BUILD_NO_FIXINFACINGNORMALS_PROCESS)
    out.push_back( new FixInfacingNormalsProcess());
#endif
#if (!defined ASSIMP_BUILD_NO_SPLITBYBONECOUNT_PROCESS)
    out.push_back( new SplitByBoneCountProcess());
#endif
#if (!defined ASSIMP_BUILD_NO_SPLITLARGEMESHES_PROCESS)
    out.push_back( new SplitLargeMeshesProcess_Triangle());
#endif
#if (!defined ASSIMP_BUILD_NO_GENFACENORMALS_PROCESS)
    out.push_back( new GenFaceNormalsProcess());
#endif

    // .........................................................................
    // DON'T change the order of these five ..
    // XXX this is actually a design weakness that dates back to the time
    // when Importer would maintain the postprocessing step list exclusively.
    // Now that others access it too, we need a better solution.
    out.push_back( new ComputeSpatialSortProcess());
    // .........................................................................

#if (!defined ASSIMP_BUILD_NO_GENVERTEXNORMALS_PROCESS)
    out.push_back( new GenVertexNormalsProcess());
#endif
#if (!defined ASSIMP_BUILD_NO_CALCTANGENTS_PROCESS)
    out.push_back( new CalcTangentsProcess());
#endif
#if (!defined ASSIMP_BUILD_NO_JOINVERTICES_PROCESS)
    out.push_back( new JoinVerticesProcess());
#endif

    // .........................................................................
    out.push_back( new DestroySpatialSortProcess());
    // .........................................................................

#if (!defined ASSIMP_BUILD_NO_SPLITLARGEMESHES_PROCESS)
    out.push_back( new SplitLargeMeshesProcess_Vertex());
#endif
#if (!defined ASSIMP_BUILD_NO_DEBONE_PROCESS)
    out.push_back( new DeboneProcess());
#endif
#if (!defined ASSIMP_BUILD_NO_LIMITBONEWEIGHTS_PROCESS)
    out.push_back( new LimitBoneWeightsProcess());
#endif
#if (!defined ASSIMP_BUILD_NO_IMPROVECACHELOCALITY_PROCESS)
    out.push_back( new ImproveCacheLocalityProcess());
#endif
}

}

/***********************************************************************
FBXIMPORT\PRETRANSFORMVERTICES.CPP
***********************************************************************/
/*
---------------------------------------------------------------------------
Open Asset Import Library (assimp)
---------------------------------------------------------------------------

Copyright (c) 2006-2016, assimp team

All rights reserved.

Redistribution and use of this software in source and binary forms,
with or without modification, are permitted provided that the following
conditions are met:

* Redistributions of source code must retain the above
  copyright notice, this list of conditions and the
  following disclaimer.

* Redistributions in binary form must reproduce the above
  copyright notice, this list of conditions and the
  following disclaimer in the documentation and/or other
  materials provided with the distribution.

* Neither the name of the assimp team, nor the names of its
  contributors may be used to endorse or promote products
  derived from this software without specific prior
  written permission of the assimp team.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
"AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
---------------------------------------------------------------------------
*/

/** @file PretransformVertices.cpp
 *  @brief Implementation of the "PretransformVertices" post processing step
*/



using namespace Assimp;

// some array offsets
#define AI_PTVS_VERTEX 0x0
#define AI_PTVS_FACE 0x1

// ------------------------------------------------------------------------------------------------
// Constructor to be privately used by Importer
PretransformVertices::PretransformVertices()
:   configKeepHierarchy (false), configNormalize(false), configTransform(false), configTransformation()
{
}

// ------------------------------------------------------------------------------------------------
// Destructor, private as well
PretransformVertices::~PretransformVertices()
{
    // nothing to do here
}

// ------------------------------------------------------------------------------------------------
// Returns whether the processing step is present in the given flag field.
bool PretransformVertices::IsActive( unsigned int pFlags) const
{
    return  (pFlags & aiProcess_PreTransformVertices) != 0;
}

// ------------------------------------------------------------------------------------------------
// Setup import configuration
void PretransformVertices::SetupProperties(const Importer* pImp)
{
    // Get the current value of AI_CONFIG_PP_PTV_KEEP_HIERARCHY, AI_CONFIG_PP_PTV_NORMALIZE,
    // AI_CONFIG_PP_PTV_ADD_ROOT_TRANSFORMATION and AI_CONFIG_PP_PTV_ROOT_TRANSFORMATION
    configKeepHierarchy = (0 != pImp->GetPropertyInteger(AI_CONFIG_PP_PTV_KEEP_HIERARCHY,0));
    configNormalize = (0 != pImp->GetPropertyInteger(AI_CONFIG_PP_PTV_NORMALIZE,0));
    configTransform = (0 != pImp->GetPropertyInteger(AI_CONFIG_PP_PTV_ADD_ROOT_TRANSFORMATION,0));

    configTransformation = pImp->GetPropertyMatrix(AI_CONFIG_PP_PTV_ROOT_TRANSFORMATION, aiMatrix4x4());
}

// ------------------------------------------------------------------------------------------------
// Count the number of nodes
unsigned int PretransformVertices::CountNodes( aiNode* pcNode )
{
    unsigned int iRet = 1;
    for (unsigned int i = 0;i < pcNode->mNumChildren;++i)
    {
        iRet += CountNodes(pcNode->mChildren[i]);
    }
    return iRet;
}

// ------------------------------------------------------------------------------------------------
// Get a bitwise combination identifying the vertex format of a mesh
unsigned int PretransformVertices::GetMeshVFormat(aiMesh* pcMesh)
{
    // the vertex format is stored in aiMesh::mBones for later retrieval.
    // there isn't a good reason to compute it a few hundred times
    // from scratch. The pointer is unused as animations are lost
    // during PretransformVertices.
    if (pcMesh->mBones)
        return (unsigned int)(uint64_t)pcMesh->mBones;


    const unsigned int iRet = GetMeshVFormatUnique(pcMesh);

    // store the value for later use
    pcMesh->mBones = (aiBone**)(uint64_t)iRet;
    return iRet;
}

// ------------------------------------------------------------------------------------------------
// Count the number of vertices in the whole scene and a given
// material index
void PretransformVertices::CountVerticesAndFaces( aiScene* pcScene, aiNode* pcNode, unsigned int iMat,
    unsigned int iVFormat, unsigned int* piFaces, unsigned int* piVertices)
{
    for (unsigned int i = 0; i < pcNode->mNumMeshes;++i)
    {
        aiMesh* pcMesh = pcScene->mMeshes[ pcNode->mMeshes[i] ];
        if (iMat == pcMesh->mMaterialIndex && iVFormat == GetMeshVFormat(pcMesh))
        {
            *piVertices += pcMesh->mNumVertices;
            *piFaces += pcMesh->mNumFaces;
        }
    }
    for (unsigned int i = 0;i < pcNode->mNumChildren;++i)
    {
        CountVerticesAndFaces(pcScene,pcNode->mChildren[i],iMat,
            iVFormat,piFaces,piVertices);
    }
}

// ------------------------------------------------------------------------------------------------
// Collect vertex/face data
void PretransformVertices::CollectData( aiScene* pcScene, aiNode* pcNode, unsigned int iMat,
    unsigned int iVFormat, aiMesh* pcMeshOut,
    unsigned int aiCurrent[2], unsigned int* num_refs)
{
    // No need to multiply if there's no transformation
    const bool identity = pcNode->mTransformation.IsIdentity();
    for (unsigned int i = 0; i < pcNode->mNumMeshes;++i)
    {
        aiMesh* pcMesh = pcScene->mMeshes[ pcNode->mMeshes[i] ];
        if (iMat == pcMesh->mMaterialIndex && iVFormat == GetMeshVFormat(pcMesh))
        {
            // Decrement mesh reference counter
            unsigned int& num_ref = num_refs[pcNode->mMeshes[i]];
            ai_assert(0 != num_ref);
            --num_ref;

            if (identity)   {
                // copy positions without modifying them
                ::memcpy(pcMeshOut->mVertices + aiCurrent[AI_PTVS_VERTEX],
                    pcMesh->mVertices,
                    pcMesh->mNumVertices * sizeof(aiVector3D));

                if (iVFormat & 0x2) {
                    // copy normals without modifying them
                    ::memcpy(pcMeshOut->mNormals + aiCurrent[AI_PTVS_VERTEX],
                        pcMesh->mNormals,
                        pcMesh->mNumVertices * sizeof(aiVector3D));
                }
                if (iVFormat & 0x4)
                {
                    // copy tangents without modifying them
                    ::memcpy(pcMeshOut->mTangents + aiCurrent[AI_PTVS_VERTEX],
                        pcMesh->mTangents,
                        pcMesh->mNumVertices * sizeof(aiVector3D));
                    // copy bitangents without modifying them
                    ::memcpy(pcMeshOut->mBitangents + aiCurrent[AI_PTVS_VERTEX],
                        pcMesh->mBitangents,
                        pcMesh->mNumVertices * sizeof(aiVector3D));
                }
            }
            else
            {
                // copy positions, transform them to worldspace
                for (unsigned int n = 0; n < pcMesh->mNumVertices;++n)  {
                    pcMeshOut->mVertices[aiCurrent[AI_PTVS_VERTEX]+n] = pcNode->mTransformation * pcMesh->mVertices[n];
                }
                aiMatrix4x4 mWorldIT = pcNode->mTransformation;
                mWorldIT.Inverse().Transpose();

                // TODO: implement Inverse() for aiMatrix3x3
                aiMatrix3x3 m = aiMatrix3x3(mWorldIT);

                if (iVFormat & 0x2)
                {
                    // copy normals, transform them to worldspace
                    for (unsigned int n = 0; n < pcMesh->mNumVertices;++n)  {
                        pcMeshOut->mNormals[aiCurrent[AI_PTVS_VERTEX]+n] =
                            (m * pcMesh->mNormals[n]).Normalize();
                    }
                }
                if (iVFormat & 0x4)
                {
                    // copy tangents and bitangents, transform them to worldspace
                    for (unsigned int n = 0; n < pcMesh->mNumVertices;++n)  {
                        pcMeshOut->mTangents  [aiCurrent[AI_PTVS_VERTEX]+n] = (m * pcMesh->mTangents[n]).Normalize();
                        pcMeshOut->mBitangents[aiCurrent[AI_PTVS_VERTEX]+n] = (m * pcMesh->mBitangents[n]).Normalize();
                    }
                }
            }
            unsigned int p = 0;
            while (iVFormat & (0x100 << p))
            {
                // copy texture coordinates
                memcpy(pcMeshOut->mTextureCoords[p] + aiCurrent[AI_PTVS_VERTEX],
                    pcMesh->mTextureCoords[p],
                    pcMesh->mNumVertices * sizeof(aiVector3D));
                ++p;
            }
            p = 0;
            while (iVFormat & (0x1000000 << p))
            {
                // copy vertex colors
                memcpy(pcMeshOut->mColors[p] + aiCurrent[AI_PTVS_VERTEX],
                    pcMesh->mColors[p],
                    pcMesh->mNumVertices * sizeof(aiColor4D));
                ++p;
            }
            // now we need to copy all faces. since we will delete the source mesh afterwards,
            // we don't need to reallocate the array of indices except if this mesh is
            // referenced multiple times.
            for (unsigned int planck = 0;planck < pcMesh->mNumFaces;++planck)
            {
                aiFace& f_src = pcMesh->mFaces[planck];
                aiFace& f_dst = pcMeshOut->mFaces[aiCurrent[AI_PTVS_FACE]+planck];

                const unsigned int num_idx = f_src.mNumIndices;

                f_dst.mNumIndices = num_idx;

                unsigned int* pi;
                if (!num_ref) { /* if last time the mesh is referenced -> no reallocation */
                    pi = f_dst.mIndices = f_src.mIndices;

                    // offset all vertex indices
                    for (unsigned int hahn = 0; hahn < num_idx;++hahn){
                        pi[hahn] += aiCurrent[AI_PTVS_VERTEX];
                    }
                }
                else {
                    pi = f_dst.mIndices = new unsigned int[num_idx];

                    // copy and offset all vertex indices
                    for (unsigned int hahn = 0; hahn < num_idx;++hahn){
                        pi[hahn] = f_src.mIndices[hahn] + aiCurrent[AI_PTVS_VERTEX];
                    }
                }

                // Update the mPrimitiveTypes member of the mesh
                switch (pcMesh->mFaces[planck].mNumIndices)
                {
                case 0x1:
                    pcMeshOut->mPrimitiveTypes |= aiPrimitiveType_POINT;
                    break;
                case 0x2:
                    pcMeshOut->mPrimitiveTypes |= aiPrimitiveType_LINE;
                    break;
                case 0x3:
                    pcMeshOut->mPrimitiveTypes |= aiPrimitiveType_TRIANGLE;
                    break;
                default:
                    pcMeshOut->mPrimitiveTypes |= aiPrimitiveType_POLYGON;
                    break;
                };
            }
            aiCurrent[AI_PTVS_VERTEX] += pcMesh->mNumVertices;
            aiCurrent[AI_PTVS_FACE]   += pcMesh->mNumFaces;
        }
    }

    // append all children of us
    for (unsigned int i = 0;i < pcNode->mNumChildren;++i) {
        CollectData(pcScene,pcNode->mChildren[i],iMat,
            iVFormat,pcMeshOut,aiCurrent,num_refs);
    }
}

// ------------------------------------------------------------------------------------------------
// Get a list of all vertex formats that occur for a given material index
// The output list contains duplicate elements
void PretransformVertices::GetVFormatList( aiScene* pcScene, unsigned int iMat,
    std::list<unsigned int>& aiOut)
{
    for (unsigned int i = 0; i < pcScene->mNumMeshes;++i)
    {
        aiMesh* pcMesh = pcScene->mMeshes[ i ];
        if (iMat == pcMesh->mMaterialIndex) {
            aiOut.push_back(GetMeshVFormat(pcMesh));
        }
    }
}

// ------------------------------------------------------------------------------------------------
// Compute the absolute transformation matrices of each node
void PretransformVertices::ComputeAbsoluteTransform( aiNode* pcNode )
{
    if (pcNode->mParent)    {
        pcNode->mTransformation = pcNode->mParent->mTransformation*pcNode->mTransformation;
    }

    for (unsigned int i = 0;i < pcNode->mNumChildren;++i)   {
        ComputeAbsoluteTransform(pcNode->mChildren[i]);
    }
}

// ------------------------------------------------------------------------------------------------
// Apply the node transformation to a mesh
void PretransformVertices::ApplyTransform(aiMesh* mesh, const aiMatrix4x4& mat)
{
    // Check whether we need to transform the coordinates at all
    if (!mat.IsIdentity()) {

        if (mesh->HasPositions()) {
            for (unsigned int i = 0; i < mesh->mNumVertices; ++i) {
                mesh->mVertices[i] = mat * mesh->mVertices[i];
            }
        }
        if (mesh->HasNormals() || mesh->HasTangentsAndBitangents()) {
            aiMatrix4x4 mWorldIT = mat;
            mWorldIT.Inverse().Transpose();

            // TODO: implement Inverse() for aiMatrix3x3
            aiMatrix3x3 m = aiMatrix3x3(mWorldIT);

            if (mesh->HasNormals()) {
                for (unsigned int i = 0; i < mesh->mNumVertices; ++i) {
                    mesh->mNormals[i] = (m * mesh->mNormals[i]).Normalize();
                }
            }
            if (mesh->HasTangentsAndBitangents()) {
                for (unsigned int i = 0; i < mesh->mNumVertices; ++i) {
                    mesh->mTangents[i]   = (m * mesh->mTangents[i]).Normalize();
                    mesh->mBitangents[i] = (m * mesh->mBitangents[i]).Normalize();
                }
            }
        }
    }
}

// ------------------------------------------------------------------------------------------------
// Simple routine to build meshes in worldspace, no further optimization
void PretransformVertices::BuildWCSMeshes(std::vector<aiMesh*>& out, aiMesh** in,
    unsigned int numIn, aiNode* node)
{
    // NOTE:
    //  aiMesh::mNumBones store original source mesh, or UINT_MAX if not a copy
    //  aiMesh::mBones store reference to abs. transform we multiplied with

    // process meshes
    for (unsigned int i = 0; i < node->mNumMeshes;++i) {
        aiMesh* mesh = in[node->mMeshes[i]];

        // check whether we can operate on this mesh
        if (!mesh->mBones || *reinterpret_cast<aiMatrix4x4*>(mesh->mBones) == node->mTransformation) {
            // yes, we can.
            mesh->mBones = reinterpret_cast<aiBone**> (&node->mTransformation);
            mesh->mNumBones = UINT_MAX;
        }
        else {

            // try to find us in the list of newly created meshes
            for (unsigned int n = 0; n < out.size(); ++n) {
                aiMesh* ctz = out[n];
                if (ctz->mNumBones == node->mMeshes[i] && *reinterpret_cast<aiMatrix4x4*>(ctz->mBones) ==  node->mTransformation) {

                    // ok, use this one. Update node mesh index
                    node->mMeshes[i] = numIn + n;
                }
            }
            if (node->mMeshes[i] < numIn) {
                // Worst case. Need to operate on a full copy of the mesh
                DefaultLogger::get()->info("PretransformVertices: Copying mesh due to mismatching transforms");
                aiMesh* ntz;

                const unsigned int tmp = mesh->mNumBones; //
                mesh->mNumBones = 0;
                SceneCombiner::Copy(&ntz,mesh);
                mesh->mNumBones = tmp;

                ntz->mNumBones = node->mMeshes[i];
                ntz->mBones = reinterpret_cast<aiBone**> (&node->mTransformation);

                out.push_back(ntz);

                node->mMeshes[i] = numIn + out.size() - 1;
            }
        }
    }

    // call children
    for (unsigned int i = 0; i < node->mNumChildren;++i)
        BuildWCSMeshes(out,in,numIn,node->mChildren[i]);
}

// ------------------------------------------------------------------------------------------------
// Reset transformation matrices to identity
void PretransformVertices::MakeIdentityTransform(aiNode* nd)
{
    nd->mTransformation = aiMatrix4x4();

    // call children
    for (unsigned int i = 0; i < nd->mNumChildren;++i)
        MakeIdentityTransform(nd->mChildren[i]);
}

// ------------------------------------------------------------------------------------------------
// Build reference counters for all meshes
void PretransformVertices::BuildMeshRefCountArray(aiNode* nd, unsigned int * refs)
{
    for (unsigned int i = 0; i< nd->mNumMeshes;++i)
        refs[nd->mMeshes[i]]++;

    // call children
    for (unsigned int i = 0; i < nd->mNumChildren;++i)
        BuildMeshRefCountArray(nd->mChildren[i],refs);
}

// ------------------------------------------------------------------------------------------------
// Executes the post processing step on the given imported data.
void PretransformVertices::Execute( aiScene* pScene)
{
    DefaultLogger::get()->debug("PretransformVerticesProcess begin");

    // Return immediately if we have no meshes
    if (!pScene->mNumMeshes)
        return;

    const unsigned int iOldMeshes = pScene->mNumMeshes;
    const unsigned int iOldAnimationChannels = pScene->mNumAnimations;
    const unsigned int iOldNodes = CountNodes(pScene->mRootNode);

    if(configTransform) {
        pScene->mRootNode->mTransformation = configTransformation;
    }

    // first compute absolute transformation matrices for all nodes
    ComputeAbsoluteTransform(pScene->mRootNode);

    // Delete aiMesh::mBones for all meshes. The bones are
    // removed during this step and we need the pointer as
    // temporary storage
    for (unsigned int i = 0; i < pScene->mNumMeshes;++i)    {
        aiMesh* mesh = pScene->mMeshes[i];

        for (unsigned int a = 0; a < mesh->mNumBones;++a)
            delete mesh->mBones[a];

        delete[] mesh->mBones;
        mesh->mBones = NULL;
    }

    // now build a list of output meshes
    std::vector<aiMesh*> apcOutMeshes;

    // Keep scene hierarchy? It's an easy job in this case ...
    // we go on and transform all meshes, if one is referenced by nodes
    // with different absolute transformations a depth copy of the mesh
    // is required.
    if( configKeepHierarchy ) {

        // Hack: store the matrix we're transforming a mesh with in aiMesh::mBones
        BuildWCSMeshes(apcOutMeshes,pScene->mMeshes,pScene->mNumMeshes, pScene->mRootNode);

        // ... if new meshes have been generated, append them to the end of the scene
        if (apcOutMeshes.size() > 0) {
            aiMesh** npp = new aiMesh*[pScene->mNumMeshes + apcOutMeshes.size()];

            memcpy(npp,pScene->mMeshes,sizeof(aiMesh*)*pScene->mNumMeshes);
            memcpy(npp+pScene->mNumMeshes,&apcOutMeshes[0],sizeof(aiMesh*)*apcOutMeshes.size());

            pScene->mNumMeshes  += apcOutMeshes.size();
            delete[] pScene->mMeshes; pScene->mMeshes = npp;
        }

        // now iterate through all meshes and transform them to worldspace
        for (unsigned int i = 0; i < pScene->mNumMeshes; ++i) {
            ApplyTransform(pScene->mMeshes[i],*reinterpret_cast<aiMatrix4x4*>( pScene->mMeshes[i]->mBones ));

            // prevent improper destruction
            pScene->mMeshes[i]->mBones    = NULL;
            pScene->mMeshes[i]->mNumBones = 0;
        }
    }
    else {

        apcOutMeshes.reserve(pScene->mNumMaterials<<1u);
        std::list<unsigned int> aiVFormats;

        std::vector<unsigned int> s(pScene->mNumMeshes,0);
        BuildMeshRefCountArray(pScene->mRootNode,&s[0]);

        for (unsigned int i = 0; i < pScene->mNumMaterials;++i)     {
            // get the list of all vertex formats for this material
            aiVFormats.clear();
            GetVFormatList(pScene,i,aiVFormats);
            aiVFormats.sort();
            aiVFormats.unique();
            for (std::list<unsigned int>::const_iterator j =  aiVFormats.begin();j != aiVFormats.end();++j) {
                unsigned int iVertices = 0;
                unsigned int iFaces = 0;
                CountVerticesAndFaces(pScene,pScene->mRootNode,i,*j,&iFaces,&iVertices);
                if (0 != iFaces && 0 != iVertices)
                {
                    apcOutMeshes.push_back(new aiMesh());
                    aiMesh* pcMesh = apcOutMeshes.back();
                    pcMesh->mNumFaces = iFaces;
                    pcMesh->mNumVertices = iVertices;
                    pcMesh->mFaces = new aiFace[iFaces];
                    pcMesh->mVertices = new aiVector3D[iVertices];
                    pcMesh->mMaterialIndex = i;
                    if ((*j) & 0x2)pcMesh->mNormals = new aiVector3D[iVertices];
                    if ((*j) & 0x4)
                    {
                        pcMesh->mTangents    = new aiVector3D[iVertices];
                        pcMesh->mBitangents  = new aiVector3D[iVertices];
                    }
                    iFaces = 0;
                    while ((*j) & (0x100 << iFaces))
                    {
                        pcMesh->mTextureCoords[iFaces] = new aiVector3D[iVertices];
                        if ((*j) & (0x10000 << iFaces))pcMesh->mNumUVComponents[iFaces] = 3;
                        else pcMesh->mNumUVComponents[iFaces] = 2;
                        iFaces++;
                    }
                    iFaces = 0;
                    while ((*j) & (0x1000000 << iFaces))
                        pcMesh->mColors[iFaces++] = new aiColor4D[iVertices];

                    // fill the mesh ...
                    unsigned int aiTemp[2] = {0,0};
                    CollectData(pScene,pScene->mRootNode,i,*j,pcMesh,aiTemp,&s[0]);
                }
            }
        }

        // If no meshes are referenced in the node graph it is possible that we get no output meshes.
        if (apcOutMeshes.empty())   {
            throw DeadlyImportError("No output meshes: all meshes are orphaned and are not referenced by any nodes");
        }
        else
        {
            // now delete all meshes in the scene and build a new mesh list
            for (unsigned int i = 0; i < pScene->mNumMeshes;++i)
            {
                aiMesh* mesh = pScene->mMeshes[i];
                mesh->mNumBones = 0;
                mesh->mBones    = NULL;

                // we're reusing the face index arrays. avoid destruction
                for (unsigned int a = 0; a < mesh->mNumFaces; ++a) {
                    mesh->mFaces[a].mNumIndices = 0;
                    mesh->mFaces[a].mIndices = NULL;
                }

                delete mesh;

                // Invalidate the contents of the old mesh array. We will most
                // likely have less output meshes now, so the last entries of
                // the mesh array are not overridden. We set them to NULL to
                // make sure the developer gets notified when his application
                // attempts to access these fields ...
                mesh = NULL;
            }

            // It is impossible that we have more output meshes than
            // input meshes, so we can easily reuse the old mesh array
            pScene->mNumMeshes = (unsigned int)apcOutMeshes.size();
            for (unsigned int i = 0; i < pScene->mNumMeshes;++i) {
                pScene->mMeshes[i] = apcOutMeshes[i];
            }
        }
    }

    // remove all animations from the scene
    for (unsigned int i = 0; i < pScene->mNumAnimations;++i)
        delete pScene->mAnimations[i];
    delete[] pScene->mAnimations;

    pScene->mAnimations    = NULL;
    pScene->mNumAnimations = 0;

    // --- we need to keep all cameras and lights
    for (unsigned int i = 0; i < pScene->mNumCameras;++i)
    {
        aiCamera* cam = pScene->mCameras[i];
        const aiNode* nd = pScene->mRootNode->FindNode(cam->mName);
        ai_assert(NULL != nd);

        // multiply all properties of the camera with the absolute
        // transformation of the corresponding node
        cam->mPosition = nd->mTransformation * cam->mPosition;
        cam->mLookAt   = aiMatrix3x3( nd->mTransformation ) * cam->mLookAt;
        cam->mUp       = aiMatrix3x3( nd->mTransformation ) * cam->mUp;
    }

    for (unsigned int i = 0; i < pScene->mNumLights;++i)
    {
        aiLight* l = pScene->mLights[i];
        const aiNode* nd = pScene->mRootNode->FindNode(l->mName);
        ai_assert(NULL != nd);

        // multiply all properties of the camera with the absolute
        // transformation of the corresponding node
        l->mPosition   = nd->mTransformation * l->mPosition;
        l->mDirection  = aiMatrix3x3( nd->mTransformation ) * l->mDirection;
        l->mUp         = aiMatrix3x3( nd->mTransformation ) * l->mUp;
    }

    if( !configKeepHierarchy ) {

        // now delete all nodes in the scene and build a new
        // flat node graph with a root node and some level 1 children
        delete pScene->mRootNode;
        pScene->mRootNode = new aiNode();
        pScene->mRootNode->mName.Set("<dummy_root>");

        if (1 == pScene->mNumMeshes && !pScene->mNumLights && !pScene->mNumCameras)
        {
            pScene->mRootNode->mNumMeshes = 1;
            pScene->mRootNode->mMeshes = new unsigned int[1];
            pScene->mRootNode->mMeshes[0] = 0;
        }
        else
        {
            pScene->mRootNode->mNumChildren = pScene->mNumMeshes+pScene->mNumLights+pScene->mNumCameras;
            aiNode** nodes = pScene->mRootNode->mChildren = new aiNode*[pScene->mRootNode->mNumChildren];

            // generate mesh nodes
            for (unsigned int i = 0; i < pScene->mNumMeshes;++i,++nodes)
            {
                aiNode* pcNode = *nodes = new aiNode();
                pcNode->mParent = pScene->mRootNode;
                pcNode->mName.length = ::ai_snprintf(pcNode->mName.data,MAXLEN,"mesh_%u",i);

                // setup mesh indices
                pcNode->mNumMeshes = 1;
                pcNode->mMeshes = new unsigned int[1];
                pcNode->mMeshes[0] = i;
            }
            // generate light nodes
            for (unsigned int i = 0; i < pScene->mNumLights;++i,++nodes)
            {
                aiNode* pcNode = *nodes = new aiNode();
                pcNode->mParent = pScene->mRootNode;
                pcNode->mName.length = ai_snprintf(pcNode->mName.data, MAXLEN, "light_%u",i);
                pScene->mLights[i]->mName = pcNode->mName;
            }
            // generate camera nodes
            for (unsigned int i = 0; i < pScene->mNumCameras;++i,++nodes)
            {
                aiNode* pcNode = *nodes = new aiNode();
                pcNode->mParent = pScene->mRootNode;
                pcNode->mName.length = ::ai_snprintf(pcNode->mName.data,MAXLEN,"cam_%u",i);
                pScene->mCameras[i]->mName = pcNode->mName;
            }
        }
    }
    else {
        // ... and finally set the transformation matrix of all nodes to identity
        MakeIdentityTransform(pScene->mRootNode);
    }

    if (configNormalize) {
        // compute the boundary of all meshes
        aiVector3D min,max;
        MinMaxChooser<aiVector3D> ()(min,max);

        for (unsigned int a = 0; a <  pScene->mNumMeshes; ++a) {
            aiMesh* m = pScene->mMeshes[a];
            for (unsigned int i = 0; i < m->mNumVertices;++i) {
                min = std::min(m->mVertices[i],min);
                max = std::max(m->mVertices[i],max);
            }
        }

        // find the dominant axis
        aiVector3D d = max-min;
        const float div = std::max(d.x,std::max(d.y,d.z))*0.5f;

        d = min+d*0.5f;
        for (unsigned int a = 0; a <  pScene->mNumMeshes; ++a) {
            aiMesh* m = pScene->mMeshes[a];
            for (unsigned int i = 0; i < m->mNumVertices;++i) {
                m->mVertices[i] = (m->mVertices[i]-d)/div;
            }
        }
    }

    // print statistics
    if (!DefaultLogger::isNullLogger())
    {
        char buffer[4096];

        DefaultLogger::get()->debug("PretransformVerticesProcess finished");

        ::ai_snprintf(buffer,4096,"Removed %u nodes and %u animation channels (%u output nodes)",
            iOldNodes,iOldAnimationChannels,CountNodes(pScene->mRootNode));
        DefaultLogger::get()->info(buffer);

        ai_snprintf(buffer, 4096,"Kept %u lights and %u cameras",
            pScene->mNumLights,pScene->mNumCameras);
        DefaultLogger::get()->info(buffer);

        ai_snprintf(buffer, 4096,"Moved %u meshes to WCS (number of output meshes: %u)",
            iOldMeshes,pScene->mNumMeshes);
        DefaultLogger::get()->info(buffer);
    }
}


/***********************************************************************
FBXIMPORT\PROCESSHELPER.CPP
***********************************************************************/
/*
Open Asset Import Library (assimp)
----------------------------------------------------------------------

Copyright (c) 2006-2016, assimp team
All rights reserved.

Redistribution and use of this software in source and binary forms,
with or without modification, are permitted provided that the
following conditions are met:

* Redistributions of source code must retain the above
  copyright notice, this list of conditions and the
  following disclaimer.

* Redistributions in binary form must reproduce the above
  copyright notice, this list of conditions and the
  following disclaimer in the documentation and/or other
  materials provided with the distribution.

* Neither the name of the assimp team, nor the names of its
  contributors may be used to endorse or promote products
  derived from this software without specific prior
  written permission of the assimp team.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
"AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

----------------------------------------------------------------------
*/

/// @file ProcessHelper.cpp
/** Implement shared utility functions for postprocessing steps */





namespace Assimp {

// -------------------------------------------------------------------------------
void ConvertListToStrings(const std::string& in, std::list<std::string>& out)
{
    const char* s = in.c_str();
    while (*s) {
        SkipSpacesAndLineEnd(&s);
        if (*s == '\'') {
            const char* base = ++s;
            while (*s != '\'') {
                ++s;
                if (*s == '\0') {
                    DefaultLogger::get()->error("ConvertListToString: String list is ill-formatted");
                    return;
                }
            }
            out.push_back(std::string(base,(size_t)(s-base)));
            ++s;
        }
        else {
            out.push_back(GetNextToken(s));
        }
    }
}

// -------------------------------------------------------------------------------
void FindAABBTransformed (const aiMesh* mesh, aiVector3D& min, aiVector3D& max,
    const aiMatrix4x4& m)
{
    min = aiVector3D (10e10f,  10e10f, 10e10f);
    max = aiVector3D (-10e10f,-10e10f,-10e10f);
    for (unsigned int i = 0;i < mesh->mNumVertices;++i)
    {
        const aiVector3D v = m * mesh->mVertices[i];
        min = std::min(v,min);
        max = std::max(v,max);
    }
}

// -------------------------------------------------------------------------------
void FindMeshCenter (aiMesh* mesh, aiVector3D& out, aiVector3D& min, aiVector3D& max)
{
    ArrayBounds(mesh->mVertices,mesh->mNumVertices, min,max);
    out = min + (max-min)*0.5f;
}

// -------------------------------------------------------------------------------
void FindSceneCenter (aiScene* scene, aiVector3D& out, aiVector3D& min, aiVector3D& max) {
    if ( NULL == scene ) {
        return;
    }

    if ( 0 == scene->mNumMeshes ) {
        return;
    }
    FindMeshCenter(scene->mMeshes[0], out, min, max);
    for (unsigned int i = 1; i < scene->mNumMeshes; ++i) {
        aiVector3D tout, tmin, tmax;
        FindMeshCenter(scene->mMeshes[i], tout, tmin, tmax);
        if (min[0] > tmin[0]) min[0] = tmin[0];
        if (min[1] > tmin[1]) min[1] = tmin[1];
        if (min[2] > tmin[2]) min[2] = tmin[2];
        if (max[0] < tmax[0]) max[0] = tmax[0];
        if (max[1] < tmax[1]) max[1] = tmax[1];
        if (max[2] < tmax[2]) max[2] = tmax[2];
    }
    out = min + (max-min)*0.5f;
}


// -------------------------------------------------------------------------------
void FindMeshCenterTransformed (aiMesh* mesh, aiVector3D& out, aiVector3D& min,
    aiVector3D& max, const aiMatrix4x4& m)
{
    FindAABBTransformed(mesh,min,max,m);
    out = min + (max-min)*0.5f;
}

// -------------------------------------------------------------------------------
void FindMeshCenter (aiMesh* mesh, aiVector3D& out)
{
    aiVector3D min,max;
    FindMeshCenter(mesh,out,min,max);
}

// -------------------------------------------------------------------------------
void FindMeshCenterTransformed (aiMesh* mesh, aiVector3D& out,
    const aiMatrix4x4& m)
{
    aiVector3D min,max;
    FindMeshCenterTransformed(mesh,out,min,max,m);
}

// -------------------------------------------------------------------------------
float ComputePositionEpsilon(const aiMesh* pMesh)
{
    const float epsilon = 1e-4f;

    // calculate the position bounds so we have a reliable epsilon to check position differences against
    aiVector3D minVec, maxVec;
    ArrayBounds(pMesh->mVertices,pMesh->mNumVertices,minVec,maxVec);
    return (maxVec - minVec).Length() * epsilon;
}

// -------------------------------------------------------------------------------
float ComputePositionEpsilon(const aiMesh* const* pMeshes, size_t num)
{
    ai_assert( NULL != pMeshes );

    const float epsilon = 1e-4f;

    // calculate the position bounds so we have a reliable epsilon to check position differences against
    aiVector3D minVec, maxVec, mi, ma;
    MinMaxChooser<aiVector3D>()(minVec,maxVec);

    for (size_t a = 0; a < num; ++a) {
        const aiMesh* pMesh = pMeshes[a];
        ArrayBounds(pMesh->mVertices,pMesh->mNumVertices,mi,ma);

        minVec = std::min(minVec,mi);
        maxVec = std::max(maxVec,ma);
    }
    return (maxVec - minVec).Length() * epsilon;
}


// -------------------------------------------------------------------------------
unsigned int GetMeshVFormatUnique(const aiMesh* pcMesh)
{
    ai_assert(NULL != pcMesh);

    // FIX: the hash may never be 0. Otherwise a comparison against
    // nullptr could be successful
    unsigned int iRet = 1;

    // normals
    if (pcMesh->HasNormals())iRet |= 0x2;
    // tangents and bitangents
    if (pcMesh->HasTangentsAndBitangents())iRet |= 0x4;

#ifdef BOOST_STATIC_ASSERT
    BOOST_STATIC_ASSERT(8 >= AI_MAX_NUMBER_OF_COLOR_SETS);
    BOOST_STATIC_ASSERT(8 >= AI_MAX_NUMBER_OF_TEXTURECOORDS);
#endif

    // texture coordinates
    unsigned int p = 0;
    while (pcMesh->HasTextureCoords(p))
    {
        iRet |= (0x100 << p);
        if (3 == pcMesh->mNumUVComponents[p])
            iRet |= (0x10000 << p);

        ++p;
    }
    // vertex colors
    p = 0;
    while (pcMesh->HasVertexColors(p))iRet |= (0x1000000 << p++);
    return iRet;
}

// -------------------------------------------------------------------------------
VertexWeightTable* ComputeVertexBoneWeightTable(const aiMesh* pMesh)
{
    if (!pMesh || !pMesh->mNumVertices || !pMesh->mNumBones) {
        return NULL;
    }

    VertexWeightTable* avPerVertexWeights = new VertexWeightTable[pMesh->mNumVertices];
    for (unsigned int i = 0; i < pMesh->mNumBones;++i)  {

        aiBone* bone = pMesh->mBones[i];
        for (unsigned int a = 0; a < bone->mNumWeights;++a) {
            const aiVertexWeight& weight = bone->mWeights[a];
            avPerVertexWeights[weight.mVertexId].push_back( std::pair<unsigned int,float>(i,weight.mWeight) );
        }
    }
    return avPerVertexWeights;
}


// -------------------------------------------------------------------------------
const char* TextureTypeToString(aiTextureType in)
{
    switch (in)
    {
    case aiTextureType_NONE:
        return "n/a";
    case aiTextureType_DIFFUSE:
        return "Diffuse";
    case aiTextureType_SPECULAR:
        return "Specular";
    case aiTextureType_AMBIENT:
        return "Ambient";
    case aiTextureType_EMISSIVE:
        return "Emissive";
    case aiTextureType_OPACITY:
        return "Opacity";
    case aiTextureType_NORMALS:
        return "Normals";
    case aiTextureType_HEIGHT:
        return "Height";
    case aiTextureType_SHININESS:
        return "Shininess";
    case aiTextureType_DISPLACEMENT:
        return "Displacement";
    case aiTextureType_LIGHTMAP:
        return "Lightmap";
    case aiTextureType_REFLECTION:
        return "Reflection";
    case aiTextureType_UNKNOWN:
        return "Unknown";
    default:
        break;
    }

    ai_assert(false);
    return  "BUG";
}

// -------------------------------------------------------------------------------
const char* MappingTypeToString(aiTextureMapping in)
{
    switch (in)
    {
    case aiTextureMapping_UV:
        return "UV";
    case aiTextureMapping_BOX:
        return "Box";
    case aiTextureMapping_SPHERE:
        return "Sphere";
    case aiTextureMapping_CYLINDER:
        return "Cylinder";
    case aiTextureMapping_PLANE:
        return "Plane";
    case aiTextureMapping_OTHER:
        return "Other";
    default:
        break;
    }

    ai_assert(false);
    return  "BUG";
}


// -------------------------------------------------------------------------------
aiMesh* MakeSubmesh(const aiMesh *pMesh, const std::vector<unsigned int> &subMeshFaces, unsigned int subFlags)
{
    aiMesh *oMesh = new aiMesh();
    std::vector<unsigned int> vMap(pMesh->mNumVertices,UINT_MAX);

    size_t numSubVerts = 0;
    size_t numSubFaces = subMeshFaces.size();

    for(unsigned int i=0;i<numSubFaces;i++) {
        const aiFace &f = pMesh->mFaces[subMeshFaces[i]];

        for(unsigned int j=0;j<f.mNumIndices;j++)   {
            if(vMap[f.mIndices[j]]==UINT_MAX)   {
                vMap[f.mIndices[j]] = numSubVerts++;
            }
        }
    }

    oMesh->mName = pMesh->mName;

    oMesh->mMaterialIndex = pMesh->mMaterialIndex;
    oMesh->mPrimitiveTypes = pMesh->mPrimitiveTypes;

    // create all the arrays for this mesh if the old mesh contained them

    oMesh->mNumFaces = subMeshFaces.size();
    oMesh->mNumVertices = numSubVerts;
    oMesh->mVertices = new aiVector3D[numSubVerts];
    if( pMesh->HasNormals() ) {
        oMesh->mNormals = new aiVector3D[numSubVerts];
    }

    if( pMesh->HasTangentsAndBitangents() ) {
        oMesh->mTangents = new aiVector3D[numSubVerts];
        oMesh->mBitangents = new aiVector3D[numSubVerts];
    }

    for( size_t a = 0;  pMesh->HasTextureCoords( a) ; ++a ) {
        oMesh->mTextureCoords[a] = new aiVector3D[numSubVerts];
        oMesh->mNumUVComponents[a] = pMesh->mNumUVComponents[a];
    }

    for( size_t a = 0; pMesh->HasVertexColors( a); ++a )    {
        oMesh->mColors[a] = new aiColor4D[numSubVerts];
    }

    // and copy over the data, generating faces with linear indices along the way
    oMesh->mFaces = new aiFace[numSubFaces];

    for(unsigned int a = 0; a < numSubFaces; ++a )  {

        const aiFace& srcFace = pMesh->mFaces[subMeshFaces[a]];
        aiFace& dstFace = oMesh->mFaces[a];
        dstFace.mNumIndices = srcFace.mNumIndices;
        dstFace.mIndices = new unsigned int[dstFace.mNumIndices];

        // accumulate linearly all the vertices of the source face
        for( size_t b = 0; b < dstFace.mNumIndices; ++b )   {
            dstFace.mIndices[b] = vMap[srcFace.mIndices[b]];
        }
    }

    for(unsigned int srcIndex = 0; srcIndex < pMesh->mNumVertices; ++srcIndex ) {
        unsigned int nvi = vMap[srcIndex];
        if(nvi==UINT_MAX) {
            continue;
        }

        oMesh->mVertices[nvi] = pMesh->mVertices[srcIndex];
        if( pMesh->HasNormals() ) {
            oMesh->mNormals[nvi] = pMesh->mNormals[srcIndex];
        }

        if( pMesh->HasTangentsAndBitangents() ) {
            oMesh->mTangents[nvi] = pMesh->mTangents[srcIndex];
            oMesh->mBitangents[nvi] = pMesh->mBitangents[srcIndex];
        }
        for( size_t c = 0, cc = pMesh->GetNumUVChannels(); c < cc; ++c )    {
                oMesh->mTextureCoords[c][nvi] = pMesh->mTextureCoords[c][srcIndex];
        }
        for( size_t c = 0, cc = pMesh->GetNumColorChannels(); c < cc; ++c ) {
            oMesh->mColors[c][nvi] = pMesh->mColors[c][srcIndex];
        }
    }

    if(~subFlags&AI_SUBMESH_FLAGS_SANS_BONES)   {
        std::vector<unsigned int> subBones(pMesh->mNumBones,0);

        for(unsigned int a=0;a<pMesh->mNumBones;++a)    {
            const aiBone* bone = pMesh->mBones[a];

            for(unsigned int b=0;b<bone->mNumWeights;b++)   {
                unsigned int v = vMap[bone->mWeights[b].mVertexId];

                if(v!=UINT_MAX) {
                    subBones[a]++;
                }
            }
        }

        for(unsigned int a=0;a<pMesh->mNumBones;++a)    {
            if(subBones[a]>0) {
                oMesh->mNumBones++;
            }
        }

        if(oMesh->mNumBones) {
            oMesh->mBones = new aiBone*[oMesh->mNumBones]();
            unsigned int nbParanoia = oMesh->mNumBones;

            oMesh->mNumBones = 0; //rewind

            for(unsigned int a=0;a<pMesh->mNumBones;++a)    {
                if(subBones[a]==0) {
                    continue;
                }
                aiBone *newBone = new aiBone;
                oMesh->mBones[oMesh->mNumBones++] = newBone;

                const aiBone* bone = pMesh->mBones[a];

                newBone->mName = bone->mName;
                newBone->mOffsetMatrix = bone->mOffsetMatrix;
                newBone->mWeights = new aiVertexWeight[subBones[a]];

                for(unsigned int b=0;b<bone->mNumWeights;b++)   {
                    const unsigned int v = vMap[bone->mWeights[b].mVertexId];

                    if(v!=UINT_MAX) {
                        aiVertexWeight w(v,bone->mWeights[b].mWeight);
                        newBone->mWeights[newBone->mNumWeights++] = w;
                    }
                }
            }

            ai_assert(nbParanoia==oMesh->mNumBones);
            (void)nbParanoia; // remove compiler warning on release build
        }
    }

    return oMesh;
}

} // namespace Assimp

/***********************************************************************
FBXIMPORT\REMOVEREDUNDANTMATERIALS.CPP
***********************************************************************/
/*
---------------------------------------------------------------------------
Open Asset Import Library (assimp)
---------------------------------------------------------------------------

Copyright (c) 2006-2016, assimp team

All rights reserved.

Redistribution and use of this software in source and binary forms,
with or without modification, are permitted provided that the following
conditions are met:

* Redistributions of source code must retain the above
  copyright notice, this list of conditions and the
  following disclaimer.

* Redistributions in binary form must reproduce the above
  copyright notice, this list of conditions and the
  following disclaimer in the documentation and/or other
  materials provided with the distribution.

* Neither the name of the assimp team, nor the names of its
  contributors may be used to endorse or promote products
  derived from this software without specific prior
  written permission of the assimp team.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
"AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
---------------------------------------------------------------------------
*/
/** @file RemoveRedundantMaterials.cpp
 *  @brief Implementation of the "RemoveRedundantMaterials" post processing step
*/

// internal headers


using namespace Assimp;

// ------------------------------------------------------------------------------------------------
// Constructor to be privately used by Importer
RemoveRedundantMatsProcess::RemoveRedundantMatsProcess()
: configFixedMaterials() {
    // nothing to do here
}

// ------------------------------------------------------------------------------------------------
// Destructor, private as well
RemoveRedundantMatsProcess::~RemoveRedundantMatsProcess()
{
    // nothing to do here
}

// ------------------------------------------------------------------------------------------------
// Returns whether the processing step is present in the given flag field.
bool RemoveRedundantMatsProcess::IsActive( unsigned int pFlags) const
{
    return (pFlags & aiProcess_RemoveRedundantMaterials) != 0;
}

// ------------------------------------------------------------------------------------------------
// Setup import properties
void RemoveRedundantMatsProcess::SetupProperties(const Importer* pImp)
{
    // Get value of AI_CONFIG_PP_RRM_EXCLUDE_LIST
    configFixedMaterials = pImp->GetPropertyString(AI_CONFIG_PP_RRM_EXCLUDE_LIST,"");
}

// ------------------------------------------------------------------------------------------------
// Executes the post processing step on the given imported data.
void RemoveRedundantMatsProcess::Execute( aiScene* pScene)
{
    DefaultLogger::get()->debug("RemoveRedundantMatsProcess begin");

    unsigned int redundantRemoved = 0, unreferencedRemoved = 0;
    if (pScene->mNumMaterials)
    {
        // Find out which materials are referenced by meshes
        std::vector<bool> abReferenced(pScene->mNumMaterials,false);
        for (unsigned int i = 0;i < pScene->mNumMeshes;++i)
            abReferenced[pScene->mMeshes[i]->mMaterialIndex] = true;

        // If a list of materials to be excluded was given, match the list with
        // our imported materials and 'salt' all positive matches to ensure that
        // we get unique hashes later.
        if (configFixedMaterials.length()) {

            std::list<std::string> strings;
            ConvertListToStrings(configFixedMaterials,strings);

            for (unsigned int i = 0; i < pScene->mNumMaterials;++i) {
                aiMaterial* mat = pScene->mMaterials[i];

                aiString name;
                mat->Get(AI_MATKEY_NAME,name);

                if (name.length) {
                    std::list<std::string>::const_iterator it = std::find(strings.begin(), strings.end(), name.data);
                    if (it != strings.end()) {

                        // Our brilliant 'salt': A single material property with ~ as first
                        // character to mark it as internal and temporary.
                        const int dummy = 1;
                        ((aiMaterial*)mat)->AddProperty(&dummy,1,"~RRM.UniqueMaterial",0,0);

                        // Keep this material even if no mesh references it
                        abReferenced[i] = true;
                        DefaultLogger::get()->debug(std::string("Found positive match in exclusion list: \'") + name.data + "\'");
                    }
                }
            }
        }

        // TODO: re-implement this algorithm to work in-place
        unsigned int *aiMappingTable = new unsigned int[pScene->mNumMaterials];
        for ( unsigned int i=0; i<pScene->mNumMaterials; i++ ) {
            aiMappingTable[ i ] = 0;
        }
        unsigned int iNewNum = 0;

        // Iterate through all materials and calculate a hash for them
        // store all hashes in a list and so a quick search whether
        // we do already have a specific hash. This allows us to
        // determine which materials are identical.
        uint32_t *aiHashes = new uint32_t[ pScene->mNumMaterials ];;
        for (unsigned int i = 0; i < pScene->mNumMaterials;++i)
        {
            // No mesh is referencing this material, remove it.
            if (!abReferenced[i]) {
                ++unreferencedRemoved;
                delete pScene->mMaterials[i];
                continue;
            }

            // Check all previously mapped materials for a matching hash.
            // On a match we can delete this material and just make it ref to the same index.
            uint32_t me = aiHashes[i] = ComputeMaterialHash(pScene->mMaterials[i]);
            for (unsigned int a = 0; a < i;++a)
            {
                if (abReferenced[a] && me == aiHashes[a]) {
                    ++redundantRemoved;
                    me = 0;
                    aiMappingTable[i] = aiMappingTable[a];
                    delete pScene->mMaterials[i];
                    break;
                }
            }
            // This is a new material that is referenced, add to the map.
            if (me) {
                aiMappingTable[i] = iNewNum++;
            }
        }
        // If the new material count differs from the original,
        // we need to rebuild the material list and remap mesh material indexes.
        if (iNewNum != pScene->mNumMaterials) {
            aiMaterial** ppcMaterials = new aiMaterial*[iNewNum];
            ::memset(ppcMaterials,0,sizeof(void*)*iNewNum);
            for (unsigned int p = 0; p < pScene->mNumMaterials;++p)
            {
                // if the material is not referenced ... remove it
                if (!abReferenced[p]) {
                    continue;
                }

                // generate new names for all modified materials
                const unsigned int idx = aiMappingTable[p];
                if (ppcMaterials[idx]) {
                    aiString sz;
                    sz.length = ::ai_snprintf(sz.data,MAXLEN,"JoinedMaterial_#%u",p);
                    ((aiMaterial*)ppcMaterials[idx])->AddProperty(&sz,AI_MATKEY_NAME);
                } else {
                    ppcMaterials[idx] = pScene->mMaterials[p];
                }
            }
            // update all material indices
            for (unsigned int p = 0; p < pScene->mNumMeshes;++p) {
                aiMesh* mesh = pScene->mMeshes[p];
                ai_assert( NULL!=mesh );
                mesh->mMaterialIndex = aiMappingTable[mesh->mMaterialIndex];
            }
            // delete the old material list
            delete[] pScene->mMaterials;
            pScene->mMaterials = ppcMaterials;
            pScene->mNumMaterials = iNewNum;
        }
        // delete temporary storage
        delete[] aiHashes;
        delete[] aiMappingTable;
    }
    if (redundantRemoved == 0 && unreferencedRemoved == 0)
    {
        DefaultLogger::get()->debug("RemoveRedundantMatsProcess finished ");
    }
    else
    {
        char szBuffer[128]; // should be sufficiently large
        ::ai_snprintf(szBuffer,128,"RemoveRedundantMatsProcess finished. Removed %u redundant and %u unused materials.",
            redundantRemoved,unreferencedRemoved);
        DefaultLogger::get()->info(szBuffer);
    }
}

/***********************************************************************
FBXIMPORT\REMOVEVCPROCESS.CPP
***********************************************************************/
/*
---------------------------------------------------------------------------
Open Asset Import Library (assimp)
---------------------------------------------------------------------------

Copyright (c) 2006-2016, assimp team

All rights reserved.

Redistribution and use of this software in source and binary forms,
with or without modification, are permitted provided that the following
conditions are met:

* Redistributions of source code must retain the above
  copyright notice, this list of conditions and the
  following disclaimer.

* Redistributions in binary form must reproduce the above
  copyright notice, this list of conditions and the
  following disclaimer in the documentation and/or other
  materials provided with the distribution.

* Neither the name of the assimp team, nor the names of its
  contributors may be used to endorse or promote products
  derived from this software without specific prior
  written permission of the assimp team.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
"AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
---------------------------------------------------------------------------
*/
/** @file Implementation of the post processing step to remove
 *        any parts of the mesh structure from the imported data.
*/



using namespace Assimp;

// ------------------------------------------------------------------------------------------------
// Constructor to be privately used by Importer
RemoveVCProcess::RemoveVCProcess() :
    configDeleteFlags()
  , mScene()
{}

// ------------------------------------------------------------------------------------------------
// Destructor, private as well
RemoveVCProcess::~RemoveVCProcess()
{}

// ------------------------------------------------------------------------------------------------
// Returns whether the processing step is present in the given flag field.
bool RemoveVCProcess::IsActive( unsigned int pFlags) const
{
    return (pFlags & aiProcess_RemoveComponent) != 0;
}

// ------------------------------------------------------------------------------------------------
// Small helper function to delete all elements in a T** aray using delete
template <typename T>
inline void ArrayDelete(T**& in, unsigned int& num)
{
    for (unsigned int i = 0; i < num; ++i)
        delete in[i];

    delete[] in;
    in = NULL;
    num = 0;
}

#if 0
// ------------------------------------------------------------------------------------------------
// Updates the node graph - removes all nodes which have the "remove" flag set and the
// "don't remove" flag not set. Nodes with meshes are never deleted.
bool UpdateNodeGraph(aiNode* node,std::list<aiNode*>& childsOfParent,bool root)
{
    bool b = false;

    std::list<aiNode*> mine;
    for (unsigned int i = 0; i < node->mNumChildren;++i)
    {
        if(UpdateNodeGraph(node->mChildren[i],mine,false))
            b = true;
    }

    // somewhat tricky ... mNumMeshes must be originally 0 and MSB2 may not be set,
    // so we can do a simple comparison against MSB here
    if (!root && AI_RC_UINT_MSB == node->mNumMeshes )
    {
        // this node needs to be removed
        if(node->mNumChildren)
        {
            childsOfParent.insert(childsOfParent.end(),mine.begin(),mine.end());

            // set all children to NULL to make sure they are not deleted when we delete ourself
            for (unsigned int i = 0; i < node->mNumChildren;++i)
                node->mChildren[i] = NULL;
        }
        b = true;
        delete node;
    }
    else
    {
        AI_RC_UNMASK(node->mNumMeshes);
        childsOfParent.push_back(node);

        if (b)
        {
            // reallocate the array of our children here
            node->mNumChildren = (unsigned int)mine.size();
            aiNode** const children = new aiNode*[mine.size()];
            aiNode** ptr = children;

            for (std::list<aiNode*>::iterator it = mine.begin(), end = mine.end();
                 it != end; ++it)
            {
                *ptr++ = *it;
            }
            delete[] node->mChildren;
            node->mChildren = children;
            return false;
        }
    }
    return b;
}
#endif

// ------------------------------------------------------------------------------------------------
// Executes the post processing step on the given imported data.
void RemoveVCProcess::Execute( aiScene* pScene)
{
    DefaultLogger::get()->debug("RemoveVCProcess begin");
    bool bHas = false; //,bMasked = false;

    mScene = pScene;

    // handle animations
    if ( configDeleteFlags & aiComponent_ANIMATIONS)
    {

        bHas = true;
        ArrayDelete(pScene->mAnimations,pScene->mNumAnimations);
    }

    // handle textures
    if ( configDeleteFlags & aiComponent_TEXTURES)
    {
        bHas = true;
        ArrayDelete(pScene->mTextures,pScene->mNumTextures);
    }

    // handle materials
    if ( configDeleteFlags & aiComponent_MATERIALS && pScene->mNumMaterials)
    {
        bHas = true;
        for (unsigned int i = 1;i < pScene->mNumMaterials;++i)
            delete pScene->mMaterials[i];

        pScene->mNumMaterials = 1;
        aiMaterial* helper = (aiMaterial*) pScene->mMaterials[0];
        ai_assert(NULL != helper);
        helper->Clear();

        // gray
        aiColor3D clr(0.6f,0.6f,0.6f);
        helper->AddProperty(&clr,1,AI_MATKEY_COLOR_DIFFUSE);

        // add a small ambient color value
        clr = aiColor3D(0.05f,0.05f,0.05f);
        helper->AddProperty(&clr,1,AI_MATKEY_COLOR_AMBIENT);

        aiString s;
        s.Set("Dummy_MaterialsRemoved");
        helper->AddProperty(&s,AI_MATKEY_NAME);
    }

    // handle light sources
    if ( configDeleteFlags & aiComponent_LIGHTS)
    {
        bHas =  true;
        ArrayDelete(pScene->mLights,pScene->mNumLights);
    }

    // handle camneras
    if ( configDeleteFlags & aiComponent_CAMERAS)
    {
        bHas = true;
        ArrayDelete(pScene->mCameras,pScene->mNumCameras);
    }

    // handle meshes
    if (configDeleteFlags & aiComponent_MESHES)
    {
        bHas = true;
        ArrayDelete(pScene->mMeshes,pScene->mNumMeshes);
    }
    else
    {
        for( unsigned int a = 0; a < pScene->mNumMeshes; a++)
        {
            if( ProcessMesh( pScene->mMeshes[a]))
                bHas = true;
        }
    }


    // now check whether the result is still a full scene
    if (!pScene->mNumMeshes || !pScene->mNumMaterials)
    {
        pScene->mFlags |= AI_SCENE_FLAGS_INCOMPLETE;
        DefaultLogger::get()->debug("Setting AI_SCENE_FLAGS_INCOMPLETE flag");

        // If we have no meshes anymore we should also clear another flag ...
        if (!pScene->mNumMeshes)
            pScene->mFlags &= ~AI_SCENE_FLAGS_NON_VERBOSE_FORMAT;
    }

    if (bHas)DefaultLogger::get()->info("RemoveVCProcess finished. Data structure cleanup has been done.");
    else DefaultLogger::get()->debug("RemoveVCProcess finished. Nothing to be done ...");
}

// ------------------------------------------------------------------------------------------------
// Setup configuration properties for the step
void RemoveVCProcess::SetupProperties(const Importer* pImp)
{
    configDeleteFlags = pImp->GetPropertyInteger(AI_CONFIG_PP_RVC_FLAGS,0x0);
    if (!configDeleteFlags)
    {
        DefaultLogger::get()->warn("RemoveVCProcess: AI_CONFIG_PP_RVC_FLAGS is zero.");
    }
}

// ------------------------------------------------------------------------------------------------
// Executes the post processing step on the given imported data.
bool RemoveVCProcess::ProcessMesh(aiMesh* pMesh)
{
    bool ret = false;

    // if all materials have been deleted let the material
    // index of the mesh point to the created default material
    if ( configDeleteFlags & aiComponent_MATERIALS)
        pMesh->mMaterialIndex = 0;

    // handle normals
    if (configDeleteFlags & aiComponent_NORMALS && pMesh->mNormals)
    {
        delete[] pMesh->mNormals;
        pMesh->mNormals = NULL;
        ret = true;
    }

    // handle tangents and bitangents
    if (configDeleteFlags & aiComponent_TANGENTS_AND_BITANGENTS && pMesh->mTangents)
    {
        delete[] pMesh->mTangents;
        pMesh->mTangents = NULL;

        delete[] pMesh->mBitangents;
        pMesh->mBitangents = NULL;
        ret = true;
    }

    // handle texture coordinates
    bool b = (0 != (configDeleteFlags & aiComponent_TEXCOORDS));
    for (unsigned int i = 0, real = 0; real < AI_MAX_NUMBER_OF_TEXTURECOORDS; ++real)
    {
        if (!pMesh->mTextureCoords[i])break;
        if (configDeleteFlags & aiComponent_TEXCOORDSn(real) || b)
        {
            delete [] pMesh->mTextureCoords[i];
            pMesh->mTextureCoords[i] = NULL;
            ret = true;

            if (!b)
            {
                // collapse the rest of the array
                for (unsigned int a = i+1; a < AI_MAX_NUMBER_OF_TEXTURECOORDS;++a)
                    pMesh->mTextureCoords[a-1] = pMesh->mTextureCoords[a];

                pMesh->mTextureCoords[AI_MAX_NUMBER_OF_TEXTURECOORDS-1] = NULL;
                continue;
            }
        }
        ++i;
    }

    // handle vertex colors
    b = (0 != (configDeleteFlags & aiComponent_COLORS));
    for (unsigned int i = 0, real = 0; real < AI_MAX_NUMBER_OF_COLOR_SETS; ++real)
    {
        if (!pMesh->mColors[i])break;
        if (configDeleteFlags & aiComponent_COLORSn(i) || b)
        {
            delete pMesh->mColors[i];
            pMesh->mColors[i] = NULL;
            ret = true;

            if (!b)
            {
                // collapse the rest of the array
                for (unsigned int a = i+1; a < AI_MAX_NUMBER_OF_COLOR_SETS;++a)
                    pMesh->mColors[a-1] = pMesh->mColors[a];

                pMesh->mColors[AI_MAX_NUMBER_OF_COLOR_SETS-1] = NULL;
                continue;
            }
        }
        ++i;
    }

    // handle bones
    if (configDeleteFlags & aiComponent_BONEWEIGHTS && pMesh->mBones)
    {
        ArrayDelete(pMesh->mBones,pMesh->mNumBones);
        ret = true;
    }
    return ret;
}

/***********************************************************************
FBXIMPORT\SCENECOMBINER.CPP
***********************************************************************/
/*
Open Asset Import Library (assimp)
----------------------------------------------------------------------

Copyright (c) 2006-2016, assimp team
All rights reserved.

Redistribution and use of this software in source and binary forms,
with or without modification, are permitted provided that the
following conditions are met:

* Redistributions of source code must retain the above
  copyright notice, this list of conditions and the
  following disclaimer.

* Redistributions in binary form must reproduce the above
  copyright notice, this list of conditions and the
  following disclaimer in the documentation and/or other
  materials provided with the distribution.

* Neither the name of the assimp team, nor the names of its
  contributors may be used to endorse or promote products
  derived from this software without specific prior
  written permission of the assimp team.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
"AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

----------------------------------------------------------------------
*/

// TODO: refactor entire file to get rid of the "flat-copy" first approach
// to copying structures. This easily breaks in the most unintuitive way
// possible as new fields are added to assimp structures.

// ----------------------------------------------------------------------------
/** @file Implements Assimp::SceneCombiner. This is a smart utility
 *    class that combines multiple scenes, meshes, ... into one. Currently
 *    these utilities are used by the IRR and LWS loaders and the
 *    OptimizeGraph step.
 */
// ----------------------------------------------------------------------------
#include <time.h>

namespace Assimp    {

// ------------------------------------------------------------------------------------------------
// Add a prefix to a string
inline void PrefixString(aiString& string,const char* prefix, unsigned int len)
{
    // If the string is already prefixed, we won't prefix it a second time
    if (string.length >= 1 && string.data[0] == '$')
        return;

    if (len+string.length>=MAXLEN-1) {
        DefaultLogger::get()->debug("Can't add an unique prefix because the string is too long");
        ai_assert(false);
        return;
    }

    // Add the prefix
    ::memmove(string.data+len,string.data,string.length+1);
    ::memcpy (string.data, prefix, len);

    // And update the string's length
    string.length += len;
}

// ------------------------------------------------------------------------------------------------
// Add node identifiers to a hashing set
void SceneCombiner::AddNodeHashes(aiNode* node, std::set<unsigned int>& hashes)
{
    // Add node name to hashing set if it is non-empty - empty nodes are allowed
    // and they can't have any anims assigned so its absolutely safe to duplicate them.
    if (node->mName.length) {
        hashes.insert( SuperFastHash(node->mName.data,node->mName.length) );
    }

    // Process all children recursively
    for (unsigned int i = 0; i < node->mNumChildren;++i)
        AddNodeHashes(node->mChildren[i],hashes);
}

// ------------------------------------------------------------------------------------------------
// Add a name prefix to all nodes in a hierarchy
void SceneCombiner::AddNodePrefixes(aiNode* node, const char* prefix, unsigned int len)
{
    ai_assert(NULL != prefix);
    PrefixString(node->mName,prefix,len);

    // Process all children recursively
    for (unsigned int i = 0; i < node->mNumChildren;++i)
        AddNodePrefixes(node->mChildren[i],prefix,len);
}

// ------------------------------------------------------------------------------------------------
// Search for matching names
bool SceneCombiner::FindNameMatch(const aiString& name, std::vector<SceneHelper>& input, unsigned int cur)
{
    const unsigned int hash = SuperFastHash(name.data, name.length);

    // Check whether we find a positive match in one of the given sets
    for (unsigned int i = 0; i < input.size(); ++i) {

        if (cur != i && input[i].hashes.find(hash) != input[i].hashes.end()) {
            return true;
        }
    }
    return false;
}

// ------------------------------------------------------------------------------------------------
// Add a name prefix to all nodes in a hierarchy if a hash match is found
void SceneCombiner::AddNodePrefixesChecked(aiNode* node, const char* prefix, unsigned int len,
    std::vector<SceneHelper>& input, unsigned int cur)
{
    ai_assert(NULL != prefix);
    const unsigned int hash = SuperFastHash(node->mName.data,node->mName.length);

    // Check whether we find a positive match in one of the given sets
    for (unsigned int i = 0; i < input.size(); ++i) {

        if (cur != i && input[i].hashes.find(hash) != input[i].hashes.end()) {
            PrefixString(node->mName,prefix,len);
            break;
        }
    }

    // Process all children recursively
    for (unsigned int i = 0; i < node->mNumChildren;++i)
        AddNodePrefixesChecked(node->mChildren[i],prefix,len,input,cur);
}

// ------------------------------------------------------------------------------------------------
// Add an offset to all mesh indices in a node graph
void SceneCombiner::OffsetNodeMeshIndices (aiNode* node, unsigned int offset)
{
    for (unsigned int i = 0; i < node->mNumMeshes;++i)
        node->mMeshes[i] += offset;

    for (unsigned int i = 0; i < node->mNumChildren;++i)
        OffsetNodeMeshIndices(node->mChildren[i],offset);
}

// ------------------------------------------------------------------------------------------------
// Merges two scenes. Currently only used by the LWS loader.
void SceneCombiner::MergeScenes(aiScene** _dest,std::vector<aiScene*>& src,
    unsigned int flags)
{
    ai_assert(NULL != _dest);

    // if _dest points to NULL allocate a new scene. Otherwise clear the old and reuse it
    if (src.empty())
    {
        if (*_dest)
        {
            (*_dest)->~aiScene();
            SceneCombiner::CopySceneFlat(_dest,src[0]);
        }
        else *_dest = src[0];
        return;
    }
    if (*_dest)(*_dest)->~aiScene();
    else *_dest = new aiScene();

    // Create a dummy scene to serve as master for the others
    aiScene* master = new aiScene();
    master->mRootNode = new aiNode();
    master->mRootNode->mName.Set("<MergeRoot>");

    std::vector<AttachmentInfo> srcList (src.size());
    for (unsigned int i = 0; i < srcList.size();++i)    {
        srcList[i] = AttachmentInfo(src[i],master->mRootNode);
    }

    // 'master' will be deleted afterwards
    MergeScenes (_dest, master, srcList, flags);
}

// ------------------------------------------------------------------------------------------------
void SceneCombiner::AttachToGraph (aiNode* attach, std::vector<NodeAttachmentInfo>& srcList)
{
    unsigned int cnt;
    for (cnt = 0; cnt < attach->mNumChildren;++cnt)
        AttachToGraph(attach->mChildren[cnt],srcList);

    cnt = 0;
    for (std::vector<NodeAttachmentInfo>::iterator it = srcList.begin();
         it != srcList.end(); ++it)
    {
        if ((*it).attachToNode == attach && !(*it).resolved)
            ++cnt;
    }

    if (cnt)    {
        aiNode** n = new aiNode*[cnt+attach->mNumChildren];
        if (attach->mNumChildren)   {
            ::memcpy(n,attach->mChildren,sizeof(void*)*attach->mNumChildren);
            delete[] attach->mChildren;
        }
        attach->mChildren = n;

        n += attach->mNumChildren;
        attach->mNumChildren += cnt;

        for (unsigned int i = 0; i < srcList.size();++i)    {
            NodeAttachmentInfo& att = srcList[i];
            if (att.attachToNode == attach && !att.resolved)    {
                *n = att.node;
                (**n).mParent = attach;
                ++n;

                // mark this attachment as resolved
                att.resolved = true;
            }
        }
    }
}

// ------------------------------------------------------------------------------------------------
void SceneCombiner::AttachToGraph ( aiScene* master,
    std::vector<NodeAttachmentInfo>& src)
{
    ai_assert(NULL != master);
    AttachToGraph(master->mRootNode,src);
}

// ------------------------------------------------------------------------------------------------
void SceneCombiner::MergeScenes(aiScene** _dest, aiScene* master,
    std::vector<AttachmentInfo>& srcList,
    unsigned int flags)
{
    ai_assert(NULL != _dest);

    // if _dest points to NULL allocate a new scene. Otherwise clear the old and reuse it
    if (srcList.empty())    {
        if (*_dest) {
            SceneCombiner::CopySceneFlat(_dest,master);
        }
        else *_dest = master;
        return;
    }
    if (*_dest) {
        (*_dest)->~aiScene();
        new (*_dest) aiScene();
    }
    else *_dest = new aiScene();

    aiScene* dest = *_dest;

    std::vector<SceneHelper> src (srcList.size()+1);
    src[0].scene = master;
    for (unsigned int i = 0; i < srcList.size();++i)    {
        src[i+1] = SceneHelper( srcList[i].scene );
    }

    // this helper array specifies which scenes are duplicates of others
    std::vector<unsigned int> duplicates(src.size(),UINT_MAX);

    // this helper array is used as lookup table several times
    std::vector<unsigned int> offset(src.size());

    // Find duplicate scenes
    for (unsigned int i = 0; i < src.size();++i) {
        if (duplicates[i] != i && duplicates[i] != UINT_MAX) {
            continue;
        }

        duplicates[i] = i;
        for ( unsigned int a = i+1; a < src.size(); ++a)    {
            if (src[i].scene == src[a].scene) {
                duplicates[a] = i;
            }
        }
    }

    // Generate unique names for all named stuff?
    if (flags & AI_INT_MERGE_SCENE_GEN_UNIQUE_NAMES)
    {
#if 0
        // Construct a proper random number generator
        boost::mt19937 rng(  );
        boost::uniform_int<> dist(1u,1 << 24u);
        boost::variate_generator<boost::mt19937&, boost::uniform_int<> > rndGen(rng, dist);
#endif
        for (unsigned int i = 1; i < src.size();++i)
        {
            //if (i != duplicates[i])
            //{
            //  // duplicate scenes share the same UID
            //  ::strcpy( src[i].id, src[duplicates[i]].id );
            //  src[i].idlen = src[duplicates[i]].idlen;

            //  continue;
            //}

            src[i].idlen = ai_snprintf(src[i].id, 32, "$%.6X$_",i);

            if (flags & AI_INT_MERGE_SCENE_GEN_UNIQUE_NAMES_IF_NECESSARY) {

                // Compute hashes for all identifiers in this scene and store them
                // in a sorted table (for convenience I'm using std::set). We hash
                // just the node and animation channel names, all identifiers except
                // the material names should be caught by doing this.
                AddNodeHashes(src[i]->mRootNode,src[i].hashes);

                for (unsigned int a = 0; a < src[i]->mNumAnimations;++a) {
                    aiAnimation* anim = src[i]->mAnimations[a];
                    src[i].hashes.insert(SuperFastHash(anim->mName.data,anim->mName.length));
                }
            }
        }
    }

    unsigned int cnt;

    // First find out how large the respective output arrays must be
    for ( unsigned int n = 0; n < src.size();++n )
    {
        SceneHelper* cur = &src[n];

        if (n == duplicates[n] || flags & AI_INT_MERGE_SCENE_DUPLICATES_DEEP_CPY)   {
            dest->mNumTextures   += (*cur)->mNumTextures;
            dest->mNumMaterials  += (*cur)->mNumMaterials;
            dest->mNumMeshes     += (*cur)->mNumMeshes;
        }

        dest->mNumLights     += (*cur)->mNumLights;
        dest->mNumCameras    += (*cur)->mNumCameras;
        dest->mNumAnimations += (*cur)->mNumAnimations;

        // Combine the flags of all scenes
        // We need to process them flag-by-flag here to get correct results
        // dest->mFlags ; //|= (*cur)->mFlags;
        if ((*cur)->mFlags & AI_SCENE_FLAGS_NON_VERBOSE_FORMAT) {
            dest->mFlags |= AI_SCENE_FLAGS_NON_VERBOSE_FORMAT;
        }
    }

    // generate the output texture list + an offset table for all texture indices
    if (dest->mNumTextures)
    {
        aiTexture** pip = dest->mTextures = new aiTexture*[dest->mNumMaterials];
        cnt = 0;
        for ( unsigned int n = 0; n < src.size();++n )
        {
            SceneHelper* cur = &src[n];
            for (unsigned int i = 0; i < (*cur)->mNumTextures;++i)
            {
                if (n != duplicates[n])
                {
                    if ( flags & AI_INT_MERGE_SCENE_DUPLICATES_DEEP_CPY)
                        Copy(pip,(*cur)->mTextures[i]);

                    else continue;
                }
                else *pip = (*cur)->mTextures[i];
                ++pip;
            }

            offset[n] = cnt;
            cnt = (unsigned int)(pip - dest->mTextures);
        }
    }

    // generate the output material list + an offset table for all material indices
    if (dest->mNumMaterials)
    {
        aiMaterial** pip = dest->mMaterials = new aiMaterial*[dest->mNumMaterials];
        cnt = 0;
        for ( unsigned int n = 0; n < src.size();++n )  {
            SceneHelper* cur = &src[n];
            for (unsigned int i = 0; i < (*cur)->mNumMaterials;++i)
            {
                if (n != duplicates[n])
                {
                    if ( flags & AI_INT_MERGE_SCENE_DUPLICATES_DEEP_CPY)
                        Copy(pip,(*cur)->mMaterials[i]);

                    else continue;
                }
                else *pip = (*cur)->mMaterials[i];

                if ((*cur)->mNumTextures != dest->mNumTextures)     {
                    // We need to update all texture indices of the mesh. So we need to search for
                    // a material property called '$tex.file'

                    for (unsigned int a = 0; a < (*pip)->mNumProperties;++a)
                    {
                        aiMaterialProperty* prop = (*pip)->mProperties[a];
                        if (!strncmp(prop->mKey.data,"$tex.file",9))
                        {
                            // Check whether this texture is an embedded texture.
                            // In this case the property looks like this: *<n>,
                            // where n is the index of the texture.
                            aiString& s = *((aiString*)prop->mData);
                            if ('*' == s.data[0])   {
                                // Offset the index and write it back ..
                                const unsigned int idx = strtoul10(&s.data[1]) + offset[n];
                                ASSIMP_itoa10(&s.data[1],sizeof(s.data)-1,idx);
                            }
                        }

                        // Need to generate new, unique material names?
                        else if (!::strcmp( prop->mKey.data,"$mat.name" ) && flags & AI_INT_MERGE_SCENE_GEN_UNIQUE_MATNAMES)
                        {
                            aiString* pcSrc = (aiString*) prop->mData;
                            PrefixString(*pcSrc, (*cur).id, (*cur).idlen);
                        }
                    }
                }
                ++pip;
            }

            offset[n] = cnt;
            cnt = (unsigned int)(pip - dest->mMaterials);
        }
    }

    // generate the output mesh list + again an offset table for all mesh indices
    if (dest->mNumMeshes)
    {
        aiMesh** pip = dest->mMeshes = new aiMesh*[dest->mNumMeshes];
        cnt = 0;
        for ( unsigned int n = 0; n < src.size();++n )
        {
            SceneHelper* cur = &src[n];
            for (unsigned int i = 0; i < (*cur)->mNumMeshes;++i)
            {
                if (n != duplicates[n]) {
                    if ( flags & AI_INT_MERGE_SCENE_DUPLICATES_DEEP_CPY)
                        Copy(pip, (*cur)->mMeshes[i]);

                    else continue;
                }
                else *pip = (*cur)->mMeshes[i];

                // update the material index of the mesh
                (*pip)->mMaterialIndex +=  offset[n];
                ++pip;
            }

            // reuse the offset array - store now the mesh offset in it
            offset[n] = cnt;
            cnt = (unsigned int)(pip - dest->mMeshes);
        }
    }

    std::vector <NodeAttachmentInfo> nodes;
    nodes.reserve(srcList.size());

    // ----------------------------------------------------------------------------
    // Now generate the output node graph. We need to make those
    // names in the graph that are referenced by anims or lights
    // or cameras unique. So we add a prefix to them ... $<rand>_
    // We could also use a counter, but using a random value allows us to
    // use just one prefix if we are joining multiple scene hierarchies recursively.
    // Chances are quite good we don't collide, so we try that ...
    // ----------------------------------------------------------------------------

    // Allocate space for light sources, cameras and animations
    aiLight** ppLights = dest->mLights = (dest->mNumLights
        ? new aiLight*[dest->mNumLights] : NULL);

    aiCamera** ppCameras = dest->mCameras = (dest->mNumCameras
        ? new aiCamera*[dest->mNumCameras] : NULL);

    aiAnimation** ppAnims = dest->mAnimations = (dest->mNumAnimations
        ? new aiAnimation*[dest->mNumAnimations] : NULL);

    for ( int n = src.size()-1; n >= 0 ;--n ) /* !!! important !!! */
    {
        SceneHelper* cur = &src[n];
        aiNode* node;

        // To offset or not to offset, this is the question
        if (n != (int)duplicates[n])
        {
            // Get full scene-graph copy
            Copy( &node, (*cur)->mRootNode );
            OffsetNodeMeshIndices(node,offset[duplicates[n]]);

            if (flags & AI_INT_MERGE_SCENE_DUPLICATES_DEEP_CPY) {
                // (note:) they are already 'offseted' by offset[duplicates[n]]
                OffsetNodeMeshIndices(node,offset[n] - offset[duplicates[n]]);
            }
        }
        else // if (n == duplicates[n])
        {
            node = (*cur)->mRootNode;
            OffsetNodeMeshIndices(node,offset[n]);
        }
        if (n) // src[0] is the master node
            nodes.push_back(NodeAttachmentInfo( node,srcList[n-1].attachToNode,n ));

        // add name prefixes?
        if (flags & AI_INT_MERGE_SCENE_GEN_UNIQUE_NAMES) {

            // or the whole scenegraph
            if (flags & AI_INT_MERGE_SCENE_GEN_UNIQUE_NAMES_IF_NECESSARY) {
                AddNodePrefixesChecked(node,(*cur).id,(*cur).idlen,src,n);
            }
            else AddNodePrefixes(node,(*cur).id,(*cur).idlen);

            // meshes
            for (unsigned int i = 0; i < (*cur)->mNumMeshes;++i)    {
                aiMesh* mesh = (*cur)->mMeshes[i];

                // rename all bones
                for (unsigned int a = 0; a < mesh->mNumBones;++a)   {
                    if (flags & AI_INT_MERGE_SCENE_GEN_UNIQUE_NAMES_IF_NECESSARY) {
                        if (!FindNameMatch(mesh->mBones[a]->mName,src,n))
                            continue;
                    }
                    PrefixString(mesh->mBones[a]->mName,(*cur).id,(*cur).idlen);
                }
            }
        }

        // --------------------------------------------------------------------
        // Copy light sources
        for (unsigned int i = 0; i < (*cur)->mNumLights;++i,++ppLights)
        {
            if (n != (int)duplicates[n]) // duplicate scene?
            {
                Copy(ppLights, (*cur)->mLights[i]);
            }
            else *ppLights = (*cur)->mLights[i];


            // Add name prefixes?
            if (flags & AI_INT_MERGE_SCENE_GEN_UNIQUE_NAMES) {
                if (flags & AI_INT_MERGE_SCENE_GEN_UNIQUE_NAMES_IF_NECESSARY) {
                    if (!FindNameMatch((*ppLights)->mName,src,n))
                        continue;
                }

                PrefixString((*ppLights)->mName,(*cur).id,(*cur).idlen);
            }
        }

        // --------------------------------------------------------------------
        // Copy cameras
        for (unsigned int i = 0; i < (*cur)->mNumCameras;++i,++ppCameras)   {
            if (n != (int)duplicates[n]) // duplicate scene?
            {
                Copy(ppCameras, (*cur)->mCameras[i]);
            }
            else *ppCameras = (*cur)->mCameras[i];

            // Add name prefixes?
            if (flags & AI_INT_MERGE_SCENE_GEN_UNIQUE_NAMES) {
                if (flags & AI_INT_MERGE_SCENE_GEN_UNIQUE_NAMES_IF_NECESSARY) {
                    if (!FindNameMatch((*ppCameras)->mName,src,n))
                        continue;
                }

                PrefixString((*ppCameras)->mName,(*cur).id,(*cur).idlen);
            }
        }

        // --------------------------------------------------------------------
        // Copy animations
        for (unsigned int i = 0; i < (*cur)->mNumAnimations;++i,++ppAnims)  {
            if (n != (int)duplicates[n]) // duplicate scene?
            {
                Copy(ppAnims, (*cur)->mAnimations[i]);
            }
            else *ppAnims = (*cur)->mAnimations[i];

            // Add name prefixes?
            if (flags & AI_INT_MERGE_SCENE_GEN_UNIQUE_NAMES) {
                if (flags & AI_INT_MERGE_SCENE_GEN_UNIQUE_NAMES_IF_NECESSARY) {
                    if (!FindNameMatch((*ppAnims)->mName,src,n))
                        continue;
                }

                PrefixString((*ppAnims)->mName,(*cur).id,(*cur).idlen);

                // don't forget to update all node animation channels
                for (unsigned int a = 0; a < (*ppAnims)->mNumChannels;++a) {
                    if (flags & AI_INT_MERGE_SCENE_GEN_UNIQUE_NAMES_IF_NECESSARY) {
                        if (!FindNameMatch((*ppAnims)->mChannels[a]->mNodeName,src,n))
                            continue;
                    }

                    PrefixString((*ppAnims)->mChannels[a]->mNodeName,(*cur).id,(*cur).idlen);
                }
            }
        }
    }

    // Now build the output graph
    AttachToGraph ( master, nodes);
    dest->mRootNode = master->mRootNode;

    // Check whether we succeeded at building the output graph
    for (std::vector <NodeAttachmentInfo> ::iterator it = nodes.begin();
        it != nodes.end(); ++it)
    {
        if (!(*it).resolved) {
            if (flags & AI_INT_MERGE_SCENE_RESOLVE_CROSS_ATTACHMENTS) {
                // search for this attachment point in all other imported scenes, too.
                for ( unsigned int n = 0; n < src.size();++n ) {
                    if (n != (*it).src_idx) {
                        AttachToGraph(src[n].scene,nodes);
                        if ((*it).resolved)
                            break;
                    }
                }
            }
            if (!(*it).resolved) {
                DefaultLogger::get()->error(std::string("SceneCombiner: Failed to resolve attachment ")
                    + (*it).node->mName.data + " " + (*it).attachToNode->mName.data);
            }
        }
    }

    // now delete all input scenes. Make sure duplicate scenes aren't
    // deleted more than one time
    for ( unsigned int n = 0; n < src.size();++n )  {
        if (n != duplicates[n]) // duplicate scene?
            continue;

        aiScene* deleteMe = src[n].scene;

        // We need to delete the arrays before the destructor is called -
        // we are reusing the array members
        delete[] deleteMe->mMeshes;     deleteMe->mMeshes     = NULL;
        delete[] deleteMe->mCameras;    deleteMe->mCameras    = NULL;
        delete[] deleteMe->mLights;     deleteMe->mLights     = NULL;
        delete[] deleteMe->mMaterials;  deleteMe->mMaterials  = NULL;
        delete[] deleteMe->mAnimations; deleteMe->mAnimations = NULL;

        deleteMe->mRootNode = NULL;

        // Now we can safely delete the scene
        delete deleteMe;
    }

    // Check flags
    if (!dest->mNumMeshes || !dest->mNumMaterials) {
        dest->mFlags |= AI_SCENE_FLAGS_INCOMPLETE;
    }

    // We're finished
}

// ------------------------------------------------------------------------------------------------
// Build a list of unique bones
void SceneCombiner::BuildUniqueBoneList(std::list<BoneWithHash>& asBones,
    std::vector<aiMesh*>::const_iterator it,
    std::vector<aiMesh*>::const_iterator end)
{
    unsigned int iOffset = 0;
    for (; it != end;++it)  {
        for (unsigned int l = 0; l < (*it)->mNumBones;++l)  {
            aiBone* p = (*it)->mBones[l];
            uint32_t itml = SuperFastHash(p->mName.data,(unsigned int)p->mName.length);

            std::list<BoneWithHash>::iterator it2  = asBones.begin();
            std::list<BoneWithHash>::iterator end2 = asBones.end();

            for (;it2 != end2;++it2)    {
                if ((*it2).first == itml)   {
                    (*it2).pSrcBones.push_back(BoneSrcIndex(p,iOffset));
                    break;
                }
            }
            if (end2 == it2)    {
                // need to begin a new bone entry
                asBones.push_back(BoneWithHash());
                BoneWithHash& btz = asBones.back();

                // setup members
                btz.first = itml;
                btz.second = &p->mName;
                btz.pSrcBones.push_back(BoneSrcIndex(p,iOffset));
            }
        }
        iOffset += (*it)->mNumVertices;
    }
}

// ------------------------------------------------------------------------------------------------
// Merge a list of bones
void SceneCombiner::MergeBones(aiMesh* out,std::vector<aiMesh*>::const_iterator it,
    std::vector<aiMesh*>::const_iterator end)
{
    ai_assert(NULL != out && !out->mNumBones);

    // find we need to build an unique list of all bones.
    // we work with hashes to make the comparisons MUCH faster,
    // at least if we have many bones.
    std::list<BoneWithHash> asBones;
    BuildUniqueBoneList(asBones, it,end);

    // now create the output bones
    out->mNumBones = 0;
    out->mBones = new aiBone*[asBones.size()];

    for (std::list<BoneWithHash>::const_iterator it = asBones.begin(),end = asBones.end(); it != end;++it)  {
        // Allocate a bone and setup it's name
        aiBone* pc = out->mBones[out->mNumBones++] = new aiBone();
        pc->mName = aiString( *((*it).second ));

        std::vector< BoneSrcIndex >::const_iterator wend = (*it).pSrcBones.end();

        // Loop through all bones to be joined for this bone
        for (std::vector< BoneSrcIndex >::const_iterator wmit = (*it).pSrcBones.begin(); wmit != wend; ++wmit)  {
            pc->mNumWeights += (*wmit).first->mNumWeights;

            // NOTE: different offset matrices for bones with equal names
            // are - at the moment - not handled correctly.
            if (wmit != (*it).pSrcBones.begin() && pc->mOffsetMatrix != (*wmit).first->mOffsetMatrix)   {
                DefaultLogger::get()->warn("Bones with equal names but different offset matrices can't be joined at the moment");
                continue;
            }
            pc->mOffsetMatrix = (*wmit).first->mOffsetMatrix;
        }

        // Allocate the vertex weight array
        aiVertexWeight* avw = pc->mWeights = new aiVertexWeight[pc->mNumWeights];

        // And copy the final weights - adjust the vertex IDs by the
        // face index offset of the coresponding mesh.
        for (std::vector< BoneSrcIndex >::const_iterator wmit = (*it).pSrcBones.begin(); wmit != wend; ++wmit)  {
            aiBone* pip = (*wmit).first;
            for (unsigned int mp = 0; mp < pip->mNumWeights;++mp,++avw) {
                const aiVertexWeight& vfi = pip->mWeights[mp];
                avw->mWeight = vfi.mWeight;
                avw->mVertexId = vfi.mVertexId + (*wmit).second;
            }
        }
    }
}

// ------------------------------------------------------------------------------------------------
// Merge a list of meshes
void SceneCombiner::MergeMeshes(aiMesh** _out,unsigned int /*flags*/,
    std::vector<aiMesh*>::const_iterator begin,
    std::vector<aiMesh*>::const_iterator end)
{
    ai_assert(NULL != _out);

    if (begin == end)   {
        *_out = NULL; // no meshes ...
        return;
    }

    // Allocate the output mesh
    aiMesh* out = *_out = new aiMesh();
    out->mMaterialIndex = (*begin)->mMaterialIndex;

    // Find out how much output storage we'll need
    for (std::vector<aiMesh*>::const_iterator it = begin; it != end;++it)   {
        out->mNumVertices   += (*it)->mNumVertices;
        out->mNumFaces      += (*it)->mNumFaces;
        out->mNumBones      += (*it)->mNumBones;

        // combine primitive type flags
        out->mPrimitiveTypes |= (*it)->mPrimitiveTypes;
    }

    if (out->mNumVertices) {
        aiVector3D* pv2;

        // copy vertex positions
        if ((**begin).HasPositions())   {

            pv2 = out->mVertices = new aiVector3D[out->mNumVertices];
            for (std::vector<aiMesh*>::const_iterator it = begin; it != end;++it)   {
                if ((*it)->mVertices)   {
                    ::memcpy(pv2,(*it)->mVertices,(*it)->mNumVertices*sizeof(aiVector3D));
                }
                else DefaultLogger::get()->warn("JoinMeshes: Positions expected but input mesh contains no positions");
                pv2 += (*it)->mNumVertices;
            }
        }
        // copy normals
        if ((**begin).HasNormals()) {

            pv2 = out->mNormals = new aiVector3D[out->mNumVertices];
            for (std::vector<aiMesh*>::const_iterator it = begin; it != end;++it)   {
                if ((*it)->mNormals)    {
                    ::memcpy(pv2,(*it)->mNormals,(*it)->mNumVertices*sizeof(aiVector3D));
                }
                else DefaultLogger::get()->warn("JoinMeshes: Normals expected but input mesh contains no normals");
                pv2 += (*it)->mNumVertices;
            }
        }
        // copy tangents and bitangents
        if ((**begin).HasTangentsAndBitangents())   {

            pv2 = out->mTangents = new aiVector3D[out->mNumVertices];
            aiVector3D* pv2b = out->mBitangents = new aiVector3D[out->mNumVertices];

            for (std::vector<aiMesh*>::const_iterator it = begin; it != end;++it)   {
                if ((*it)->mTangents)   {
                    ::memcpy(pv2, (*it)->mTangents,  (*it)->mNumVertices*sizeof(aiVector3D));
                    ::memcpy(pv2b,(*it)->mBitangents,(*it)->mNumVertices*sizeof(aiVector3D));
                }
                else DefaultLogger::get()->warn("JoinMeshes: Tangents expected but input mesh contains no tangents");
                pv2  += (*it)->mNumVertices;
                pv2b += (*it)->mNumVertices;
            }
        }
        // copy texture coordinates
        unsigned int n = 0;
        while ((**begin).HasTextureCoords(n))   {
            out->mNumUVComponents[n] = (*begin)->mNumUVComponents[n];

            pv2 = out->mTextureCoords[n] = new aiVector3D[out->mNumVertices];
            for (std::vector<aiMesh*>::const_iterator it = begin; it != end;++it)   {

                if ((*it)->mTextureCoords[n])   {
                    ::memcpy(pv2,(*it)->mTextureCoords[n],(*it)->mNumVertices*sizeof(aiVector3D));
                }
                else DefaultLogger::get()->warn("JoinMeshes: UVs expected but input mesh contains no UVs");
                pv2 += (*it)->mNumVertices;
            }
            ++n;
        }
        // copy vertex colors
        n = 0;
        while ((**begin).HasVertexColors(n))    {
            aiColor4D* pv2 = out->mColors[n] = new aiColor4D[out->mNumVertices];
            for (std::vector<aiMesh*>::const_iterator it = begin; it != end;++it)   {

                if ((*it)->mColors[n])  {
                    ::memcpy(pv2,(*it)->mColors[n],(*it)->mNumVertices*sizeof(aiColor4D));
                }
                else DefaultLogger::get()->warn("JoinMeshes: VCs expected but input mesh contains no VCs");
                pv2 += (*it)->mNumVertices;
            }
            ++n;
        }
    }

    if (out->mNumFaces) // just for safety
    {
        // copy faces
        out->mFaces = new aiFace[out->mNumFaces];
        aiFace* pf2 = out->mFaces;

        unsigned int ofs = 0;
        for (std::vector<aiMesh*>::const_iterator it = begin; it != end;++it)   {
            for (unsigned int m = 0; m < (*it)->mNumFaces;++m,++pf2)    {
                aiFace& face = (*it)->mFaces[m];
                pf2->mNumIndices = face.mNumIndices;
                pf2->mIndices = face.mIndices;

                if (ofs)    {
                    // add the offset to the vertex
                    for (unsigned int q = 0; q < face.mNumIndices; ++q)
                        face.mIndices[q] += ofs;
                }
                face.mIndices = NULL;
            }
            ofs += (*it)->mNumVertices;
        }
    }

    // bones - as this is quite lengthy, I moved the code to a separate function
    if (out->mNumBones)
        MergeBones(out,begin,end);

    // delete all source meshes
    for (std::vector<aiMesh*>::const_iterator it = begin; it != end;++it)
        delete *it;
}

// ------------------------------------------------------------------------------------------------
void SceneCombiner::MergeMaterials(aiMaterial** dest,
        std::vector<aiMaterial*>::const_iterator begin,
        std::vector<aiMaterial*>::const_iterator end)
{
    ai_assert(NULL != dest);

    if (begin == end)   {
        *dest = NULL; // no materials ...
        return;
    }

    // Allocate the output material
    aiMaterial* out = *dest = new aiMaterial();

    // Get the maximal number of properties
    unsigned int size = 0;
    for (std::vector<aiMaterial*>::const_iterator it = begin; it != end; ++it) {
        size += (*it)->mNumProperties;
    }

    out->Clear();
    delete[] out->mProperties;

    out->mNumAllocated = size;
    out->mNumProperties = 0;
    out->mProperties = new aiMaterialProperty*[out->mNumAllocated];

    for (std::vector<aiMaterial*>::const_iterator it = begin; it != end; ++it) {
        for(unsigned int i = 0; i < (*it)->mNumProperties; ++i) {
            aiMaterialProperty* sprop = (*it)->mProperties[i];

            // Test if we already have a matching property
            const aiMaterialProperty* prop_exist;
            if(aiGetMaterialProperty(out, sprop->mKey.C_Str(), sprop->mSemantic, sprop->mIndex, &prop_exist) != AI_SUCCESS) {
                // If not, we add it to the new material
                aiMaterialProperty* prop = out->mProperties[out->mNumProperties] = new aiMaterialProperty();

                prop->mDataLength = sprop->mDataLength;
                prop->mData = new char[prop->mDataLength];
                ::memcpy(prop->mData, sprop->mData, prop->mDataLength);

                prop->mIndex    = sprop->mIndex;
                prop->mSemantic = sprop->mSemantic;
                prop->mKey      = sprop->mKey;
                prop->mType     = sprop->mType;

                out->mNumProperties++;
            }
        }
    }
}

// ------------------------------------------------------------------------------------------------
template <typename Type>
inline void CopyPtrArray (Type**& dest, const Type* const * src, unsigned int num)
{
    if (!num)
    {
        dest = NULL;
        return;
    }
    dest = new Type*[num];
    for (unsigned int i = 0; i < num;++i) {
        SceneCombiner::Copy(&dest[i],src[i]);
    }
}

// ------------------------------------------------------------------------------------------------
template <typename Type>
inline void GetArrayCopy (Type*& dest, unsigned int num )
{
    if (!dest)return;
    Type* old = dest;

    dest = new Type[num];
    ::memcpy(dest, old, sizeof(Type) * num);
}

// ------------------------------------------------------------------------------------------------
void SceneCombiner::CopySceneFlat(aiScene** _dest,const aiScene* src)
{
    // reuse the old scene or allocate a new?
    if (*_dest) {
        (*_dest)->~aiScene();
        new (*_dest) aiScene();
    }
    else *_dest = new aiScene();

    ::memcpy(*_dest,src,sizeof(aiScene));
}

// ------------------------------------------------------------------------------------------------
void SceneCombiner::CopyScene(aiScene** _dest,const aiScene* src,bool allocate)
{
    ai_assert(NULL != _dest && NULL != src);

    if (allocate) {
        *_dest = new aiScene();
    }
    aiScene* dest = *_dest;
    ai_assert(dest);

    // copy animations
    dest->mNumAnimations = src->mNumAnimations;
    CopyPtrArray(dest->mAnimations,src->mAnimations,
        dest->mNumAnimations);

    // copy textures
    dest->mNumTextures = src->mNumTextures;
    CopyPtrArray(dest->mTextures,src->mTextures,
        dest->mNumTextures);

    // copy materials
    dest->mNumMaterials = src->mNumMaterials;
    CopyPtrArray(dest->mMaterials,src->mMaterials,
        dest->mNumMaterials);

    // copy lights
    dest->mNumLights = src->mNumLights;
    CopyPtrArray(dest->mLights,src->mLights,
        dest->mNumLights);

    // copy cameras
    dest->mNumCameras = src->mNumCameras;
    CopyPtrArray(dest->mCameras,src->mCameras,
        dest->mNumCameras);

    // copy meshes
    dest->mNumMeshes = src->mNumMeshes;
    CopyPtrArray(dest->mMeshes,src->mMeshes,
        dest->mNumMeshes);

    // now - copy the root node of the scene (deep copy, too)
    Copy( &dest->mRootNode, src->mRootNode);

    // and keep the flags ...
    dest->mFlags = src->mFlags;

    // source private data might be NULL if the scene is user-allocated (i.e. for use with the export API)
    if (dest->mPrivate != NULL) {
        ScenePriv(dest)->mPPStepsApplied = ScenePriv(src) ? ScenePriv(src)->mPPStepsApplied : 0;
    }
}

// ------------------------------------------------------------------------------------------------
void SceneCombiner::Copy     (aiMesh** _dest, const aiMesh* src)
{
    ai_assert(NULL != _dest && NULL != src);

    aiMesh* dest = *_dest = new aiMesh();

    // get a flat copy
    ::memcpy(dest,src,sizeof(aiMesh));

    // and reallocate all arrays
    GetArrayCopy( dest->mVertices,   dest->mNumVertices );
    GetArrayCopy( dest->mNormals ,   dest->mNumVertices );
    GetArrayCopy( dest->mTangents,   dest->mNumVertices );
    GetArrayCopy( dest->mBitangents, dest->mNumVertices );

    unsigned int n = 0;
    while (dest->HasTextureCoords(n))
        GetArrayCopy( dest->mTextureCoords[n++],   dest->mNumVertices );

    n = 0;
    while (dest->HasVertexColors(n))
        GetArrayCopy( dest->mColors[n++],   dest->mNumVertices );

    // make a deep copy of all bones
    CopyPtrArray(dest->mBones,dest->mBones,dest->mNumBones);

    // make a deep copy of all faces
    GetArrayCopy(dest->mFaces,dest->mNumFaces);
    for (unsigned int i = 0; i < dest->mNumFaces;++i)
    {
        aiFace& f = dest->mFaces[i];
        GetArrayCopy(f.mIndices,f.mNumIndices);
    }
}

// ------------------------------------------------------------------------------------------------
void SceneCombiner::Copy (aiMaterial** _dest, const aiMaterial* src)
{
    ai_assert(NULL != _dest && NULL != src);

    aiMaterial* dest = (aiMaterial*) ( *_dest = new aiMaterial() );

    dest->Clear();
    delete[] dest->mProperties;

    dest->mNumAllocated  =  src->mNumAllocated;
    dest->mNumProperties =  src->mNumProperties;
    dest->mProperties    =  new aiMaterialProperty* [dest->mNumAllocated];

    for (unsigned int i = 0; i < dest->mNumProperties;++i)
    {
        aiMaterialProperty* prop  = dest->mProperties[i] = new aiMaterialProperty();
        aiMaterialProperty* sprop = src->mProperties[i];

        prop->mDataLength = sprop->mDataLength;
        prop->mData = new char[prop->mDataLength];
        ::memcpy(prop->mData,sprop->mData,prop->mDataLength);

        prop->mIndex    = sprop->mIndex;
        prop->mSemantic = sprop->mSemantic;
        prop->mKey      = sprop->mKey;
        prop->mType     = sprop->mType;
    }
}

// ------------------------------------------------------------------------------------------------
void SceneCombiner::Copy  (aiTexture** _dest, const aiTexture* src)
{
    ai_assert(NULL != _dest && NULL != src);

    aiTexture* dest = *_dest = new aiTexture();

    // get a flat copy
    ::memcpy(dest,src,sizeof(aiTexture));

    // and reallocate all arrays. We must do it manually here
    const char* old = (const char*)dest->pcData;
    if (old)
    {
        unsigned int cpy;
        if (!dest->mHeight)cpy = dest->mWidth;
        else cpy = dest->mHeight * dest->mWidth * sizeof(aiTexel);

        if (!cpy)
        {
            dest->pcData = NULL;
            return;
        }
        // the cast is legal, the aiTexel c'tor does nothing important
        dest->pcData = (aiTexel*) new char[cpy];
        ::memcpy(dest->pcData, old, cpy);
    }
}

// ------------------------------------------------------------------------------------------------
void SceneCombiner::Copy( aiAnimation** _dest, const aiAnimation* src )
{
    ai_assert( NULL != _dest );
    ai_assert( NULL != src );
    
    aiAnimation* dest = *_dest = new aiAnimation();

    // get a flat copy
    ::memcpy(dest,src,sizeof(aiAnimation));

    // and reallocate all arrays
    CopyPtrArray( dest->mChannels, src->mChannels, dest->mNumChannels );
}

// ------------------------------------------------------------------------------------------------
void SceneCombiner::Copy     (aiNodeAnim** _dest, const aiNodeAnim* src)
{
    ai_assert(NULL != _dest && NULL != src);

    aiNodeAnim* dest = *_dest = new aiNodeAnim();

    // get a flat copy
    ::memcpy(dest,src,sizeof(aiNodeAnim));

    // and reallocate all arrays
    GetArrayCopy( dest->mPositionKeys, dest->mNumPositionKeys );
    GetArrayCopy( dest->mScalingKeys,  dest->mNumScalingKeys );
    GetArrayCopy( dest->mRotationKeys, dest->mNumRotationKeys );
}

// ------------------------------------------------------------------------------------------------
void SceneCombiner::Copy   (aiCamera** _dest,const  aiCamera* src)
{
    ai_assert(NULL != _dest && NULL != src);

    aiCamera* dest = *_dest = new aiCamera();

    // get a flat copy, that's already OK
    ::memcpy(dest,src,sizeof(aiCamera));
}

// ------------------------------------------------------------------------------------------------
void SceneCombiner::Copy   (aiLight** _dest, const aiLight* src)
{
    ai_assert(NULL != _dest && NULL != src);

    aiLight* dest = *_dest = new aiLight();

    // get a flat copy, that's already OK
    ::memcpy(dest,src,sizeof(aiLight));
}

// ------------------------------------------------------------------------------------------------
void SceneCombiner::Copy     (aiBone** _dest, const aiBone* src)
{
    ai_assert(NULL != _dest && NULL != src);

    aiBone* dest = *_dest = new aiBone();

    // get a flat copy
    ::memcpy(dest,src,sizeof(aiBone));

    // and reallocate all arrays
    GetArrayCopy( dest->mWeights, dest->mNumWeights );
}

// ------------------------------------------------------------------------------------------------
void SceneCombiner::Copy     (aiNode** _dest, const aiNode* src)
{
    ai_assert(NULL != _dest && NULL != src);

    aiNode* dest = *_dest = new aiNode();

    // get a flat copy
    ::memcpy(dest,src,sizeof(aiNode));

    if (src->mMetaData) {
        Copy(&dest->mMetaData, src->mMetaData);
    }

    // and reallocate all arrays
    GetArrayCopy( dest->mMeshes, dest->mNumMeshes );
    CopyPtrArray( dest->mChildren, src->mChildren,dest->mNumChildren);

	// need to set the mParent fields to the created aiNode.
	for( unsigned int i = 0; i < dest->mNumChildren; i ++ ) {
		dest->mChildren[i]->mParent = dest;
	}
}

// ------------------------------------------------------------------------------------------------
void SceneCombiner::Copy (aiMetadata** _dest, const aiMetadata* src)
{
    ai_assert(NULL != _dest && NULL != src);

    aiMetadata* dest = *_dest = new aiMetadata();
    dest->mNumProperties = src->mNumProperties;
    dest->mKeys = new aiString[src->mNumProperties];
    std::copy(src->mKeys, src->mKeys + src->mNumProperties, dest->mKeys);

    dest->mValues = new aiMetadataEntry[src->mNumProperties];
    for (unsigned int i = 0; i < src->mNumProperties; ++i) {
        aiMetadataEntry& in = src->mValues[i];
        aiMetadataEntry& out = dest->mValues[i];
        out.mType = in.mType;
        switch (dest->mValues[i].mType) {
        case AI_BOOL:
            out.mData = new bool(*static_cast<bool*>(in.mData));
            break;
        case AI_INT:
            out.mData = new int(*static_cast<int*>(in.mData));
            break;
        case AI_UINT64:
            out.mData = new uint64_t(*static_cast<uint64_t*>(in.mData));
            break;
        case AI_FLOAT:
            out.mData = new float(*static_cast<float*>(in.mData));
            break;
        case AI_AISTRING:
            out.mData = new aiString(*static_cast<aiString*>(in.mData));
            break;
        case AI_AIVECTOR3D:
            out.mData = new aiVector3D(*static_cast<aiVector3D*>(in.mData));
            break;
        default:
            ai_assert(false);
        }
    }
}

}

/***********************************************************************
FBXIMPORT\SCENEPREPROCESSOR.CPP
***********************************************************************/
/*
Open Asset Import Library (assimp)
----------------------------------------------------------------------

Copyright (c) 2006-2016, assimp team
All rights reserved.

Redistribution and use of this software in source and binary forms,
with or without modification, are permitted provided that the
following conditions are met:

* Redistributions of source code must retain the above
  copyright notice, this list of conditions and the
  following disclaimer.

* Redistributions in binary form must reproduce the above
  copyright notice, this list of conditions and the
  following disclaimer in the documentation and/or other
  materials provided with the distribution.

* Neither the name of the assimp team, nor the names of its
  contributors may be used to endorse or promote products
  derived from this software without specific prior
  written permission of the assimp team.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
"AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

----------------------------------------------------------------------
*/



using namespace Assimp;

// ---------------------------------------------------------------------------------------------
void ScenePreprocessor::ProcessScene ()
{
    ai_assert(scene != NULL);

    // Process all meshes
    for (unsigned int i = 0; i < scene->mNumMeshes;++i)
        ProcessMesh(scene->mMeshes[i]);

    // - nothing to do for nodes for the moment
    // - nothing to do for textures for the moment
    // - nothing to do for lights for the moment
    // - nothing to do for cameras for the moment

    // Process all animations
    for (unsigned int i = 0; i < scene->mNumAnimations;++i)
        ProcessAnimation(scene->mAnimations[i]);

    // Generate a default material if none was specified
    if (!scene->mNumMaterials && scene->mNumMeshes) {
        scene->mMaterials      = new aiMaterial*[2];
        aiMaterial* helper;

        aiString name;

        scene->mMaterials[scene->mNumMaterials] = helper = new aiMaterial();
        aiColor3D clr(0.6f,0.6f,0.6f);
        helper->AddProperty(&clr,1,AI_MATKEY_COLOR_DIFFUSE);

        // setup the default name to make this material identifiable
        name.Set(AI_DEFAULT_MATERIAL_NAME);
        helper->AddProperty(&name,AI_MATKEY_NAME);

        DefaultLogger::get()->debug("ScenePreprocessor: Adding default material \'" AI_DEFAULT_MATERIAL_NAME  "\'");

        for (unsigned int i = 0; i < scene->mNumMeshes;++i) {
            scene->mMeshes[i]->mMaterialIndex = scene->mNumMaterials;
        }

        scene->mNumMaterials++;
    }
}

// ---------------------------------------------------------------------------------------------
void ScenePreprocessor::ProcessMesh (aiMesh* mesh)
{
    // If aiMesh::mNumUVComponents is *not* set assign the default value of 2
    for (unsigned int i = 0; i < AI_MAX_NUMBER_OF_TEXTURECOORDS; ++i)   {
        if (!mesh->mTextureCoords[i]) {
            mesh->mNumUVComponents[i] = 0;
        } else {
            if (!mesh->mNumUVComponents[i])
                mesh->mNumUVComponents[i] = 2;

            aiVector3D* p = mesh->mTextureCoords[i], *end = p+mesh->mNumVertices;

            // Ensure unsued components are zeroed. This will make 1D texture channels work
            // as if they were 2D channels .. just in case an application doesn't handle
            // this case
            if (2 == mesh->mNumUVComponents[i]) {
                for (; p != end; ++p)
                    p->z = 0.f;
            }
            else if (1 == mesh->mNumUVComponents[i]) {
                for (; p != end; ++p)
                    p->z = p->y = 0.f;
            }
            else if (3 == mesh->mNumUVComponents[i]) {
                // Really 3D coordinates? Check whether the third coordinate is != 0 for at least one element
                for (; p != end; ++p) {
                    if (p->z != 0)
                        break;
                }
                if (p == end) {
                    DefaultLogger::get()->warn("ScenePreprocessor: UVs are declared to be 3D but they're obviously not. Reverting to 2D.");
                    mesh->mNumUVComponents[i] = 2;
                }
            }
        }
    }

    // If the information which primitive types are there in the
    // mesh is currently not available, compute it.
    if (!mesh->mPrimitiveTypes) {
        for (unsigned int a = 0; a < mesh->mNumFaces; ++a)  {
            aiFace& face = mesh->mFaces[a];
            switch (face.mNumIndices)
            {
            case 3u:
                mesh->mPrimitiveTypes |= aiPrimitiveType_TRIANGLE;
                break;

            case 2u:
                mesh->mPrimitiveTypes |= aiPrimitiveType_LINE;
                break;

            case 1u:
                mesh->mPrimitiveTypes |= aiPrimitiveType_POINT;
                break;

            default:
                mesh->mPrimitiveTypes |= aiPrimitiveType_POLYGON;
                break;
            }
        }
    }

    // If tangents and normals are given but no bitangents compute them
    if (mesh->mTangents && mesh->mNormals && !mesh->mBitangents)    {

        mesh->mBitangents = new aiVector3D[mesh->mNumVertices];
        for (unsigned int i = 0; i < mesh->mNumVertices;++i)    {
            mesh->mBitangents[i] = mesh->mNormals[i] ^ mesh->mTangents[i];
        }
    }
}

// ---------------------------------------------------------------------------------------------
void ScenePreprocessor::ProcessAnimation (aiAnimation* anim)
{
    double first = 10e10, last = -10e10;
    for (unsigned int i = 0; i < anim->mNumChannels;++i)    {
        aiNodeAnim* channel = anim->mChannels[i];

        /*  If the exact duration of the animation is not given
         *  compute it now.
         */
        if (anim->mDuration == -1.) {

            // Position keys
            for (unsigned int i = 0; i < channel->mNumPositionKeys;++i) {
                aiVectorKey& key = channel->mPositionKeys[i];
                first = std::min (first, key.mTime);
                last  = std::max (last,  key.mTime);
            }

            // Scaling keys
            for (unsigned int i = 0; i < channel->mNumScalingKeys;++i)  {
                aiVectorKey& key = channel->mScalingKeys[i];
                first = std::min (first, key.mTime);
                last  = std::max (last,  key.mTime);
            }

            // Rotation keys
            for (unsigned int i = 0; i < channel->mNumRotationKeys;++i) {
                aiQuatKey& key = channel->mRotationKeys[i];
                first = std::min (first, key.mTime);
                last  = std::max (last,  key.mTime);
            }
        }

        /*  Check whether the animation channel has no rotation
         *  or position tracks. In this case we generate a dummy
         *  track from the information we have in the transformation
         *  matrix of the corresponding node.
         */
        if (!channel->mNumRotationKeys || !channel->mNumPositionKeys || !channel->mNumScalingKeys)  {
            // Find the node that belongs to this animation
            aiNode* node = scene->mRootNode->FindNode(channel->mNodeName);
            if (node) // ValidateDS will complain later if 'node' is NULL
            {
                // Decompose the transformation matrix of the node
                aiVector3D scaling, position;
                aiQuaternion rotation;

                node->mTransformation.Decompose(scaling, rotation,position);

                // No rotation keys? Generate a dummy track
                if (!channel->mNumRotationKeys) {
                    channel->mNumRotationKeys = 1;
                    channel->mRotationKeys = new aiQuatKey[1];
                    aiQuatKey& q = channel->mRotationKeys[0];

                    q.mTime  = 0.;
                    q.mValue = rotation;

                    DefaultLogger::get()->debug("ScenePreprocessor: Dummy rotation track has been generated");
                }

                // No scaling keys? Generate a dummy track
                if (!channel->mNumScalingKeys)  {
                    channel->mNumScalingKeys = 1;
                    channel->mScalingKeys = new aiVectorKey[1];
                    aiVectorKey& q = channel->mScalingKeys[0];

                    q.mTime  = 0.;
                    q.mValue = scaling;

                    DefaultLogger::get()->debug("ScenePreprocessor: Dummy scaling track has been generated");
                }

                // No position keys? Generate a dummy track
                if (!channel->mNumPositionKeys) {
                    channel->mNumPositionKeys = 1;
                    channel->mPositionKeys = new aiVectorKey[1];
                    aiVectorKey& q = channel->mPositionKeys[0];

                    q.mTime  = 0.;
                    q.mValue = position;

                    DefaultLogger::get()->debug("ScenePreprocessor: Dummy position track has been generated");
                }
            }
        }
    }

    if (anim->mDuration == -1.)     {
        DefaultLogger::get()->debug("ScenePreprocessor: Setting animation duration");
        anim->mDuration = last - std::min( first, 0. );
    }
}

/***********************************************************************
FBXIMPORT\SORTBYPTYPEPROCESS.CPP
***********************************************************************/
/*
---------------------------------------------------------------------------
Open Asset Import Library (assimp)
---------------------------------------------------------------------------

Copyright (c) 2006-2016, assimp team

All rights reserved.

Redistribution and use of this software in source and binary forms,
with or without modification, are permitted provided that the following
conditions are met:

* Redistributions of source code must retain the above
  copyright notice, this list of conditions and the
  following disclaimer.

* Redistributions in binary form must reproduce the above
  copyright notice, this list of conditions and the
  following disclaimer in the documentation and/or other
  materials provided with the distribution.

* Neither the name of the assimp team, nor the names of its
  contributors may be used to endorse or promote products
  derived from this software without specific prior
  written permission of the assimp team.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
"AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
---------------------------------------------------------------------------
*/

/** @file Implementation of the DeterminePTypeHelperProcess and
 *  SortByPTypeProcess post-process steps.
*/



// internal headers

using namespace Assimp;

// ------------------------------------------------------------------------------------------------
// Constructor to be privately used by Importer
SortByPTypeProcess::SortByPTypeProcess()
{
    configRemoveMeshes = 0;
}

// ------------------------------------------------------------------------------------------------
// Destructor, private as well
SortByPTypeProcess::~SortByPTypeProcess()
{
    // nothing to do here
}

// ------------------------------------------------------------------------------------------------
// Returns whether the processing step is present in the given flag field.
bool SortByPTypeProcess::IsActive( unsigned int pFlags) const
{
    return  (pFlags & aiProcess_SortByPType) != 0;
}

// ------------------------------------------------------------------------------------------------
void SortByPTypeProcess::SetupProperties(const Importer* pImp)
{
    configRemoveMeshes = pImp->GetPropertyInteger(AI_CONFIG_PP_SBP_REMOVE,0);
}

// ------------------------------------------------------------------------------------------------
// Update changed meshes in all nodes
void UpdateNodes(const std::vector<unsigned int>& replaceMeshIndex, aiNode* node)
{
//  std::vector<unsigned int>::const_iterator it;

    if (node->mNumMeshes)
    {
        unsigned int newSize = 0;
        for (unsigned int m = 0; m< node->mNumMeshes; ++m)
        {
            unsigned int add = node->mMeshes[m]<<2;
            for (unsigned int i = 0; i < 4;++i)
            {
                if (UINT_MAX != replaceMeshIndex[add+i])++newSize;
            }
        }
        if (!newSize)
        {
            delete[] node->mMeshes;
            node->mNumMeshes = 0;
            node->mMeshes    = NULL;
        }
        else
        {
            // Try to reuse the old array if possible
            unsigned int* newMeshes = (newSize > node->mNumMeshes
                ? new unsigned int[newSize] : node->mMeshes);

            for (unsigned int m = 0; m< node->mNumMeshes; ++m)
            {
                unsigned int add = node->mMeshes[m]<<2;
                for (unsigned int i = 0; i < 4;++i)
                {
                    if (UINT_MAX != replaceMeshIndex[add+i])
                        *newMeshes++ = replaceMeshIndex[add+i];
                }
            }
            if (newSize > node->mNumMeshes)
                delete[] node->mMeshes;

            node->mMeshes = newMeshes-(node->mNumMeshes = newSize);
        }
    }

    // call all subnodes recursively
    for (unsigned int m = 0; m < node->mNumChildren; ++m)
        UpdateNodes(replaceMeshIndex,node->mChildren[m]);
}

// ------------------------------------------------------------------------------------------------
// Executes the post processing step on the given imported data.
void SortByPTypeProcess::Execute( aiScene* pScene)
{
    if (!pScene->mNumMeshes)
    {
        DefaultLogger::get()->debug("SortByPTypeProcess skipped, there are no meshes");
        return;
    }

    DefaultLogger::get()->debug("SortByPTypeProcess begin");

    unsigned int aiNumMeshesPerPType[4] = {0,0,0,0};

    std::vector<aiMesh*> outMeshes;
    outMeshes.reserve(pScene->mNumMeshes<<1u);

    bool bAnyChanges = false;

    std::vector<unsigned int> replaceMeshIndex(pScene->mNumMeshes*4,UINT_MAX);
    std::vector<unsigned int>::iterator meshIdx = replaceMeshIndex.begin();
    for (unsigned int i = 0; i < pScene->mNumMeshes;++i)
    {
        aiMesh* const mesh = pScene->mMeshes[i];
        ai_assert(0 != mesh->mPrimitiveTypes);

        // if there's just one primitive type in the mesh there's nothing to do for us
        unsigned int num = 0;
        if (mesh->mPrimitiveTypes & aiPrimitiveType_POINT)
        {
            ++aiNumMeshesPerPType[0];
            ++num;
        }
        if (mesh->mPrimitiveTypes & aiPrimitiveType_LINE)
        {
            ++aiNumMeshesPerPType[1];
            ++num;
        }
        if (mesh->mPrimitiveTypes & aiPrimitiveType_TRIANGLE)
        {
            ++aiNumMeshesPerPType[2];
            ++num;
        }
        if (mesh->mPrimitiveTypes & aiPrimitiveType_POLYGON)
        {
            ++aiNumMeshesPerPType[3];
            ++num;
        }

        if (1 == num)
        {
            if (!(configRemoveMeshes & mesh->mPrimitiveTypes))
            {
                *meshIdx = (unsigned int) outMeshes.size();
                outMeshes.push_back(mesh);
            }
            else bAnyChanges = true;

            meshIdx += 4;
            continue;
        }
        bAnyChanges = true;

        // reuse our current mesh arrays for the submesh
        // with the largest numer of primitives
        unsigned int aiNumPerPType[4] = {0,0,0,0};
        aiFace* pFirstFace = mesh->mFaces;
        aiFace* const pLastFace = pFirstFace + mesh->mNumFaces;

        unsigned int numPolyVerts = 0;
        for (;pFirstFace != pLastFace; ++pFirstFace)
        {
            if (pFirstFace->mNumIndices <= 3)
                ++aiNumPerPType[pFirstFace->mNumIndices-1];
            else
            {
                ++aiNumPerPType[3];
                numPolyVerts += pFirstFace-> mNumIndices;
            }
        }

        VertexWeightTable* avw = ComputeVertexBoneWeightTable(mesh);
        for (unsigned int real = 0; real < 4; ++real,++meshIdx)
        {
            if ( !aiNumPerPType[real] || configRemoveMeshes & (1u << real))
            {
                continue;
            }

            *meshIdx = (unsigned int) outMeshes.size();
            outMeshes.push_back(new aiMesh());
            aiMesh* out = outMeshes.back();

            // the name carries the adjacency information between the meshes
            out->mName = mesh->mName;

            // copy data members
            out->mPrimitiveTypes = 1u << real;
            out->mMaterialIndex = mesh->mMaterialIndex;

            // allocate output storage
            out->mNumFaces = aiNumPerPType[real];
            aiFace* outFaces = out->mFaces = new aiFace[out->mNumFaces];

            out->mNumVertices = (3 == real ? numPolyVerts : out->mNumFaces * (real+1));

            aiVector3D *vert(NULL), *nor(NULL), *tan(NULL), *bit(NULL);
            aiVector3D *uv   [AI_MAX_NUMBER_OF_TEXTURECOORDS];
            aiColor4D  *cols [AI_MAX_NUMBER_OF_COLOR_SETS];

            if (mesh->mVertices)
                vert = out->mVertices = new aiVector3D[out->mNumVertices];

            if (mesh->mNormals)
                nor  = out->mNormals  = new aiVector3D[out->mNumVertices];

            if (mesh->mTangents)
            {
                tan = out->mTangents   = new aiVector3D[out->mNumVertices];
                bit = out->mBitangents = new aiVector3D[out->mNumVertices];
            }

            for (unsigned int i = 0; i < AI_MAX_NUMBER_OF_TEXTURECOORDS;++i)
            {
                if (mesh->mTextureCoords[i])
                    uv[i] = out->mTextureCoords[i] = new aiVector3D[out->mNumVertices];
                else uv[i] = NULL;

                out->mNumUVComponents[i] = mesh->mNumUVComponents[i];
            }

            for (unsigned int i = 0; i < AI_MAX_NUMBER_OF_COLOR_SETS;++i)
            {
                if (mesh->mColors[i])
                    cols[i] = out->mColors[i] = new aiColor4D[out->mNumVertices];
                else cols[i] = NULL;
            }

            typedef std::vector< aiVertexWeight > TempBoneInfo;
            std::vector< TempBoneInfo > tempBones(mesh->mNumBones);

            // try to guess how much storage we'll need
            for (unsigned int q = 0; q < mesh->mNumBones;++q)
            {
                tempBones[q].reserve(mesh->mBones[q]->mNumWeights / (num-1));
            }

            unsigned int outIdx = 0;
            for (unsigned int m = 0; m < mesh->mNumFaces; ++m)
            {
                aiFace& in = mesh->mFaces[m];
                if ((real == 3  && in.mNumIndices <= 3) || (real != 3 && in.mNumIndices != real+1))
                {
                    continue;
                }

                outFaces->mNumIndices = in.mNumIndices;
                outFaces->mIndices    = in.mIndices;

                for (unsigned int q = 0; q < in.mNumIndices; ++q)
                {
                    unsigned int idx = in.mIndices[q];

                    // process all bones of this index
                    if (avw)
                    {
                        VertexWeightTable& tbl = avw[idx];
                        for (VertexWeightTable::const_iterator it = tbl.begin(), end = tbl.end();
                             it != end; ++it)
                        {
                            tempBones[ (*it).first ].push_back( aiVertexWeight(outIdx, (*it).second) );
                        }
                    }

                    if (vert)
                    {
                        *vert++ = mesh->mVertices[idx];
                        //mesh->mVertices[idx].x = get_qnan();
                    }
                    if (nor )*nor++  = mesh->mNormals[idx];
                    if (tan )
                    {
                        *tan++  = mesh->mTangents[idx];
                        *bit++  = mesh->mBitangents[idx];
                    }

                    for (unsigned int pp = 0; pp < AI_MAX_NUMBER_OF_TEXTURECOORDS; ++pp)
                    {
                        if (!uv[pp])break;
                        *uv[pp]++ = mesh->mTextureCoords[pp][idx];
                    }

                    for (unsigned int pp = 0; pp < AI_MAX_NUMBER_OF_COLOR_SETS; ++pp)
                    {
                        if (!cols[pp])break;
                        *cols[pp]++ = mesh->mColors[pp][idx];
                    }

                    in.mIndices[q] = outIdx++;
                }

                in.mIndices = NULL;
                ++outFaces;
            }
            ai_assert(outFaces == out->mFaces + out->mNumFaces);

            // now generate output bones
            for (unsigned int q = 0; q < mesh->mNumBones;++q)
                if (!tempBones[q].empty())++out->mNumBones;

            if (out->mNumBones)
            {
                out->mBones = new aiBone*[out->mNumBones];
                for (unsigned int q = 0, real = 0; q < mesh->mNumBones;++q)
                {
                    TempBoneInfo& in = tempBones[q];
                    if (in.empty())continue;

                    aiBone* srcBone = mesh->mBones[q];
                    aiBone* bone = out->mBones[real] = new aiBone();

                    bone->mName = srcBone->mName;
                    bone->mOffsetMatrix = srcBone->mOffsetMatrix;

                    bone->mNumWeights = (unsigned int)in.size();
                    bone->mWeights = new aiVertexWeight[bone->mNumWeights];

                    ::memcpy(bone->mWeights,&in[0],bone->mNumWeights*sizeof(aiVertexWeight));

                    ++real;
                }
            }
        }

        // delete the per-vertex bone weights table
        delete[] avw;

        // delete the input mesh
        delete mesh;

        // avoid invalid pointer
        pScene->mMeshes[i] = NULL;
    }

    if (outMeshes.empty())
    {
        // This should not occur
        throw DeadlyImportError("No meshes remaining");
    }

    // If we added at least one mesh process all nodes in the node
    // graph and update their respective mesh indices.
    if (bAnyChanges)
    {
        UpdateNodes(replaceMeshIndex,pScene->mRootNode);
    }

    if (outMeshes.size() != pScene->mNumMeshes)
    {
        delete[] pScene->mMeshes;
        pScene->mNumMeshes = (unsigned int)outMeshes.size();
        pScene->mMeshes = new aiMesh*[pScene->mNumMeshes];
    }
    ::memcpy(pScene->mMeshes,&outMeshes[0],pScene->mNumMeshes*sizeof(void*));

    if (!DefaultLogger::isNullLogger())
    {
        char buffer[1024];
        ::ai_snprintf(buffer,1024,"Points: %u%s, Lines: %u%s, Triangles: %u%s, Polygons: %u%s (Meshes, X = removed)",
            aiNumMeshesPerPType[0], ((configRemoveMeshes & aiPrimitiveType_POINT)     ? "X" : ""),
            aiNumMeshesPerPType[1], ((configRemoveMeshes & aiPrimitiveType_LINE)      ? "X" : ""),
            aiNumMeshesPerPType[2], ((configRemoveMeshes & aiPrimitiveType_TRIANGLE)  ? "X" : ""),
            aiNumMeshesPerPType[3], ((configRemoveMeshes & aiPrimitiveType_POLYGON)   ? "X" : ""));
        DefaultLogger::get()->info(buffer);
        DefaultLogger::get()->debug("SortByPTypeProcess finished");
    }
}


/***********************************************************************
FBXIMPORT\SPATIALSORT.CPP
***********************************************************************/
/*
---------------------------------------------------------------------------
Open Asset Import Library (assimp)
---------------------------------------------------------------------------

Copyright (c) 2006-2016, assimp team

All rights reserved.

Redistribution and use of this software in source and binary forms,
with or without modification, are permitted provided that the following
conditions are met:

* Redistributions of source code must retain the above
  copyright notice, this list of conditions and the
  following disclaimer.

* Redistributions in binary form must reproduce the above
  copyright notice, this list of conditions and the
  following disclaimer in the documentation and/or other
  materials provided with the distribution.

* Neither the name of the assimp team, nor the names of its
  contributors may be used to endorse or promote products
  derived from this software without specific prior
  written permission of the assimp team.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
"AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
---------------------------------------------------------------------------
*/

/** @file Implementation of the helper class to quickly find vertices close to a given position */


using namespace Assimp;

// CHAR_BIT seems to be defined under MVSC, but not under GCC. Pray that the correct value is 8.
#ifndef CHAR_BIT
#   define CHAR_BIT 8
#endif

// ------------------------------------------------------------------------------------------------
// Constructs a spatially sorted representation from the given position array.
SpatialSort::SpatialSort( const aiVector3D* pPositions, unsigned int pNumPositions,
    unsigned int pElementOffset)

    // define the reference plane. We choose some arbitrary vector away from all basic axises
    // in the hope that no model spreads all its vertices along this plane.
    : mPlaneNormal(0.8523f, 0.34321f, 0.5736f)
{
    mPlaneNormal.Normalize();
    Fill(pPositions,pNumPositions,pElementOffset);
}

// ------------------------------------------------------------------------------------------------
SpatialSort :: SpatialSort()
: mPlaneNormal(0.8523f, 0.34321f, 0.5736f)
{
    mPlaneNormal.Normalize();
}

// ------------------------------------------------------------------------------------------------
// Destructor
SpatialSort::~SpatialSort()
{
    // nothing to do here, everything destructs automatically
}

// ------------------------------------------------------------------------------------------------
void SpatialSort::Fill( const aiVector3D* pPositions, unsigned int pNumPositions,
    unsigned int pElementOffset,
    bool pFinalize /*= true */)
{
    mPositions.clear();
    Append(pPositions,pNumPositions,pElementOffset,pFinalize);
}

// ------------------------------------------------------------------------------------------------
void SpatialSort :: Finalize()
{
    std::sort( mPositions.begin(), mPositions.end());
}

// ------------------------------------------------------------------------------------------------
void SpatialSort::Append( const aiVector3D* pPositions, unsigned int pNumPositions,
    unsigned int pElementOffset,
    bool pFinalize /*= true */)
{
    // store references to all given positions along with their distance to the reference plane
    const size_t initial = mPositions.size();
    mPositions.reserve(initial + (pFinalize?pNumPositions:pNumPositions*2));
    for( unsigned int a = 0; a < pNumPositions; a++)
    {
        const char* tempPointer = reinterpret_cast<const char*> (pPositions);
        const aiVector3D* vec   = reinterpret_cast<const aiVector3D*> (tempPointer + a * pElementOffset);

        // store position by index and distance
        float distance = *vec * mPlaneNormal;
        mPositions.push_back( Entry( a+initial, *vec, distance));
    }

    if (pFinalize) {
        // now sort the array ascending by distance.
        Finalize();
    }
}

// ------------------------------------------------------------------------------------------------
// Returns an iterator for all positions close to the given position.
void SpatialSort::FindPositions( const aiVector3D& pPosition,
    float pRadius, std::vector<unsigned int>& poResults) const
{
    const float dist = pPosition * mPlaneNormal;
    const float minDist = dist - pRadius, maxDist = dist + pRadius;

    // clear the array in this strange fashion because a simple clear() would also deallocate
    // the array which we want to avoid
    poResults.erase( poResults.begin(), poResults.end());

    // quick check for positions outside the range
    if( mPositions.size() == 0)
        return;
    if( maxDist < mPositions.front().mDistance)
        return;
    if( minDist > mPositions.back().mDistance)
        return;

    // do a binary search for the minimal distance to start the iteration there
    unsigned int index = (unsigned int)mPositions.size() / 2;
    unsigned int binaryStepSize = (unsigned int)mPositions.size() / 4;
    while( binaryStepSize > 1)
    {
        if( mPositions[index].mDistance < minDist)
            index += binaryStepSize;
        else
            index -= binaryStepSize;

        binaryStepSize /= 2;
    }

    // depending on the direction of the last step we need to single step a bit back or forth
    // to find the actual beginning element of the range
    while( index > 0 && mPositions[index].mDistance > minDist)
        index--;
    while( index < (mPositions.size() - 1) && mPositions[index].mDistance < minDist)
        index++;

    // Mow start iterating from there until the first position lays outside of the distance range.
    // Add all positions inside the distance range within the given radius to the result aray
    std::vector<Entry>::const_iterator it = mPositions.begin() + index;
    const float pSquared = pRadius*pRadius;
    while( it->mDistance < maxDist)
    {
        if( (it->mPosition - pPosition).SquareLength() < pSquared)
            poResults.push_back( it->mIndex);
        ++it;
        if( it == mPositions.end())
            break;
    }

    // that's it
}

namespace {

    // Binary, signed-integer representation of a single-precision floating-point value.
    // IEEE 754 says: "If two floating-point numbers in the same format are ordered then they are
    //  ordered the same way when their bits are reinterpreted as sign-magnitude integers."
    // This allows us to convert all floating-point numbers to signed integers of arbitrary size
    //  and then use them to work with ULPs (Units in the Last Place, for high-precision
    //  computations) or to compare them (integer comparisons are faster than floating-point
    //  comparisons on many platforms).
    typedef signed int BinFloat;

    // --------------------------------------------------------------------------------------------
    // Converts the bit pattern of a floating-point number to its signed integer representation.
    BinFloat ToBinary( const float & pValue) {

        // If this assertion fails, signed int is not big enough to store a float on your platform.
        //  Please correct the declaration of BinFloat a few lines above - but do it in a portable,
        //  #ifdef'd manner!
        static_assert( sizeof(BinFloat) >= sizeof(float), "sizeof(BinFloat) >= sizeof(float)");

        #if defined( _MSC_VER)
            // If this assertion fails, Visual C++ has finally moved to ILP64. This means that this
            //  code has just become legacy code! Find out the current value of _MSC_VER and modify
            //  the #if above so it evaluates false on the current and all upcoming VC versions (or
            //  on the current platform, if LP64 or LLP64 are still used on other platforms).
            static_assert( sizeof(BinFloat) == sizeof(float), "sizeof(BinFloat) == sizeof(float)");

            // This works best on Visual C++, but other compilers have their problems with it.
            const BinFloat binValue = reinterpret_cast<BinFloat const &>(pValue);
        #else
            // On many compilers, reinterpreting a float address as an integer causes aliasing
            // problems. This is an ugly but more or less safe way of doing it.
            union {
                float       asFloat;
                BinFloat    asBin;
            } conversion;
            conversion.asBin    = 0; // zero empty space in case sizeof(BinFloat) > sizeof(float)
            conversion.asFloat  = pValue;
            const BinFloat binValue = conversion.asBin;
        #endif

        // floating-point numbers are of sign-magnitude format, so find out what signed number
        //  representation we must convert negative values to.
        // See http://en.wikipedia.org/wiki/Signed_number_representations.

        // Two's complement?
        if( (-42 == (~42 + 1)) && (binValue & 0x80000000))
            return BinFloat(1 << (CHAR_BIT * sizeof(BinFloat) - 1)) - binValue;
        // One's complement?
        else if( (-42 == ~42) && (binValue & 0x80000000))
            return BinFloat(-0) - binValue;
        // Sign-magnitude?
        else if( (-42 == (42 | (-0))) && (binValue & 0x80000000)) // -0 = 1000... binary
            return binValue;
        else
            return binValue;
    }

} // namespace

// ------------------------------------------------------------------------------------------------
// Fills an array with indices of all positions identical to the given position. In opposite to
// FindPositions(), not an epsilon is used but a (very low) tolerance of four floating-point units.
void SpatialSort::FindIdenticalPositions( const aiVector3D& pPosition,
    std::vector<unsigned int>& poResults) const
{
    // Epsilons have a huge disadvantage: they are of constant precision, while floating-point
    //  values are of log2 precision. If you apply e=0.01 to 100, the epsilon is rather small, but
    //  if you apply it to 0.001, it is enormous.

    // The best way to overcome this is the unit in the last place (ULP). A precision of 2 ULPs
    //  tells us that a float does not differ more than 2 bits from the "real" value. ULPs are of
    //  logarithmic precision - around 1, they are 1(2^24) and around 10000, they are 0.00125.

    // For standard C math, we can assume a precision of 0.5 ULPs according to IEEE 754. The
    //  incoming vertex positions might have already been transformed, probably using rather
    //  inaccurate SSE instructions, so we assume a tolerance of 4 ULPs to safely identify
    //  identical vertex positions.
    static const int toleranceInULPs = 4;
    // An interesting point is that the inaccuracy grows linear with the number of operations:
    //  multiplying to numbers, each inaccurate to four ULPs, results in an inaccuracy of four ULPs
    //  plus 0.5 ULPs for the multiplication.
    // To compute the distance to the plane, a dot product is needed - that is a multiplication and
    //  an addition on each number.
    static const int distanceToleranceInULPs = toleranceInULPs + 1;
    // The squared distance between two 3D vectors is computed the same way, but with an additional
    //  subtraction.
    static const int distance3DToleranceInULPs = distanceToleranceInULPs + 1;

    // Convert the plane distance to its signed integer representation so the ULPs tolerance can be
    //  applied. For some reason, VC won't optimize two calls of the bit pattern conversion.
    const BinFloat minDistBinary = ToBinary( pPosition * mPlaneNormal) - distanceToleranceInULPs;
    const BinFloat maxDistBinary = minDistBinary + 2 * distanceToleranceInULPs;

    // clear the array in this strange fashion because a simple clear() would also deallocate
    // the array which we want to avoid
    poResults.erase( poResults.begin(), poResults.end());

    // do a binary search for the minimal distance to start the iteration there
    unsigned int index = (unsigned int)mPositions.size() / 2;
    unsigned int binaryStepSize = (unsigned int)mPositions.size() / 4;
    while( binaryStepSize > 1)
    {
        // Ugly, but conditional jumps are faster with integers than with floats
        if( minDistBinary > ToBinary(mPositions[index].mDistance))
            index += binaryStepSize;
        else
            index -= binaryStepSize;

        binaryStepSize /= 2;
    }

    // depending on the direction of the last step we need to single step a bit back or forth
    // to find the actual beginning element of the range
    while( index > 0 && minDistBinary < ToBinary(mPositions[index].mDistance) )
        index--;
    while( index < (mPositions.size() - 1) && minDistBinary > ToBinary(mPositions[index].mDistance))
        index++;

    // Now start iterating from there until the first position lays outside of the distance range.
    // Add all positions inside the distance range within the tolerance to the result aray
    std::vector<Entry>::const_iterator it = mPositions.begin() + index;
    while( ToBinary(it->mDistance) < maxDistBinary)
    {
        if( distance3DToleranceInULPs >= ToBinary((it->mPosition - pPosition).SquareLength()))
            poResults.push_back(it->mIndex);
        ++it;
        if( it == mPositions.end())
            break;
    }

    // that's it
}

// ------------------------------------------------------------------------------------------------
unsigned int SpatialSort::GenerateMappingTable(std::vector<unsigned int>& fill,float pRadius) const
{
    fill.resize(mPositions.size(),UINT_MAX);
    float dist, maxDist;

    unsigned int t=0;
    const float pSquared = pRadius*pRadius;
    for (size_t i = 0; i < mPositions.size();) {
        dist = mPositions[i].mPosition * mPlaneNormal;
        maxDist = dist + pRadius;

        fill[mPositions[i].mIndex] = t;
        const aiVector3D& oldpos = mPositions[i].mPosition;
        for (++i; i < fill.size() && mPositions[i].mDistance < maxDist
            && (mPositions[i].mPosition - oldpos).SquareLength() < pSquared; ++i)
        {
            fill[mPositions[i].mIndex] = t;
        }
        ++t;
    }
#ifdef ASSIMP_BUILD_DEBUG
    // debug invariant: mPositions[i].mIndex values must range from 0 to mPositions.size()-1
    for (size_t i = 0; i < fill.size(); ++i) {
        ai_assert(fill[i]<mPositions.size());
    }
#endif
    return t;
}

/***********************************************************************
FBXIMPORT\SPLITBYBONECOUNTPROCESS.CPP
***********************************************************************/
/*
Open Asset Import Library (assimp)
----------------------------------------------------------------------

Copyright (c) 2006-2016, assimp team
All rights reserved.

Redistribution and use of this software in source and binary forms,
with or without modification, are permitted provided that the
following conditions are met:

* Redistributions of source code must retain the above
  copyright notice, this list of conditions and the
  following disclaimer.

* Redistributions in binary form must reproduce the above
  copyright notice, this list of conditions and the
  following disclaimer in the documentation and/or other
  materials provided with the distribution.

* Neither the name of the assimp team, nor the names of its
  contributors may be used to endorse or promote products
  derived from this software without specific prior
  written permission of the assimp team.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
"AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

----------------------------------------------------------------------
*/


/// @file SplitByBoneCountProcess.cpp
/// Implementation of the SplitByBoneCount postprocessing step

// internal headers of the post-processing framework


using namespace Assimp;
using namespace Assimp::Formatter;

// ------------------------------------------------------------------------------------------------
// Constructor
SplitByBoneCountProcess::SplitByBoneCountProcess()
{
    // set default, might be overriden by importer config
    mMaxBoneCount = AI_SBBC_DEFAULT_MAX_BONES;
}

// ------------------------------------------------------------------------------------------------
// Destructor
SplitByBoneCountProcess::~SplitByBoneCountProcess()
{
    // nothing to do here
}

// ------------------------------------------------------------------------------------------------
// Returns whether the processing step is present in the given flag.
bool SplitByBoneCountProcess::IsActive( unsigned int pFlags) const
{
    return !!(pFlags & aiProcess_SplitByBoneCount);
}

// ------------------------------------------------------------------------------------------------
// Updates internal properties
void SplitByBoneCountProcess::SetupProperties(const Importer* pImp)
{
    mMaxBoneCount = pImp->GetPropertyInteger(AI_CONFIG_PP_SBBC_MAX_BONES,AI_SBBC_DEFAULT_MAX_BONES);
}

// ------------------------------------------------------------------------------------------------
// Executes the post processing step on the given imported data.
void SplitByBoneCountProcess::Execute( aiScene* pScene)
{
    DefaultLogger::get()->debug("SplitByBoneCountProcess begin");

    // early out
    bool isNecessary = false;
    for( unsigned int a = 0; a < pScene->mNumMeshes; ++a)
        if( pScene->mMeshes[a]->mNumBones > mMaxBoneCount )
            isNecessary = true;

    if( !isNecessary )
    {
        DefaultLogger::get()->debug( format() << "SplitByBoneCountProcess early-out: no meshes with more than " << mMaxBoneCount << " bones." );
        return;
    }

    // we need to do something. Let's go.
    mSubMeshIndices.clear();
    mSubMeshIndices.resize( pScene->mNumMeshes);

    // build a new array of meshes for the scene
    std::vector<aiMesh*> meshes;

    for( unsigned int a = 0; a < pScene->mNumMeshes; ++a)
    {
        aiMesh* srcMesh = pScene->mMeshes[a];

        std::vector<aiMesh*> newMeshes;
        SplitMesh( pScene->mMeshes[a], newMeshes);

        // mesh was split
        if( !newMeshes.empty() )
        {
            // store new meshes and indices of the new meshes
            for( unsigned int b = 0; b < newMeshes.size(); ++b)
            {
                mSubMeshIndices[a].push_back( static_cast<unsigned int>(meshes.size()));
                meshes.push_back( newMeshes[b]);
            }

            // and destroy the source mesh. It should be completely contained inside the new submeshes
            delete srcMesh;
        }
        else
        {
            // Mesh is kept unchanged - store it's new place in the mesh array
            mSubMeshIndices[a].push_back( static_cast<unsigned int>(meshes.size()));
            meshes.push_back( srcMesh);
        }
    }

    // rebuild the scene's mesh array
    pScene->mNumMeshes = static_cast<unsigned int>(meshes.size());
    delete [] pScene->mMeshes;
    pScene->mMeshes = new aiMesh*[pScene->mNumMeshes];
    std::copy( meshes.begin(), meshes.end(), pScene->mMeshes);

    // recurse through all nodes and translate the node's mesh indices to fit the new mesh array
    UpdateNode( pScene->mRootNode);

    DefaultLogger::get()->debug( format() << "SplitByBoneCountProcess end: split " << mSubMeshIndices.size() << " meshes into " << meshes.size() << " submeshes." );
}

// ------------------------------------------------------------------------------------------------
// Splits the given mesh by bone count.
void SplitByBoneCountProcess::SplitMesh( const aiMesh* pMesh, std::vector<aiMesh*>& poNewMeshes) const
{
    // skip if not necessary
    if( pMesh->mNumBones <= mMaxBoneCount )
        return;

    // necessary optimisation: build a list of all affecting bones for each vertex
    // TODO: (thom) maybe add a custom allocator here to avoid allocating tens of thousands of small arrays
    typedef std::pair<unsigned int, float> BoneWeight;
    std::vector< std::vector<BoneWeight> > vertexBones( pMesh->mNumVertices);
    for( unsigned int a = 0; a < pMesh->mNumBones; ++a)
    {
        const aiBone* bone = pMesh->mBones[a];
        for( unsigned int b = 0; b < bone->mNumWeights; ++b)
            vertexBones[ bone->mWeights[b].mVertexId ].push_back( BoneWeight( a, bone->mWeights[b].mWeight));
    }

    unsigned int numFacesHandled = 0;
    std::vector<bool> isFaceHandled( pMesh->mNumFaces, false);
    while( numFacesHandled < pMesh->mNumFaces )
    {
        // which bones are used in the current submesh
        unsigned int numBones = 0;
        std::vector<bool> isBoneUsed( pMesh->mNumBones, false);
        // indices of the faces which are going to go into this submesh
        std::vector<unsigned int> subMeshFaces;
        subMeshFaces.reserve( pMesh->mNumFaces);
        // accumulated vertex count of all the faces in this submesh
        unsigned int numSubMeshVertices = 0;
        // a small local array of new bones for the current face. State of all used bones for that face
        // can only be updated AFTER the face is completely analysed. Thanks to imre for the fix.
        std::vector<unsigned int> newBonesAtCurrentFace;

        // add faces to the new submesh as long as all bones affecting the faces' vertices fit in the limit
        for( unsigned int a = 0; a < pMesh->mNumFaces; ++a)
        {
            // skip if the face is already stored in a submesh
            if( isFaceHandled[a] )
                continue;

            const aiFace& face = pMesh->mFaces[a];
            // check every vertex if its bones would still fit into the current submesh
            for( unsigned int b = 0; b < face.mNumIndices; ++b )
            {
                const std::vector<BoneWeight>& vb = vertexBones[face.mIndices[b]];
                for( unsigned int c = 0; c < vb.size(); ++c)
                {
                    unsigned int boneIndex = vb[c].first;
                    // if the bone is already used in this submesh, it's ok
                    if( isBoneUsed[boneIndex] )
                        continue;

                    // if it's not used, yet, we would need to add it. Store its bone index
                    if( std::find( newBonesAtCurrentFace.begin(), newBonesAtCurrentFace.end(), boneIndex) == newBonesAtCurrentFace.end() )
                        newBonesAtCurrentFace.push_back( boneIndex);
                }
            }

            // leave out the face if the new bones required for this face don't fit the bone count limit anymore
            if( numBones + newBonesAtCurrentFace.size() > mMaxBoneCount )
                continue;

            // mark all new bones as necessary
            while( !newBonesAtCurrentFace.empty() )
            {
                unsigned int newIndex = newBonesAtCurrentFace.back();
                newBonesAtCurrentFace.pop_back(); // this also avoids the deallocation which comes with a clear()
                if( isBoneUsed[newIndex] )
                    continue;

                isBoneUsed[newIndex] = true;
                numBones++;
            }

            // store the face index and the vertex count
            subMeshFaces.push_back( a);
            numSubMeshVertices += face.mNumIndices;

            // remember that this face is handled
            isFaceHandled[a] = true;
            numFacesHandled++;
        }

        // create a new mesh to hold this subset of the source mesh
        aiMesh* newMesh = new aiMesh;
        if( pMesh->mName.length > 0 )
            newMesh->mName.Set( format() << pMesh->mName.data << "_sub" << poNewMeshes.size());
        newMesh->mMaterialIndex = pMesh->mMaterialIndex;
        newMesh->mPrimitiveTypes = pMesh->mPrimitiveTypes;
        poNewMeshes.push_back( newMesh);

        // create all the arrays for this mesh if the old mesh contained them
        newMesh->mNumVertices = numSubMeshVertices;
        newMesh->mNumFaces = static_cast<unsigned int>(subMeshFaces.size());
        newMesh->mVertices = new aiVector3D[newMesh->mNumVertices];
        if( pMesh->HasNormals() )
            newMesh->mNormals = new aiVector3D[newMesh->mNumVertices];
        if( pMesh->HasTangentsAndBitangents() )
        {
            newMesh->mTangents = new aiVector3D[newMesh->mNumVertices];
            newMesh->mBitangents = new aiVector3D[newMesh->mNumVertices];
        }
        for( unsigned int a = 0; a < AI_MAX_NUMBER_OF_TEXTURECOORDS; ++a )
        {
            if( pMesh->HasTextureCoords( a) )
                newMesh->mTextureCoords[a] = new aiVector3D[newMesh->mNumVertices];
            newMesh->mNumUVComponents[a] = pMesh->mNumUVComponents[a];
        }
        for( unsigned int a = 0; a < AI_MAX_NUMBER_OF_COLOR_SETS; ++a )
        {
            if( pMesh->HasVertexColors( a) )
                newMesh->mColors[a] = new aiColor4D[newMesh->mNumVertices];
        }

        // and copy over the data, generating faces with linear indices along the way
        newMesh->mFaces = new aiFace[subMeshFaces.size()];
        unsigned int nvi = 0; // next vertex index
        std::vector<unsigned int> previousVertexIndices( numSubMeshVertices, std::numeric_limits<unsigned int>::max()); // per new vertex: its index in the source mesh
        for( unsigned int a = 0; a < subMeshFaces.size(); ++a )
        {
            const aiFace& srcFace = pMesh->mFaces[subMeshFaces[a]];
            aiFace& dstFace = newMesh->mFaces[a];
            dstFace.mNumIndices = srcFace.mNumIndices;
            dstFace.mIndices = new unsigned int[dstFace.mNumIndices];

            // accumulate linearly all the vertices of the source face
            for( unsigned int b = 0; b < dstFace.mNumIndices; ++b )
            {
                unsigned int srcIndex = srcFace.mIndices[b];
                dstFace.mIndices[b] = nvi;
                previousVertexIndices[nvi] = srcIndex;

                newMesh->mVertices[nvi] = pMesh->mVertices[srcIndex];
                if( pMesh->HasNormals() )
                    newMesh->mNormals[nvi] = pMesh->mNormals[srcIndex];
                if( pMesh->HasTangentsAndBitangents() )
                {
                    newMesh->mTangents[nvi] = pMesh->mTangents[srcIndex];
                    newMesh->mBitangents[nvi] = pMesh->mBitangents[srcIndex];
                }
                for( unsigned int c = 0; c < AI_MAX_NUMBER_OF_TEXTURECOORDS; ++c )
                {
                    if( pMesh->HasTextureCoords( c) )
                        newMesh->mTextureCoords[c][nvi] = pMesh->mTextureCoords[c][srcIndex];
                }
                for( unsigned int c = 0; c < AI_MAX_NUMBER_OF_COLOR_SETS; ++c )
                {
                    if( pMesh->HasVertexColors( c) )
                        newMesh->mColors[c][nvi] = pMesh->mColors[c][srcIndex];
                }

                nvi++;
            }
        }

        ai_assert( nvi == numSubMeshVertices );

        // Create the bones for the new submesh: first create the bone array
        newMesh->mNumBones = 0;
        newMesh->mBones = new aiBone*[numBones];

        std::vector<unsigned int> mappedBoneIndex( pMesh->mNumBones, std::numeric_limits<unsigned int>::max());
        for( unsigned int a = 0; a < pMesh->mNumBones; ++a )
        {
            if( !isBoneUsed[a] )
                continue;

            // create the new bone
            const aiBone* srcBone = pMesh->mBones[a];
            aiBone* dstBone = new aiBone;
            mappedBoneIndex[a] = newMesh->mNumBones;
            newMesh->mBones[newMesh->mNumBones++] = dstBone;
            dstBone->mName = srcBone->mName;
            dstBone->mOffsetMatrix = srcBone->mOffsetMatrix;
            dstBone->mNumWeights = 0;
        }

        ai_assert( newMesh->mNumBones == numBones );

        // iterate over all new vertices and count which bones affected its old vertex in the source mesh
        for( unsigned int a = 0; a < numSubMeshVertices; ++a )
        {
            unsigned int oldIndex = previousVertexIndices[a];
            const std::vector<BoneWeight>& bonesOnThisVertex = vertexBones[oldIndex];

            for( unsigned int b = 0; b < bonesOnThisVertex.size(); ++b )
            {
                unsigned int newBoneIndex = mappedBoneIndex[ bonesOnThisVertex[b].first ];
                if( newBoneIndex != std::numeric_limits<unsigned int>::max() )
                    newMesh->mBones[newBoneIndex]->mNumWeights++;
            }
        }

        // allocate all bone weight arrays accordingly
        for( unsigned int a = 0; a < newMesh->mNumBones; ++a )
        {
            aiBone* bone = newMesh->mBones[a];
            ai_assert( bone->mNumWeights > 0 );
            bone->mWeights = new aiVertexWeight[bone->mNumWeights];
            bone->mNumWeights = 0; // for counting up in the next step
        }

        // now copy all the bone vertex weights for all the vertices which made it into the new submesh
        for( unsigned int a = 0; a < numSubMeshVertices; ++a)
        {
            // find the source vertex for it in the source mesh
            unsigned int previousIndex = previousVertexIndices[a];
            // these bones were affecting it
            const std::vector<BoneWeight>& bonesOnThisVertex = vertexBones[previousIndex];
            // all of the bones affecting it should be present in the new submesh, or else
            // the face it comprises shouldn't be present
            for( unsigned int b = 0; b < bonesOnThisVertex.size(); ++b)
            {
                unsigned int newBoneIndex = mappedBoneIndex[ bonesOnThisVertex[b].first ];
                ai_assert( newBoneIndex != std::numeric_limits<unsigned int>::max() );
                aiVertexWeight* dstWeight = newMesh->mBones[newBoneIndex]->mWeights + newMesh->mBones[newBoneIndex]->mNumWeights;
                newMesh->mBones[newBoneIndex]->mNumWeights++;

                dstWeight->mVertexId = a;
                dstWeight->mWeight = bonesOnThisVertex[b].second;
            }
        }

        // I have the strange feeling that this will break apart at some point in time...
    }
}

// ------------------------------------------------------------------------------------------------
// Recursively updates the node's mesh list to account for the changed mesh list
void SplitByBoneCountProcess::UpdateNode( aiNode* pNode) const
{
    // rebuild the node's mesh index list
    if( pNode->mNumMeshes > 0 )
    {
        std::vector<unsigned int> newMeshList;
        for( unsigned int a = 0; a < pNode->mNumMeshes; ++a)
        {
            unsigned int srcIndex = pNode->mMeshes[a];
            const std::vector<unsigned int>& replaceMeshes = mSubMeshIndices[srcIndex];
            newMeshList.insert( newMeshList.end(), replaceMeshes.begin(), replaceMeshes.end());
        }

        delete pNode->mMeshes;
        pNode->mNumMeshes = static_cast<unsigned int>(newMeshList.size());
        pNode->mMeshes = new unsigned int[pNode->mNumMeshes];
        std::copy( newMeshList.begin(), newMeshList.end(), pNode->mMeshes);
    }

    // do that also recursively for all children
    for( unsigned int a = 0; a < pNode->mNumChildren; ++a )
    {
        UpdateNode( pNode->mChildren[a]);
    }
}

/***********************************************************************
FBXIMPORT\SPLITLARGEMESHES.CPP
***********************************************************************/
/*
Open Asset Import Library (assimp)
----------------------------------------------------------------------

Copyright (c) 2006-2016, assimp team
All rights reserved.

Redistribution and use of this software in source and binary forms,
with or without modification, are permitted provided that the
following conditions are met:

* Redistributions of source code must retain the above
  copyright notice, this list of conditions and the
  following disclaimer.

* Redistributions in binary form must reproduce the above
  copyright notice, this list of conditions and the
  following disclaimer in the documentation and/or other
  materials provided with the distribution.

* Neither the name of the assimp team, nor the names of its
  contributors may be used to endorse or promote products
  derived from this software without specific prior
  written permission of the assimp team.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
"AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

----------------------------------------------------------------------
*/


/** @file Implementation of the SplitLargeMeshes postprocessing step
*/



// internal headers of the post-processing framework

using namespace Assimp;


// ------------------------------------------------------------------------------------------------
SplitLargeMeshesProcess_Triangle::SplitLargeMeshesProcess_Triangle()
{
    LIMIT = AI_SLM_DEFAULT_MAX_TRIANGLES;
}

// ------------------------------------------------------------------------------------------------
SplitLargeMeshesProcess_Triangle::~SplitLargeMeshesProcess_Triangle()
{
    // nothing to do here
}

// ------------------------------------------------------------------------------------------------
// Returns whether the processing step is present in the given flag field.
bool SplitLargeMeshesProcess_Triangle::IsActive( unsigned int pFlags) const
{
    return (pFlags & aiProcess_SplitLargeMeshes) != 0;
}

// ------------------------------------------------------------------------------------------------
// Executes the post processing step on the given imported data.
void SplitLargeMeshesProcess_Triangle::Execute( aiScene* pScene)
{
    if (0xffffffff == this->LIMIT)return;

    DefaultLogger::get()->debug("SplitLargeMeshesProcess_Triangle begin");
    std::vector<std::pair<aiMesh*, unsigned int> > avList;

    for( unsigned int a = 0; a < pScene->mNumMeshes; a++)
        this->SplitMesh(a, pScene->mMeshes[a],avList);

    if (avList.size() != pScene->mNumMeshes)
    {
        // it seems something has been split. rebuild the mesh list
        delete[] pScene->mMeshes;
        pScene->mNumMeshes = (unsigned int)avList.size();
        pScene->mMeshes = new aiMesh*[avList.size()];

        for (unsigned int i = 0; i < avList.size();++i)
            pScene->mMeshes[i] = avList[i].first;

        // now we need to update all nodes
        this->UpdateNode(pScene->mRootNode,avList);
        DefaultLogger::get()->info("SplitLargeMeshesProcess_Triangle finished. Meshes have been split");
    }
    else DefaultLogger::get()->debug("SplitLargeMeshesProcess_Triangle finished. There was nothing to do");
    return;
}

// ------------------------------------------------------------------------------------------------
// Setup properties
void SplitLargeMeshesProcess_Triangle::SetupProperties( const Importer* pImp)
{
    // get the current value of the split property
    this->LIMIT = pImp->GetPropertyInteger(AI_CONFIG_PP_SLM_TRIANGLE_LIMIT,AI_SLM_DEFAULT_MAX_TRIANGLES);
}

// ------------------------------------------------------------------------------------------------
// Update a node after some meshes have been split
void SplitLargeMeshesProcess_Triangle::UpdateNode(aiNode* pcNode,
    const std::vector<std::pair<aiMesh*, unsigned int> >& avList)
{
    // for every index in out list build a new entry
    std::vector<unsigned int> aiEntries;
    aiEntries.reserve(pcNode->mNumMeshes + 1);
    for (unsigned int i = 0; i < pcNode->mNumMeshes;++i)
    {
        for (unsigned int a = 0; a < avList.size();++a)
        {
            if (avList[a].second == pcNode->mMeshes[i])
            {
                aiEntries.push_back(a);
            }
        }
    }

    // now build the new list
    delete[] pcNode->mMeshes;
    pcNode->mNumMeshes = (unsigned int)aiEntries.size();
    pcNode->mMeshes = new unsigned int[pcNode->mNumMeshes];

    for (unsigned int b = 0; b < pcNode->mNumMeshes;++b)
        pcNode->mMeshes[b] = aiEntries[b];

    // recusively update all other nodes
    for (unsigned int i = 0; i < pcNode->mNumChildren;++i)
    {
        UpdateNode ( pcNode->mChildren[i], avList );
    }
    return;
}

// ------------------------------------------------------------------------------------------------
// Executes the post processing step on the given imported data.
void SplitLargeMeshesProcess_Triangle::SplitMesh(
    unsigned int a,
    aiMesh* pMesh,
    std::vector<std::pair<aiMesh*, unsigned int> >& avList)
{
    if (pMesh->mNumFaces > SplitLargeMeshesProcess_Triangle::LIMIT)
    {
        DefaultLogger::get()->info("Mesh exceeds the triangle limit. It will be split ...");

        // we need to split this mesh into sub meshes
        // determine the size of a submesh
        const unsigned int iSubMeshes = (pMesh->mNumFaces / LIMIT) + 1;

        const unsigned int iOutFaceNum = pMesh->mNumFaces / iSubMeshes;
        const unsigned int iOutVertexNum = iOutFaceNum * 3;

        // now generate all submeshes
        for (unsigned int i = 0; i < iSubMeshes;++i)
        {
            aiMesh* pcMesh          = new aiMesh;
            pcMesh->mNumFaces       = iOutFaceNum;
            pcMesh->mMaterialIndex  = pMesh->mMaterialIndex;

            // the name carries the adjacency information between the meshes
            pcMesh->mName = pMesh->mName;

            if (i == iSubMeshes-1)
            {
                pcMesh->mNumFaces = iOutFaceNum + (
                    pMesh->mNumFaces - iOutFaceNum * iSubMeshes);
            }
            // copy the list of faces
            pcMesh->mFaces = new aiFace[pcMesh->mNumFaces];

            const unsigned int iBase = iOutFaceNum * i;

            // get the total number of indices
            unsigned int iCnt = 0;
            for (unsigned int p = iBase; p < pcMesh->mNumFaces + iBase;++p)
            {
                iCnt += pMesh->mFaces[p].mNumIndices;
            }
            pcMesh->mNumVertices = iCnt;

            // allocate storage
            if (pMesh->mVertices != NULL)
                pcMesh->mVertices = new aiVector3D[iCnt];

            if (pMesh->HasNormals())
                pcMesh->mNormals = new aiVector3D[iCnt];

            if (pMesh->HasTangentsAndBitangents())
            {
                pcMesh->mTangents = new aiVector3D[iCnt];
                pcMesh->mBitangents = new aiVector3D[iCnt];
            }

            // texture coordinates
            for (unsigned int c = 0;  c < AI_MAX_NUMBER_OF_TEXTURECOORDS;++c)
            {
                pcMesh->mNumUVComponents[c] = pMesh->mNumUVComponents[c];
                if (pMesh->HasTextureCoords( c))
                {
                    pcMesh->mTextureCoords[c] = new aiVector3D[iCnt];
                }
            }

            // vertex colors
            for (unsigned int c = 0;  c < AI_MAX_NUMBER_OF_COLOR_SETS;++c)
            {
                if (pMesh->HasVertexColors( c))
                {
                    pcMesh->mColors[c] = new aiColor4D[iCnt];
                }
            }

            if (pMesh->HasBones())
            {
                // assume the number of bones won't change in most cases
                pcMesh->mBones = new aiBone*[pMesh->mNumBones];

                // iterate through all bones of the mesh and find those which
                // need to be copied to the split mesh
                std::vector<aiVertexWeight> avTempWeights;
                for (unsigned int p = 0; p < pcMesh->mNumBones;++p)
                {
                    aiBone* const bone = pcMesh->mBones[p];
                    avTempWeights.clear();
                    avTempWeights.reserve(bone->mNumWeights / iSubMeshes);

                    for (unsigned int q = 0; q < bone->mNumWeights;++q)
                    {
                        aiVertexWeight& weight = bone->mWeights[q];
                        if(weight.mVertexId >= iBase && weight.mVertexId < iBase + iOutVertexNum)
                        {
                            avTempWeights.push_back(weight);
                            weight = avTempWeights.back();
                            weight.mVertexId -= iBase;
                        }
                    }

                    if (!avTempWeights.empty())
                    {
                        // we'll need this bone. Copy it ...
                        aiBone* pc = new aiBone();
                        pcMesh->mBones[pcMesh->mNumBones++] = pc;
                        pc->mName = aiString(bone->mName);
                        pc->mNumWeights = (unsigned int)avTempWeights.size();
                        pc->mOffsetMatrix = bone->mOffsetMatrix;

                        // no need to reallocate the array for the last submesh.
                        // Here we can reuse the (large) source array, although
                        // we'll waste some memory
                        if (iSubMeshes-1 == i)
                        {
                            pc->mWeights = bone->mWeights;
                            bone->mWeights = NULL;
                        }
                        else pc->mWeights = new aiVertexWeight[pc->mNumWeights];

                        // copy the weights
                        ::memcpy(pc->mWeights,&avTempWeights[0],sizeof(aiVertexWeight)*pc->mNumWeights);
                    }
                }
            }

            // (we will also need to copy the array of indices)
            unsigned int iCurrent = 0;
            for (unsigned int p = 0; p < pcMesh->mNumFaces;++p)
            {
                pcMesh->mFaces[p].mNumIndices = 3;
                // allocate a new array
                const unsigned int iTemp = p + iBase;
                const unsigned int iNumIndices = pMesh->mFaces[iTemp].mNumIndices;

                // setup face type and number of indices
                pcMesh->mFaces[p].mNumIndices = iNumIndices;
                unsigned int* pi = pMesh->mFaces[iTemp].mIndices;
                unsigned int* piOut = pcMesh->mFaces[p].mIndices = new unsigned int[iNumIndices];

                // need to update the output primitive types
                switch (iNumIndices)
                {
                case 1:
                    pcMesh->mPrimitiveTypes |= aiPrimitiveType_POINT;
                    break;
                case 2:
                    pcMesh->mPrimitiveTypes |= aiPrimitiveType_LINE;
                    break;
                case 3:
                    pcMesh->mPrimitiveTypes |= aiPrimitiveType_TRIANGLE;
                    break;
                default:
                    pcMesh->mPrimitiveTypes |= aiPrimitiveType_POLYGON;
                }

                // and copy the contents of the old array, offset by current base
                for (unsigned int v = 0; v < iNumIndices;++v)
                {
                    unsigned int iIndex = pi[v];
                    unsigned int iIndexOut = iCurrent++;
                    piOut[v] = iIndexOut;

                    // copy positions
                    if (pMesh->mVertices != NULL)
                        pcMesh->mVertices[iIndexOut] = pMesh->mVertices[iIndex];

                    // copy normals
                    if (pMesh->HasNormals())
                        pcMesh->mNormals[iIndexOut] = pMesh->mNormals[iIndex];

                    // copy tangents/bitangents
                    if (pMesh->HasTangentsAndBitangents())
                    {
                        pcMesh->mTangents[iIndexOut] = pMesh->mTangents[iIndex];
                        pcMesh->mBitangents[iIndexOut] = pMesh->mBitangents[iIndex];
                    }

                    // texture coordinates
                    for (unsigned int c = 0;  c < AI_MAX_NUMBER_OF_TEXTURECOORDS;++c)
                    {
                        if (pMesh->HasTextureCoords( c))
                            pcMesh->mTextureCoords[c][iIndexOut] = pMesh->mTextureCoords[c][iIndex];
                    }
                    // vertex colors
                    for (unsigned int c = 0;  c < AI_MAX_NUMBER_OF_COLOR_SETS;++c)
                    {
                        if (pMesh->HasVertexColors( c))
                            pcMesh->mColors[c][iIndexOut] = pMesh->mColors[c][iIndex];
                    }
                }
            }

            // add the newly created mesh to the list
            avList.push_back(std::pair<aiMesh*, unsigned int>(pcMesh,a));
        }

        // now delete the old mesh data
        delete pMesh;
    }
    else avList.push_back(std::pair<aiMesh*, unsigned int>(pMesh,a));
    return;
}

// ------------------------------------------------------------------------------------------------
SplitLargeMeshesProcess_Vertex::SplitLargeMeshesProcess_Vertex()
{
    LIMIT = AI_SLM_DEFAULT_MAX_VERTICES;
}

// ------------------------------------------------------------------------------------------------
SplitLargeMeshesProcess_Vertex::~SplitLargeMeshesProcess_Vertex()
{
    // nothing to do here
}

// ------------------------------------------------------------------------------------------------
// Returns whether the processing step is present in the given flag field.
bool SplitLargeMeshesProcess_Vertex::IsActive( unsigned int pFlags) const
{
    return (pFlags & aiProcess_SplitLargeMeshes) != 0;
}

// ------------------------------------------------------------------------------------------------
// Executes the post processing step on the given imported data.
void SplitLargeMeshesProcess_Vertex::Execute( aiScene* pScene)
{
    std::vector<std::pair<aiMesh*, unsigned int> > avList;

    if (0xffffffff == this->LIMIT)return;

    DefaultLogger::get()->debug("SplitLargeMeshesProcess_Vertex begin");
    for( unsigned int a = 0; a < pScene->mNumMeshes; a++)
        this->SplitMesh(a, pScene->mMeshes[a],avList);

    if (avList.size() != pScene->mNumMeshes)
    {
        // it seems something has been split. rebuild the mesh list
        delete[] pScene->mMeshes;
        pScene->mNumMeshes = (unsigned int)avList.size();
        pScene->mMeshes = new aiMesh*[avList.size()];

        for (unsigned int i = 0; i < avList.size();++i)
            pScene->mMeshes[i] = avList[i].first;

        // now we need to update all nodes
        SplitLargeMeshesProcess_Triangle::UpdateNode(pScene->mRootNode,avList);
        DefaultLogger::get()->info("SplitLargeMeshesProcess_Vertex finished. Meshes have been split");
    }
    else DefaultLogger::get()->debug("SplitLargeMeshesProcess_Vertex finished. There was nothing to do");
    return;
}

// ------------------------------------------------------------------------------------------------
// Setup properties
void SplitLargeMeshesProcess_Vertex::SetupProperties( const Importer* pImp)
{
    this->LIMIT = pImp->GetPropertyInteger(AI_CONFIG_PP_SLM_VERTEX_LIMIT,AI_SLM_DEFAULT_MAX_VERTICES);
}

// ------------------------------------------------------------------------------------------------
// Executes the post processing step on the given imported data.
void SplitLargeMeshesProcess_Vertex::SplitMesh(
    unsigned int a,
    aiMesh* pMesh,
    std::vector<std::pair<aiMesh*, unsigned int> >& avList)
{
    if (pMesh->mNumVertices > SplitLargeMeshesProcess_Vertex::LIMIT)
    {
        typedef std::vector< std::pair<unsigned int,float> > VertexWeightTable;

        // build a per-vertex weight list if necessary
        VertexWeightTable* avPerVertexWeights = ComputeVertexBoneWeightTable(pMesh);

        // we need to split this mesh into sub meshes
        // determine the estimated size of a submesh
        // (this could be too large. Max waste is a single digit percentage)
        const unsigned int iSubMeshes = (pMesh->mNumVertices / SplitLargeMeshesProcess_Vertex::LIMIT) + 1;
        //const unsigned int iOutVertexNum2 = pMesh->mNumVertices /iSubMeshes;

        // create a std::vector<unsigned int> to indicate which vertices
        // have already been copied
        std::vector<unsigned int> avWasCopied;
        avWasCopied.resize(pMesh->mNumVertices,0xFFFFFFFF);

        // try to find a good estimate for the number of output faces
        // per mesh. Add 12.5% as buffer
        unsigned int iEstimatedSize = pMesh->mNumFaces / iSubMeshes;
        iEstimatedSize += iEstimatedSize >> 3;

        // now generate all submeshes
        unsigned int iBase = 0;
        while (true)
        {
            const unsigned int iOutVertexNum = SplitLargeMeshesProcess_Vertex::LIMIT;

            aiMesh* pcMesh          = new aiMesh;
            pcMesh->mNumVertices    = 0;
            pcMesh->mMaterialIndex  = pMesh->mMaterialIndex;

            // the name carries the adjacency information between the meshes
            pcMesh->mName = pMesh->mName;

            typedef std::vector<aiVertexWeight> BoneWeightList;
            if (pMesh->HasBones())
            {
                pcMesh->mBones = new aiBone*[pMesh->mNumBones];
                ::memset(pcMesh->mBones,0,sizeof(void*)*pMesh->mNumBones);
            }

            // clear the temporary helper array
            if (iBase)
            {
                // we can't use memset here we unsigned int needn' be 32 bits
                for (auto &elem : avWasCopied)
                {
                    elem = 0xffffffff;
                }
            }

            // output vectors
            std::vector<aiFace> vFaces;

            // reserve enough storage for most cases
            if (pMesh->HasPositions())
            {
                pcMesh->mVertices = new aiVector3D[iOutVertexNum];
            }
            if (pMesh->HasNormals())
            {
                pcMesh->mNormals = new aiVector3D[iOutVertexNum];
            }
            if (pMesh->HasTangentsAndBitangents())
            {
                pcMesh->mTangents = new aiVector3D[iOutVertexNum];
                pcMesh->mBitangents = new aiVector3D[iOutVertexNum];
            }
            for (unsigned int c = 0; pMesh->HasVertexColors(c);++c)
            {
                pcMesh->mColors[c] = new aiColor4D[iOutVertexNum];
            }
            for (unsigned int c = 0; pMesh->HasTextureCoords(c);++c)
            {
                pcMesh->mNumUVComponents[c] = pMesh->mNumUVComponents[c];
                pcMesh->mTextureCoords[c] = new aiVector3D[iOutVertexNum];
            }
            vFaces.reserve(iEstimatedSize);

            // (we will also need to copy the array of indices)
            while (iBase < pMesh->mNumFaces)
            {
                // allocate a new array
                const unsigned int iNumIndices = pMesh->mFaces[iBase].mNumIndices;

                // doesn't catch degenerates but is quite fast
                unsigned int iNeed = 0;
                for (unsigned int v = 0; v < iNumIndices;++v)
                {
                    unsigned int iIndex = pMesh->mFaces[iBase].mIndices[v];

                    // check whether we do already have this vertex
                    if (0xFFFFFFFF == avWasCopied[iIndex])
                    {
                        iNeed++;
                    }
                }
                if (pcMesh->mNumVertices + iNeed > iOutVertexNum)
                {
                    // don't use this face
                    break;
                }

                vFaces.push_back(aiFace());
                aiFace& rFace = vFaces.back();

                // setup face type and number of indices
                rFace.mNumIndices = iNumIndices;
                rFace.mIndices = new unsigned int[iNumIndices];

                // need to update the output primitive types
                switch (rFace.mNumIndices)
                {
                case 1:
                    pcMesh->mPrimitiveTypes |= aiPrimitiveType_POINT;
                    break;
                case 2:
                    pcMesh->mPrimitiveTypes |= aiPrimitiveType_LINE;
                    break;
                case 3:
                    pcMesh->mPrimitiveTypes |= aiPrimitiveType_TRIANGLE;
                    break;
                default:
                    pcMesh->mPrimitiveTypes |= aiPrimitiveType_POLYGON;
                }

                // and copy the contents of the old array, offset by current base
                for (unsigned int v = 0; v < iNumIndices;++v)
                {
                    unsigned int iIndex = pMesh->mFaces[iBase].mIndices[v];

                    // check whether we do already have this vertex
                    if (0xFFFFFFFF != avWasCopied[iIndex])
                    {
                        rFace.mIndices[v] = avWasCopied[iIndex];
                        continue;
                    }

                    // copy positions
                    pcMesh->mVertices[pcMesh->mNumVertices] = (pMesh->mVertices[iIndex]);

                    // copy normals
                    if (pMesh->HasNormals())
                    {
                        pcMesh->mNormals[pcMesh->mNumVertices] = (pMesh->mNormals[iIndex]);
                    }

                    // copy tangents/bitangents
                    if (pMesh->HasTangentsAndBitangents())
                    {
                        pcMesh->mTangents[pcMesh->mNumVertices] = (pMesh->mTangents[iIndex]);
                        pcMesh->mBitangents[pcMesh->mNumVertices] = (pMesh->mBitangents[iIndex]);
                    }

                    // texture coordinates
                    for (unsigned int c = 0;  c < AI_MAX_NUMBER_OF_TEXTURECOORDS;++c)
                    {
                        if (pMesh->HasTextureCoords( c))
                        {
                            pcMesh->mTextureCoords[c][pcMesh->mNumVertices] = pMesh->mTextureCoords[c][iIndex];
                        }
                    }
                    // vertex colors
                    for (unsigned int c = 0;  c < AI_MAX_NUMBER_OF_COLOR_SETS;++c)
                    {
                        if (pMesh->HasVertexColors( c))
                        {
                            pcMesh->mColors[c][pcMesh->mNumVertices] = pMesh->mColors[c][iIndex];
                        }
                    }
                    // check whether we have bone weights assigned to this vertex
                    rFace.mIndices[v] = pcMesh->mNumVertices;
                    if (avPerVertexWeights)
                    {
                        VertexWeightTable& table = avPerVertexWeights[ pcMesh->mNumVertices ];
                        if( !table.empty() )
                        {
                            for (VertexWeightTable::const_iterator
                                iter =  table.begin();
                                iter != table.end();++iter)
                            {
                                // allocate the bone weight array if necessary
                                BoneWeightList* pcWeightList = (BoneWeightList*)pcMesh->mBones[(*iter).first];
                                if (!pcWeightList)
                                {
                                    pcMesh->mBones[(*iter).first] = (aiBone*)(pcWeightList = new BoneWeightList());
                                }
                                pcWeightList->push_back(aiVertexWeight(pcMesh->mNumVertices,(*iter).second));
                            }
                        }
                    }

                    avWasCopied[iIndex] = pcMesh->mNumVertices;
                    pcMesh->mNumVertices++;
                }
                iBase++;
                if(pcMesh->mNumVertices == iOutVertexNum)
                {
                    // break here. The face is only added if it was complete
                    break;
                }
            }

            // check which bones we'll need to create for this submesh
            if (pMesh->HasBones())
            {
                aiBone** ppCurrent = pcMesh->mBones;
                for (unsigned int k = 0; k < pMesh->mNumBones;++k)
                {
                    // check whether the bone is existing
                    BoneWeightList* pcWeightList;
                    if ((pcWeightList = (BoneWeightList*)pcMesh->mBones[k]))
                    {
                        aiBone* pcOldBone = pMesh->mBones[k];
                        aiBone* pcOut;
                        *ppCurrent++ = pcOut = new aiBone();
                        pcOut->mName = aiString(pcOldBone->mName);
                        pcOut->mOffsetMatrix = pcOldBone->mOffsetMatrix;
                        pcOut->mNumWeights = (unsigned int)pcWeightList->size();
                        pcOut->mWeights = new aiVertexWeight[pcOut->mNumWeights];

                        // copy the vertex weights
                        ::memcpy(pcOut->mWeights,&pcWeightList->operator[](0),
                            pcOut->mNumWeights * sizeof(aiVertexWeight));

                        // delete the temporary bone weight list
                        delete pcWeightList;
                        pcMesh->mNumBones++;
                    }
                }
            }

            // copy the face list to the mesh
            pcMesh->mFaces = new aiFace[vFaces.size()];
            pcMesh->mNumFaces = (unsigned int)vFaces.size();

            for (unsigned int p = 0; p < pcMesh->mNumFaces;++p)
                pcMesh->mFaces[p] = vFaces[p];

            // add the newly created mesh to the list
            avList.push_back(std::pair<aiMesh*, unsigned int>(pcMesh,a));

            if (iBase == pMesh->mNumFaces)
            {
                // have all faces ... finish the outer loop, too
                break;
            }
        }

        // delete the per-vertex weight list again
        delete[] avPerVertexWeights;

        // now delete the old mesh data
        delete pMesh;
        return;
    }
    avList.push_back(std::pair<aiMesh*, unsigned int>(pMesh,a));
    return;
}

/***********************************************************************
FBXIMPORT\TEXTURETRANSFORM.CPP
***********************************************************************/
/*
Open Asset Import Library (assimp)
----------------------------------------------------------------------

Copyright (c) 2006-2016, assimp team
All rights reserved.

Redistribution and use of this software in source and binary forms,
with or without modification, are permitted provided that the
following conditions are met:

* Redistributions of source code must retain the above
  copyright notice, this list of conditions and the
  following disclaimer.

* Redistributions in binary form must reproduce the above
  copyright notice, this list of conditions and the
  following disclaimer in the documentation and/or other
  materials provided with the distribution.

* Neither the name of the assimp team, nor the names of its
  contributors may be used to endorse or promote products
  derived from this software without specific prior
  written permission of the assimp team.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
"AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

----------------------------------------------------------------------
*/

/** @file A helper class that processes texture transformations */





using namespace Assimp;

// ------------------------------------------------------------------------------------------------
// Constructor to be privately used by Importer
TextureTransformStep::TextureTransformStep() :
    configFlags()
{
    // nothing to do here
}

// ------------------------------------------------------------------------------------------------
// Destructor, private as well
TextureTransformStep::~TextureTransformStep()
{
    // nothing to do here
}

// ------------------------------------------------------------------------------------------------
// Returns whether the processing step is present in the given flag field.
bool TextureTransformStep::IsActive( unsigned int pFlags) const
{
    return  (pFlags & aiProcess_TransformUVCoords) != 0;
}

// ------------------------------------------------------------------------------------------------
// Setup properties
void TextureTransformStep::SetupProperties(const Importer* pImp)
{
    configFlags = pImp->GetPropertyInteger(AI_CONFIG_PP_TUV_EVALUATE,AI_UVTRAFO_ALL);
}

// ------------------------------------------------------------------------------------------------
void TextureTransformStep::PreProcessUVTransform(STransformVecInfo& info)
{
    /*  This function tries to simplify the input UV transformation.
     *  That's very important as it allows us to reduce the number
     *  of output UV channels. The oder in which the transformations
     *  are applied is - as always - scaling, rotation, translation.
     */

    char szTemp[512];
    int rounded = 0;


    /* Optimize the rotation angle. That's slightly difficult as
     * we have an inprecise floating-point number (when comparing
     * UV transformations we'll take that into account by using
     * an epsilon of 5 degrees). If there is a rotation value, we can't
     * perform any further optimizations.
     */
    if (info.mRotation)
    {
        float out = info.mRotation;
        if ((rounded = (int)(info.mRotation / (float)AI_MATH_TWO_PI)))
        {
            out -= rounded*(float)AI_MATH_PI;

            ai_snprintf(szTemp, 512, "Texture coordinate rotation %f can be simplified to %f",info.mRotation,out);
            DefaultLogger::get()->info(szTemp);
        }

        // Next step - convert negative rotation angles to positives
        if (out < 0.f)
            out = (float)AI_MATH_TWO_PI * 2 + out;

        info.mRotation = out;
        return;
    }


    /* Optimize UV translation in the U direction. To determine whether
     * or not we can optimize we need to look at the requested mapping
     * type (e.g. if mirroring is active there IS a difference between
     * offset 2 and 3)
     */
    if ((rounded  = (int)info.mTranslation.x))  {
        float out = 0.0f;
        szTemp[0] = 0;
        if (aiTextureMapMode_Wrap == info.mapU) {
            // Wrap - simple take the fraction of the field
            out = info.mTranslation.x-(float)rounded;
			ai_snprintf(szTemp, 512, "[w] UV U offset %f can be simplified to %f", info.mTranslation.x, out);
        }
        else if (aiTextureMapMode_Mirror == info.mapU && 1 != rounded)  {
            // Mirror
            if (rounded % 2)
                rounded--;
            out = info.mTranslation.x-(float)rounded;

            ai_snprintf(szTemp,512,"[m/d] UV U offset %f can be simplified to %f",info.mTranslation.x,out);
        }
        else if (aiTextureMapMode_Clamp == info.mapU || aiTextureMapMode_Decal == info.mapU)    {
            // Clamp - translations beyond 1,1 are senseless
            ai_snprintf(szTemp,512,"[c] UV U offset %f can be clamped to 1.0f",info.mTranslation.x);

            out = 1.f;
        }
        if (szTemp[0])      {
            DefaultLogger::get()->info(szTemp);
            info.mTranslation.x = out;
        }
    }

    /* Optimize UV translation in the V direction. To determine whether
     * or not we can optimize we need to look at the requested mapping
     * type (e.g. if mirroring is active there IS a difference between
     * offset 2 and 3)
     */
    if ((rounded  = (int)info.mTranslation.y))  {
        float out = 0.0f;
        szTemp[0] = 0;
        if (aiTextureMapMode_Wrap == info.mapV) {
            // Wrap - simple take the fraction of the field
            out = info.mTranslation.y-(float)rounded;
            ::ai_snprintf(szTemp,512,"[w] UV V offset %f can be simplified to %f",info.mTranslation.y,out);
        }
        else if (aiTextureMapMode_Mirror == info.mapV  && 1 != rounded) {
            // Mirror
            if (rounded % 2)
                rounded--;
            out = info.mTranslation.x-(float)rounded;

            ::ai_snprintf(szTemp,512,"[m/d] UV V offset %f can be simplified to %f",info.mTranslation.y,out);
        }
        else if (aiTextureMapMode_Clamp == info.mapV || aiTextureMapMode_Decal == info.mapV)    {
            // Clamp - translations beyond 1,1 are senseless
            ::ai_snprintf(szTemp,512,"[c] UV V offset %f canbe clamped to 1.0f",info.mTranslation.y);

            out = 1.f;
        }
        if (szTemp[0])  {
            DefaultLogger::get()->info(szTemp);
            info.mTranslation.y = out;
        }
    }
    return;
}

// ------------------------------------------------------------------------------------------------
void UpdateUVIndex(const std::list<TTUpdateInfo>& l, unsigned int n)
{
    // Don't set if == 0 && wasn't set before
    for (std::list<TTUpdateInfo>::const_iterator it = l.begin();it != l.end(); ++it) {
        const TTUpdateInfo& info = *it;

        if (info.directShortcut)
            *info.directShortcut = n;
        else if (!n)
        {
            info.mat->AddProperty<int>((int*)&n,1,AI_MATKEY_UVWSRC(info.semantic,info.index));
        }
    }
}

// ------------------------------------------------------------------------------------------------
inline const char* MappingModeToChar(aiTextureMapMode map)
{
    if (aiTextureMapMode_Wrap == map)
        return "-w";

    if (aiTextureMapMode_Mirror == map)
        return "-m";

    return "-c";
}

// ------------------------------------------------------------------------------------------------
void TextureTransformStep::Execute( aiScene* pScene)
{
    DefaultLogger::get()->debug("TransformUVCoordsProcess begin");


    /*  We build a per-mesh list of texture transformations we'll need
     *  to apply. To achieve this, we iterate through all materials,
     *  find all textures and get their transformations and UV indices.
     *  Then we search for all meshes using this material.
     */
    typedef std::list<STransformVecInfo> MeshTrafoList;
    std::vector<MeshTrafoList> meshLists(pScene->mNumMeshes);

    for (unsigned int i = 0; i < pScene->mNumMaterials;++i) {

        aiMaterial* mat = pScene->mMaterials[i];
        for (unsigned int a = 0; a < mat->mNumProperties;++a)   {

            aiMaterialProperty* prop = mat->mProperties[a];
            if (!::strcmp( prop->mKey.data, "$tex.file"))   {
                STransformVecInfo info;

                // Setup a shortcut structure to allow for a fast updating
                // of the UV index later
                TTUpdateInfo update;
                update.mat = (aiMaterial*) mat;
                update.semantic = prop->mSemantic;
                update.index = prop->mIndex;

                // Get textured properties and transform
                for (unsigned int a2 = 0; a2 < mat->mNumProperties;++a2)  {
                    aiMaterialProperty* prop2 = mat->mProperties[a2];
                    if (prop2->mSemantic != prop->mSemantic || prop2->mIndex != prop->mIndex) {
                        continue;
                    }

                    if ( !::strcmp( prop2->mKey.data, "$tex.uvwsrc")) {
                        info.uvIndex = *((int*)prop2->mData);

                        // Store a direct pointer for later use
                        update.directShortcut = (unsigned int*) prop2->mData;
                    }

                    else if ( !::strcmp( prop2->mKey.data, "$tex.mapmodeu")) {
                        info.mapU = *((aiTextureMapMode*)prop2->mData);
                    }
                    else if ( !::strcmp( prop2->mKey.data, "$tex.mapmodev")) {
                        info.mapV = *((aiTextureMapMode*)prop2->mData);
                    }
                    else if ( !::strcmp( prop2->mKey.data, "$tex.uvtrafo"))  {
                        // ValidateDS should check this
                        ai_assert(prop2->mDataLength >= 20);
                        ::memcpy(&info.mTranslation.x,prop2->mData,sizeof(float)*5);

                        // Directly remove this property from the list
                        mat->mNumProperties--;
                        for (unsigned int a3 = a2; a3 < mat->mNumProperties;++a3) {
                            mat->mProperties[a3] = mat->mProperties[a3+1];
                        }

                        delete prop2;

                        // Warn: could be an underflow, but this does not invoke undefined behaviour
                        --a2;
                    }
                }

                // Find out which transformations are to be evaluated
                if (!(configFlags & AI_UVTRAFO_ROTATION)) {
                    info.mRotation = 0.f;
                }
                if (!(configFlags & AI_UVTRAFO_SCALING)) {
                    info.mScaling = aiVector2D(1.f,1.f);
                }
                if (!(configFlags & AI_UVTRAFO_TRANSLATION)) {
                    info.mTranslation = aiVector2D(0.f,0.f);
                }

                // Do some preprocessing
                PreProcessUVTransform(info);
                info.uvIndex = std::min(info.uvIndex,AI_MAX_NUMBER_OF_TEXTURECOORDS -1u);

                // Find out whether this material is used by more than
                // one mesh. This will make our task much, much more difficult!
                unsigned int cnt = 0;
                for (unsigned int n = 0; n < pScene->mNumMeshes;++n)    {
                    if (pScene->mMeshes[n]->mMaterialIndex == i)
                        ++cnt;
                }

                if (!cnt)
                    continue;
                else if (1 != cnt)  {
                    // This material is referenced by more than one mesh!
                    // So we need to make sure the UV index for the texture
                    // is identical for each of it ...
                    info.lockedPos = AI_TT_UV_IDX_LOCK_TBD;
                }

                // Get all coresponding meshes
                for (unsigned int n = 0; n < pScene->mNumMeshes;++n)    {
                    aiMesh* mesh = pScene->mMeshes[n];
                    if (mesh->mMaterialIndex != i || !mesh->mTextureCoords[0])
                        continue;

                    unsigned int uv = info.uvIndex;
                    if (!mesh->mTextureCoords[uv])  {
                        // If the requested UV index is not available, take the first one instead.
                        uv = 0;
                    }

                    if (mesh->mNumUVComponents[info.uvIndex] >= 3){
                        DefaultLogger::get()->warn("UV transformations on 3D mapping channels are not supported");
                        continue;
                    }

                    MeshTrafoList::iterator it;

                    // Check whether we have this transform setup already
                    for (it = meshLists[n].begin();it != meshLists[n].end(); ++it)  {

                        if ((*it) == info && (*it).uvIndex == uv)   {
                            (*it).updateList.push_back(update);
                            break;
                        }
                    }

                    if (it == meshLists[n].end())   {
                        meshLists[n].push_back(info);
                        meshLists[n].back().uvIndex = uv;
                        meshLists[n].back().updateList.push_back(update);
                    }
                }
            }
        }
    }

    char buffer[1024]; // should be sufficiently large
    unsigned int outChannels = 0, inChannels = 0, transformedChannels = 0;

    // Now process all meshes. Important: we don't remove unreferenced UV channels.
    // This is a job for the RemoveUnreferencedData-Step.
    for (unsigned int q = 0; q < pScene->mNumMeshes;++q)    {

        aiMesh* mesh = pScene->mMeshes[q];
        MeshTrafoList& trafo =  meshLists[q];

        inChannels += mesh->GetNumUVChannels();

        if (!mesh->mTextureCoords[0] || trafo.empty() ||  (trafo.size() == 1 && trafo.begin()->IsUntransformed())) {
            outChannels += mesh->GetNumUVChannels();
            continue;
        }

        // Move untransformed UV channels to the first position in the list ....
        // except if we need a new locked index which should be as small as possible
        bool veto = false, need = false;
        unsigned int cnt = 0;
        unsigned int untransformed = 0;

        MeshTrafoList::iterator it,it2;
        for (it = trafo.begin();it != trafo.end(); ++it,++cnt)  {

            if (!(*it).IsUntransformed()) {
                need = true;
            }

            if ((*it).lockedPos == AI_TT_UV_IDX_LOCK_TBD)   {
                // Lock this index and make sure it won't be changed
                (*it).lockedPos = cnt;
                veto = true;
                continue;
            }

            if (!veto && it != trafo.begin() && (*it).IsUntransformed())    {
                for (it2 = trafo.begin();it2 != it; ++it2) {
                    if (!(*it2).IsUntransformed())
                        break;
                }
                trafo.insert(it2,*it);
                trafo.erase(it);
                break;
            }
        }
        if (!need)
            continue;

        // Find all that are not at their 'locked' position and move them to it.
        // Conflicts are possible but quite unlikely.
        cnt = 0;
        for (it = trafo.begin();it != trafo.end(); ++it,++cnt) {
            if ((*it).lockedPos != AI_TT_UV_IDX_LOCK_NONE && (*it).lockedPos != cnt) {
                it2 = trafo.begin();unsigned int t = 0;
                while (t != (*it).lockedPos)
                    ++it2;

                if ((*it2).lockedPos != AI_TT_UV_IDX_LOCK_NONE) {
                    DefaultLogger::get()->error("Channel mismatch, can't compute all transformations properly [design bug]");
                    continue;
                }

                std::swap(*it2,*it);
                if ((*it).lockedPos == untransformed)
                    untransformed = cnt;
            }
        }

        // ... and add dummies for all unreferenced channels
        // at the end of the list
        bool ref[AI_MAX_NUMBER_OF_TEXTURECOORDS];
        for (unsigned int n = 0; n < AI_MAX_NUMBER_OF_TEXTURECOORDS;++n)
            ref[n] = (!mesh->mTextureCoords[n] ? true : false);

        for (it = trafo.begin();it != trafo.end(); ++it)
            ref[(*it).uvIndex] = true;

        for (unsigned int n = 0; n < AI_MAX_NUMBER_OF_TEXTURECOORDS;++n) {
            if (ref[n])
                continue;
            trafo.push_back(STransformVecInfo());
            trafo.back().uvIndex = n;
        }

        // Then check whether this list breaks the channel limit.
        // The unimportant ones are at the end of the list, so
        // it shouldn't be too worse if we remove them.
        unsigned int size = (unsigned int)trafo.size();
        if (size > AI_MAX_NUMBER_OF_TEXTURECOORDS) {

            if (!DefaultLogger::isNullLogger()) {
                ::ai_snprintf(buffer,1024,"%u UV channels required but just %u available",
                    static_cast<unsigned int>(trafo.size()),AI_MAX_NUMBER_OF_TEXTURECOORDS);

                DefaultLogger::get()->error(buffer);
            }
            size = AI_MAX_NUMBER_OF_TEXTURECOORDS;
        }


        aiVector3D* old[AI_MAX_NUMBER_OF_TEXTURECOORDS];
        for (unsigned int n = 0; n < AI_MAX_NUMBER_OF_TEXTURECOORDS;++n)
            old[n] = mesh->mTextureCoords[n];

        // Now continue and generate the output channels. Channels
        // that we're not going to need later can be overridden.
        it = trafo.begin();
        for (unsigned int n = 0; n < trafo.size();++n,++it) {

            if (n >= size)  {
                // Try to use an untransformed channel for all channels we threw over board
                UpdateUVIndex((*it).updateList,untransformed);
                continue;
            }

            outChannels++;

            // Write to the log
            if (!DefaultLogger::isNullLogger()) {
                ::ai_snprintf(buffer,1024,"Mesh %u, channel %u: t(%.3f,%.3f), s(%.3f,%.3f), r(%.3f), %s%s",
                    q,n,
                    (*it).mTranslation.x,
                    (*it).mTranslation.y,
                    (*it).mScaling.x,
                    (*it).mScaling.y,
                    AI_RAD_TO_DEG( (*it).mRotation),
                    MappingModeToChar ((*it).mapU),
                    MappingModeToChar ((*it).mapV));

                DefaultLogger::get()->info(buffer);
            }

            // Check whether we need a new buffer here
            if (mesh->mTextureCoords[n])    {

                it2 = it;++it2;
                for (unsigned int m = n+1; m < size;++m, ++it2) {

                    if ((*it2).uvIndex == n){
                        it2 = trafo.begin();
                        break;
                    }
                }
                if (it2 == trafo.begin()){
                    mesh->mTextureCoords[n] = new aiVector3D[mesh->mNumVertices];
                }
            }
            else mesh->mTextureCoords[n] = new aiVector3D[mesh->mNumVertices];

            aiVector3D* src = old[(*it).uvIndex];
            aiVector3D* dest, *end;
            dest = mesh->mTextureCoords[n];

            ai_assert(NULL != src);

            // Copy the data to the destination array
            if (dest != src)
                ::memcpy(dest,src,sizeof(aiVector3D)*mesh->mNumVertices);

            end = dest + mesh->mNumVertices;

            // Build a transformation matrix and transform all UV coords with it
            if (!(*it).IsUntransformed()) {
                const aiVector2D& trl = (*it).mTranslation;
                const aiVector2D& scl = (*it).mScaling;

                // fixme: simplify ..
                ++transformedChannels;
                aiMatrix3x3 matrix;

                aiMatrix3x3 m2,m3,m4,m5;

                m4.a1 = scl.x;
                m4.b2 = scl.y;

                m2.a3 = m2.b3 = 0.5f;
                m3.a3 = m3.b3 = -0.5f;

                if ((*it).mRotation > AI_TT_ROTATION_EPSILON )
                    aiMatrix3x3::RotationZ((*it).mRotation,matrix);

                m5.a3 += trl.x; m5.b3 += trl.y;
                matrix = m2 * m4 * matrix * m3 * m5;

                for (src = dest; src != end; ++src) { /* manual homogenious divide */
                    src->z = 1.f;
                    *src = matrix * *src;
                    src->x /= src->z;
                    src->y /= src->z;
                    src->z = 0.f;
                }
            }

            // Update all UV indices
            UpdateUVIndex((*it).updateList,n);
        }
    }

    // Print some detailed statistics into the log
    if (!DefaultLogger::isNullLogger()) {

        if (transformedChannels)    {
            ::ai_snprintf(buffer,1024,"TransformUVCoordsProcess end: %u output channels (in: %u, modified: %u)",
                outChannels,inChannels,transformedChannels);

            DefaultLogger::get()->info(buffer);
        }
        else DefaultLogger::get()->debug("TransformUVCoordsProcess finished");
    }
}



/***********************************************************************
FBXIMPORT\TRIANGULATEPROCESS.CPP
***********************************************************************/
/*
---------------------------------------------------------------------------
Open Asset Import Library (assimp)
---------------------------------------------------------------------------

Copyright (c) 2006-2016, assimp team

All rights reserved.

Redistribution and use of this software in source and binary forms,
with or without modification, are permitted provided that the following
conditions are met:

* Redistributions of source code must retain the above
  copyright notice, this list of conditions and the
  following disclaimer.

* Redistributions in binary form must reproduce the above
  copyright notice, this list of conditions and the
  following disclaimer in the documentation and/or other
  materials provided with the distribution.

* Neither the name of the assimp team, nor the names of its
  contributors may be used to endorse or promote products
  derived from this software without specific prior
  written permission of the assimp team.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
"AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
---------------------------------------------------------------------------
*/

/** @file  TriangulateProcess.cpp
 *  @brief Implementation of the post processing step to split up
 *    all faces with more than three indices into triangles.
 *
 *
 *  The triangulation algorithm will handle concave or convex polygons.
 *  Self-intersecting or non-planar polygons are not rejected, but
 *  they're probably not triangulated correctly.
 *
 * DEBUG SWITCHES - do not enable any of them in release builds:
 *
 * AI_BUILD_TRIANGULATE_COLOR_FACE_WINDING
 *   - generates vertex colors to represent the face winding order.
 *     the first vertex of a polygon becomes red, the last blue.
 * AI_BUILD_TRIANGULATE_DEBUG_POLYS
 *   - dump all polygons and their triangulation sequences to
 *     a file
 */



#ifndef ASSIMP_BUILD_NO_TRIANGULATE_PROCESS

//#define AI_BUILD_TRIANGULATE_COLOR_FACE_WINDING
//#define AI_BUILD_TRIANGULATE_DEBUG_POLYS

#define POLY_GRID_Y 40
#define POLY_GRID_X 70
#define POLY_GRID_XPAD 20
#define POLY_OUTPUT_FILE "assimp_polygons_debug.txt"

using namespace Assimp;

// ------------------------------------------------------------------------------------------------
// Constructor to be privately used by Importer
TriangulateProcess::TriangulateProcess()
{
    // nothing to do here
}

// ------------------------------------------------------------------------------------------------
// Destructor, private as well
TriangulateProcess::~TriangulateProcess()
{
    // nothing to do here
}

// ------------------------------------------------------------------------------------------------
// Returns whether the processing step is present in the given flag field.
bool TriangulateProcess::IsActive( unsigned int pFlags) const
{
    return (pFlags & aiProcess_Triangulate) != 0;
}

// ------------------------------------------------------------------------------------------------
// Executes the post processing step on the given imported data.
void TriangulateProcess::Execute( aiScene* pScene)
{
    DefaultLogger::get()->debug("TriangulateProcess begin");

    bool bHas = false;
    for( unsigned int a = 0; a < pScene->mNumMeshes; a++)
    {
        if( TriangulateMesh( pScene->mMeshes[a]))
            bHas = true;
    }
    if (bHas)DefaultLogger::get()->info ("TriangulateProcess finished. All polygons have been triangulated.");
    else     DefaultLogger::get()->debug("TriangulateProcess finished. There was nothing to be done.");
}


// ------------------------------------------------------------------------------------------------
// Triangulates the given mesh.
bool TriangulateProcess::TriangulateMesh( aiMesh* pMesh)
{
    // Now we have aiMesh::mPrimitiveTypes, so this is only here for test cases
    if (!pMesh->mPrimitiveTypes)    {
        bool bNeed = false;

        for( unsigned int a = 0; a < pMesh->mNumFaces; a++) {
            const aiFace& face = pMesh->mFaces[a];

            if( face.mNumIndices != 3)  {
                bNeed = true;
            }
        }
        if (!bNeed)
            return false;
    }
    else if (!(pMesh->mPrimitiveTypes & aiPrimitiveType_POLYGON)) {
        return false;
    }

    // Find out how many output faces we'll get
    unsigned int numOut = 0, max_out = 0;
    bool get_normals = true;
    for( unsigned int a = 0; a < pMesh->mNumFaces; a++) {
        aiFace& face = pMesh->mFaces[a];
        if (face.mNumIndices <= 4) {
            get_normals = false;
        }
        if( face.mNumIndices <= 3) {
            numOut++;

        }
        else {
            numOut += face.mNumIndices-2;
            max_out = std::max(max_out,face.mNumIndices);
        }
    }

    // Just another check whether aiMesh::mPrimitiveTypes is correct
    assert(numOut != pMesh->mNumFaces);

    aiVector3D* nor_out = NULL;

    // if we don't have normals yet, but expect them to be a cheap side
    // product of triangulation anyway, allocate storage for them.
    if (!pMesh->mNormals && get_normals) {
        // XXX need a mechanism to inform the GenVertexNormals process to treat these normals as preprocessed per-face normals
    //  nor_out = pMesh->mNormals = new aiVector3D[pMesh->mNumVertices];
    }

    // the output mesh will contain triangles, but no polys anymore
    pMesh->mPrimitiveTypes |= aiPrimitiveType_TRIANGLE;
    pMesh->mPrimitiveTypes &= ~aiPrimitiveType_POLYGON;

    aiFace* out = new aiFace[numOut](), *curOut = out;
    std::vector<aiVector3D> temp_verts3d(max_out+2); /* temporary storage for vertices */
    std::vector<aiVector2D> temp_verts(max_out+2);

    // Apply vertex colors to represent the face winding?
#ifdef AI_BUILD_TRIANGULATE_COLOR_FACE_WINDING
    if (!pMesh->mColors[0])
        pMesh->mColors[0] = new aiColor4D[pMesh->mNumVertices];
    else
        new(pMesh->mColors[0]) aiColor4D[pMesh->mNumVertices];

    aiColor4D* clr = pMesh->mColors[0];
#endif


#ifdef AI_BUILD_TRIANGULATE_DEBUG_POLYS
    FILE* fout = fopen(POLY_OUTPUT_FILE,"a");
#endif

    const aiVector3D* verts = pMesh->mVertices;

    // use std::unique_ptr to avoid slow std::vector<bool> specialiations
    std::unique_ptr<bool[]> done(new bool[max_out]);
    for( unsigned int a = 0; a < pMesh->mNumFaces; a++) {
        aiFace& face = pMesh->mFaces[a];

        unsigned int* idx = face.mIndices;
        int num = (int)face.mNumIndices, ear = 0, tmp, prev = num-1, next = 0, max = num;

        // Apply vertex colors to represent the face winding?
#ifdef AI_BUILD_TRIANGULATE_COLOR_FACE_WINDING
        for (unsigned int i = 0; i < face.mNumIndices; ++i) {
            aiColor4D& c = clr[idx[i]];
            c.r = (i+1) / (float)max;
            c.b = 1.f - c.r;
        }
#endif

        aiFace* const last_face = curOut;

        // if it's a simple point,line or triangle: just copy it
        if( face.mNumIndices <= 3)
        {
            aiFace& nface = *curOut++;
            nface.mNumIndices = face.mNumIndices;
            nface.mIndices    = face.mIndices;

            face.mIndices = NULL;
            continue;
        }
        // optimized code for quadrilaterals
        else if ( face.mNumIndices == 4) {

            // quads can have at maximum one concave vertex. Determine
            // this vertex (if it exists) and start tri-fanning from
            // it.
            unsigned int start_vertex = 0;
            for (unsigned int i = 0; i < 4; ++i) {
                const aiVector3D& v0 = verts[face.mIndices[(i+3) % 4]];
                const aiVector3D& v1 = verts[face.mIndices[(i+2) % 4]];
                const aiVector3D& v2 = verts[face.mIndices[(i+1) % 4]];

                const aiVector3D& v = verts[face.mIndices[i]];

                aiVector3D left = (v0-v);
                aiVector3D diag = (v1-v);
                aiVector3D right = (v2-v);

                left.Normalize();
                diag.Normalize();
                right.Normalize();

                const float angle = std::acos(left*diag) + std::acos(right*diag);
                if (angle > AI_MATH_PI_F) {
                    // this is the concave point
                    start_vertex = i;
                    break;
                }
            }

            const unsigned int temp[] = {face.mIndices[0], face.mIndices[1], face.mIndices[2], face.mIndices[3]};

            aiFace& nface = *curOut++;
            nface.mNumIndices = 3;
            nface.mIndices = face.mIndices;

            nface.mIndices[0] = temp[start_vertex];
            nface.mIndices[1] = temp[(start_vertex + 1) % 4];
            nface.mIndices[2] = temp[(start_vertex + 2) % 4];

            aiFace& sface = *curOut++;
            sface.mNumIndices = 3;
            sface.mIndices = new unsigned int[3];

            sface.mIndices[0] = temp[start_vertex];
            sface.mIndices[1] = temp[(start_vertex + 2) % 4];
            sface.mIndices[2] = temp[(start_vertex + 3) % 4];

            // prevent double deletion of the indices field
            face.mIndices = NULL;
            continue;
        }
        else
        {
            // A polygon with more than 3 vertices can be either concave or convex.
            // Usually everything we're getting is convex and we could easily
            // triangulate by trifanning. However, LightWave is probably the only
            // modeling suite to make extensive use of highly concave, monster polygons ...
            // so we need to apply the full 'ear cutting' algorithm to get it right.

            // RERQUIREMENT: polygon is expected to be simple and *nearly* planar.
            // We project it onto a plane to get a 2d triangle.

            // Collect all vertices of of the polygon.
            for (tmp = 0; tmp < max; ++tmp) {
                temp_verts3d[tmp] = verts[idx[tmp]];
            }

            // Get newell normal of the polygon. Store it for future use if it's a polygon-only mesh
            aiVector3D n;
            NewellNormal<3,3,3>(n,max,&temp_verts3d.front().x,&temp_verts3d.front().y,&temp_verts3d.front().z);
            if (nor_out) {
                 for (tmp = 0; tmp < max; ++tmp)
                     nor_out[idx[tmp]] = n;
            }

            // Select largest normal coordinate to ignore for projection
            const float ax = (n.x>0 ? n.x : -n.x);
            const float ay = (n.y>0 ? n.y : -n.y);
            const float az = (n.z>0 ? n.z : -n.z);

            unsigned int ac = 0, bc = 1; /* no z coord. projection to xy */
            float inv = n.z;
            if (ax > ay) {
                if (ax > az) { /* no x coord. projection to yz */
                    ac = 1; bc = 2;
                    inv = n.x;
                }
            }
            else if (ay > az) { /* no y coord. projection to zy */
                ac = 2; bc = 0;
                inv = n.y;
            }

            // Swap projection axes to take the negated projection vector into account
            if (inv < 0.f) {
                std::swap(ac,bc);
            }

            for (tmp =0; tmp < max; ++tmp) {
                temp_verts[tmp].x = verts[idx[tmp]][ac];
                temp_verts[tmp].y = verts[idx[tmp]][bc];
                done[tmp] = false;
            }


#ifdef AI_BUILD_TRIANGULATE_DEBUG_POLYS
            // plot the plane onto which we mapped the polygon to a 2D ASCII pic
            aiVector2D bmin,bmax;
            ArrayBounds(&temp_verts[0],max,bmin,bmax);

            char grid[POLY_GRID_Y][POLY_GRID_X+POLY_GRID_XPAD];
            std::fill_n((char*)grid,POLY_GRID_Y*(POLY_GRID_X+POLY_GRID_XPAD),' ');

            for (int i =0; i < max; ++i) {
                const aiVector2D& v = (temp_verts[i] - bmin) / (bmax-bmin);
                const size_t x = static_cast<size_t>(v.x*(POLY_GRID_X-1)), y = static_cast<size_t>(v.y*(POLY_GRID_Y-1));
                char* loc = grid[y]+x;
                if (grid[y][x] != ' ') {
                    for(;*loc != ' '; ++loc);
                    *loc++ = '_';
                }
                *(loc+::ai_snprintf(loc, POLY_GRID_XPAD,"%i",i)) = ' ';
            }


            for(size_t y = 0; y < POLY_GRID_Y; ++y) {
                grid[y][POLY_GRID_X+POLY_GRID_XPAD-1] = '\0';
                fprintf(fout,"%s\n",grid[y]);
            }

            fprintf(fout,"\ntriangulation sequence: ");
#endif

            //
            // FIXME: currently this is the slow O(kn) variant with a worst case
            // complexity of O(n^2) (I think). Can be done in O(n).
            while (num > 3) {

                // Find the next ear of the polygon
                int num_found = 0;
                for (ear = next;;prev = ear,ear = next) {

                    // break after we looped two times without a positive match
                    for (next=ear+1;done[(next>=max?next=0:next)];++next);
                    if (next < ear) {
                        if (++num_found == 2) {
                            break;
                        }
                    }
                    const aiVector2D* pnt1 = &temp_verts[ear],
                        *pnt0 = &temp_verts[prev],
                        *pnt2 = &temp_verts[next];

                    // Must be a convex point. Assuming ccw winding, it must be on the right of the line between p-1 and p+1.
                    if (OnLeftSideOfLine2D(*pnt0,*pnt2,*pnt1)) {
                        continue;
                    }

                    // and no other point may be contained in this triangle
                    for ( tmp = 0; tmp < max; ++tmp) {

                        // We need to compare the actual values because it's possible that multiple indexes in
                        // the polygon are referring to the same position. concave_polygon.obj is a sample
                        //
                        // FIXME: Use 'epsiloned' comparisons instead? Due to numeric inaccuracies in
                        // PointInTriangle() I'm guessing that it's actually possible to construct
                        // input data that would cause us to end up with no ears. The problem is,
                        // which epsilon? If we chose a too large value, we'd get wrong results
                        const aiVector2D& vtmp = temp_verts[tmp];
                        if ( vtmp != *pnt1 && vtmp != *pnt2 && vtmp != *pnt0 && PointInTriangle2D(*pnt0,*pnt1,*pnt2,vtmp)) {
                            break;
                        }
                    }
                    if (tmp != max) {
                        continue;
                    }

                    // this vertex is an ear
                    break;
                }
                if (num_found == 2) {

                    // Due to the 'two ear theorem', every simple polygon with more than three points must
                    // have 2 'ears'. Here's definitely someting wrong ... but we don't give up yet.
                    //

                    // Instead we're continuting with the standard trifanning algorithm which we'd
                    // use if we had only convex polygons. That's life.
                    DefaultLogger::get()->error("Failed to triangulate polygon (no ear found). Probably not a simple polygon?");


#ifdef AI_BUILD_TRIANGULATE_DEBUG_POLYS
                    fprintf(fout,"critical error here, no ear found! ");
#endif
                    num = 0;
                    break;

                    curOut -= (max-num); /* undo all previous work */
                    for (tmp = 0; tmp < max-2; ++tmp) {
                        aiFace& nface = *curOut++;

                        nface.mNumIndices = 3;
                        if (!nface.mIndices)
                            nface.mIndices = new unsigned int[3];

                        nface.mIndices[0] = 0;
                        nface.mIndices[1] = tmp+1;
                        nface.mIndices[2] = tmp+2;

                    }
                    num = 0;
                    break;
                }

                aiFace& nface = *curOut++;
                nface.mNumIndices = 3;

                if (!nface.mIndices) {
                    nface.mIndices = new unsigned int[3];
                }

                // setup indices for the new triangle ...
                nface.mIndices[0] = prev;
                nface.mIndices[1] = ear;
                nface.mIndices[2] = next;

                // exclude the ear from most further processing
                done[ear] = true;
                --num;
            }
            if (num > 0) {
                // We have three indices forming the last 'ear' remaining. Collect them.
                aiFace& nface = *curOut++;
                nface.mNumIndices = 3;
                if (!nface.mIndices) {
                    nface.mIndices = new unsigned int[3];
                }

                for (tmp = 0; done[tmp]; ++tmp);
                nface.mIndices[0] = tmp;

                for (++tmp; done[tmp]; ++tmp);
                nface.mIndices[1] = tmp;

                for (++tmp; done[tmp]; ++tmp);
                nface.mIndices[2] = tmp;

            }
        }

#ifdef AI_BUILD_TRIANGULATE_DEBUG_POLYS

        for(aiFace* f = last_face; f != curOut; ++f) {
            unsigned int* i = f->mIndices;
            fprintf(fout," (%i %i %i)",i[0],i[1],i[2]);
        }

        fprintf(fout,"\n*********************************************************************\n");
        fflush(fout);

#endif

        for(aiFace* f = last_face; f != curOut; ) {
            unsigned int* i = f->mIndices;

            //  drop dumb 0-area triangles
            if (std::fabs(GetArea2D(temp_verts[i[0]],temp_verts[i[1]],temp_verts[i[2]])) < 1e-5f) {
                DefaultLogger::get()->debug("Dropping triangle with area 0");
                --curOut;

                delete[] f->mIndices;
                f->mIndices = NULL;

                for(aiFace* ff = f; ff != curOut; ++ff) {
                    ff->mNumIndices = (ff+1)->mNumIndices;
                    ff->mIndices = (ff+1)->mIndices;
                    (ff+1)->mIndices = NULL;
                }
                continue;
            }

            i[0] = idx[i[0]];
            i[1] = idx[i[1]];
            i[2] = idx[i[2]];
            ++f;
        }

        delete[] face.mIndices;
        face.mIndices = NULL;
    }

#ifdef AI_BUILD_TRIANGULATE_DEBUG_POLYS
    fclose(fout);
#endif

    // kill the old faces
    delete [] pMesh->mFaces;

    // ... and store the new ones
    pMesh->mFaces    = out;
    pMesh->mNumFaces = (unsigned int)(curOut-out); /* not necessarily equal to numOut */
    return true;
}

#endif // !! ASSIMP_BUILD_NO_TRIANGULATE_PROCESS

/***********************************************************************
FBXIMPORT\VALIDATEDATASTRUCTURE.CPP
***********************************************************************/
/*
---------------------------------------------------------------------------
Open Asset Import Library (assimp)
---------------------------------------------------------------------------

Copyright (c) 2006-2016, assimp team

All rights reserved.

Redistribution and use of this software in source and binary forms,
with or without modification, are permitted provided that the following
conditions are met:

* Redistributions of source code must retain the above
  copyright notice, this list of conditions and the
  following disclaimer.

* Redistributions in binary form must reproduce the above
  copyright notice, this list of conditions and the
  following disclaimer in the documentation and/or other
  materials provided with the distribution.

* Neither the name of the assimp team, nor the names of its
  contributors may be used to endorse or promote products
  derived from this software without specific prior
  written permission of the assimp team.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
"AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
---------------------------------------------------------------------------
*/

/** @file  ValidateDataStructure.cpp
 *  @brief Implementation of the post processing step to validate
 *    the data structure returned by Assimp.
 */



// internal headers

// CRT headers
#include <stdarg.h>

using namespace Assimp;

// ------------------------------------------------------------------------------------------------
// Constructor to be privately used by Importer
ValidateDSProcess::ValidateDSProcess() :
    mScene()
{}

// ------------------------------------------------------------------------------------------------
// Destructor, private as well
ValidateDSProcess::~ValidateDSProcess()
{}

// ------------------------------------------------------------------------------------------------
// Returns whether the processing step is present in the given flag field.
bool ValidateDSProcess::IsActive( unsigned int pFlags) const
{
    return (pFlags & aiProcess_ValidateDataStructure) != 0;
}
// ------------------------------------------------------------------------------------------------
AI_WONT_RETURN void ValidateDSProcess::ReportError(const char* msg,...)
{
    ai_assert(NULL != msg);

    va_list args;
    va_start(args,msg);

    char szBuffer[3000];
    const int iLen = vsprintf(szBuffer,msg,args);
    ai_assert(iLen > 0);

    va_end(args);
#ifdef ASSIMP_BUILD_DEBUG
    ai_assert( false );
#endif
    throw DeadlyImportError("Validation failed: " + std::string(szBuffer,iLen));
}
// ------------------------------------------------------------------------------------------------
void ValidateDSProcess::ReportWarning(const char* msg,...)
{
    ai_assert(NULL != msg);

    va_list args;
    va_start(args,msg);

    char szBuffer[3000];
    const int iLen = vsprintf(szBuffer,msg,args);
    ai_assert(iLen > 0);

    va_end(args);
    DefaultLogger::get()->warn("Validation warning: " + std::string(szBuffer,iLen));
}

// ------------------------------------------------------------------------------------------------
inline int HasNameMatch(const aiString& in, aiNode* node)
{
    int result = (node->mName == in ? 1 : 0 );
    for (unsigned int i = 0; i < node->mNumChildren;++i)    {
        result += HasNameMatch(in,node->mChildren[i]);
    }
    return result;
}

// ------------------------------------------------------------------------------------------------
template <typename T>
inline void ValidateDSProcess::DoValidation(T** parray, unsigned int size,
    const char* firstName, const char* secondName)
{
    // validate all entries
    if (size)
    {
        if (!parray)
        {
            ReportError("aiScene::%s is NULL (aiScene::%s is %i)",
                firstName, secondName, size);
        }
        for (unsigned int i = 0; i < size;++i)
        {
            if (!parray[i])
            {
                ReportError("aiScene::%s[%i] is NULL (aiScene::%s is %i)",
                    firstName,i,secondName,size);
            }
            Validate(parray[i]);
        }
    }
}

// ------------------------------------------------------------------------------------------------
template <typename T>
inline void ValidateDSProcess::DoValidationEx(T** parray, unsigned int size,
    const char* firstName, const char* secondName)
{
    // validate all entries
    if (size)
    {
        if (!parray)    {
            ReportError("aiScene::%s is NULL (aiScene::%s is %i)",
                firstName, secondName, size);
        }
        for (unsigned int i = 0; i < size;++i)
        {
            if (!parray[i])
            {
                ReportError("aiScene::%s[%i] is NULL (aiScene::%s is %i)",
                    firstName,i,secondName,size);
            }
            Validate(parray[i]);

            // check whether there are duplicate names
            for (unsigned int a = i+1; a < size;++a)
            {
                if (parray[i]->mName == parray[a]->mName)
                {
                    this->ReportError("aiScene::%s[%i] has the same name as "
                        "aiScene::%s[%i]",firstName, i,secondName, a);
                }
            }
        }
    }
}

// ------------------------------------------------------------------------------------------------
template <typename T>
inline void ValidateDSProcess::DoValidationWithNameCheck(T** array,
    unsigned int size, const char* firstName,
    const char* secondName)
{
    // validate all entries
    DoValidationEx(array,size,firstName,secondName);

    for (unsigned int i = 0; i < size;++i)
    {
        int res = HasNameMatch(array[i]->mName,mScene->mRootNode);
        if (!res)   {
            ReportError("aiScene::%s[%i] has no corresponding node in the scene graph (%s)",
                firstName,i,array[i]->mName.data);
        }
        else if (1 != res)  {
            ReportError("aiScene::%s[%i]: there are more than one nodes with %s as name",
                firstName,i,array[i]->mName.data);
        }
    }
}

// ------------------------------------------------------------------------------------------------
// Executes the post processing step on the given imported data.
void ValidateDSProcess::Execute( aiScene* pScene)
{
    this->mScene = pScene;
    DefaultLogger::get()->debug("ValidateDataStructureProcess begin");

    // validate the node graph of the scene
    Validate(pScene->mRootNode);

    // validate all meshes
    if (pScene->mNumMeshes) {
        DoValidation(pScene->mMeshes,pScene->mNumMeshes,"mMeshes","mNumMeshes");
    }
    else if (!(mScene->mFlags & AI_SCENE_FLAGS_INCOMPLETE)) {
        ReportError("aiScene::mNumMeshes is 0. At least one mesh must be there");
    }
    else if (pScene->mMeshes)   {
        ReportError("aiScene::mMeshes is non-null although there are no meshes");
    }

    // validate all animations
    if (pScene->mNumAnimations) {
        DoValidation(pScene->mAnimations,pScene->mNumAnimations,
            "mAnimations","mNumAnimations");
    }
    else if (pScene->mAnimations)   {
        ReportError("aiScene::mAnimations is non-null although there are no animations");
    }

    // validate all cameras
    if (pScene->mNumCameras) {
        DoValidationWithNameCheck(pScene->mCameras,pScene->mNumCameras,
            "mCameras","mNumCameras");
    }
    else if (pScene->mCameras)  {
        ReportError("aiScene::mCameras is non-null although there are no cameras");
    }

    // validate all lights
    if (pScene->mNumLights) {
        DoValidationWithNameCheck(pScene->mLights,pScene->mNumLights,
            "mLights","mNumLights");
    }
    else if (pScene->mLights)   {
        ReportError("aiScene::mLights is non-null although there are no lights");
    }

    // validate all textures
    if (pScene->mNumTextures) {
        DoValidation(pScene->mTextures,pScene->mNumTextures,
            "mTextures","mNumTextures");
    }
    else if (pScene->mTextures) {
        ReportError("aiScene::mTextures is non-null although there are no textures");
    }

    // validate all materials
    if (pScene->mNumMaterials) {
        DoValidation(pScene->mMaterials,pScene->mNumMaterials,"mMaterials","mNumMaterials");
    }
#if 0
    // NOTE: ScenePreprocessor generates a default material if none is there
    else if (!(mScene->mFlags & AI_SCENE_FLAGS_INCOMPLETE)) {
        ReportError("aiScene::mNumMaterials is 0. At least one material must be there");
    }
#endif
    else if (pScene->mMaterials)    {
        ReportError("aiScene::mMaterials is non-null although there are no materials");
    }

//  if (!has)ReportError("The aiScene data structure is empty");
    DefaultLogger::get()->debug("ValidateDataStructureProcess end");
}

// ------------------------------------------------------------------------------------------------
void ValidateDSProcess::Validate( const aiLight* pLight)
{
    if (pLight->mType == aiLightSource_UNDEFINED)
        ReportWarning("aiLight::mType is aiLightSource_UNDEFINED");

    if (!pLight->mAttenuationConstant &&
        !pLight->mAttenuationLinear   &&
        !pLight->mAttenuationQuadratic) {
        ReportWarning("aiLight::mAttenuationXXX - all are zero");
    }

    if (pLight->mAngleInnerCone > pLight->mAngleOuterCone)
        ReportError("aiLight::mAngleInnerCone is larger than aiLight::mAngleOuterCone");

    if (pLight->mColorDiffuse.IsBlack() && pLight->mColorAmbient.IsBlack()
        && pLight->mColorSpecular.IsBlack())
    {
        ReportWarning("aiLight::mColorXXX - all are black and won't have any influence");
    }
}

// ------------------------------------------------------------------------------------------------
void ValidateDSProcess::Validate( const aiCamera* pCamera)
{
    if (pCamera->mClipPlaneFar <= pCamera->mClipPlaneNear)
        ReportError("aiCamera::mClipPlaneFar must be >= aiCamera::mClipPlaneNear");

    // FIX: there are many 3ds files with invalid FOVs. No reason to
    // reject them at all ... a warning is appropriate.
    if (!pCamera->mHorizontalFOV || pCamera->mHorizontalFOV >= (float)AI_MATH_PI)
        ReportWarning("%f is not a valid value for aiCamera::mHorizontalFOV",pCamera->mHorizontalFOV);
}

// ------------------------------------------------------------------------------------------------
void ValidateDSProcess::Validate( const aiMesh* pMesh)
{
    // validate the material index of the mesh
    if (mScene->mNumMaterials && pMesh->mMaterialIndex >= mScene->mNumMaterials)
    {
        ReportError("aiMesh::mMaterialIndex is invalid (value: %i maximum: %i)",
            pMesh->mMaterialIndex,mScene->mNumMaterials-1);
    }

    Validate(&pMesh->mName);

    for (unsigned int i = 0; i < pMesh->mNumFaces; ++i)
    {
        aiFace& face = pMesh->mFaces[i];

        if (pMesh->mPrimitiveTypes)
        {
            switch (face.mNumIndices)
            {
            case 0:
                ReportError("aiMesh::mFaces[%i].mNumIndices is 0",i);
            case 1:
                if (0 == (pMesh->mPrimitiveTypes & aiPrimitiveType_POINT))
                {
                    ReportError("aiMesh::mFaces[%i] is a POINT but aiMesh::mPrimtiveTypes "
                        "does not report the POINT flag",i);
                }
                break;
            case 2:
                if (0 == (pMesh->mPrimitiveTypes & aiPrimitiveType_LINE))
                {
                    ReportError("aiMesh::mFaces[%i] is a LINE but aiMesh::mPrimtiveTypes "
                        "does not report the LINE flag",i);
                }
                break;
            case 3:
                if (0 == (pMesh->mPrimitiveTypes & aiPrimitiveType_TRIANGLE))
                {
                    ReportError("aiMesh::mFaces[%i] is a TRIANGLE but aiMesh::mPrimtiveTypes "
                        "does not report the TRIANGLE flag",i);
                }
                break;
            default:
                if (0 == (pMesh->mPrimitiveTypes & aiPrimitiveType_POLYGON))
                {
                    this->ReportError("aiMesh::mFaces[%i] is a POLYGON but aiMesh::mPrimtiveTypes "
                        "does not report the POLYGON flag",i);
                }
                break;
            };
        }

        if (!face.mIndices)
            ReportError("aiMesh::mFaces[%i].mIndices is NULL",i);
    }

    // positions must always be there ...
    if (!pMesh->mNumVertices || (!pMesh->mVertices && !mScene->mFlags)) {
        ReportError("The mesh contains no vertices");
    }

    if (pMesh->mNumVertices > AI_MAX_VERTICES) {
        ReportError("Mesh has too many vertices: %u, but the limit is %u",pMesh->mNumVertices,AI_MAX_VERTICES);
    }
    if (pMesh->mNumFaces > AI_MAX_FACES) {
        ReportError("Mesh has too many faces: %u, but the limit is %u",pMesh->mNumFaces,AI_MAX_FACES);
    }

    // if tangents are there there must also be bitangent vectors ...
    if ((pMesh->mTangents != NULL) != (pMesh->mBitangents != NULL)) {
        ReportError("If there are tangents, bitangent vectors must be present as well");
    }

    // faces, too
    if (!pMesh->mNumFaces || (!pMesh->mFaces && !mScene->mFlags))   {
        ReportError("Mesh contains no faces");
    }

    // now check whether the face indexing layout is correct:
    // unique vertices, pseudo-indexed.
    std::vector<bool> abRefList;
    abRefList.resize(pMesh->mNumVertices,false);
    for (unsigned int i = 0; i < pMesh->mNumFaces;++i)
    {
        aiFace& face = pMesh->mFaces[i];
        if (face.mNumIndices > AI_MAX_FACE_INDICES) {
            ReportError("Face %u has too many faces: %u, but the limit is %u",i,face.mNumIndices,AI_MAX_FACE_INDICES);
        }

        for (unsigned int a = 0; a < face.mNumIndices;++a)
        {
            if (face.mIndices[a] >= pMesh->mNumVertices)    {
                ReportError("aiMesh::mFaces[%i]::mIndices[%i] is out of range",i,a);
            }
            // the MSB flag is temporarily used by the extra verbose
            // mode to tell us that the JoinVerticesProcess might have
            // been executed already.
            if ( !(this->mScene->mFlags & AI_SCENE_FLAGS_NON_VERBOSE_FORMAT ) && abRefList[face.mIndices[a]])
            {
                ReportError("aiMesh::mVertices[%i] is referenced twice - second "
                    "time by aiMesh::mFaces[%i]::mIndices[%i]",face.mIndices[a],i,a);
            }
            abRefList[face.mIndices[a]] = true;
        }
    }

    // check whether there are vertices that aren't referenced by a face
    bool b = false;
    for (unsigned int i = 0; i < pMesh->mNumVertices;++i)   {
        if (!abRefList[i])b = true;
    }
    abRefList.clear();
    if (b)ReportWarning("There are unreferenced vertices");

    // texture channel 2 may not be set if channel 1 is zero ...
    {
        unsigned int i = 0;
        for (;i < AI_MAX_NUMBER_OF_TEXTURECOORDS;++i)
        {
            if (!pMesh->HasTextureCoords(i))break;
        }
        for (;i < AI_MAX_NUMBER_OF_TEXTURECOORDS;++i)
            if (pMesh->HasTextureCoords(i))
            {
                ReportError("Texture coordinate channel %i exists "
                    "although the previous channel was NULL.",i);
            }
    }
    // the same for the vertex colors
    {
        unsigned int i = 0;
        for (;i < AI_MAX_NUMBER_OF_COLOR_SETS;++i)
        {
            if (!pMesh->HasVertexColors(i))break;
        }
        for (;i < AI_MAX_NUMBER_OF_COLOR_SETS;++i)
            if (pMesh->HasVertexColors(i))
            {
                ReportError("Vertex color channel %i is exists "
                    "although the previous channel was NULL.",i);
            }
    }


    // now validate all bones
    if (pMesh->mNumBones)
    {
        if (!pMesh->mBones)
        {
            ReportError("aiMesh::mBones is NULL (aiMesh::mNumBones is %i)",
                pMesh->mNumBones);
        }
        std::unique_ptr<float[]> afSum(nullptr);
        if (pMesh->mNumVertices)
        {
            afSum.reset(new float[pMesh->mNumVertices]);
            for (unsigned int i = 0; i < pMesh->mNumVertices;++i)
                afSum[i] = 0.0f;
        }

        // check whether there are duplicate bone names
        for (unsigned int i = 0; i < pMesh->mNumBones;++i)
        {
            const aiBone* bone = pMesh->mBones[i];
            if (bone->mNumWeights > AI_MAX_BONE_WEIGHTS) {
                ReportError("Bone %u has too many weights: %u, but the limit is %u",i,bone->mNumWeights,AI_MAX_BONE_WEIGHTS);
            }

            if (!pMesh->mBones[i])
            {
                ReportError("aiMesh::mBones[%i] is NULL (aiMesh::mNumBones is %i)",
                    i,pMesh->mNumBones);
            }
            Validate(pMesh,pMesh->mBones[i],afSum.get());

            for (unsigned int a = i+1; a < pMesh->mNumBones;++a)
            {
                if (pMesh->mBones[i]->mName == pMesh->mBones[a]->mName)
                {
                    ReportError("aiMesh::mBones[%i] has the same name as "
                        "aiMesh::mBones[%i]",i,a);
                }
            }
        }
        // check whether all bone weights for a vertex sum to 1.0 ...
        for (unsigned int i = 0; i < pMesh->mNumVertices;++i)
        {
            if (afSum[i] && (afSum[i] <= 0.94 || afSum[i] >= 1.05)) {
                ReportWarning("aiMesh::mVertices[%i]: bone weight sum != 1.0 (sum is %f)",i,afSum[i]);
            }
        }
    }
    else if (pMesh->mBones)
    {
        ReportError("aiMesh::mBones is non-null although there are no bones");
    }
}

// ------------------------------------------------------------------------------------------------
void ValidateDSProcess::Validate( const aiMesh* pMesh,
    const aiBone* pBone,float* afSum)
{
    this->Validate(&pBone->mName);

    if (!pBone->mNumWeights)    {
        ReportError("aiBone::mNumWeights is zero");
    }

    // check whether all vertices affected by this bone are valid
    for (unsigned int i = 0; i < pBone->mNumWeights;++i)
    {
        if (pBone->mWeights[i].mVertexId >= pMesh->mNumVertices)    {
            ReportError("aiBone::mWeights[%i].mVertexId is out of range",i);
        }
        else if (!pBone->mWeights[i].mWeight || pBone->mWeights[i].mWeight > 1.0f)  {
            ReportWarning("aiBone::mWeights[%i].mWeight has an invalid value",i);
        }
        afSum[pBone->mWeights[i].mVertexId] += pBone->mWeights[i].mWeight;
    }
}

// ------------------------------------------------------------------------------------------------
void ValidateDSProcess::Validate( const aiAnimation* pAnimation)
{
    Validate(&pAnimation->mName);

    // validate all materials
    if (pAnimation->mNumChannels)
    {
        if (!pAnimation->mChannels) {
            ReportError("aiAnimation::mChannels is NULL (aiAnimation::mNumChannels is %i)",
                pAnimation->mNumChannels);
        }
        for (unsigned int i = 0; i < pAnimation->mNumChannels;++i)
        {
            if (!pAnimation->mChannels[i])
            {
                ReportError("aiAnimation::mChannels[%i] is NULL (aiAnimation::mNumChannels is %i)",
                    i, pAnimation->mNumChannels);
            }
            Validate(pAnimation, pAnimation->mChannels[i]);
        }
    }
    else ReportError("aiAnimation::mNumChannels is 0. At least one node animation channel must be there.");

    // Animation duration is allowed to be zero in cases where the anim contains only a single key frame.
    // if (!pAnimation->mDuration)this->ReportError("aiAnimation::mDuration is zero");
}

// ------------------------------------------------------------------------------------------------
void ValidateDSProcess::SearchForInvalidTextures(const aiMaterial* pMaterial,
    aiTextureType type)
{
    const char* szType = TextureTypeToString(type);

    // ****************************************************************************
    // Search all keys of the material ...
    // textures must be specified with ascending indices
    // (e.g. diffuse #2 may not be specified if diffuse #1 is not there ...)
    // ****************************************************************************

    int iNumIndices = 0;
    int iIndex = -1;
    for (unsigned int i = 0; i < pMaterial->mNumProperties;++i)
    {
        aiMaterialProperty* prop = pMaterial->mProperties[i];
        if (!::strcmp(prop->mKey.data,"$tex.file") && prop->mSemantic == type)  {
            iIndex = std::max(iIndex, (int) prop->mIndex);
            ++iNumIndices;

            if (aiPTI_String != prop->mType)
                ReportError("Material property %s is expected to be a string",prop->mKey.data);
        }
    }
    if (iIndex +1 != iNumIndices)   {
        ReportError("%s #%i is set, but there are only %i %s textures",
            szType,iIndex,iNumIndices,szType);
    }
    if (!iNumIndices)return;
    std::vector<aiTextureMapping> mappings(iNumIndices);

    // Now check whether all UV indices are valid ...
    bool bNoSpecified = true;
    for (unsigned int i = 0; i < pMaterial->mNumProperties;++i)
    {
        aiMaterialProperty* prop = pMaterial->mProperties[i];
        if (prop->mSemantic != type)continue;

        if ((int)prop->mIndex >= iNumIndices)
        {
            ReportError("Found texture property with index %i, although there "
                "are only %i textures of type %s",
                prop->mIndex, iNumIndices, szType);
        }

        if (!::strcmp(prop->mKey.data,"$tex.mapping"))  {
            if (aiPTI_Integer != prop->mType || prop->mDataLength < sizeof(aiTextureMapping))
            {
                ReportError("Material property %s%i is expected to be an integer (size is %i)",
                    prop->mKey.data,prop->mIndex,prop->mDataLength);
            }
            mappings[prop->mIndex] = *((aiTextureMapping*)prop->mData);
        }
        else if (!::strcmp(prop->mKey.data,"$tex.uvtrafo")) {
            if (aiPTI_Float != prop->mType || prop->mDataLength < sizeof(aiUVTransform))
            {
                ReportError("Material property %s%i is expected to be 5 floats large (size is %i)",
                    prop->mKey.data,prop->mIndex, prop->mDataLength);
            }
            mappings[prop->mIndex] = *((aiTextureMapping*)prop->mData);
        }
        else if (!::strcmp(prop->mKey.data,"$tex.uvwsrc")) {
            if (aiPTI_Integer != prop->mType || sizeof(int) > prop->mDataLength)
            {
                ReportError("Material property %s%i is expected to be an integer (size is %i)",
                    prop->mKey.data,prop->mIndex,prop->mDataLength);
            }
            bNoSpecified = false;

            // Ignore UV indices for texture channels that are not there ...

            // Get the value
            iIndex = *((unsigned int*)prop->mData);

            // Check whether there is a mesh using this material
            // which has not enough UV channels ...
            for (unsigned int a = 0; a < mScene->mNumMeshes;++a)
            {
                aiMesh* mesh = this->mScene->mMeshes[a];
                if(mesh->mMaterialIndex == (unsigned int)i)
                {
                    int iChannels = 0;
                    while (mesh->HasTextureCoords(iChannels))++iChannels;
                    if (iIndex >= iChannels)
                    {
                        ReportWarning("Invalid UV index: %i (key %s). Mesh %i has only %i UV channels",
                            iIndex,prop->mKey.data,a,iChannels);
                    }
                }
            }
        }
    }
    if (bNoSpecified)
    {
        // Assume that all textures are using the first UV channel
        for (unsigned int a = 0; a < mScene->mNumMeshes;++a)
        {
            aiMesh* mesh = mScene->mMeshes[a];
            if(mesh->mMaterialIndex == (unsigned int)iIndex && mappings[0] == aiTextureMapping_UV)
            {
                if (!mesh->mTextureCoords[0])
                {
                    // This is a special case ... it could be that the
                    // original mesh format intended the use of a special
                    // mapping here.
                    ReportWarning("UV-mapped texture, but there are no UV coords");
                }
            }
        }
    }
}
// ------------------------------------------------------------------------------------------------
void ValidateDSProcess::Validate( const aiMaterial* pMaterial)
{
    // check whether there are material keys that are obviously not legal
    for (unsigned int i = 0; i < pMaterial->mNumProperties;++i)
    {
        const aiMaterialProperty* prop = pMaterial->mProperties[i];
        if (!prop)  {
            ReportError("aiMaterial::mProperties[%i] is NULL (aiMaterial::mNumProperties is %i)",
                i,pMaterial->mNumProperties);
        }
        if (!prop->mDataLength || !prop->mData) {
            ReportError("aiMaterial::mProperties[%i].mDataLength or "
                "aiMaterial::mProperties[%i].mData is 0",i,i);
        }
        // check all predefined types
        if (aiPTI_String == prop->mType)    {
            // FIX: strings are now stored in a less expensive way, but we can't use the
            // validation routine for 'normal' aiStrings
            if (prop->mDataLength < 5 || prop->mDataLength < 4 + (*reinterpret_cast<uint32_t*>(prop->mData)) + 1)   {
                ReportError("aiMaterial::mProperties[%i].mDataLength is "
                    "too small to contain a string (%i, needed: %i)",
                    i,prop->mDataLength,sizeof(aiString));
            }
            if(prop->mData[prop->mDataLength-1]) {
                ReportError("Missing null-terminator in string material property");
            }
        //  Validate((const aiString*)prop->mData);
        }
        else if (aiPTI_Float == prop->mType)    {
            if (prop->mDataLength < sizeof(float))  {
                ReportError("aiMaterial::mProperties[%i].mDataLength is "
                    "too small to contain a float (%i, needed: %i)",
                    i,prop->mDataLength,sizeof(float));
            }
        }
        else if (aiPTI_Integer == prop->mType)  {
            if (prop->mDataLength < sizeof(int))    {
                ReportError("aiMaterial::mProperties[%i].mDataLength is "
                    "too small to contain an integer (%i, needed: %i)",
                    i,prop->mDataLength,sizeof(int));
            }
        }
        // TODO: check whether there is a key with an unknown name ...
    }

    // make some more specific tests
    float fTemp;
    int iShading;
    if (AI_SUCCESS == aiGetMaterialInteger( pMaterial,AI_MATKEY_SHADING_MODEL,&iShading))   {
        switch ((aiShadingMode)iShading)
        {
        case aiShadingMode_Blinn:
        case aiShadingMode_CookTorrance:
        case aiShadingMode_Phong:

            if (AI_SUCCESS != aiGetMaterialFloat(pMaterial,AI_MATKEY_SHININESS,&fTemp)) {
                ReportWarning("A specular shading model is specified but there is no "
                    "AI_MATKEY_SHININESS key");
            }
            if (AI_SUCCESS == aiGetMaterialFloat(pMaterial,AI_MATKEY_SHININESS_STRENGTH,&fTemp) && !fTemp)  {
                ReportWarning("A specular shading model is specified but the value of the "
                    "AI_MATKEY_SHININESS_STRENGTH key is 0.0");
            }
            break;
        default: ;
        };
    }

    if (AI_SUCCESS == aiGetMaterialFloat( pMaterial,AI_MATKEY_OPACITY,&fTemp) && (!fTemp || fTemp > 1.01f)) {
        ReportWarning("Invalid opacity value (must be 0 < opacity < 1.0)");
    }

    // Check whether there are invalid texture keys
    // TODO: that's a relict of the past, where texture type and index were baked
    // into the material string ... we could do that in one single pass.
    SearchForInvalidTextures(pMaterial,aiTextureType_DIFFUSE);
    SearchForInvalidTextures(pMaterial,aiTextureType_SPECULAR);
    SearchForInvalidTextures(pMaterial,aiTextureType_AMBIENT);
    SearchForInvalidTextures(pMaterial,aiTextureType_EMISSIVE);
    SearchForInvalidTextures(pMaterial,aiTextureType_OPACITY);
    SearchForInvalidTextures(pMaterial,aiTextureType_SHININESS);
    SearchForInvalidTextures(pMaterial,aiTextureType_HEIGHT);
    SearchForInvalidTextures(pMaterial,aiTextureType_NORMALS);
    SearchForInvalidTextures(pMaterial,aiTextureType_DISPLACEMENT);
    SearchForInvalidTextures(pMaterial,aiTextureType_LIGHTMAP);
    SearchForInvalidTextures(pMaterial,aiTextureType_REFLECTION);
}

// ------------------------------------------------------------------------------------------------
void ValidateDSProcess::Validate( const aiTexture* pTexture)
{
    // the data section may NEVER be NULL
    if (!pTexture->pcData)  {
        ReportError("aiTexture::pcData is NULL");
    }
    if (pTexture->mHeight)
    {
        if (!pTexture->mWidth)ReportError("aiTexture::mWidth is zero "
            "(aiTexture::mHeight is %i, uncompressed texture)",pTexture->mHeight);
    }
    else
    {
        if (!pTexture->mWidth) {
            ReportError("aiTexture::mWidth is zero (compressed texture)");
        }
        if ('\0' != pTexture->achFormatHint[3]) {
            ReportWarning("aiTexture::achFormatHint must be zero-terminated");
        }
        else if ('.'  == pTexture->achFormatHint[0])    {
            ReportWarning("aiTexture::achFormatHint should contain a file extension "
                "without a leading dot (format hint: %s).",pTexture->achFormatHint);
        }
    }

    const char* sz = pTexture->achFormatHint;
    if ((sz[0] >= 'A' && sz[0] <= 'Z') ||
        (sz[1] >= 'A' && sz[1] <= 'Z') ||
        (sz[2] >= 'A' && sz[2] <= 'Z') ||
        (sz[3] >= 'A' && sz[3] <= 'Z')) {
        ReportError("aiTexture::achFormatHint contains non-lowercase letters");
    }
}

// ------------------------------------------------------------------------------------------------
void ValidateDSProcess::Validate( const aiAnimation* pAnimation,
     const aiNodeAnim* pNodeAnim)
{
    Validate(&pNodeAnim->mNodeName);

    if (!pNodeAnim->mNumPositionKeys && !pNodeAnim->mScalingKeys && !pNodeAnim->mNumRotationKeys)
        ReportError("Empty node animation channel");

    // otherwise check whether one of the keys exceeds the total duration of the animation
    if (pNodeAnim->mNumPositionKeys)
    {
        if (!pNodeAnim->mPositionKeys)
        {
            this->ReportError("aiNodeAnim::mPositionKeys is NULL (aiNodeAnim::mNumPositionKeys is %i)",
                pNodeAnim->mNumPositionKeys);
        }
        double dLast = -10e10;
        for (unsigned int i = 0; i < pNodeAnim->mNumPositionKeys;++i)
        {
            // ScenePreprocessor will compute the duration if still the default value
            // (Aramis) Add small epsilon, comparison tended to fail if max_time == duration,
            //  seems to be due the compilers register usage/width.
            if (pAnimation->mDuration > 0. && pNodeAnim->mPositionKeys[i].mTime > pAnimation->mDuration+0.001)
            {
                ReportError("aiNodeAnim::mPositionKeys[%i].mTime (%.5f) is larger "
                    "than aiAnimation::mDuration (which is %.5f)",i,
                    (float)pNodeAnim->mPositionKeys[i].mTime,
                    (float)pAnimation->mDuration);
            }
            if (i && pNodeAnim->mPositionKeys[i].mTime <= dLast)
            {
                ReportWarning("aiNodeAnim::mPositionKeys[%i].mTime (%.5f) is smaller "
                    "than aiAnimation::mPositionKeys[%i] (which is %.5f)",i,
                    (float)pNodeAnim->mPositionKeys[i].mTime,
                    i-1, (float)dLast);
            }
            dLast = pNodeAnim->mPositionKeys[i].mTime;
        }
    }
    // rotation keys
    if (pNodeAnim->mNumRotationKeys)
    {
        if (!pNodeAnim->mRotationKeys)
        {
            this->ReportError("aiNodeAnim::mRotationKeys is NULL (aiNodeAnim::mNumRotationKeys is %i)",
                pNodeAnim->mNumRotationKeys);
        }
        double dLast = -10e10;
        for (unsigned int i = 0; i < pNodeAnim->mNumRotationKeys;++i)
        {
            if (pAnimation->mDuration > 0. && pNodeAnim->mRotationKeys[i].mTime > pAnimation->mDuration+0.001)
            {
                ReportError("aiNodeAnim::mRotationKeys[%i].mTime (%.5f) is larger "
                    "than aiAnimation::mDuration (which is %.5f)",i,
                    (float)pNodeAnim->mRotationKeys[i].mTime,
                    (float)pAnimation->mDuration);
            }
            if (i && pNodeAnim->mRotationKeys[i].mTime <= dLast)
            {
                ReportWarning("aiNodeAnim::mRotationKeys[%i].mTime (%.5f) is smaller "
                    "than aiAnimation::mRotationKeys[%i] (which is %.5f)",i,
                    (float)pNodeAnim->mRotationKeys[i].mTime,
                    i-1, (float)dLast);
            }
            dLast = pNodeAnim->mRotationKeys[i].mTime;
        }
    }
    // scaling keys
    if (pNodeAnim->mNumScalingKeys)
    {
        if (!pNodeAnim->mScalingKeys)   {
            ReportError("aiNodeAnim::mScalingKeys is NULL (aiNodeAnim::mNumScalingKeys is %i)",
                pNodeAnim->mNumScalingKeys);
        }
        double dLast = -10e10;
        for (unsigned int i = 0; i < pNodeAnim->mNumScalingKeys;++i)
        {
            if (pAnimation->mDuration > 0. && pNodeAnim->mScalingKeys[i].mTime > pAnimation->mDuration+0.001)
            {
                ReportError("aiNodeAnim::mScalingKeys[%i].mTime (%.5f) is larger "
                    "than aiAnimation::mDuration (which is %.5f)",i,
                    (float)pNodeAnim->mScalingKeys[i].mTime,
                    (float)pAnimation->mDuration);
            }
            if (i && pNodeAnim->mScalingKeys[i].mTime <= dLast)
            {
                ReportWarning("aiNodeAnim::mScalingKeys[%i].mTime (%.5f) is smaller "
                    "than aiAnimation::mScalingKeys[%i] (which is %.5f)",i,
                    (float)pNodeAnim->mScalingKeys[i].mTime,
                    i-1, (float)dLast);
            }
            dLast = pNodeAnim->mScalingKeys[i].mTime;
        }
    }

    if (!pNodeAnim->mNumScalingKeys && !pNodeAnim->mNumRotationKeys &&
        !pNodeAnim->mNumPositionKeys)
    {
        ReportError("A node animation channel must have at least one subtrack");
    }
}

// ------------------------------------------------------------------------------------------------
void ValidateDSProcess::Validate( const aiNode* pNode)
{
    if (!pNode)ReportError("A node of the scenegraph is NULL");
    if (pNode != mScene->mRootNode && !pNode->mParent)
        this->ReportError("A node has no valid parent (aiNode::mParent is NULL)");

    this->Validate(&pNode->mName);

    // validate all meshes
    if (pNode->mNumMeshes)
    {
        if (!pNode->mMeshes)
        {
            ReportError("aiNode::mMeshes is NULL (aiNode::mNumMeshes is %i)",
                pNode->mNumMeshes);
        }
        std::vector<bool> abHadMesh;
        abHadMesh.resize(mScene->mNumMeshes,false);
        for (unsigned int i = 0; i < pNode->mNumMeshes;++i)
        {
            if (pNode->mMeshes[i] >= mScene->mNumMeshes)
            {
                ReportError("aiNode::mMeshes[%i] is out of range (maximum is %i)",
                    pNode->mMeshes[i],mScene->mNumMeshes-1);
            }
            if (abHadMesh[pNode->mMeshes[i]])
            {
                ReportError("aiNode::mMeshes[%i] is already referenced by this node (value: %i)",
                    i,pNode->mMeshes[i]);
            }
            abHadMesh[pNode->mMeshes[i]] = true;
        }
    }
    if (pNode->mNumChildren)
    {
        if (!pNode->mChildren)  {
            ReportError("aiNode::mChildren is NULL (aiNode::mNumChildren is %i)",
                pNode->mNumChildren);
        }
        for (unsigned int i = 0; i < pNode->mNumChildren;++i)   {
            Validate(pNode->mChildren[i]);
        }
    }
}

// ------------------------------------------------------------------------------------------------
void ValidateDSProcess::Validate( const aiString* pString)
{
    if (pString->length > MAXLEN)
    {
        this->ReportError("aiString::length is too large (%i, maximum is %i)",
            pString->length,MAXLEN);
    }
    const char* sz = pString->data;
    while (true)
    {
        if ('\0' == *sz)
        {
            if (pString->length != (unsigned int)(sz-pString->data))
                ReportError("aiString::data is invalid: the terminal zero is at a wrong offset");
            break;
        }
        else if (sz >= &pString->data[MAXLEN])
            ReportError("aiString::data is invalid. There is no terminal character");
        ++sz;
    }
}

/***********************************************************************
FBXIMPORT\VERSION.CPP
***********************************************************************/

// Actually just a dummy, used by the compiler to build the precompiled header.


static const unsigned int MajorVersion = 3;
static const unsigned int MinorVersion = 2;

// --------------------------------------------------------------------------------
// Legal information string - dont't remove this.
static const char* LEGAL_INFORMATION =

"Open Asset Import Library (Assimp).\n"
"A free C/C++ library to import various 3D file formats into applications\n\n"

"(c) 2008-2010, assimp team\n"
"License under the terms and conditions of the 3-clause BSD license\n"
"http://assimp.sourceforge.net\n"
;

// ------------------------------------------------------------------------------------------------
// Get legal string
ASSIMP_API const char*  aiGetLegalString  ()    {
    return LEGAL_INFORMATION;
}

// ------------------------------------------------------------------------------------------------
// Get Assimp minor version
ASSIMP_API unsigned int aiGetVersionMinor ()    {
    return MinorVersion;
}

// ------------------------------------------------------------------------------------------------
// Get Assimp major version
ASSIMP_API unsigned int aiGetVersionMajor ()    {
    return MajorVersion;
}

// ------------------------------------------------------------------------------------------------
// Get flags used for compilation
ASSIMP_API unsigned int aiGetCompileFlags ()    {

    unsigned int flags = 0;

#ifdef ASSIMP_BUILD_BOOST_WORKAROUND
    flags |= ASSIMP_CFLAGS_NOBOOST;
#endif
#ifdef ASSIMP_BUILD_SINGLETHREADED
    flags |= ASSIMP_CFLAGS_SINGLETHREADED;
#endif
#ifdef ASSIMP_BUILD_DEBUG
    flags |= ASSIMP_CFLAGS_DEBUG;
#endif
#ifdef ASSIMP_BUILD_DLL_EXPORT
    flags |= ASSIMP_CFLAGS_SHARED;
#endif
#ifdef _STLPORT_VERSION
    flags |= ASSIMP_CFLAGS_STLPORT;
#endif

    return flags;
}

// include current build revision, which is even updated from time to time -- :-)

// ------------------------------------------------------------------------------------------------
ASSIMP_API unsigned int aiGetVersionRevision ()
{
    return GitVersion;
}

// ------------------------------------------------------------------------------------------------
ASSIMP_API aiScene::aiScene()
    : mFlags(0)
    , mRootNode(NULL)
    , mNumMeshes(0)
    , mMeshes(NULL)
    , mNumMaterials(0)
    , mMaterials(NULL)
    , mNumAnimations(0)
    , mAnimations(NULL)
    , mNumTextures(0)
    , mTextures(NULL)
    , mNumLights(0)
    , mLights(NULL)
    , mNumCameras(0)
    , mCameras(NULL)
    , mPrivate(new Assimp::ScenePrivateData())
    {
    }

// ------------------------------------------------------------------------------------------------
ASSIMP_API aiScene::~aiScene()
{
    // delete all sub-objects recursively
    delete mRootNode;

    // To make sure we won't crash if the data is invalid it's
    // much better to check whether both mNumXXX and mXXX are
    // valid instead of relying on just one of them.
    if (mNumMeshes && mMeshes)
        for( unsigned int a = 0; a < mNumMeshes; a++)
            delete mMeshes[a];
    delete [] mMeshes;

    if (mNumMaterials && mMaterials)
        for( unsigned int a = 0; a < mNumMaterials; a++)
            delete mMaterials[a];
    delete [] mMaterials;

    if (mNumAnimations && mAnimations)
        for( unsigned int a = 0; a < mNumAnimations; a++)
            delete mAnimations[a];
    delete [] mAnimations;

    if (mNumTextures && mTextures)
        for( unsigned int a = 0; a < mNumTextures; a++)
            delete mTextures[a];
    delete [] mTextures;

    if (mNumLights && mLights)
        for( unsigned int a = 0; a < mNumLights; a++)
            delete mLights[a];
    delete [] mLights;

    if (mNumCameras && mCameras)
        for( unsigned int a = 0; a < mNumCameras; a++)
            delete mCameras[a];
    delete [] mCameras;

    delete static_cast<Assimp::ScenePrivateData*>( mPrivate );
}


/***********************************************************************
FBXIMPORT\VERTEXTRIANGLEADJACENCY.CPP
***********************************************************************/
/*
---------------------------------------------------------------------------
Open Asset Import Library (assimp)
---------------------------------------------------------------------------

Copyright (c) 2006-2016, assimp team

All rights reserved.

Redistribution and use of this software in source and binary forms,
with or without modification, are permitted provided that the following
conditions are met:

* Redistributions of source code must retain the above
  copyright notice, this list of conditions and the
  following disclaimer.

* Redistributions in binary form must reproduce the above
  copyright notice, this list of conditions and the
  following disclaimer in the documentation and/or other
  materials provided with the distribution.

* Neither the name of the assimp team, nor the names of its
  contributors may be used to endorse or promote products
  derived from this software without specific prior
  written permission of the assimp team.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
"AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
---------------------------------------------------------------------------
*/

/** @file Implementation of the VertexTriangleAdjacency helper class
 */

// internal headers


using namespace Assimp;

// ------------------------------------------------------------------------------------------------
VertexTriangleAdjacency::VertexTriangleAdjacency(aiFace *pcFaces,
    unsigned int iNumFaces,
    unsigned int iNumVertices /*= 0*/,
    bool bComputeNumTriangles /*= false*/)
{
    // compute the number of referenced vertices if it wasn't specified by the caller
    const aiFace* const pcFaceEnd = pcFaces + iNumFaces;
    if (!iNumVertices)  {

        for (aiFace* pcFace = pcFaces; pcFace != pcFaceEnd; ++pcFace)   {
            ai_assert(3 == pcFace->mNumIndices);
            iNumVertices = std::max(iNumVertices,pcFace->mIndices[0]);
            iNumVertices = std::max(iNumVertices,pcFace->mIndices[1]);
            iNumVertices = std::max(iNumVertices,pcFace->mIndices[2]);
        }
    }

    this->iNumVertices = iNumVertices;

    unsigned int* pi;

    // allocate storage
    if (bComputeNumTriangles)   {
        pi = mLiveTriangles = new unsigned int[iNumVertices+1];
        memset(mLiveTriangles,0,sizeof(unsigned int)*(iNumVertices+1));
        mOffsetTable = new unsigned int[iNumVertices+2]+1;
    }
    else {
        pi = mOffsetTable = new unsigned int[iNumVertices+2]+1;
        memset(mOffsetTable,0,sizeof(unsigned int)*(iNumVertices+1));
        mLiveTriangles = NULL; // important, otherwise the d'tor would crash
    }

    // get a pointer to the end of the buffer
    unsigned int* piEnd = pi+iNumVertices;
    *piEnd++ = 0u;

    // first pass: compute the number of faces referencing each vertex
    for (aiFace* pcFace = pcFaces; pcFace != pcFaceEnd; ++pcFace)
    {
        pi[pcFace->mIndices[0]]++;
        pi[pcFace->mIndices[1]]++;
        pi[pcFace->mIndices[2]]++;
    }

    // second pass: compute the final offset table
    unsigned int iSum = 0;
    unsigned int* piCurOut = this->mOffsetTable;
    for (unsigned int* piCur = pi; piCur != piEnd;++piCur,++piCurOut)   {

        unsigned int iLastSum = iSum;
        iSum += *piCur;
        *piCurOut = iLastSum;
    }
    pi = this->mOffsetTable;

    // third pass: compute the final table
    this->mAdjacencyTable = new unsigned int[iSum];
    iSum = 0;
    for (aiFace* pcFace = pcFaces; pcFace != pcFaceEnd; ++pcFace,++iSum)    {

        unsigned int idx = pcFace->mIndices[0];
        mAdjacencyTable[pi[idx]++] = iSum;

        idx = pcFace->mIndices[1];
        mAdjacencyTable[pi[idx]++] = iSum;

        idx = pcFace->mIndices[2];
        mAdjacencyTable[pi[idx]++] = iSum;
    }
    // fourth pass: undo the offset computations made during the third pass
    // We could do this in a separate buffer, but this would be TIMES slower.
    --mOffsetTable;
    *mOffsetTable = 0u;
}
// ------------------------------------------------------------------------------------------------
VertexTriangleAdjacency::~VertexTriangleAdjacency()
{
    // delete allocated storage
    delete[] mOffsetTable;
    delete[] mAdjacencyTable;
    delete[] mLiveTriangles;
}

/***********************************************************************
FBXIMPORT\CONVERTUTF.C
***********************************************************************/
/*
 * Copyright 2001-2004 Unicode, Inc.
 * 
 * Disclaimer
 * 
 * This source code is provided as is by Unicode, Inc. No claims are
 * made as to fitness for any particular purpose. No warranties of any
 * kind are expressed or implied. The recipient agrees to determine
 * applicability of information provided. If this file has been
 * purchased on magnetic or optical media from Unicode, Inc., the
 * sole remedy for any claim will be exchange of defective media
 * within 90 days of receipt.
 * 
 * Limitations on Rights to Redistribute This Code
 * 
 * Unicode, Inc. hereby grants the right to freely use the information
 * supplied in this file in the creation of products supporting the
 * Unicode Standard, and to make copies of this file in any form
 * for internal or external distribution as long as this notice
 * remains attached.
 */

/* ---------------------------------------------------------------------

    Conversions between UTF32, UTF-16, and UTF-8. Source code file.
    Author: Mark E. Davis, 1994.
    Rev History: Rick McGowan, fixes & updates May 2001.
    Sept 2001: fixed const & error conditions per
	mods suggested by S. Parent & A. Lillich.
    June 2002: Tim Dodd added detection and handling of incomplete
	source sequences, enhanced error detection, added casts
	to eliminate compiler warnings.
    July 2003: slight mods to back out aggressive FFFE detection.
    Jan 2004: updated switches in from-UTF8 conversions.
    Oct 2004: updated to use UNI_MAX_LEGAL_UTF32 in UTF-32 conversions.

    See the header file "ConvertUTF.h" for complete documentation.

------------------------------------------------------------------------ */


#ifdef CVTUTF_DEBUG
#endif

static const int halfShift  = 10; /* used for shifting by 10 bits */

static const UTF32 halfBase = 0x0010000UL;
static const UTF32 halfMask = 0x3FFUL;

#define UNI_SUR_HIGH_START  (UTF32)0xD800
#define UNI_SUR_HIGH_END    (UTF32)0xDBFF
#define UNI_SUR_LOW_START   (UTF32)0xDC00
#define UNI_SUR_LOW_END     (UTF32)0xDFFF
#define false	   0
#define true	    1

/* --------------------------------------------------------------------- */

ConversionResult ConvertUTF32toUTF16 (
	const UTF32** sourceStart, const UTF32* sourceEnd, 
	UTF16** targetStart, UTF16* targetEnd, ConversionFlags flags) {
    ConversionResult result = conversionOK;
    const UTF32* source = *sourceStart;
    UTF16* target = *targetStart;
    while (source < sourceEnd) {
	UTF32 ch;
	if (target >= targetEnd) {
	    result = targetExhausted; break;
	}
	ch = *source++;
	if (ch <= UNI_MAX_BMP) { /* Target is a character <= 0xFFFF */
	    /* UTF-16 surrogate values are illegal in UTF-32; 0xffff or 0xfffe are both reserved values */
	    if (ch >= UNI_SUR_HIGH_START && ch <= UNI_SUR_LOW_END) {
		if (flags == strictConversion) {
		    --source; /* return to the illegal value itself */
		    result = sourceIllegal;
		    break;
		} else {
		    *target++ = UNI_REPLACEMENT_CHAR;
		}
	    } else {
		*target++ = (UTF16)ch; /* normal case */
	    }
	} else if (ch > UNI_MAX_LEGAL_UTF32) {
	    if (flags == strictConversion) {
		result = sourceIllegal;
	    } else {
		*target++ = UNI_REPLACEMENT_CHAR;
	    }
	} else {
	    /* target is a character in range 0xFFFF - 0x10FFFF. */
	    if (target + 1 >= targetEnd) {
		--source; /* Back up source pointer! */
		result = targetExhausted; break;
	    }
	    ch -= halfBase;
	    *target++ = (UTF16)((ch >> halfShift) + UNI_SUR_HIGH_START);
	    *target++ = (UTF16)((ch & halfMask) + UNI_SUR_LOW_START);
	}
    }
    *sourceStart = source;
    *targetStart = target;
    return result;
}

/* --------------------------------------------------------------------- */

ConversionResult ConvertUTF16toUTF32 (
	const UTF16** sourceStart, const UTF16* sourceEnd, 
	UTF32** targetStart, UTF32* targetEnd, ConversionFlags flags) {
    ConversionResult result = conversionOK;
    const UTF16* source = *sourceStart;
    UTF32* target = *targetStart;
    UTF32 ch, ch2;
    while (source < sourceEnd) {
	const UTF16* oldSource = source; /*  In case we have to back up because of target overflow. */
	ch = *source++;
	/* If we have a surrogate pair, convert to UTF32 first. */
	if (ch >= UNI_SUR_HIGH_START && ch <= UNI_SUR_HIGH_END) {
	    /* If the 16 bits following the high surrogate are in the source buffer... */
	    if (source < sourceEnd) {
		ch2 = *source;
		/* If it's a low surrogate, convert to UTF32. */
		if (ch2 >= UNI_SUR_LOW_START && ch2 <= UNI_SUR_LOW_END) {
		    ch = ((ch - UNI_SUR_HIGH_START) << halfShift)
			+ (ch2 - UNI_SUR_LOW_START) + halfBase;
		    ++source;
		} else if (flags == strictConversion) { /* it's an unpaired high surrogate */
		    --source; /* return to the illegal value itself */
		    result = sourceIllegal;
		    break;
		}
	    } else { /* We don't have the 16 bits following the high surrogate. */
		--source; /* return to the high surrogate */
		result = sourceExhausted;
		break;
	    }
	} else if (flags == strictConversion) {
	    /* UTF-16 surrogate values are illegal in UTF-32 */
	    if (ch >= UNI_SUR_LOW_START && ch <= UNI_SUR_LOW_END) {
		--source; /* return to the illegal value itself */
		result = sourceIllegal;
		break;
	    }
	}
	if (target >= targetEnd) {
	    source = oldSource; /* Back up source pointer! */
	    result = targetExhausted; break;
	}
	*target++ = ch;
    }
    *sourceStart = source;
    *targetStart = target;
#ifdef CVTUTF_DEBUG
if (result == sourceIllegal) {
    fprintf(stderr, "ConvertUTF16toUTF32 illegal seq 0x%04x,%04x\n", ch, ch2);
    fflush(stderr);
}
#endif
    return result;
}

/* --------------------------------------------------------------------- */

/*
 * Index into the table below with the first byte of a UTF-8 sequence to
 * get the number of trailing bytes that are supposed to follow it.
 * Note that *legal* UTF-8 values can't have 4 or 5-bytes. The table is
 * left as-is for anyone who may want to do such conversion, which was
 * allowed in earlier algorithms.
 */
static const char trailingBytesForUTF8[256] = {
    0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0, 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
    0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0, 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
    0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0, 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
    0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0, 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
    0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0, 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
    0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0, 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
    1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1, 1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
    2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2, 3,3,3,3,3,3,3,3,4,4,4,4,5,5,5,5
};

/*
 * Magic values subtracted from a buffer value during UTF8 conversion.
 * This table contains as many values as there might be trailing bytes
 * in a UTF-8 sequence.
 */
static const UTF32 offsetsFromUTF8[6] = { 0x00000000UL, 0x00003080UL, 0x000E2080UL, 
		     0x03C82080UL, 0xFA082080UL, 0x82082080UL };

/*
 * Once the bits are split out into bytes of UTF-8, this is a mask OR-ed
 * into the first byte, depending on how many bytes follow.  There are
 * as many entries in this table as there are UTF-8 sequence types.
 * (I.e., one byte sequence, two byte... etc.). Remember that sequencs
 * for *legal* UTF-8 will be 4 or fewer bytes total.
 */
static const UTF8 firstByteMark[7] = { 0x00, 0x00, 0xC0, 0xE0, 0xF0, 0xF8, 0xFC };

/* --------------------------------------------------------------------- */

/* The interface converts a whole buffer to avoid function-call overhead.
 * Constants have been gathered. Loops & conditionals have been removed as
 * much as possible for efficiency, in favor of drop-through switches.
 * (See "Note A" at the bottom of the file for equivalent code.)
 * If your compiler supports it, the "isLegalUTF8" call can be turned
 * into an inline function.
 */

/* --------------------------------------------------------------------- */

ConversionResult ConvertUTF16toUTF8 (
	const UTF16** sourceStart, const UTF16* sourceEnd, 
	UTF8** targetStart, UTF8* targetEnd, ConversionFlags flags) {
    ConversionResult result = conversionOK;
    const UTF16* source = *sourceStart;
    UTF8* target = *targetStart;
    while (source < sourceEnd) {
	UTF32 ch;
	unsigned short bytesToWrite = 0;
	const UTF32 byteMask = 0xBF;
	const UTF32 byteMark = 0x80; 
	const UTF16* oldSource = source; /* In case we have to back up because of target overflow. */
	ch = *source++;
	/* If we have a surrogate pair, convert to UTF32 first. */
	if (ch >= UNI_SUR_HIGH_START && ch <= UNI_SUR_HIGH_END) {
	    /* If the 16 bits following the high surrogate are in the source buffer... */
	    if (source < sourceEnd) {
		UTF32 ch2 = *source;
		/* If it's a low surrogate, convert to UTF32. */
		if (ch2 >= UNI_SUR_LOW_START && ch2 <= UNI_SUR_LOW_END) {
		    ch = ((ch - UNI_SUR_HIGH_START) << halfShift)
			+ (ch2 - UNI_SUR_LOW_START) + halfBase;
		    ++source;
		} else if (flags == strictConversion) { /* it's an unpaired high surrogate */
		    --source; /* return to the illegal value itself */
		    result = sourceIllegal;
		    break;
		}
	    } else { /* We don't have the 16 bits following the high surrogate. */
		--source; /* return to the high surrogate */
		result = sourceExhausted;
		break;
	    }
	} else if (flags == strictConversion) {
	    /* UTF-16 surrogate values are illegal in UTF-32 */
	    if (ch >= UNI_SUR_LOW_START && ch <= UNI_SUR_LOW_END) {
		--source; /* return to the illegal value itself */
		result = sourceIllegal;
		break;
	    }
	}
	/* Figure out how many bytes the result will require */
	if (ch < (UTF32)0x80) {	     bytesToWrite = 1;
	} else if (ch < (UTF32)0x800) {     bytesToWrite = 2;
	} else if (ch < (UTF32)0x10000) {   bytesToWrite = 3;
	} else if (ch < (UTF32)0x110000) {  bytesToWrite = 4;
	} else {			    bytesToWrite = 3;
					    ch = UNI_REPLACEMENT_CHAR;
	}

	target += bytesToWrite;
	if (target > targetEnd) {
	    source = oldSource; /* Back up source pointer! */
	    target -= bytesToWrite; result = targetExhausted; break;
	}
	switch (bytesToWrite) { /* note: everything falls through. */
	    case 4: *--target = (UTF8)((ch | byteMark) & byteMask); ch >>= 6;
	    case 3: *--target = (UTF8)((ch | byteMark) & byteMask); ch >>= 6;
	    case 2: *--target = (UTF8)((ch | byteMark) & byteMask); ch >>= 6;
	    case 1: *--target =  (UTF8)(ch | firstByteMark[bytesToWrite]);
	}
	target += bytesToWrite;
    }
    *sourceStart = source;
    *targetStart = target;
    return result;
}

/* --------------------------------------------------------------------- */

/*
 * Utility routine to tell whether a sequence of bytes is legal UTF-8.
 * This must be called with the length pre-determined by the first byte.
 * If not calling this from ConvertUTF8to*, then the length can be set by:
 *  length = trailingBytesForUTF8[*source]+1;
 * and the sequence is illegal right away if there aren't that many bytes
 * available.
 * If presented with a length > 4, this returns false.  The Unicode
 * definition of UTF-8 goes up to 4-byte sequences.
 */

static Boolean isLegalUTF8(const UTF8 *source, int length) {
    UTF8 a;
    const UTF8 *srcptr = source+length;
    switch (length) {
    default: return false;
	/* Everything else falls through when "true"... */
    case 4: if ((a = (*--srcptr)) < 0x80 || a > 0xBF) return false;
    case 3: if ((a = (*--srcptr)) < 0x80 || a > 0xBF) return false;
    case 2: if ((a = (*--srcptr)) > 0xBF) return false;

	switch (*source) {
	    /* no fall-through in this inner switch */
	    case 0xE0: if (a < 0xA0) return false; break;
	    case 0xED: if (a > 0x9F) return false; break;
	    case 0xF0: if (a < 0x90) return false; break;
	    case 0xF4: if (a > 0x8F) return false; break;
	    default:   if (a < 0x80) return false;
	}

    case 1: if (*source >= 0x80 && *source < 0xC2) return false;
    }
    if (*source > 0xF4) return false;
    return true;
}

/* --------------------------------------------------------------------- */

/*
 * Exported function to return whether a UTF-8 sequence is legal or not.
 * This is not used here; it's just exported.
 */
Boolean isLegalUTF8Sequence(const UTF8 *source, const UTF8 *sourceEnd) {
    int length = trailingBytesForUTF8[*source]+1;
    if (source+length > sourceEnd) {
	return false;
    }
    return isLegalUTF8(source, length);
}

/* --------------------------------------------------------------------- */

ConversionResult ConvertUTF8toUTF16 (
	const UTF8** sourceStart, const UTF8* sourceEnd, 
	UTF16** targetStart, UTF16* targetEnd, ConversionFlags flags) {
    ConversionResult result = conversionOK;
    const UTF8* source = *sourceStart;
    UTF16* target = *targetStart;
    while (source < sourceEnd) {
	UTF32 ch = 0;
	unsigned short extraBytesToRead = trailingBytesForUTF8[*source];
	if (source + extraBytesToRead >= sourceEnd) {
	    result = sourceExhausted; break;
	}
	/* Do this check whether lenient or strict */
	if (! isLegalUTF8(source, extraBytesToRead+1)) {
	    result = sourceIllegal;
	    break;
	}
	/*
	 * The cases all fall through. See "Note A" below.
	 */
	switch (extraBytesToRead) {
	    case 5: ch += *source++; ch <<= 6; /* remember, illegal UTF-8 */
	    case 4: ch += *source++; ch <<= 6; /* remember, illegal UTF-8 */
	    case 3: ch += *source++; ch <<= 6;
	    case 2: ch += *source++; ch <<= 6;
	    case 1: ch += *source++; ch <<= 6;
	    case 0: ch += *source++;
	}
	ch -= offsetsFromUTF8[extraBytesToRead];

	if (target >= targetEnd) {
	    source -= (extraBytesToRead+1); /* Back up source pointer! */
	    result = targetExhausted; break;
	}
	if (ch <= UNI_MAX_BMP) { /* Target is a character <= 0xFFFF */
	    /* UTF-16 surrogate values are illegal in UTF-32 */
	    if (ch >= UNI_SUR_HIGH_START && ch <= UNI_SUR_LOW_END) {
		if (flags == strictConversion) {
		    source -= (extraBytesToRead+1); /* return to the illegal value itself */
		    result = sourceIllegal;
		    break;
		} else {
		    *target++ = UNI_REPLACEMENT_CHAR;
		}
	    } else {
		*target++ = (UTF16)ch; /* normal case */
	    }
	} else if (ch > UNI_MAX_UTF16) {
	    if (flags == strictConversion) {
		result = sourceIllegal;
		source -= (extraBytesToRead+1); /* return to the start */
		break; /* Bail out; shouldn't continue */
	    } else {
		*target++ = UNI_REPLACEMENT_CHAR;
	    }
	} else {
	    /* target is a character in range 0xFFFF - 0x10FFFF. */
	    if (target + 1 >= targetEnd) {
		source -= (extraBytesToRead+1); /* Back up source pointer! */
		result = targetExhausted; break;
	    }
	    ch -= halfBase;
	    *target++ = (UTF16)((ch >> halfShift) + UNI_SUR_HIGH_START);
	    *target++ = (UTF16)((ch & halfMask) + UNI_SUR_LOW_START);
	}
    }
    *sourceStart = source;
    *targetStart = target;
    return result;
}

/* --------------------------------------------------------------------- */

ConversionResult ConvertUTF32toUTF8 (
	const UTF32** sourceStart, const UTF32* sourceEnd, 
	UTF8** targetStart, UTF8* targetEnd, ConversionFlags flags) {
    ConversionResult result = conversionOK;
    const UTF32* source = *sourceStart;
    UTF8* target = *targetStart;
    while (source < sourceEnd) {
	UTF32 ch;
	unsigned short bytesToWrite = 0;
	const UTF32 byteMask = 0xBF;
	const UTF32 byteMark = 0x80; 
	ch = *source++;
	if (flags == strictConversion ) {
	    /* UTF-16 surrogate values are illegal in UTF-32 */
	    if (ch >= UNI_SUR_HIGH_START && ch <= UNI_SUR_LOW_END) {
		--source; /* return to the illegal value itself */
		result = sourceIllegal;
		break;
	    }
	}
	/*
	 * Figure out how many bytes the result will require. Turn any
	 * illegally large UTF32 things (> Plane 17) into replacement chars.
	 */
	if (ch < (UTF32)0x80) {	     bytesToWrite = 1;
	} else if (ch < (UTF32)0x800) {     bytesToWrite = 2;
	} else if (ch < (UTF32)0x10000) {   bytesToWrite = 3;
	} else if (ch <= UNI_MAX_LEGAL_UTF32) {  bytesToWrite = 4;
	} else {			    bytesToWrite = 3;
					    ch = UNI_REPLACEMENT_CHAR;
					    result = sourceIllegal;
	}
	
	target += bytesToWrite;
	if (target > targetEnd) {
	    --source; /* Back up source pointer! */
	    target -= bytesToWrite; result = targetExhausted; break;
	}
	switch (bytesToWrite) { /* note: everything falls through. */
	    case 4: *--target = (UTF8)((ch | byteMark) & byteMask); ch >>= 6;
	    case 3: *--target = (UTF8)((ch | byteMark) & byteMask); ch >>= 6;
	    case 2: *--target = (UTF8)((ch | byteMark) & byteMask); ch >>= 6;
	    case 1: *--target = (UTF8) (ch | firstByteMark[bytesToWrite]);
	}
	target += bytesToWrite;
    }
    *sourceStart = source;
    *targetStart = target;
    return result;
}

/* --------------------------------------------------------------------- */

ConversionResult ConvertUTF8toUTF32 (
	const UTF8** sourceStart, const UTF8* sourceEnd, 
	UTF32** targetStart, UTF32* targetEnd, ConversionFlags flags) {
    ConversionResult result = conversionOK;
    const UTF8* source = *sourceStart;
    UTF32* target = *targetStart;
    while (source < sourceEnd) {
	UTF32 ch = 0;
	unsigned short extraBytesToRead = trailingBytesForUTF8[*source];
	if (source + extraBytesToRead >= sourceEnd) {
	    result = sourceExhausted; break;
	}
	/* Do this check whether lenient or strict */
	if (! isLegalUTF8(source, extraBytesToRead+1)) {
	    result = sourceIllegal;
	    break;
	}
	/*
	 * The cases all fall through. See "Note A" below.
	 */
	switch (extraBytesToRead) {
	    case 5: ch += *source++; ch <<= 6;
	    case 4: ch += *source++; ch <<= 6;
	    case 3: ch += *source++; ch <<= 6;
	    case 2: ch += *source++; ch <<= 6;
	    case 1: ch += *source++; ch <<= 6;
	    case 0: ch += *source++;
	}
	ch -= offsetsFromUTF8[extraBytesToRead];

	if (target >= targetEnd) {
	    source -= (extraBytesToRead+1); /* Back up the source pointer! */
	    result = targetExhausted; break;
	}
	if (ch <= UNI_MAX_LEGAL_UTF32) {
	    /*
	     * UTF-16 surrogate values are illegal in UTF-32, and anything
	     * over Plane 17 (> 0x10FFFF) is illegal.
	     */
	    if (ch >= UNI_SUR_HIGH_START && ch <= UNI_SUR_LOW_END) {
		if (flags == strictConversion) {
		    source -= (extraBytesToRead+1); /* return to the illegal value itself */
		    result = sourceIllegal;
		    break;
		} else {
		    *target++ = UNI_REPLACEMENT_CHAR;
		}
	    } else {
		*target++ = ch;
	    }
	} else { /* i.e., ch > UNI_MAX_LEGAL_UTF32 */
	    result = sourceIllegal;
	    *target++ = UNI_REPLACEMENT_CHAR;
	}
    }
    *sourceStart = source;
    *targetStart = target;
    return result;
}

/* ---------------------------------------------------------------------

    Note A.
    The fall-through switches in UTF-8 reading code save a
    temp variable, some decrements & conditionals.  The switches
    are equivalent to the following loop:
	{
	    int tmpBytesToRead = extraBytesToRead+1;
	    do {
		ch += *source++;
		--tmpBytesToRead;
		if (tmpBytesToRead) ch <<= 6;
	    } while (tmpBytesToRead > 0);
	}
    In UTF-8 writing code, the switches on "bytesToWrite" are
    similarly unrolled loops.

   --------------------------------------------------------------------- */

/***********************************************************************
ZLIB\ADLER32.C
***********************************************************************/
/* adler32.c -- compute the Adler-32 checksum of a data stream
 * Copyright (C) 1995-2011 Mark Adler
 * For conditions of distribution and use, see copyright notice in zlib.h
 */

/* @(#) $Id$ */


#define local static

local uLong adler32_combine_ OF((uLong adler1, uLong adler2, z_off64_t len2));

#define BASE 65521      /* largest prime smaller than 65536 */
#define NMAX 5552
/* NMAX is the largest n such that 255n(n+1)/2 + (n+1)(BASE-1) <= 2^32-1 */

#define DO1(buf,i)  {adler += (buf)[i]; sum2 += adler;}
#define DO2(buf,i)  DO1(buf,i); DO1(buf,i+1);
#define DO4(buf,i)  DO2(buf,i); DO2(buf,i+2);
#define DO8(buf,i)  DO4(buf,i); DO4(buf,i+4);
#define DO16(buf)   DO8(buf,0); DO8(buf,8);

/* use NO_DIVIDE if your processor does not do division in hardware --
   try it both ways to see which is faster */
#ifdef NO_DIVIDE
/* note that this assumes BASE is 65521, where 65536 % 65521 == 15
   (thank you to John Reiser for pointing this out) */
#  define CHOP(a) \
    do { \
        unsigned long tmp = a >> 16; \
        a &= 0xffffUL; \
        a += (tmp << 4) - tmp; \
    } while (0)
#  define MOD28(a) \
    do { \
        CHOP(a); \
        if (a >= BASE) a -= BASE; \
    } while (0)
#  define MOD(a) \
    do { \
        CHOP(a); \
        MOD28(a); \
    } while (0)
#  define MOD63(a) \
    do { /* this assumes a is not negative */ \
        z_off64_t tmp = a >> 32; \
        a &= 0xffffffffL; \
        a += (tmp << 8) - (tmp << 5) + tmp; \
        tmp = a >> 16; \
        a &= 0xffffL; \
        a += (tmp << 4) - tmp; \
        tmp = a >> 16; \
        a &= 0xffffL; \
        a += (tmp << 4) - tmp; \
        if (a >= BASE) a -= BASE; \
    } while (0)
#else
#  define MOD(a) a %= BASE
#  define MOD28(a) a %= BASE
#  define MOD63(a) a %= BASE
#endif

/* ========================================================================= */
uLong ZEXPORT adler32(adler, buf, len)
    uLong adler;
    const Bytef *buf;
    uInt len;
{
    unsigned long sum2;
    unsigned n;

    /* split Adler-32 into component sums */
    sum2 = (adler >> 16) & 0xffff;
    adler &= 0xffff;

    /* in case user likes doing a byte at a time, keep it fast */
    if (len == 1) {
        adler += buf[0];
        if (adler >= BASE)
            adler -= BASE;
        sum2 += adler;
        if (sum2 >= BASE)
            sum2 -= BASE;
        return adler | (sum2 << 16);
    }

    /* initial Adler-32 value (deferred check for len == 1 speed) */
    if (buf == Z_NULL)
        return 1L;

    /* in case short lengths are provided, keep it somewhat fast */
    if (len < 16) {
        while (len--) {
            adler += *buf++;
            sum2 += adler;
        }
        if (adler >= BASE)
            adler -= BASE;
        MOD28(sum2);            /* only added so many BASE's */
        return adler | (sum2 << 16);
    }

    /* do length NMAX blocks -- requires just one modulo operation */
    while (len >= NMAX) {
        len -= NMAX;
        n = NMAX / 16;          /* NMAX is divisible by 16 */
        do {
            DO16(buf);          /* 16 sums unrolled */
            buf += 16;
        } while (--n);
        MOD(adler);
        MOD(sum2);
    }

    /* do remaining bytes (less than NMAX, still just one modulo) */
    if (len) {                  /* avoid modulos if none remaining */
        while (len >= 16) {
            len -= 16;
            DO16(buf);
            buf += 16;
        }
        while (len--) {
            adler += *buf++;
            sum2 += adler;
        }
        MOD(adler);
        MOD(sum2);
    }

    /* return recombined sums */
    return adler | (sum2 << 16);
}

/* ========================================================================= */
local uLong adler32_combine_(adler1, adler2, len2)
    uLong adler1;
    uLong adler2;
    z_off64_t len2;
{
    unsigned long sum1;
    unsigned long sum2;
    unsigned rem;

    /* for negative len, return invalid adler32 as a clue for debugging */
    if (len2 < 0)
        return 0xffffffffUL;

    /* the derivation of this formula is left as an exercise for the reader */
    MOD63(len2);                /* assumes len2 >= 0 */
    rem = (unsigned)len2;
    sum1 = adler1 & 0xffff;
    sum2 = rem * sum1;
    MOD(sum2);
    sum1 += (adler2 & 0xffff) + BASE - 1;
    sum2 += ((adler1 >> 16) & 0xffff) + ((adler2 >> 16) & 0xffff) + BASE - rem;
    if (sum1 >= BASE) sum1 -= BASE;
    if (sum1 >= BASE) sum1 -= BASE;
    if (sum2 >= (BASE << 1)) sum2 -= (BASE << 1);
    if (sum2 >= BASE) sum2 -= BASE;
    return sum1 | (sum2 << 16);
}

/* ========================================================================= */
uLong ZEXPORT adler32_combine(adler1, adler2, len2)
    uLong adler1;
    uLong adler2;
    z_off_t len2;
{
    return adler32_combine_(adler1, adler2, len2);
}

uLong ZEXPORT adler32_combine64(adler1, adler2, len2)
    uLong adler1;
    uLong adler2;
    z_off64_t len2;
{
    return adler32_combine_(adler1, adler2, len2);
}

/***********************************************************************
ZLIB\COMPRESS.C
***********************************************************************/
/* compress.c -- compress a memory buffer
 * Copyright (C) 1995-2005 Jean-loup Gailly.
 * For conditions of distribution and use, see copyright notice in zlib.h
 */

/* @(#) $Id$ */

#define ZLIB_INTERNAL

/* ===========================================================================
     Compresses the source buffer into the destination buffer. The level
   parameter has the same meaning as in deflateInit.  sourceLen is the byte
   length of the source buffer. Upon entry, destLen is the total size of the
   destination buffer, which must be at least 0.1% larger than sourceLen plus
   12 bytes. Upon exit, destLen is the actual size of the compressed buffer.

     compress2 returns Z_OK if success, Z_MEM_ERROR if there was not enough
   memory, Z_BUF_ERROR if there was not enough room in the output buffer,
   Z_STREAM_ERROR if the level parameter is invalid.
*/
int ZEXPORT compress2 (dest, destLen, source, sourceLen, level)
    Bytef *dest;
    uLongf *destLen;
    const Bytef *source;
    uLong sourceLen;
    int level;
{
    z_stream stream;
    int err;

    stream.next_in = (z_const Bytef *)source;
    stream.avail_in = (uInt)sourceLen;
#ifdef MAXSEG_64K
    /* Check for source > 64K on 16-bit machine: */
    if ((uLong)stream.avail_in != sourceLen) return Z_BUF_ERROR;
#endif
    stream.next_out = dest;
    stream.avail_out = (uInt)*destLen;
    if ((uLong)stream.avail_out != *destLen) return Z_BUF_ERROR;

    stream.zalloc = (alloc_func)0;
    stream.zfree = (free_func)0;
    stream.opaque = (voidpf)0;

    err = deflateInit(&stream, level);
    if (err != Z_OK) return err;

    err = deflate(&stream, Z_FINISH);
    if (err != Z_STREAM_END) {
        deflateEnd(&stream);
        return err == Z_OK ? Z_BUF_ERROR : err;
    }
    *destLen = stream.total_out;

    err = deflateEnd(&stream);
    return err;
}

/* ===========================================================================
 */
int ZEXPORT compress (dest, destLen, source, sourceLen)
    Bytef *dest;
    uLongf *destLen;
    const Bytef *source;
    uLong sourceLen;
{
    return compress2(dest, destLen, source, sourceLen, Z_DEFAULT_COMPRESSION);
}

/* ===========================================================================
     If the default memLevel or windowBits for deflateInit() is changed, then
   this function needs to be updated.
 */
uLong ZEXPORT compressBound (sourceLen)
    uLong sourceLen;
{
    return sourceLen + (sourceLen >> 12) + (sourceLen >> 14) +
           (sourceLen >> 25) + 13;
}

/***********************************************************************
ZLIB\CRC32.C
***********************************************************************/
/* crc32.c -- compute the CRC-32 of a data stream
 * Copyright (C) 1995-2006, 2010, 2011, 2012 Mark Adler
 * For conditions of distribution and use, see copyright notice in zlib.h
 *
 * Thanks to Rodney Brown <rbrown64@csc.com.au> for his contribution of faster
 * CRC methods: exclusive-oring 32 bits of data at a time, and pre-computing
 * tables for updating the shift register in one step with three exclusive-ors
 * instead of four steps with four exclusive-ors.  This results in about a
 * factor of two increase in speed on a Power PC G4 (PPC7455) using gcc -O3.
 */

/* @(#) $Id$ */

/*
  Note on the use of DYNAMIC_CRC_TABLE: there is no mutex or semaphore
  protection on the static variables used to control the first-use generation
  of the crc tables.  Therefore, if you #define DYNAMIC_CRC_TABLE, you should
  first call get_crc_table() to initialize the tables before allowing more than
  one thread to use crc32().

  DYNAMIC_CRC_TABLE and MAKECRCH can be #defined to write out crc32.h.
 */

#ifdef MAKECRCH
#  include <stdio.h>
#  ifndef DYNAMIC_CRC_TABLE
#    define DYNAMIC_CRC_TABLE
#  endif /* !DYNAMIC_CRC_TABLE */
#endif /* MAKECRCH */

#include "zutil.h"      /* for STDC and FAR definitions */

#define local static

/* Definitions for doing the crc four data bytes at a time. */
#if !defined(NOBYFOUR) && defined(Z_U4)
#  define BYFOUR
#endif
#ifdef BYFOUR
   local unsigned long crc32_little OF((unsigned long,
                        const unsigned char FAR *, unsigned));
   local unsigned long crc32_big OF((unsigned long,
                        const unsigned char FAR *, unsigned));
#  define TBLS 8
#else
#  define TBLS 1
#endif /* BYFOUR */

/* Local functions for crc concatenation */
local unsigned long gf2_matrix_times OF((unsigned long *mat,
                                         unsigned long vec));
local void gf2_matrix_square OF((unsigned long *square, unsigned long *mat));
local uLong crc32_combine_ OF((uLong crc1, uLong crc2, z_off64_t len2));


#ifdef DYNAMIC_CRC_TABLE

local volatile int crc_table_empty = 1;
local z_crc_t FAR crc_table[TBLS][256];
local void make_crc_table OF((void));
#ifdef MAKECRCH
   local void write_table OF((FILE *, const z_crc_t FAR *));
#endif /* MAKECRCH */
/*
  Generate tables for a byte-wise 32-bit CRC calculation on the polynomial:
  x^32+x^26+x^23+x^22+x^16+x^12+x^11+x^10+x^8+x^7+x^5+x^4+x^2+x+1.

  Polynomials over GF(2) are represented in binary, one bit per coefficient,
  with the lowest powers in the most significant bit.  Then adding polynomials
  is just exclusive-or, and multiplying a polynomial by x is a right shift by
  one.  If we call the above polynomial p, and represent a byte as the
  polynomial q, also with the lowest power in the most significant bit (so the
  byte 0xb1 is the polynomial x^7+x^3+x+1), then the CRC is (q*x^32) mod p,
  where a mod b means the remainder after dividing a by b.

  This calculation is done using the shift-register method of multiplying and
  taking the remainder.  The register is initialized to zero, and for each
  incoming bit, x^32 is added mod p to the register if the bit is a one (where
  x^32 mod p is p+x^32 = x^26+...+1), and the register is multiplied mod p by
  x (which is shifting right by one and adding x^32 mod p if the bit shifted
  out is a one).  We start with the highest power (least significant bit) of
  q and repeat for all eight bits of q.

  The first table is simply the CRC of all possible eight bit values.  This is
  all the information needed to generate CRCs on data a byte at a time for all
  combinations of CRC register values and incoming bytes.  The remaining tables
  allow for word-at-a-time CRC calculation for both big-endian and little-
  endian machines, where a word is four bytes.
*/
local void make_crc_table()
{
    z_crc_t c;
    int n, k;
    z_crc_t poly;                       /* polynomial exclusive-or pattern */
    /* terms of polynomial defining this crc (except x^32): */
    static volatile int first = 1;      /* flag to limit concurrent making */
    static const unsigned char p[] = {0,1,2,4,5,7,8,10,11,12,16,22,23,26};

    /* See if another task is already doing this (not thread-safe, but better
       than nothing -- significantly reduces duration of vulnerability in
       case the advice about DYNAMIC_CRC_TABLE is ignored) */
    if (first) {
        first = 0;

        /* make exclusive-or pattern from polynomial (0xedb88320UL) */
        poly = 0;
        for (n = 0; n < (int)(sizeof(p)/sizeof(unsigned char)); n++)
            poly |= (z_crc_t)1 << (31 - p[n]);

        /* generate a crc for every 8-bit value */
        for (n = 0; n < 256; n++) {
            c = (z_crc_t)n;
            for (k = 0; k < 8; k++)
                c = c & 1 ? poly ^ (c >> 1) : c >> 1;
            crc_table[0][n] = c;
        }

#ifdef BYFOUR
        /* generate crc for each value followed by one, two, and three zeros,
           and then the byte reversal of those as well as the first table */
        for (n = 0; n < 256; n++) {
            c = crc_table[0][n];
            crc_table[4][n] = ZSWAP32(c);
            for (k = 1; k < 4; k++) {
                c = crc_table[0][c & 0xff] ^ (c >> 8);
                crc_table[k][n] = c;
                crc_table[k + 4][n] = ZSWAP32(c);
            }
        }
#endif /* BYFOUR */

        crc_table_empty = 0;
    }
    else {      /* not first */
        /* wait for the other guy to finish (not efficient, but rare) */
        while (crc_table_empty)
            ;
    }

#ifdef MAKECRCH
    /* write out CRC tables to crc32.h */
    {
        FILE *out;

        out = fopen("crc32.h", "w");
        if (out == NULL) return;
        fprintf(out, "/* crc32.h -- tables for rapid CRC calculation\n");
        fprintf(out, " * Generated automatically by crc32.c\n */\n\n");
        fprintf(out, "local const z_crc_t FAR ");
        fprintf(out, "crc_table[TBLS][256] =\n{\n  {\n");
        write_table(out, crc_table[0]);
#  ifdef BYFOUR
        fprintf(out, "#ifdef BYFOUR\n");
        for (k = 1; k < 8; k++) {
            fprintf(out, "  },\n  {\n");
            write_table(out, crc_table[k]);
        }
        fprintf(out, "#endif\n");
#  endif /* BYFOUR */
        fprintf(out, "  }\n};\n");
        fclose(out);
    }
#endif /* MAKECRCH */
}

#ifdef MAKECRCH
local void write_table(out, table)
    FILE *out;
    const z_crc_t FAR *table;
{
    int n;

    for (n = 0; n < 256; n++)
        fprintf(out, "%s0x%08lxUL%s", n % 5 ? "" : "    ",
                (unsigned long)(table[n]),
                n == 255 ? "\n" : (n % 5 == 4 ? ",\n" : ", "));
}
#endif /* MAKECRCH */

#else /* !DYNAMIC_CRC_TABLE */
/* ========================================================================
 * Tables of CRC-32s of all single-byte values, made by make_crc_table().
 */
#endif /* DYNAMIC_CRC_TABLE */

/* =========================================================================
 * This function can be used by asm versions of crc32()
 */
const z_crc_t FAR * ZEXPORT get_crc_table()
{
#ifdef DYNAMIC_CRC_TABLE
    if (crc_table_empty)
        make_crc_table();
#endif /* DYNAMIC_CRC_TABLE */
    return (const z_crc_t FAR *)crc_table;
}

/* ========================================================================= */
#define DO1 crc = crc_table[0][((int)crc ^ (*buf++)) & 0xff] ^ (crc >> 8)
#define DO8 DO1; DO1; DO1; DO1; DO1; DO1; DO1; DO1

/* ========================================================================= */
unsigned long ZEXPORT crc32(crc, buf, len)
    unsigned long crc;
    const unsigned char FAR *buf;
    uInt len;
{
    if (buf == Z_NULL) return 0UL;

#ifdef DYNAMIC_CRC_TABLE
    if (crc_table_empty)
        make_crc_table();
#endif /* DYNAMIC_CRC_TABLE */

#ifdef BYFOUR
    if (sizeof(void *) == sizeof(ptrdiff_t)) {
        z_crc_t endian;

        endian = 1;
        if (*((unsigned char *)(&endian)))
            return crc32_little(crc, buf, len);
        else
            return crc32_big(crc, buf, len);
    }
#endif /* BYFOUR */
    crc = crc ^ 0xffffffffUL;
    while (len >= 8) {
        DO8;
        len -= 8;
    }
    if (len) do {
        DO1;
    } while (--len);
    return crc ^ 0xffffffffUL;
}

#ifdef BYFOUR

/* ========================================================================= */
#define DOLIT4 c ^= *buf4++; \
        c = crc_table[3][c & 0xff] ^ crc_table[2][(c >> 8) & 0xff] ^ \
            crc_table[1][(c >> 16) & 0xff] ^ crc_table[0][c >> 24]
#define DOLIT32 DOLIT4; DOLIT4; DOLIT4; DOLIT4; DOLIT4; DOLIT4; DOLIT4; DOLIT4

/* ========================================================================= */
local unsigned long crc32_little(crc, buf, len)
    unsigned long crc;
    const unsigned char FAR *buf;
    unsigned len;
{
    register z_crc_t c;
    register const z_crc_t FAR *buf4;

    c = (z_crc_t)crc;
    c = ~c;
    while (len && ((ptrdiff_t)buf & 3)) {
        c = crc_table[0][(c ^ *buf++) & 0xff] ^ (c >> 8);
        len--;
    }

    buf4 = (const z_crc_t FAR *)(const void FAR *)buf;
    while (len >= 32) {
        DOLIT32;
        len -= 32;
    }
    while (len >= 4) {
        DOLIT4;
        len -= 4;
    }
    buf = (const unsigned char FAR *)buf4;

    if (len) do {
        c = crc_table[0][(c ^ *buf++) & 0xff] ^ (c >> 8);
    } while (--len);
    c = ~c;
    return (unsigned long)c;
}

/* ========================================================================= */
#define DOBIG4 c ^= *++buf4; \
        c = crc_table[4][c & 0xff] ^ crc_table[5][(c >> 8) & 0xff] ^ \
            crc_table[6][(c >> 16) & 0xff] ^ crc_table[7][c >> 24]
#define DOBIG32 DOBIG4; DOBIG4; DOBIG4; DOBIG4; DOBIG4; DOBIG4; DOBIG4; DOBIG4

/* ========================================================================= */
local unsigned long crc32_big(crc, buf, len)
    unsigned long crc;
    const unsigned char FAR *buf;
    unsigned len;
{
    register z_crc_t c;
    register const z_crc_t FAR *buf4;

    c = ZSWAP32((z_crc_t)crc);
    c = ~c;
    while (len && ((ptrdiff_t)buf & 3)) {
        c = crc_table[4][(c >> 24) ^ *buf++] ^ (c << 8);
        len--;
    }

    buf4 = (const z_crc_t FAR *)(const void FAR *)buf;
    buf4--;
    while (len >= 32) {
        DOBIG32;
        len -= 32;
    }
    while (len >= 4) {
        DOBIG4;
        len -= 4;
    }
    buf4++;
    buf = (const unsigned char FAR *)buf4;

    if (len) do {
        c = crc_table[4][(c >> 24) ^ *buf++] ^ (c << 8);
    } while (--len);
    c = ~c;
    return (unsigned long)(ZSWAP32(c));
}

#endif /* BYFOUR */

#define GF2_DIM 32      /* dimension of GF(2) vectors (length of CRC) */

/* ========================================================================= */
local unsigned long gf2_matrix_times(mat, vec)
    unsigned long *mat;
    unsigned long vec;
{
    unsigned long sum;

    sum = 0;
    while (vec) {
        if (vec & 1)
            sum ^= *mat;
        vec >>= 1;
        mat++;
    }
    return sum;
}

/* ========================================================================= */
local void gf2_matrix_square(square, mat)
    unsigned long *square;
    unsigned long *mat;
{
    int n;

    for (n = 0; n < GF2_DIM; n++)
        square[n] = gf2_matrix_times(mat, mat[n]);
}

/* ========================================================================= */
local uLong crc32_combine_(crc1, crc2, len2)
    uLong crc1;
    uLong crc2;
    z_off64_t len2;
{
    int n;
    unsigned long row;
    unsigned long even[GF2_DIM];    /* even-power-of-two zeros operator */
    unsigned long odd[GF2_DIM];     /* odd-power-of-two zeros operator */

    /* degenerate case (also disallow negative lengths) */
    if (len2 <= 0)
        return crc1;

    /* put operator for one zero bit in odd */
    odd[0] = 0xedb88320UL;          /* CRC-32 polynomial */
    row = 1;
    for (n = 1; n < GF2_DIM; n++) {
        odd[n] = row;
        row <<= 1;
    }

    /* put operator for two zero bits in even */
    gf2_matrix_square(even, odd);

    /* put operator for four zero bits in odd */
    gf2_matrix_square(odd, even);

    /* apply len2 zeros to crc1 (first square will put the operator for one
       zero byte, eight zero bits, in even) */
    do {
        /* apply zeros operator for this bit of len2 */
        gf2_matrix_square(even, odd);
        if (len2 & 1)
            crc1 = gf2_matrix_times(even, crc1);
        len2 >>= 1;

        /* if no more bits set, then done */
        if (len2 == 0)
            break;

        /* another iteration of the loop with odd and even swapped */
        gf2_matrix_square(odd, even);
        if (len2 & 1)
            crc1 = gf2_matrix_times(odd, crc1);
        len2 >>= 1;

        /* if no more bits set, then done */
    } while (len2 != 0);

    /* return combined crc */
    crc1 ^= crc2;
    return crc1;
}

/* ========================================================================= */
uLong ZEXPORT crc32_combine(crc1, crc2, len2)
    uLong crc1;
    uLong crc2;
    z_off_t len2;
{
    return crc32_combine_(crc1, crc2, len2);
}

uLong ZEXPORT crc32_combine64(crc1, crc2, len2)
    uLong crc1;
    uLong crc2;
    z_off64_t len2;
{
    return crc32_combine_(crc1, crc2, len2);
}

/***********************************************************************
ZLIB\DEFLATE.C
***********************************************************************/
/* deflate.c -- compress data using the deflation algorithm
 * Copyright (C) 1995-2013 Jean-loup Gailly and Mark Adler
 * For conditions of distribution and use, see copyright notice in zlib.h
 */

/*
 *  ALGORITHM
 *
 *      The "deflation" process depends on being able to identify portions
 *      of the input text which are identical to earlier input (within a
 *      sliding window trailing behind the input currently being processed).
 *
 *      The most straightforward technique turns out to be the fastest for
 *      most input files: try all possible matches and select the longest.
 *      The key feature of this algorithm is that insertions into the string
 *      dictionary are very simple and thus fast, and deletions are avoided
 *      completely. Insertions are performed at each input character, whereas
 *      string matches are performed only when the previous match ends. So it
 *      is preferable to spend more time in matches to allow very fast string
 *      insertions and avoid deletions. The matching algorithm for small
 *      strings is inspired from that of Rabin & Karp. A brute force approach
 *      is used to find longer strings when a small match has been found.
 *      A similar algorithm is used in comic (by Jan-Mark Wams) and freeze
 *      (by Leonid Broukhis).
 *         A previous version of this file used a more sophisticated algorithm
 *      (by Fiala and Greene) which is guaranteed to run in linear amortized
 *      time, but has a larger average cost, uses more memory and is patented.
 *      However the F&G algorithm may be faster for some highly redundant
 *      files if the parameter max_chain_length (described below) is too large.
 *
 *  ACKNOWLEDGEMENTS
 *
 *      The idea of lazy evaluation of matches is due to Jan-Mark Wams, and
 *      I found it in 'freeze' written by Leonid Broukhis.
 *      Thanks to many people for bug reports and testing.
 *
 *  REFERENCES
 *
 *      Deutsch, L.P.,"DEFLATE Compressed Data Format Specification".
 *      Available in http://tools.ietf.org/html/rfc1951
 *
 *      A description of the Rabin and Karp algorithm is given in the book
 *         "Algorithms" by R. Sedgewick, Addison-Wesley, p252.
 *
 *      Fiala,E.R., and Greene,D.H.
 *         Data Compression with Finite Windows, Comm.ACM, 32,4 (1989) 490-595
 *
 */

/* @(#) $Id$ */


const char deflate_copyright[] =
   " deflate 1.2.8 Copyright 1995-2013 Jean-loup Gailly and Mark Adler ";
/*
  If you use the zlib library in a product, an acknowledgment is welcome
  in the documentation of your product. If for some reason you cannot
  include such an acknowledgment, I would appreciate that you keep this
  copyright string in the executable of your product.
 */

/* ===========================================================================
 *  Function prototypes.
 */
typedef enum {
    need_more,      /* block not completed, need more input or more output */
    block_done,     /* block flush performed */
    finish_started, /* finish started, need only more output at next deflate */
    finish_done     /* finish done, accept no more input or output */
} block_state;

typedef block_state (*compress_func) OF((deflate_state *s, int flush));
/* Compression function. Returns the block state after the call. */

local void fill_window    OF((deflate_state *s));
local block_state deflate_stored OF((deflate_state *s, int flush));
local block_state deflate_fast   OF((deflate_state *s, int flush));
#ifndef FASTEST
local block_state deflate_slow   OF((deflate_state *s, int flush));
#endif
local block_state deflate_rle    OF((deflate_state *s, int flush));
local block_state deflate_huff   OF((deflate_state *s, int flush));
local void lm_init        OF((deflate_state *s));
local void putShortMSB    OF((deflate_state *s, uInt b));
local void flush_pending  OF((z_streamp strm));
local int read_buf        OF((z_streamp strm, Bytef *buf, unsigned size));
#ifdef ASMV
      void match_init OF((void)); /* asm code initialization */
      uInt longest_match  OF((deflate_state *s, IPos cur_match));
#else
local uInt longest_match  OF((deflate_state *s, IPos cur_match));
#endif

#ifdef DEBUG
local  void check_match OF((deflate_state *s, IPos start, IPos match,
                            int length));
#endif

/* ===========================================================================
 * Local data
 */

#define NIL 0
/* Tail of hash chains */

#ifndef TOO_FAR
#  define TOO_FAR 4096
#endif
/* Matches of length 3 are discarded if their distance exceeds TOO_FAR */

/* Values for max_lazy_match, good_match and max_chain_length, depending on
 * the desired pack level (0..9). The values given below have been tuned to
 * exclude worst case performance for pathological files. Better values may be
 * found for specific files.
 */
typedef struct config_s {
   ush good_length; /* reduce lazy search above this match length */
   ush max_lazy;    /* do not perform lazy search above this match length */
   ush nice_length; /* quit search above this match length */
   ush max_chain;
   compress_func func;
} config;

#ifdef FASTEST
local const config configuration_table[2] = {
/*      good lazy nice chain */
/* 0 */ {0,    0,  0,    0, deflate_stored},  /* store only */
/* 1 */ {4,    4,  8,    4, deflate_fast}}; /* max speed, no lazy matches */
#else
local const config configuration_table[10] = {
/*      good lazy nice chain */
/* 0 */ {0,    0,  0,    0, deflate_stored},  /* store only */
/* 1 */ {4,    4,  8,    4, deflate_fast}, /* max speed, no lazy matches */
/* 2 */ {4,    5, 16,    8, deflate_fast},
/* 3 */ {4,    6, 32,   32, deflate_fast},

/* 4 */ {4,    4, 16,   16, deflate_slow},  /* lazy matches */
/* 5 */ {8,   16, 32,   32, deflate_slow},
/* 6 */ {8,   16, 128, 128, deflate_slow},
/* 7 */ {8,   32, 128, 256, deflate_slow},
/* 8 */ {32, 128, 258, 1024, deflate_slow},
/* 9 */ {32, 258, 258, 4096, deflate_slow}}; /* max compression */
#endif

/* Note: the deflate() code requires max_lazy >= MIN_MATCH and max_chain >= 4
 * For deflate_fast() (levels <= 3) good is ignored and lazy has a different
 * meaning.
 */

#define EQUAL 0
/* result of memcmp for equal strings */

#ifndef NO_DUMMY_DECL
struct static_tree_desc_s {int dummy;}; /* for buggy compilers */
#endif

/* rank Z_BLOCK between Z_NO_FLUSH and Z_PARTIAL_FLUSH */
#define RANK(f) (((f) << 1) - ((f) > 4 ? 9 : 0))

/* ===========================================================================
 * Update a hash value with the given input byte
 * IN  assertion: all calls to to UPDATE_HASH are made with consecutive
 *    input characters, so that a running hash key can be computed from the
 *    previous key instead of complete recalculation each time.
 */
#define UPDATE_HASH(s,h,c) (h = (((h)<<s->hash_shift) ^ (c)) & s->hash_mask)


/* ===========================================================================
 * Insert string str in the dictionary and set match_head to the previous head
 * of the hash chain (the most recent string with same hash key). Return
 * the previous length of the hash chain.
 * If this file is compiled with -DFASTEST, the compression level is forced
 * to 1, and no hash chains are maintained.
 * IN  assertion: all calls to to INSERT_STRING are made with consecutive
 *    input characters and the first MIN_MATCH bytes of str are valid
 *    (except for the last MIN_MATCH-1 bytes of the input file).
 */
#ifdef FASTEST
#define INSERT_STRING(s, str, match_head) \
   (UPDATE_HASH(s, s->ins_h, s->window[(str) + (MIN_MATCH-1)]), \
    match_head = s->head[s->ins_h], \
    s->head[s->ins_h] = (Pos)(str))
#else
#define INSERT_STRING(s, str, match_head) \
   (UPDATE_HASH(s, s->ins_h, s->window[(str) + (MIN_MATCH-1)]), \
    match_head = s->prev[(str) & s->w_mask] = s->head[s->ins_h], \
    s->head[s->ins_h] = (Pos)(str))
#endif

/* ===========================================================================
 * Initialize the hash table (avoiding 64K overflow for 16 bit systems).
 * prev[] will be initialized on the fly.
 */
#define CLEAR_HASH(s) \
    s->head[s->hash_size-1] = NIL; \
    zmemzero((Bytef *)s->head, (unsigned)(s->hash_size-1)*sizeof(*s->head));

/* ========================================================================= */
int ZEXPORT deflateInit_(strm, level, version, stream_size)
    z_streamp strm;
    int level;
    const char *version;
    int stream_size;
{
    return deflateInit2_(strm, level, Z_DEFLATED, MAX_WBITS, DEF_MEM_LEVEL,
                         Z_DEFAULT_STRATEGY, version, stream_size);
    /* To do: ignore strm->next_in if we use it as window */
}

/* ========================================================================= */
int ZEXPORT deflateInit2_(strm, level, method, windowBits, memLevel, strategy,
                  version, stream_size)
    z_streamp strm;
    int  level;
    int  method;
    int  windowBits;
    int  memLevel;
    int  strategy;
    const char *version;
    int stream_size;
{
    deflate_state *s;
    int wrap = 1;
    static const char my_version[] = ZLIB_VERSION;

    ushf *overlay;
    /* We overlay pending_buf and d_buf+l_buf. This works since the average
     * output size for (length,distance) codes is <= 24 bits.
     */

    if (version == Z_NULL || version[0] != my_version[0] ||
        stream_size != sizeof(z_stream)) {
        return Z_VERSION_ERROR;
    }
    if (strm == Z_NULL) return Z_STREAM_ERROR;

    strm->msg = Z_NULL;
    if (strm->zalloc == (alloc_func)0) {
#ifdef Z_SOLO
        return Z_STREAM_ERROR;
#else
        strm->zalloc = zcalloc;
        strm->opaque = (voidpf)0;
#endif
    }
    if (strm->zfree == (free_func)0)
#ifdef Z_SOLO
        return Z_STREAM_ERROR;
#else
        strm->zfree = zcfree;
#endif

#ifdef FASTEST
    if (level != 0) level = 1;
#else
    if (level == Z_DEFAULT_COMPRESSION) level = 6;
#endif

    if (windowBits < 0) { /* suppress zlib wrapper */
        wrap = 0;
        windowBits = -windowBits;
    }
#ifdef GZIP
    else if (windowBits > 15) {
        wrap = 2;       /* write gzip wrapper instead */
        windowBits -= 16;
    }
#endif
    if (memLevel < 1 || memLevel > MAX_MEM_LEVEL || method != Z_DEFLATED ||
        windowBits < 8 || windowBits > 15 || level < 0 || level > 9 ||
        strategy < 0 || strategy > Z_FIXED) {
        return Z_STREAM_ERROR;
    }
    if (windowBits == 8) windowBits = 9;  /* until 256-byte window bug fixed */
    s = (deflate_state *) ZALLOC(strm, 1, sizeof(deflate_state));
    if (s == Z_NULL) return Z_MEM_ERROR;
    strm->state = (struct internal_state FAR *)s;
    s->strm = strm;

    s->wrap = wrap;
    s->gzhead = Z_NULL;
    s->w_bits = windowBits;
    s->w_size = 1 << s->w_bits;
    s->w_mask = s->w_size - 1;

    s->hash_bits = memLevel + 7;
    s->hash_size = 1 << s->hash_bits;
    s->hash_mask = s->hash_size - 1;
    s->hash_shift =  ((s->hash_bits+MIN_MATCH-1)/MIN_MATCH);

    s->window = (Bytef *) ZALLOC(strm, s->w_size, 2*sizeof(Byte));
    s->prev   = (Posf *)  ZALLOC(strm, s->w_size, sizeof(Pos));
    s->head   = (Posf *)  ZALLOC(strm, s->hash_size, sizeof(Pos));

    s->high_water = 0;      /* nothing written to s->window yet */

    s->lit_bufsize = 1 << (memLevel + 6); /* 16K elements by default */

    overlay = (ushf *) ZALLOC(strm, s->lit_bufsize, sizeof(ush)+2);
    s->pending_buf = (uchf *) overlay;
    s->pending_buf_size = (ulg)s->lit_bufsize * (sizeof(ush)+2L);

    if (s->window == Z_NULL || s->prev == Z_NULL || s->head == Z_NULL ||
        s->pending_buf == Z_NULL) {
        s->status = FINISH_STATE;
        strm->msg = ERR_MSG(Z_MEM_ERROR);
        deflateEnd (strm);
        return Z_MEM_ERROR;
    }
    s->d_buf = overlay + s->lit_bufsize/sizeof(ush);
    s->l_buf = s->pending_buf + (1+sizeof(ush))*s->lit_bufsize;

    s->level = level;
    s->strategy = strategy;
    s->method = (Byte)method;

    return deflateReset(strm);
}

/* ========================================================================= */
int ZEXPORT deflateSetDictionary (strm, dictionary, dictLength)
    z_streamp strm;
    const Bytef *dictionary;
    uInt  dictLength;
{
    deflate_state *s;
    uInt str, n;
    int wrap;
    unsigned avail;
    z_const unsigned char *next;

    if (strm == Z_NULL || strm->state == Z_NULL || dictionary == Z_NULL)
        return Z_STREAM_ERROR;
    s = strm->state;
    wrap = s->wrap;
    if (wrap == 2 || (wrap == 1 && s->status != INIT_STATE) || s->lookahead)
        return Z_STREAM_ERROR;

    /* when using zlib wrappers, compute Adler-32 for provided dictionary */
    if (wrap == 1)
        strm->adler = adler32(strm->adler, dictionary, dictLength);
    s->wrap = 0;                    /* avoid computing Adler-32 in read_buf */

    /* if dictionary would fill window, just replace the history */
    if (dictLength >= s->w_size) {
        if (wrap == 0) {            /* already empty otherwise */
            CLEAR_HASH(s);
            s->strstart = 0;
            s->block_start = 0L;
            s->insert = 0;
        }
        dictionary += dictLength - s->w_size;  /* use the tail */
        dictLength = s->w_size;
    }

    /* insert dictionary into window and hash */
    avail = strm->avail_in;
    next = strm->next_in;
    strm->avail_in = dictLength;
    strm->next_in = (z_const Bytef *)dictionary;
    fill_window(s);
    while (s->lookahead >= MIN_MATCH) {
        str = s->strstart;
        n = s->lookahead - (MIN_MATCH-1);
        do {
            UPDATE_HASH(s, s->ins_h, s->window[str + MIN_MATCH-1]);
#ifndef FASTEST
            s->prev[str & s->w_mask] = s->head[s->ins_h];
#endif
            s->head[s->ins_h] = (Pos)str;
            str++;
        } while (--n);
        s->strstart = str;
        s->lookahead = MIN_MATCH-1;
        fill_window(s);
    }
    s->strstart += s->lookahead;
    s->block_start = (long)s->strstart;
    s->insert = s->lookahead;
    s->lookahead = 0;
    s->match_length = s->prev_length = MIN_MATCH-1;
    s->match_available = 0;
    strm->next_in = next;
    strm->avail_in = avail;
    s->wrap = wrap;
    return Z_OK;
}

/* ========================================================================= */
int ZEXPORT deflateResetKeep (strm)
    z_streamp strm;
{
    deflate_state *s;

    if (strm == Z_NULL || strm->state == Z_NULL ||
        strm->zalloc == (alloc_func)0 || strm->zfree == (free_func)0) {
        return Z_STREAM_ERROR;
    }

    strm->total_in = strm->total_out = 0;
    strm->msg = Z_NULL; /* use zfree if we ever allocate msg dynamically */
    strm->data_type = Z_UNKNOWN;

    s = (deflate_state *)strm->state;
    s->pending = 0;
    s->pending_out = s->pending_buf;

    if (s->wrap < 0) {
        s->wrap = -s->wrap; /* was made negative by deflate(..., Z_FINISH); */
    }
    s->status = s->wrap ? INIT_STATE : BUSY_STATE;
    strm->adler =
#ifdef GZIP
        s->wrap == 2 ? crc32(0L, Z_NULL, 0) :
#endif
        adler32(0L, Z_NULL, 0);
    s->last_flush = Z_NO_FLUSH;

    _tr_init(s);

    return Z_OK;
}

/* ========================================================================= */
int ZEXPORT deflateReset (strm)
    z_streamp strm;
{
    int ret;

    ret = deflateResetKeep(strm);
    if (ret == Z_OK)
        lm_init(strm->state);
    return ret;
}

/* ========================================================================= */
int ZEXPORT deflateSetHeader (strm, head)
    z_streamp strm;
    gz_headerp head;
{
    if (strm == Z_NULL || strm->state == Z_NULL) return Z_STREAM_ERROR;
    if (strm->state->wrap != 2) return Z_STREAM_ERROR;
    strm->state->gzhead = head;
    return Z_OK;
}

/* ========================================================================= */
int ZEXPORT deflatePending (strm, pending, bits)
    unsigned *pending;
    int *bits;
    z_streamp strm;
{
    if (strm == Z_NULL || strm->state == Z_NULL) return Z_STREAM_ERROR;
    if (pending != Z_NULL)
        *pending = strm->state->pending;
    if (bits != Z_NULL)
        *bits = strm->state->bi_valid;
    return Z_OK;
}

/* ========================================================================= */
int ZEXPORT deflatePrime (strm, bits, value)
    z_streamp strm;
    int bits;
    int value;
{
    deflate_state *s;
    int put;

    if (strm == Z_NULL || strm->state == Z_NULL) return Z_STREAM_ERROR;
    s = strm->state;
    if ((Bytef *)(s->d_buf) < s->pending_out + ((Buf_size + 7) >> 3))
        return Z_BUF_ERROR;
    do {
        put = Buf_size - s->bi_valid;
        if (put > bits)
            put = bits;
        s->bi_buf |= (ush)((value & ((1 << put) - 1)) << s->bi_valid);
        s->bi_valid += put;
        _tr_flush_bits(s);
        value >>= put;
        bits -= put;
    } while (bits);
    return Z_OK;
}

/* ========================================================================= */
int ZEXPORT deflateParams(strm, level, strategy)
    z_streamp strm;
    int level;
    int strategy;
{
    deflate_state *s;
    compress_func func;
    int err = Z_OK;

    if (strm == Z_NULL || strm->state == Z_NULL) return Z_STREAM_ERROR;
    s = strm->state;

#ifdef FASTEST
    if (level != 0) level = 1;
#else
    if (level == Z_DEFAULT_COMPRESSION) level = 6;
#endif
    if (level < 0 || level > 9 || strategy < 0 || strategy > Z_FIXED) {
        return Z_STREAM_ERROR;
    }
    func = configuration_table[s->level].func;

    if ((strategy != s->strategy || func != configuration_table[level].func) &&
        strm->total_in != 0) {
        /* Flush the last buffer: */
        err = deflate(strm, Z_BLOCK);
        if (err == Z_BUF_ERROR && s->pending == 0)
            err = Z_OK;
    }
    if (s->level != level) {
        s->level = level;
        s->max_lazy_match   = configuration_table[level].max_lazy;
        s->good_match       = configuration_table[level].good_length;
        s->nice_match       = configuration_table[level].nice_length;
        s->max_chain_length = configuration_table[level].max_chain;
    }
    s->strategy = strategy;
    return err;
}

/* ========================================================================= */
int ZEXPORT deflateTune(strm, good_length, max_lazy, nice_length, max_chain)
    z_streamp strm;
    int good_length;
    int max_lazy;
    int nice_length;
    int max_chain;
{
    deflate_state *s;

    if (strm == Z_NULL || strm->state == Z_NULL) return Z_STREAM_ERROR;
    s = strm->state;
    s->good_match = good_length;
    s->max_lazy_match = max_lazy;
    s->nice_match = nice_length;
    s->max_chain_length = max_chain;
    return Z_OK;
}

/* =========================================================================
 * For the default windowBits of 15 and memLevel of 8, this function returns
 * a close to exact, as well as small, upper bound on the compressed size.
 * They are coded as constants here for a reason--if the #define's are
 * changed, then this function needs to be changed as well.  The return
 * value for 15 and 8 only works for those exact settings.
 *
 * For any setting other than those defaults for windowBits and memLevel,
 * the value returned is a conservative worst case for the maximum expansion
 * resulting from using fixed blocks instead of stored blocks, which deflate
 * can emit on compressed data for some combinations of the parameters.
 *
 * This function could be more sophisticated to provide closer upper bounds for
 * every combination of windowBits and memLevel.  But even the conservative
 * upper bound of about 14% expansion does not seem onerous for output buffer
 * allocation.
 */
uLong ZEXPORT deflateBound(strm, sourceLen)
    z_streamp strm;
    uLong sourceLen;
{
    deflate_state *s;
    uLong complen, wraplen;
    Bytef *str;

    /* conservative upper bound for compressed data */
    complen = sourceLen +
              ((sourceLen + 7) >> 3) + ((sourceLen + 63) >> 6) + 5;

    /* if can't get parameters, return conservative bound plus zlib wrapper */
    if (strm == Z_NULL || strm->state == Z_NULL)
        return complen + 6;

    /* compute wrapper length */
    s = strm->state;
    switch (s->wrap) {
    case 0:                                 /* raw deflate */
        wraplen = 0;
        break;
    case 1:                                 /* zlib wrapper */
        wraplen = 6 + (s->strstart ? 4 : 0);
        break;
    case 2:                                 /* gzip wrapper */
        wraplen = 18;
        if (s->gzhead != Z_NULL) {          /* user-supplied gzip header */
            if (s->gzhead->extra != Z_NULL)
                wraplen += 2 + s->gzhead->extra_len;
            str = s->gzhead->name;
            if (str != Z_NULL)
                do {
                    wraplen++;
                } while (*str++);
            str = s->gzhead->comment;
            if (str != Z_NULL)
                do {
                    wraplen++;
                } while (*str++);
            if (s->gzhead->hcrc)
                wraplen += 2;
        }
        break;
    default:                                /* for compiler happiness */
        wraplen = 6;
    }

    /* if not default parameters, return conservative bound */
    if (s->w_bits != 15 || s->hash_bits != 8 + 7)
        return complen + wraplen;

    /* default settings: return tight bound for that case */
    return sourceLen + (sourceLen >> 12) + (sourceLen >> 14) +
           (sourceLen >> 25) + 13 - 6 + wraplen;
}

/* =========================================================================
 * Put a short in the pending buffer. The 16-bit value is put in MSB order.
 * IN assertion: the stream state is correct and there is enough room in
 * pending_buf.
 */
local void putShortMSB (s, b)
    deflate_state *s;
    uInt b;
{
    put_byte(s, (Byte)(b >> 8));
    put_byte(s, (Byte)(b & 0xff));
}

/* =========================================================================
 * Flush as much pending output as possible. All deflate() output goes
 * through this function so some applications may wish to modify it
 * to avoid allocating a large strm->next_out buffer and copying into it.
 * (See also read_buf()).
 */
local void flush_pending(strm)
    z_streamp strm;
{
    unsigned len;
    deflate_state *s = strm->state;

    _tr_flush_bits(s);
    len = s->pending;
    if (len > strm->avail_out) len = strm->avail_out;
    if (len == 0) return;

    zmemcpy(strm->next_out, s->pending_out, len);
    strm->next_out  += len;
    s->pending_out  += len;
    strm->total_out += len;
    strm->avail_out  -= len;
    s->pending -= len;
    if (s->pending == 0) {
        s->pending_out = s->pending_buf;
    }
}

/* ========================================================================= */
int ZEXPORT deflate (strm, flush)
    z_streamp strm;
    int flush;
{
    int old_flush; /* value of flush param for previous deflate call */
    deflate_state *s;

    if (strm == Z_NULL || strm->state == Z_NULL ||
        flush > Z_BLOCK || flush < 0) {
        return Z_STREAM_ERROR;
    }
    s = strm->state;

    if (strm->next_out == Z_NULL ||
        (strm->next_in == Z_NULL && strm->avail_in != 0) ||
        (s->status == FINISH_STATE && flush != Z_FINISH)) {
        ERR_RETURN(strm, Z_STREAM_ERROR);
    }
    if (strm->avail_out == 0) ERR_RETURN(strm, Z_BUF_ERROR);

    s->strm = strm; /* just in case */
    old_flush = s->last_flush;
    s->last_flush = flush;

    /* Write the header */
    if (s->status == INIT_STATE) {
#ifdef GZIP
        if (s->wrap == 2) {
            strm->adler = crc32(0L, Z_NULL, 0);
            put_byte(s, 31);
            put_byte(s, 139);
            put_byte(s, 8);
            if (s->gzhead == Z_NULL) {
                put_byte(s, 0);
                put_byte(s, 0);
                put_byte(s, 0);
                put_byte(s, 0);
                put_byte(s, 0);
                put_byte(s, s->level == 9 ? 2 :
                            (s->strategy >= Z_HUFFMAN_ONLY || s->level < 2 ?
                             4 : 0));
                put_byte(s, OS_CODE);
                s->status = BUSY_STATE;
            }
            else {
                put_byte(s, (s->gzhead->text ? 1 : 0) +
                            (s->gzhead->hcrc ? 2 : 0) +
                            (s->gzhead->extra == Z_NULL ? 0 : 4) +
                            (s->gzhead->name == Z_NULL ? 0 : 8) +
                            (s->gzhead->comment == Z_NULL ? 0 : 16)
                        );
                put_byte(s, (Byte)(s->gzhead->time & 0xff));
                put_byte(s, (Byte)((s->gzhead->time >> 8) & 0xff));
                put_byte(s, (Byte)((s->gzhead->time >> 16) & 0xff));
                put_byte(s, (Byte)((s->gzhead->time >> 24) & 0xff));
                put_byte(s, s->level == 9 ? 2 :
                            (s->strategy >= Z_HUFFMAN_ONLY || s->level < 2 ?
                             4 : 0));
                put_byte(s, s->gzhead->os & 0xff);
                if (s->gzhead->extra != Z_NULL) {
                    put_byte(s, s->gzhead->extra_len & 0xff);
                    put_byte(s, (s->gzhead->extra_len >> 8) & 0xff);
                }
                if (s->gzhead->hcrc)
                    strm->adler = crc32(strm->adler, s->pending_buf,
                                        s->pending);
                s->gzindex = 0;
                s->status = EXTRA_STATE;
            }
        }
        else
#endif
        {
            uInt header = (Z_DEFLATED + ((s->w_bits-8)<<4)) << 8;
            uInt level_flags;

            if (s->strategy >= Z_HUFFMAN_ONLY || s->level < 2)
                level_flags = 0;
            else if (s->level < 6)
                level_flags = 1;
            else if (s->level == 6)
                level_flags = 2;
            else
                level_flags = 3;
            header |= (level_flags << 6);
            if (s->strstart != 0) header |= PRESET_DICT;
            header += 31 - (header % 31);

            s->status = BUSY_STATE;
            putShortMSB(s, header);

            /* Save the adler32 of the preset dictionary: */
            if (s->strstart != 0) {
                putShortMSB(s, (uInt)(strm->adler >> 16));
                putShortMSB(s, (uInt)(strm->adler & 0xffff));
            }
            strm->adler = adler32(0L, Z_NULL, 0);
        }
    }
#ifdef GZIP
    if (s->status == EXTRA_STATE) {
        if (s->gzhead->extra != Z_NULL) {
            uInt beg = s->pending;  /* start of bytes to update crc */

            while (s->gzindex < (s->gzhead->extra_len & 0xffff)) {
                if (s->pending == s->pending_buf_size) {
                    if (s->gzhead->hcrc && s->pending > beg)
                        strm->adler = crc32(strm->adler, s->pending_buf + beg,
                                            s->pending - beg);
                    flush_pending(strm);
                    beg = s->pending;
                    if (s->pending == s->pending_buf_size)
                        break;
                }
                put_byte(s, s->gzhead->extra[s->gzindex]);
                s->gzindex++;
            }
            if (s->gzhead->hcrc && s->pending > beg)
                strm->adler = crc32(strm->adler, s->pending_buf + beg,
                                    s->pending - beg);
            if (s->gzindex == s->gzhead->extra_len) {
                s->gzindex = 0;
                s->status = NAME_STATE;
            }
        }
        else
            s->status = NAME_STATE;
    }
    if (s->status == NAME_STATE) {
        if (s->gzhead->name != Z_NULL) {
            uInt beg = s->pending;  /* start of bytes to update crc */
            int val;

            do {
                if (s->pending == s->pending_buf_size) {
                    if (s->gzhead->hcrc && s->pending > beg)
                        strm->adler = crc32(strm->adler, s->pending_buf + beg,
                                            s->pending - beg);
                    flush_pending(strm);
                    beg = s->pending;
                    if (s->pending == s->pending_buf_size) {
                        val = 1;
                        break;
                    }
                }
                val = s->gzhead->name[s->gzindex++];
                put_byte(s, val);
            } while (val != 0);
            if (s->gzhead->hcrc && s->pending > beg)
                strm->adler = crc32(strm->adler, s->pending_buf + beg,
                                    s->pending - beg);
            if (val == 0) {
                s->gzindex = 0;
                s->status = COMMENT_STATE;
            }
        }
        else
            s->status = COMMENT_STATE;
    }
    if (s->status == COMMENT_STATE) {
        if (s->gzhead->comment != Z_NULL) {
            uInt beg = s->pending;  /* start of bytes to update crc */
            int val;

            do {
                if (s->pending == s->pending_buf_size) {
                    if (s->gzhead->hcrc && s->pending > beg)
                        strm->adler = crc32(strm->adler, s->pending_buf + beg,
                                            s->pending - beg);
                    flush_pending(strm);
                    beg = s->pending;
                    if (s->pending == s->pending_buf_size) {
                        val = 1;
                        break;
                    }
                }
                val = s->gzhead->comment[s->gzindex++];
                put_byte(s, val);
            } while (val != 0);
            if (s->gzhead->hcrc && s->pending > beg)
                strm->adler = crc32(strm->adler, s->pending_buf + beg,
                                    s->pending - beg);
            if (val == 0)
                s->status = HCRC_STATE;
        }
        else
            s->status = HCRC_STATE;
    }
    if (s->status == HCRC_STATE) {
        if (s->gzhead->hcrc) {
            if (s->pending + 2 > s->pending_buf_size)
                flush_pending(strm);
            if (s->pending + 2 <= s->pending_buf_size) {
                put_byte(s, (Byte)(strm->adler & 0xff));
                put_byte(s, (Byte)((strm->adler >> 8) & 0xff));
                strm->adler = crc32(0L, Z_NULL, 0);
                s->status = BUSY_STATE;
            }
        }
        else
            s->status = BUSY_STATE;
    }
#endif

    /* Flush as much pending output as possible */
    if (s->pending != 0) {
        flush_pending(strm);
        if (strm->avail_out == 0) {
            /* Since avail_out is 0, deflate will be called again with
             * more output space, but possibly with both pending and
             * avail_in equal to zero. There won't be anything to do,
             * but this is not an error situation so make sure we
             * return OK instead of BUF_ERROR at next call of deflate:
             */
            s->last_flush = -1;
            return Z_OK;
        }

    /* Make sure there is something to do and avoid duplicate consecutive
     * flushes. For repeated and useless calls with Z_FINISH, we keep
     * returning Z_STREAM_END instead of Z_BUF_ERROR.
     */
    } else if (strm->avail_in == 0 && RANK(flush) <= RANK(old_flush) &&
               flush != Z_FINISH) {
        ERR_RETURN(strm, Z_BUF_ERROR);
    }

    /* User must not provide more input after the first FINISH: */
    if (s->status == FINISH_STATE && strm->avail_in != 0) {
        ERR_RETURN(strm, Z_BUF_ERROR);
    }

    /* Start a new block or continue the current one.
     */
    if (strm->avail_in != 0 || s->lookahead != 0 ||
        (flush != Z_NO_FLUSH && s->status != FINISH_STATE)) {
        block_state bstate;

        bstate = s->strategy == Z_HUFFMAN_ONLY ? deflate_huff(s, flush) :
                    (s->strategy == Z_RLE ? deflate_rle(s, flush) :
                        (*(configuration_table[s->level].func))(s, flush));

        if (bstate == finish_started || bstate == finish_done) {
            s->status = FINISH_STATE;
        }
        if (bstate == need_more || bstate == finish_started) {
            if (strm->avail_out == 0) {
                s->last_flush = -1; /* avoid BUF_ERROR next call, see above */
            }
            return Z_OK;
            /* If flush != Z_NO_FLUSH && avail_out == 0, the next call
             * of deflate should use the same flush parameter to make sure
             * that the flush is complete. So we don't have to output an
             * empty block here, this will be done at next call. This also
             * ensures that for a very small output buffer, we emit at most
             * one empty block.
             */
        }
        if (bstate == block_done) {
            if (flush == Z_PARTIAL_FLUSH) {
                _tr_align(s);
            } else if (flush != Z_BLOCK) { /* FULL_FLUSH or SYNC_FLUSH */
                _tr_stored_block(s, (char*)0, 0L, 0);
                /* For a full flush, this empty block will be recognized
                 * as a special marker by inflate_sync().
                 */
                if (flush == Z_FULL_FLUSH) {
                    CLEAR_HASH(s);             /* forget history */
                    if (s->lookahead == 0) {
                        s->strstart = 0;
                        s->block_start = 0L;
                        s->insert = 0;
                    }
                }
            }
            flush_pending(strm);
            if (strm->avail_out == 0) {
              s->last_flush = -1; /* avoid BUF_ERROR at next call, see above */
              return Z_OK;
            }
        }
    }
    Assert(strm->avail_out > 0, "bug2");

    if (flush != Z_FINISH) return Z_OK;
    if (s->wrap <= 0) return Z_STREAM_END;

    /* Write the trailer */
#ifdef GZIP
    if (s->wrap == 2) {
        put_byte(s, (Byte)(strm->adler & 0xff));
        put_byte(s, (Byte)((strm->adler >> 8) & 0xff));
        put_byte(s, (Byte)((strm->adler >> 16) & 0xff));
        put_byte(s, (Byte)((strm->adler >> 24) & 0xff));
        put_byte(s, (Byte)(strm->total_in & 0xff));
        put_byte(s, (Byte)((strm->total_in >> 8) & 0xff));
        put_byte(s, (Byte)((strm->total_in >> 16) & 0xff));
        put_byte(s, (Byte)((strm->total_in >> 24) & 0xff));
    }
    else
#endif
    {
        putShortMSB(s, (uInt)(strm->adler >> 16));
        putShortMSB(s, (uInt)(strm->adler & 0xffff));
    }
    flush_pending(strm);
    /* If avail_out is zero, the application will call deflate again
     * to flush the rest.
     */
    if (s->wrap > 0) s->wrap = -s->wrap; /* write the trailer only once! */
    return s->pending != 0 ? Z_OK : Z_STREAM_END;
}

/* ========================================================================= */
int ZEXPORT deflateEnd (strm)
    z_streamp strm;
{
    int status;

    if (strm == Z_NULL || strm->state == Z_NULL) return Z_STREAM_ERROR;

    status = strm->state->status;
    if (status != INIT_STATE &&
        status != EXTRA_STATE &&
        status != NAME_STATE &&
        status != COMMENT_STATE &&
        status != HCRC_STATE &&
        status != BUSY_STATE &&
        status != FINISH_STATE) {
      return Z_STREAM_ERROR;
    }

    /* Deallocate in reverse order of allocations: */
    TRY_FREE(strm, strm->state->pending_buf);
    TRY_FREE(strm, strm->state->head);
    TRY_FREE(strm, strm->state->prev);
    TRY_FREE(strm, strm->state->window);

    ZFREE(strm, strm->state);
    strm->state = Z_NULL;

    return status == BUSY_STATE ? Z_DATA_ERROR : Z_OK;
}

/* =========================================================================
 * Copy the source state to the destination state.
 * To simplify the source, this is not supported for 16-bit MSDOS (which
 * doesn't have enough memory anyway to duplicate compression states).
 */
int ZEXPORT deflateCopy (dest, source)
    z_streamp dest;
    z_streamp source;
{
#ifdef MAXSEG_64K
    return Z_STREAM_ERROR;
#else
    deflate_state *ds;
    deflate_state *ss;
    ushf *overlay;


    if (source == Z_NULL || dest == Z_NULL || source->state == Z_NULL) {
        return Z_STREAM_ERROR;
    }

    ss = source->state;

    zmemcpy((voidpf)dest, (voidpf)source, sizeof(z_stream));

    ds = (deflate_state *) ZALLOC(dest, 1, sizeof(deflate_state));
    if (ds == Z_NULL) return Z_MEM_ERROR;
    dest->state = (struct internal_state FAR *) ds;
    zmemcpy((voidpf)ds, (voidpf)ss, sizeof(deflate_state));
    ds->strm = dest;

    ds->window = (Bytef *) ZALLOC(dest, ds->w_size, 2*sizeof(Byte));
    ds->prev   = (Posf *)  ZALLOC(dest, ds->w_size, sizeof(Pos));
    ds->head   = (Posf *)  ZALLOC(dest, ds->hash_size, sizeof(Pos));
    overlay = (ushf *) ZALLOC(dest, ds->lit_bufsize, sizeof(ush)+2);
    ds->pending_buf = (uchf *) overlay;

    if (ds->window == Z_NULL || ds->prev == Z_NULL || ds->head == Z_NULL ||
        ds->pending_buf == Z_NULL) {
        deflateEnd (dest);
        return Z_MEM_ERROR;
    }
    /* following zmemcpy do not work for 16-bit MSDOS */
    zmemcpy(ds->window, ss->window, ds->w_size * 2 * sizeof(Byte));
    zmemcpy((voidpf)ds->prev, (voidpf)ss->prev, ds->w_size * sizeof(Pos));
    zmemcpy((voidpf)ds->head, (voidpf)ss->head, ds->hash_size * sizeof(Pos));
    zmemcpy(ds->pending_buf, ss->pending_buf, (uInt)ds->pending_buf_size);

    ds->pending_out = ds->pending_buf + (ss->pending_out - ss->pending_buf);
    ds->d_buf = overlay + ds->lit_bufsize/sizeof(ush);
    ds->l_buf = ds->pending_buf + (1+sizeof(ush))*ds->lit_bufsize;

    ds->l_desc.dyn_tree = ds->dyn_ltree;
    ds->d_desc.dyn_tree = ds->dyn_dtree;
    ds->bl_desc.dyn_tree = ds->bl_tree;

    return Z_OK;
#endif /* MAXSEG_64K */
}

/* ===========================================================================
 * Read a new buffer from the current input stream, update the adler32
 * and total number of bytes read.  All deflate() input goes through
 * this function so some applications may wish to modify it to avoid
 * allocating a large strm->next_in buffer and copying from it.
 * (See also flush_pending()).
 */
local int read_buf(strm, buf, size)
    z_streamp strm;
    Bytef *buf;
    unsigned size;
{
    unsigned len = strm->avail_in;

    if (len > size) len = size;
    if (len == 0) return 0;

    strm->avail_in  -= len;

    zmemcpy(buf, strm->next_in, len);
    if (strm->state->wrap == 1) {
        strm->adler = adler32(strm->adler, buf, len);
    }
#ifdef GZIP
    else if (strm->state->wrap == 2) {
        strm->adler = crc32(strm->adler, buf, len);
    }
#endif
    strm->next_in  += len;
    strm->total_in += len;

    return (int)len;
}

/* ===========================================================================
 * Initialize the "longest match" routines for a new zlib stream
 */
local void lm_init (s)
    deflate_state *s;
{
    s->window_size = (ulg)2L*s->w_size;

    CLEAR_HASH(s);

    /* Set the default configuration parameters:
     */
    s->max_lazy_match   = configuration_table[s->level].max_lazy;
    s->good_match       = configuration_table[s->level].good_length;
    s->nice_match       = configuration_table[s->level].nice_length;
    s->max_chain_length = configuration_table[s->level].max_chain;

    s->strstart = 0;
    s->block_start = 0L;
    s->lookahead = 0;
    s->insert = 0;
    s->match_length = s->prev_length = MIN_MATCH-1;
    s->match_available = 0;
    s->ins_h = 0;
#ifndef FASTEST
#ifdef ASMV
    match_init(); /* initialize the asm code */
#endif
#endif
}

#ifndef FASTEST
/* ===========================================================================
 * Set match_start to the longest match starting at the given string and
 * return its length. Matches shorter or equal to prev_length are discarded,
 * in which case the result is equal to prev_length and match_start is
 * garbage.
 * IN assertions: cur_match is the head of the hash chain for the current
 *   string (strstart) and its distance is <= MAX_DIST, and prev_length >= 1
 * OUT assertion: the match length is not greater than s->lookahead.
 */
#ifndef ASMV
/* For 80x86 and 680x0, an optimized version will be provided in match.asm or
 * match.S. The code will be functionally equivalent.
 */
local uInt longest_match(s, cur_match)
    deflate_state *s;
    IPos cur_match;                             /* current match */
{
    unsigned chain_length = s->max_chain_length;/* max hash chain length */
    register Bytef *scan = s->window + s->strstart; /* current string */
    register Bytef *match;                       /* matched string */
    register int len;                           /* length of current match */
    int best_len = s->prev_length;              /* best match length so far */
    int nice_match = s->nice_match;             /* stop if match long enough */
    IPos limit = s->strstart > (IPos)MAX_DIST(s) ?
        s->strstart - (IPos)MAX_DIST(s) : NIL;
    /* Stop when cur_match becomes <= limit. To simplify the code,
     * we prevent matches with the string of window index 0.
     */
    Posf *prev = s->prev;
    uInt wmask = s->w_mask;

#ifdef UNALIGNED_OK
    /* Compare two bytes at a time. Note: this is not always beneficial.
     * Try with and without -DUNALIGNED_OK to check.
     */
    register Bytef *strend = s->window + s->strstart + MAX_MATCH - 1;
    register ush scan_start = *(ushf*)scan;
    register ush scan_end   = *(ushf*)(scan+best_len-1);
#else
    register Bytef *strend = s->window + s->strstart + MAX_MATCH;
    register Byte scan_end1  = scan[best_len-1];
    register Byte scan_end   = scan[best_len];
#endif

    /* The code is optimized for HASH_BITS >= 8 and MAX_MATCH-2 multiple of 16.
     * It is easy to get rid of this optimization if necessary.
     */
    Assert(s->hash_bits >= 8 && MAX_MATCH == 258, "Code too clever");

    /* Do not waste too much time if we already have a good match: */
    if (s->prev_length >= s->good_match) {
        chain_length >>= 2;
    }
    /* Do not look for matches beyond the end of the input. This is necessary
     * to make deflate deterministic.
     */
    if ((uInt)nice_match > s->lookahead) nice_match = s->lookahead;

    Assert((ulg)s->strstart <= s->window_size-MIN_LOOKAHEAD, "need lookahead");

    do {
        Assert(cur_match < s->strstart, "no future");
        match = s->window + cur_match;

        /* Skip to next match if the match length cannot increase
         * or if the match length is less than 2.  Note that the checks below
         * for insufficient lookahead only occur occasionally for performance
         * reasons.  Therefore uninitialized memory will be accessed, and
         * conditional jumps will be made that depend on those values.
         * However the length of the match is limited to the lookahead, so
         * the output of deflate is not affected by the uninitialized values.
         */
#if (defined(UNALIGNED_OK) && MAX_MATCH == 258)
        /* This code assumes sizeof(unsigned short) == 2. Do not use
         * UNALIGNED_OK if your compiler uses a different size.
         */
        if (*(ushf*)(match+best_len-1) != scan_end ||
            *(ushf*)match != scan_start) continue;

        /* It is not necessary to compare scan[2] and match[2] since they are
         * always equal when the other bytes match, given that the hash keys
         * are equal and that HASH_BITS >= 8. Compare 2 bytes at a time at
         * strstart+3, +5, ... up to strstart+257. We check for insufficient
         * lookahead only every 4th comparison; the 128th check will be made
         * at strstart+257. If MAX_MATCH-2 is not a multiple of 8, it is
         * necessary to put more guard bytes at the end of the window, or
         * to check more often for insufficient lookahead.
         */
        Assert(scan[2] == match[2], "scan[2]?");
        scan++, match++;
        do {
        } while (*(ushf*)(scan+=2) == *(ushf*)(match+=2) &&
                 *(ushf*)(scan+=2) == *(ushf*)(match+=2) &&
                 *(ushf*)(scan+=2) == *(ushf*)(match+=2) &&
                 *(ushf*)(scan+=2) == *(ushf*)(match+=2) &&
                 scan < strend);
        /* The funny "do {}" generates better code on most compilers */

        /* Here, scan <= window+strstart+257 */
        Assert(scan <= s->window+(unsigned)(s->window_size-1), "wild scan");
        if (*scan == *match) scan++;

        len = (MAX_MATCH - 1) - (int)(strend-scan);
        scan = strend - (MAX_MATCH-1);

#else /* UNALIGNED_OK */

        if (match[best_len]   != scan_end  ||
            match[best_len-1] != scan_end1 ||
            *match            != *scan     ||
            *++match          != scan[1])      continue;

        /* The check at best_len-1 can be removed because it will be made
         * again later. (This heuristic is not always a win.)
         * It is not necessary to compare scan[2] and match[2] since they
         * are always equal when the other bytes match, given that
         * the hash keys are equal and that HASH_BITS >= 8.
         */
        scan += 2, match++;
        Assert(*scan == *match, "match[2]?");

        /* We check for insufficient lookahead only every 8th comparison;
         * the 256th check will be made at strstart+258.
         */
        do {
        } while (*++scan == *++match && *++scan == *++match &&
                 *++scan == *++match && *++scan == *++match &&
                 *++scan == *++match && *++scan == *++match &&
                 *++scan == *++match && *++scan == *++match &&
                 scan < strend);

        Assert(scan <= s->window+(unsigned)(s->window_size-1), "wild scan");

        len = MAX_MATCH - (int)(strend - scan);
        scan = strend - MAX_MATCH;

#endif /* UNALIGNED_OK */

        if (len > best_len) {
            s->match_start = cur_match;
            best_len = len;
            if (len >= nice_match) break;
#ifdef UNALIGNED_OK
            scan_end = *(ushf*)(scan+best_len-1);
#else
            scan_end1  = scan[best_len-1];
            scan_end   = scan[best_len];
#endif
        }
    } while ((cur_match = prev[cur_match & wmask]) > limit
             && --chain_length != 0);

    if ((uInt)best_len <= s->lookahead) return (uInt)best_len;
    return s->lookahead;
}
#endif /* ASMV */

#else /* FASTEST */

/* ---------------------------------------------------------------------------
 * Optimized version for FASTEST only
 */
local uInt longest_match(s, cur_match)
    deflate_state *s;
    IPos cur_match;                             /* current match */
{
    register Bytef *scan = s->window + s->strstart; /* current string */
    register Bytef *match;                       /* matched string */
    register int len;                           /* length of current match */
    register Bytef *strend = s->window + s->strstart + MAX_MATCH;

    /* The code is optimized for HASH_BITS >= 8 and MAX_MATCH-2 multiple of 16.
     * It is easy to get rid of this optimization if necessary.
     */
    Assert(s->hash_bits >= 8 && MAX_MATCH == 258, "Code too clever");

    Assert((ulg)s->strstart <= s->window_size-MIN_LOOKAHEAD, "need lookahead");

    Assert(cur_match < s->strstart, "no future");

    match = s->window + cur_match;

    /* Return failure if the match length is less than 2:
     */
    if (match[0] != scan[0] || match[1] != scan[1]) return MIN_MATCH-1;

    /* The check at best_len-1 can be removed because it will be made
     * again later. (This heuristic is not always a win.)
     * It is not necessary to compare scan[2] and match[2] since they
     * are always equal when the other bytes match, given that
     * the hash keys are equal and that HASH_BITS >= 8.
     */
    scan += 2, match += 2;
    Assert(*scan == *match, "match[2]?");

    /* We check for insufficient lookahead only every 8th comparison;
     * the 256th check will be made at strstart+258.
     */
    do {
    } while (*++scan == *++match && *++scan == *++match &&
             *++scan == *++match && *++scan == *++match &&
             *++scan == *++match && *++scan == *++match &&
             *++scan == *++match && *++scan == *++match &&
             scan < strend);

    Assert(scan <= s->window+(unsigned)(s->window_size-1), "wild scan");

    len = MAX_MATCH - (int)(strend - scan);

    if (len < MIN_MATCH) return MIN_MATCH - 1;

    s->match_start = cur_match;
    return (uInt)len <= s->lookahead ? (uInt)len : s->lookahead;
}

#endif /* FASTEST */

#ifdef DEBUG
/* ===========================================================================
 * Check that the match at match_start is indeed a match.
 */
local void check_match(s, start, match, length)
    deflate_state *s;
    IPos start, match;
    int length;
{
    /* check that the match is indeed a match */
    if (zmemcmp(s->window + match,
                s->window + start, length) != EQUAL) {
        fprintf(stderr, " start %u, match %u, length %d\n",
                start, match, length);
        do {
            fprintf(stderr, "%c%c", s->window[match++], s->window[start++]);
        } while (--length != 0);
        z_error("invalid match");
    }
    if (z_verbose > 1) {
        fprintf(stderr,"\\[%d,%d]", start-match, length);
        do { putc(s->window[start++], stderr); } while (--length != 0);
    }
}
#else
#  define check_match(s, start, match, length)
#endif /* DEBUG */

/* ===========================================================================
 * Fill the window when the lookahead becomes insufficient.
 * Updates strstart and lookahead.
 *
 * IN assertion: lookahead < MIN_LOOKAHEAD
 * OUT assertions: strstart <= window_size-MIN_LOOKAHEAD
 *    At least one byte has been read, or avail_in == 0; reads are
 *    performed for at least two bytes (required for the zip translate_eol
 *    option -- not supported here).
 */
local void fill_window(s)
    deflate_state *s;
{
    register unsigned n, m;
    register Posf *p;
    unsigned more;    /* Amount of free space at the end of the window. */
    uInt wsize = s->w_size;

    Assert(s->lookahead < MIN_LOOKAHEAD, "already enough lookahead");

    do {
        more = (unsigned)(s->window_size -(ulg)s->lookahead -(ulg)s->strstart);

        /* Deal with !@#$% 64K limit: */
        if (sizeof(int) <= 2) {
            if (more == 0 && s->strstart == 0 && s->lookahead == 0) {
                more = wsize;

            } else if (more == (unsigned)(-1)) {
                /* Very unlikely, but possible on 16 bit machine if
                 * strstart == 0 && lookahead == 1 (input done a byte at time)
                 */
                more--;
            }
        }

        /* If the window is almost full and there is insufficient lookahead,
         * move the upper half to the lower one to make room in the upper half.
         */
        if (s->strstart >= wsize+MAX_DIST(s)) {

            zmemcpy(s->window, s->window+wsize, (unsigned)wsize);
            s->match_start -= wsize;
            s->strstart    -= wsize; /* we now have strstart >= MAX_DIST */
            s->block_start -= (long) wsize;

            /* Slide the hash table (could be avoided with 32 bit values
               at the expense of memory usage). We slide even when level == 0
               to keep the hash table consistent if we switch back to level > 0
               later. (Using level 0 permanently is not an optimal usage of
               zlib, so we don't care about this pathological case.)
             */
            n = s->hash_size;
            p = &s->head[n];
            do {
                m = *--p;
                *p = (Pos)(m >= wsize ? m-wsize : NIL);
            } while (--n);

            n = wsize;
#ifndef FASTEST
            p = &s->prev[n];
            do {
                m = *--p;
                *p = (Pos)(m >= wsize ? m-wsize : NIL);
                /* If n is not on any hash chain, prev[n] is garbage but
                 * its value will never be used.
                 */
            } while (--n);
#endif
            more += wsize;
        }
        if (s->strm->avail_in == 0) break;

        /* If there was no sliding:
         *    strstart <= WSIZE+MAX_DIST-1 && lookahead <= MIN_LOOKAHEAD - 1 &&
         *    more == window_size - lookahead - strstart
         * => more >= window_size - (MIN_LOOKAHEAD-1 + WSIZE + MAX_DIST-1)
         * => more >= window_size - 2*WSIZE + 2
         * In the BIG_MEM or MMAP case (not yet supported),
         *   window_size == input_size + MIN_LOOKAHEAD  &&
         *   strstart + s->lookahead <= input_size => more >= MIN_LOOKAHEAD.
         * Otherwise, window_size == 2*WSIZE so more >= 2.
         * If there was sliding, more >= WSIZE. So in all cases, more >= 2.
         */
        Assert(more >= 2, "more < 2");

        n = read_buf(s->strm, s->window + s->strstart + s->lookahead, more);
        s->lookahead += n;

        /* Initialize the hash value now that we have some input: */
        if (s->lookahead + s->insert >= MIN_MATCH) {
            uInt str = s->strstart - s->insert;
            s->ins_h = s->window[str];
            UPDATE_HASH(s, s->ins_h, s->window[str + 1]);
#if MIN_MATCH != 3
            Call UPDATE_HASH() MIN_MATCH-3 more times
#endif
            while (s->insert) {
                UPDATE_HASH(s, s->ins_h, s->window[str + MIN_MATCH-1]);
#ifndef FASTEST
                s->prev[str & s->w_mask] = s->head[s->ins_h];
#endif
                s->head[s->ins_h] = (Pos)str;
                str++;
                s->insert--;
                if (s->lookahead + s->insert < MIN_MATCH)
                    break;
            }
        }
        /* If the whole input has less than MIN_MATCH bytes, ins_h is garbage,
         * but this is not important since only literal bytes will be emitted.
         */

    } while (s->lookahead < MIN_LOOKAHEAD && s->strm->avail_in != 0);

    /* If the WIN_INIT bytes after the end of the current data have never been
     * written, then zero those bytes in order to avoid memory check reports of
     * the use of uninitialized (or uninitialised as Julian writes) bytes by
     * the longest match routines.  Update the high water mark for the next
     * time through here.  WIN_INIT is set to MAX_MATCH since the longest match
     * routines allow scanning to strstart + MAX_MATCH, ignoring lookahead.
     */
    if (s->high_water < s->window_size) {
        ulg curr = s->strstart + (ulg)(s->lookahead);
        ulg init;

        if (s->high_water < curr) {
            /* Previous high water mark below current data -- zero WIN_INIT
             * bytes or up to end of window, whichever is less.
             */
            init = s->window_size - curr;
            if (init > WIN_INIT)
                init = WIN_INIT;
            zmemzero(s->window + curr, (unsigned)init);
            s->high_water = curr + init;
        }
        else if (s->high_water < (ulg)curr + WIN_INIT) {
            /* High water mark at or above current data, but below current data
             * plus WIN_INIT -- zero out to current data plus WIN_INIT, or up
             * to end of window, whichever is less.
             */
            init = (ulg)curr + WIN_INIT - s->high_water;
            if (init > s->window_size - s->high_water)
                init = s->window_size - s->high_water;
            zmemzero(s->window + s->high_water, (unsigned)init);
            s->high_water += init;
        }
    }

    Assert((ulg)s->strstart <= s->window_size - MIN_LOOKAHEAD,
           "not enough room for search");
}

/* ===========================================================================
 * Flush the current block, with given end-of-file flag.
 * IN assertion: strstart is set to the end of the current match.
 */
#define FLUSH_BLOCK_ONLY(s, last) { \
   _tr_flush_block(s, (s->block_start >= 0L ? \
                   (charf *)&s->window[(unsigned)s->block_start] : \
                   (charf *)Z_NULL), \
                (ulg)((long)s->strstart - s->block_start), \
                (last)); \
   s->block_start = s->strstart; \
   flush_pending(s->strm); \
   Tracev((stderr,"[FLUSH]")); \
}

/* Same but force premature exit if necessary. */
#define FLUSH_BLOCK(s, last) { \
   FLUSH_BLOCK_ONLY(s, last); \
   if (s->strm->avail_out == 0) return (last) ? finish_started : need_more; \
}

/* ===========================================================================
 * Copy without compression as much as possible from the input stream, return
 * the current block state.
 * This function does not insert new strings in the dictionary since
 * uncompressible data is probably not useful. This function is used
 * only for the level=0 compression option.
 * NOTE: this function should be optimized to avoid extra copying from
 * window to pending_buf.
 */
local block_state deflate_stored(s, flush)
    deflate_state *s;
    int flush;
{
    /* Stored blocks are limited to 0xffff bytes, pending_buf is limited
     * to pending_buf_size, and each stored block has a 5 byte header:
     */
    ulg max_block_size = 0xffff;
    ulg max_start;

    if (max_block_size > s->pending_buf_size - 5) {
        max_block_size = s->pending_buf_size - 5;
    }

    /* Copy as much as possible from input to output: */
    for (;;) {
        /* Fill the window as much as possible: */
        if (s->lookahead <= 1) {

            Assert(s->strstart < s->w_size+MAX_DIST(s) ||
                   s->block_start >= (long)s->w_size, "slide too late");

            fill_window(s);
            if (s->lookahead == 0 && flush == Z_NO_FLUSH) return need_more;

            if (s->lookahead == 0) break; /* flush the current block */
        }
        Assert(s->block_start >= 0L, "block gone");

        s->strstart += s->lookahead;
        s->lookahead = 0;

        /* Emit a stored block if pending_buf will be full: */
        max_start = s->block_start + max_block_size;
        if (s->strstart == 0 || (ulg)s->strstart >= max_start) {
            /* strstart == 0 is possible when wraparound on 16-bit machine */
            s->lookahead = (uInt)(s->strstart - max_start);
            s->strstart = (uInt)max_start;
            FLUSH_BLOCK(s, 0);
        }
        /* Flush if we may have to slide, otherwise block_start may become
         * negative and the data will be gone:
         */
        if (s->strstart - (uInt)s->block_start >= MAX_DIST(s)) {
            FLUSH_BLOCK(s, 0);
        }
    }
    s->insert = 0;
    if (flush == Z_FINISH) {
        FLUSH_BLOCK(s, 1);
        return finish_done;
    }
    if ((long)s->strstart > s->block_start)
        FLUSH_BLOCK(s, 0);
    return block_done;
}

/* ===========================================================================
 * Compress as much as possible from the input stream, return the current
 * block state.
 * This function does not perform lazy evaluation of matches and inserts
 * new strings in the dictionary only for unmatched strings or for short
 * matches. It is used only for the fast compression options.
 */
local block_state deflate_fast(s, flush)
    deflate_state *s;
    int flush;
{
    IPos hash_head;       /* head of the hash chain */
    int bflush;           /* set if current block must be flushed */

    for (;;) {
        /* Make sure that we always have enough lookahead, except
         * at the end of the input file. We need MAX_MATCH bytes
         * for the next match, plus MIN_MATCH bytes to insert the
         * string following the next match.
         */
        if (s->lookahead < MIN_LOOKAHEAD) {
            fill_window(s);
            if (s->lookahead < MIN_LOOKAHEAD && flush == Z_NO_FLUSH) {
                return need_more;
            }
            if (s->lookahead == 0) break; /* flush the current block */
        }

        /* Insert the string window[strstart .. strstart+2] in the
         * dictionary, and set hash_head to the head of the hash chain:
         */
        hash_head = NIL;
        if (s->lookahead >= MIN_MATCH) {
            INSERT_STRING(s, s->strstart, hash_head);
        }

        /* Find the longest match, discarding those <= prev_length.
         * At this point we have always match_length < MIN_MATCH
         */
        if (hash_head != NIL && s->strstart - hash_head <= MAX_DIST(s)) {
            /* To simplify the code, we prevent matches with the string
             * of window index 0 (in particular we have to avoid a match
             * of the string with itself at the start of the input file).
             */
            s->match_length = longest_match (s, hash_head);
            /* longest_match() sets match_start */
        }
        if (s->match_length >= MIN_MATCH) {
            check_match(s, s->strstart, s->match_start, s->match_length);

            _tr_tally_dist(s, s->strstart - s->match_start,
                           s->match_length - MIN_MATCH, bflush);

            s->lookahead -= s->match_length;

            /* Insert new strings in the hash table only if the match length
             * is not too large. This saves time but degrades compression.
             */
#ifndef FASTEST
            if (s->match_length <= s->max_insert_length &&
                s->lookahead >= MIN_MATCH) {
                s->match_length--; /* string at strstart already in table */
                do {
                    s->strstart++;
                    INSERT_STRING(s, s->strstart, hash_head);
                    /* strstart never exceeds WSIZE-MAX_MATCH, so there are
                     * always MIN_MATCH bytes ahead.
                     */
                } while (--s->match_length != 0);
                s->strstart++;
            } else
#endif
            {
                s->strstart += s->match_length;
                s->match_length = 0;
                s->ins_h = s->window[s->strstart];
                UPDATE_HASH(s, s->ins_h, s->window[s->strstart+1]);
#if MIN_MATCH != 3
                Call UPDATE_HASH() MIN_MATCH-3 more times
#endif
                /* If lookahead < MIN_MATCH, ins_h is garbage, but it does not
                 * matter since it will be recomputed at next deflate call.
                 */
            }
        } else {
            /* No match, output a literal byte */
            Tracevv((stderr,"%c", s->window[s->strstart]));
            _tr_tally_lit (s, s->window[s->strstart], bflush);
            s->lookahead--;
            s->strstart++;
        }
        if (bflush) FLUSH_BLOCK(s, 0);
    }
    s->insert = s->strstart < MIN_MATCH-1 ? s->strstart : MIN_MATCH-1;
    if (flush == Z_FINISH) {
        FLUSH_BLOCK(s, 1);
        return finish_done;
    }
    if (s->last_lit)
        FLUSH_BLOCK(s, 0);
    return block_done;
}

#ifndef FASTEST
/* ===========================================================================
 * Same as above, but achieves better compression. We use a lazy
 * evaluation for matches: a match is finally adopted only if there is
 * no better match at the next window position.
 */
local block_state deflate_slow(s, flush)
    deflate_state *s;
    int flush;
{
    IPos hash_head;          /* head of hash chain */
    int bflush;              /* set if current block must be flushed */

    /* Process the input block. */
    for (;;) {
        /* Make sure that we always have enough lookahead, except
         * at the end of the input file. We need MAX_MATCH bytes
         * for the next match, plus MIN_MATCH bytes to insert the
         * string following the next match.
         */
        if (s->lookahead < MIN_LOOKAHEAD) {
            fill_window(s);
            if (s->lookahead < MIN_LOOKAHEAD && flush == Z_NO_FLUSH) {
                return need_more;
            }
            if (s->lookahead == 0) break; /* flush the current block */
        }

        /* Insert the string window[strstart .. strstart+2] in the
         * dictionary, and set hash_head to the head of the hash chain:
         */
        hash_head = NIL;
        if (s->lookahead >= MIN_MATCH) {
            INSERT_STRING(s, s->strstart, hash_head);
        }

        /* Find the longest match, discarding those <= prev_length.
         */
        s->prev_length = s->match_length, s->prev_match = s->match_start;
        s->match_length = MIN_MATCH-1;

        if (hash_head != NIL && s->prev_length < s->max_lazy_match &&
            s->strstart - hash_head <= MAX_DIST(s)) {
            /* To simplify the code, we prevent matches with the string
             * of window index 0 (in particular we have to avoid a match
             * of the string with itself at the start of the input file).
             */
            s->match_length = longest_match (s, hash_head);
            /* longest_match() sets match_start */

            if (s->match_length <= 5 && (s->strategy == Z_FILTERED
#if TOO_FAR <= 32767
                || (s->match_length == MIN_MATCH &&
                    s->strstart - s->match_start > TOO_FAR)
#endif
                )) {

                /* If prev_match is also MIN_MATCH, match_start is garbage
                 * but we will ignore the current match anyway.
                 */
                s->match_length = MIN_MATCH-1;
            }
        }
        /* If there was a match at the previous step and the current
         * match is not better, output the previous match:
         */
        if (s->prev_length >= MIN_MATCH && s->match_length <= s->prev_length) {
            uInt max_insert = s->strstart + s->lookahead - MIN_MATCH;
            /* Do not insert strings in hash table beyond this. */

            check_match(s, s->strstart-1, s->prev_match, s->prev_length);

            _tr_tally_dist(s, s->strstart -1 - s->prev_match,
                           s->prev_length - MIN_MATCH, bflush);

            /* Insert in hash table all strings up to the end of the match.
             * strstart-1 and strstart are already inserted. If there is not
             * enough lookahead, the last two strings are not inserted in
             * the hash table.
             */
            s->lookahead -= s->prev_length-1;
            s->prev_length -= 2;
            do {
                if (++s->strstart <= max_insert) {
                    INSERT_STRING(s, s->strstart, hash_head);
                }
            } while (--s->prev_length != 0);
            s->match_available = 0;
            s->match_length = MIN_MATCH-1;
            s->strstart++;

            if (bflush) FLUSH_BLOCK(s, 0);

        } else if (s->match_available) {
            /* If there was no match at the previous position, output a
             * single literal. If there was a match but the current match
             * is longer, truncate the previous match to a single literal.
             */
            Tracevv((stderr,"%c", s->window[s->strstart-1]));
            _tr_tally_lit(s, s->window[s->strstart-1], bflush);
            if (bflush) {
                FLUSH_BLOCK_ONLY(s, 0);
            }
            s->strstart++;
            s->lookahead--;
            if (s->strm->avail_out == 0) return need_more;
        } else {
            /* There is no previous match to compare with, wait for
             * the next step to decide.
             */
            s->match_available = 1;
            s->strstart++;
            s->lookahead--;
        }
    }
    Assert (flush != Z_NO_FLUSH, "no flush?");
    if (s->match_available) {
        Tracevv((stderr,"%c", s->window[s->strstart-1]));
        _tr_tally_lit(s, s->window[s->strstart-1], bflush);
        s->match_available = 0;
    }
    s->insert = s->strstart < MIN_MATCH-1 ? s->strstart : MIN_MATCH-1;
    if (flush == Z_FINISH) {
        FLUSH_BLOCK(s, 1);
        return finish_done;
    }
    if (s->last_lit)
        FLUSH_BLOCK(s, 0);
    return block_done;
}
#endif /* FASTEST */

/* ===========================================================================
 * For Z_RLE, simply look for runs of bytes, generate matches only of distance
 * one.  Do not maintain a hash table.  (It will be regenerated if this run of
 * deflate switches away from Z_RLE.)
 */
local block_state deflate_rle(s, flush)
    deflate_state *s;
    int flush;
{
    int bflush;             /* set if current block must be flushed */
    uInt prev;              /* byte at distance one to match */
    Bytef *scan, *strend;   /* scan goes up to strend for length of run */

    for (;;) {
        /* Make sure that we always have enough lookahead, except
         * at the end of the input file. We need MAX_MATCH bytes
         * for the longest run, plus one for the unrolled loop.
         */
        if (s->lookahead <= MAX_MATCH) {
            fill_window(s);
            if (s->lookahead <= MAX_MATCH && flush == Z_NO_FLUSH) {
                return need_more;
            }
            if (s->lookahead == 0) break; /* flush the current block */
        }

        /* See how many times the previous byte repeats */
        s->match_length = 0;
        if (s->lookahead >= MIN_MATCH && s->strstart > 0) {
            scan = s->window + s->strstart - 1;
            prev = *scan;
            if (prev == *++scan && prev == *++scan && prev == *++scan) {
                strend = s->window + s->strstart + MAX_MATCH;
                do {
                } while (prev == *++scan && prev == *++scan &&
                         prev == *++scan && prev == *++scan &&
                         prev == *++scan && prev == *++scan &&
                         prev == *++scan && prev == *++scan &&
                         scan < strend);
                s->match_length = MAX_MATCH - (int)(strend - scan);
                if (s->match_length > s->lookahead)
                    s->match_length = s->lookahead;
            }
            Assert(scan <= s->window+(uInt)(s->window_size-1), "wild scan");
        }

        /* Emit match if have run of MIN_MATCH or longer, else emit literal */
        if (s->match_length >= MIN_MATCH) {
            check_match(s, s->strstart, s->strstart - 1, s->match_length);

            _tr_tally_dist(s, 1, s->match_length - MIN_MATCH, bflush);

            s->lookahead -= s->match_length;
            s->strstart += s->match_length;
            s->match_length = 0;
        } else {
            /* No match, output a literal byte */
            Tracevv((stderr,"%c", s->window[s->strstart]));
            _tr_tally_lit (s, s->window[s->strstart], bflush);
            s->lookahead--;
            s->strstart++;
        }
        if (bflush) FLUSH_BLOCK(s, 0);
    }
    s->insert = 0;
    if (flush == Z_FINISH) {
        FLUSH_BLOCK(s, 1);
        return finish_done;
    }
    if (s->last_lit)
        FLUSH_BLOCK(s, 0);
    return block_done;
}

/* ===========================================================================
 * For Z_HUFFMAN_ONLY, do not look for matches.  Do not maintain a hash table.
 * (It will be regenerated if this run of deflate switches away from Huffman.)
 */
local block_state deflate_huff(s, flush)
    deflate_state *s;
    int flush;
{
    int bflush;             /* set if current block must be flushed */

    for (;;) {
        /* Make sure that we have a literal to write. */
        if (s->lookahead == 0) {
            fill_window(s);
            if (s->lookahead == 0) {
                if (flush == Z_NO_FLUSH)
                    return need_more;
                break;      /* flush the current block */
            }
        }

        /* Output a literal byte */
        s->match_length = 0;
        Tracevv((stderr,"%c", s->window[s->strstart]));
        _tr_tally_lit (s, s->window[s->strstart], bflush);
        s->lookahead--;
        s->strstart++;
        if (bflush) FLUSH_BLOCK(s, 0);
    }
    s->insert = 0;
    if (flush == Z_FINISH) {
        FLUSH_BLOCK(s, 1);
        return finish_done;
    }
    if (s->last_lit)
        FLUSH_BLOCK(s, 0);
    return block_done;
}

/***********************************************************************
ZLIB\GZCLOSE.C
***********************************************************************/
/* gzclose.c -- zlib gzclose() function
 * Copyright (C) 2004, 2010 Mark Adler
 * For conditions of distribution and use, see copyright notice in zlib.h
 */


/* gzclose() is in a separate file so that it is linked in only if it is used.
   That way the other gzclose functions can be used instead to avoid linking in
   unneeded compression or decompression routines. */
int ZEXPORT gzclose(file)
    gzFile file;
{
#ifndef NO_GZCOMPRESS
    gz_statep state;

    if (file == NULL)
        return Z_STREAM_ERROR;
    state = (gz_statep)file;

    return state->mode == GZ_READ ? gzclose_r(file) : gzclose_w(file);
#else
    return gzclose_r(file);
#endif
}

/***********************************************************************
ZLIB\GZLIB.C
***********************************************************************/
/* gzlib.c -- zlib functions common to reading and writing gzip files
 * Copyright (C) 2004, 2010, 2011, 2012, 2013 Mark Adler
 * For conditions of distribution and use, see copyright notice in zlib.h
 */


#if defined(_WIN32) && !defined(__BORLANDC__)
#  define LSEEK _lseeki64
#else
#if defined(_LARGEFILE64_SOURCE) && _LFS64_LARGEFILE-0
#  define LSEEK lseek64
#else
#  define LSEEK lseek
#endif
#endif

/* Local functions */
local void gz_reset OF((gz_statep));
local gzFile gz_open OF((const void *, int, const char *));

#if defined UNDER_CE

/* Map the Windows error number in ERROR to a locale-dependent error message
   string and return a pointer to it.  Typically, the values for ERROR come
   from GetLastError.

   The string pointed to shall not be modified by the application, but may be
   overwritten by a subsequent call to gz_strwinerror

   The gz_strwinerror function does not change the current setting of
   GetLastError. */
char ZLIB_INTERNAL *gz_strwinerror (error)
     DWORD error;
{
    static char buf[1024];

    wchar_t *msgbuf;
    DWORD lasterr = GetLastError();
    DWORD chars = FormatMessage(FORMAT_MESSAGE_FROM_SYSTEM
        | FORMAT_MESSAGE_ALLOCATE_BUFFER,
        NULL,
        error,
        0, /* Default language */
        (LPVOID)&msgbuf,
        0,
        NULL);
    if (chars != 0) {
        /* If there is an \r\n appended, zap it.  */
        if (chars >= 2
            && msgbuf[chars - 2] == '\r' && msgbuf[chars - 1] == '\n') {
            chars -= 2;
            msgbuf[chars] = 0;
        }

        if (chars > sizeof (buf) - 1) {
            chars = sizeof (buf) - 1;
            msgbuf[chars] = 0;
        }

        wcstombs(buf, msgbuf, chars + 1);
        LocalFree(msgbuf);
    }
    else {
        sprintf(buf, "unknown win32 error (%ld)", error);
    }

    SetLastError(lasterr);
    return buf;
}

#endif /* UNDER_CE */

/* Reset gzip file state */
local void gz_reset(state)
    gz_statep state;
{
    state->x.have = 0;              /* no output data available */
    if (state->mode == GZ_READ) {   /* for reading ... */
        state->eof = 0;             /* not at end of file */
        state->past = 0;            /* have not read past end yet */
        state->how = LOOK;          /* look for gzip header */
    }
    state->seek = 0;                /* no seek request pending */
    gz_error(state, Z_OK, NULL);    /* clear error */
    state->x.pos = 0;               /* no uncompressed data yet */
    state->strm.avail_in = 0;       /* no input data yet */
}

/* Open a gzip file either by name or file descriptor. */
local gzFile gz_open(path, fd, mode)
    const void *path;
    int fd;
    const char *mode;
{
    gz_statep state;
    size_t len;
    int oflag;
#ifdef O_CLOEXEC
    int cloexec = 0;
#endif
#ifdef O_EXCL
    int exclusive = 0;
#endif

    /* check input */
    if (path == NULL)
        return NULL;

    /* allocate gzFile structure to return */
    state = (gz_statep)malloc(sizeof(gz_state));
    if (state == NULL)
        return NULL;
    state->size = 0;            /* no buffers allocated yet */
    state->want = GZBUFSIZE;    /* requested buffer size */
    state->msg = NULL;          /* no error message yet */

    /* interpret mode */
    state->mode = GZ_NONE;
    state->level = Z_DEFAULT_COMPRESSION;
    state->strategy = Z_DEFAULT_STRATEGY;
    state->direct = 0;
    while (*mode) {
        if (*mode >= '0' && *mode <= '9')
            state->level = *mode - '0';
        else
            switch (*mode) {
            case 'r':
                state->mode = GZ_READ;
                break;
#ifndef NO_GZCOMPRESS
            case 'w':
                state->mode = GZ_WRITE;
                break;
            case 'a':
                state->mode = GZ_APPEND;
                break;
#endif
            case '+':       /* can't read and write at the same time */
                free(state);
                return NULL;
            case 'b':       /* ignore -- will request binary anyway */
                break;
#ifdef O_CLOEXEC
            case 'e':
                cloexec = 1;
                break;
#endif
#ifdef O_EXCL
            case 'x':
                exclusive = 1;
                break;
#endif
            case 'f':
                state->strategy = Z_FILTERED;
                break;
            case 'h':
                state->strategy = Z_HUFFMAN_ONLY;
                break;
            case 'R':
                state->strategy = Z_RLE;
                break;
            case 'F':
                state->strategy = Z_FIXED;
                break;
            case 'T':
                state->direct = 1;
                break;
            default:        /* could consider as an error, but just ignore */
                ;
            }
        mode++;
    }

    /* must provide an "r", "w", or "a" */
    if (state->mode == GZ_NONE) {
        free(state);
        return NULL;
    }

    /* can't force transparent read */
    if (state->mode == GZ_READ) {
        if (state->direct) {
            free(state);
            return NULL;
        }
        state->direct = 1;      /* for empty file */
    }

    /* save the path name for error messages */
#ifdef _WIN32
    if (fd == -2) {
        len = wcstombs(NULL, path, 0);
        if (len == (size_t)-1)
            len = 0;
    }
    else
#endif
        len = strlen((const char *)path);
    state->path = (char *)malloc(len + 1);
    if (state->path == NULL) {
        free(state);
        return NULL;
    }
#ifdef _WIN32
    if (fd == -2)
        if (len)
            wcstombs(state->path, path, len + 1);
        else
            *(state->path) = 0;
    else
#endif
#if !defined(NO_snprintf) && !defined(NO_vsnprintf)
        snprintf(state->path, len + 1, "%s", (const char *)path);
#else
        strcpy(state->path, path);
#endif

    /* compute the flags for open() */
    oflag =
#ifdef O_LARGEFILE
        O_LARGEFILE |
#endif
#ifdef O_BINARY
        O_BINARY |
#endif
#ifdef O_CLOEXEC
        (cloexec ? O_CLOEXEC : 0) |
#endif
        (state->mode == GZ_READ ?
         O_RDONLY :
         (O_WRONLY | O_CREAT |
#ifdef O_EXCL
          (exclusive ? O_EXCL : 0) |
#endif
          (state->mode == GZ_WRITE ?
           O_TRUNC :
           O_APPEND)));

    /* open the file with the appropriate flags (or just use fd) */
    state->fd = fd > -1 ? fd : (
#ifdef _WIN32
        fd == -2 ? _wopen(path, oflag, 0666) :
#endif
        _open((const char *)path, oflag, 0666));
    if (state->fd == -1) {
        free(state->path);
        free(state);
        return NULL;
    }
    if (state->mode == GZ_APPEND)
        state->mode = GZ_WRITE;         /* simplify later checks */

    /* save the current position for rewinding (only if reading) */
    if (state->mode == GZ_READ) {
        state->start = LSEEK(state->fd, 0, SEEK_CUR);
        if (state->start == -1) state->start = 0;
    }

    /* initialize stream */
    gz_reset(state);

    /* return stream */
    return (gzFile)state;
}

/* -- see zlib.h -- */
gzFile ZEXPORT gzopen(path, mode)
    const char *path;
    const char *mode;
{
    return gz_open(path, -1, mode);
}

/* -- see zlib.h -- */
gzFile ZEXPORT gzopen64(path, mode)
    const char *path;
    const char *mode;
{
    return gz_open(path, -1, mode);
}

/* -- see zlib.h -- */
gzFile ZEXPORT gzdopen(fd, mode)
    int fd;
    const char *mode;
{
    char *path;         /* identifier for error messages */
    gzFile gz;

    if (fd == -1 || (path = (char *)malloc(7 + 3 * sizeof(int))) == NULL)
        return NULL;
#if !defined(NO_snprintf) && !defined(NO_vsnprintf)
    snprintf(path, 7 + 3 * sizeof(int), "<fd:%d>", fd); /* for debugging */
#else
    sprintf(path, "<fd:%d>", fd);   /* for debugging */
#endif
    gz = gz_open(path, fd, mode);
    free(path);
    return gz;
}

/* -- see zlib.h -- */
#ifdef _WIN32
gzFile ZEXPORT gzopen_w(path, mode)
    const wchar_t *path;
    const char *mode;
{
    return gz_open(path, -2, mode);
}
#endif

/* -- see zlib.h -- */
int ZEXPORT gzbuffer(file, size)
    gzFile file;
    unsigned size;
{
    gz_statep state;

    /* get internal structure and check integrity */
    if (file == NULL)
        return -1;
    state = (gz_statep)file;
    if (state->mode != GZ_READ && state->mode != GZ_WRITE)
        return -1;

    /* make sure we haven't already allocated memory */
    if (state->size != 0)
        return -1;

    /* check and set requested size */
    if (size < 2)
        size = 2;               /* need two bytes to check magic header */
    state->want = size;
    return 0;
}

/* -- see zlib.h -- */
int ZEXPORT gzrewind(file)
    gzFile file;
{
    gz_statep state;

    /* get internal structure */
    if (file == NULL)
        return -1;
    state = (gz_statep)file;

    /* check that we're reading and that there's no error */
    if (state->mode != GZ_READ ||
            (state->err != Z_OK && state->err != Z_BUF_ERROR))
        return -1;

    /* back up and start over */
    if (LSEEK(state->fd, state->start, SEEK_SET) == -1)
        return -1;
    gz_reset(state);
    return 0;
}

/* -- see zlib.h -- */
z_off64_t ZEXPORT gzseek64(file, offset, whence)
    gzFile file;
    z_off64_t offset;
    int whence;
{
    unsigned n;
    z_off64_t ret;
    gz_statep state;

    /* get internal structure and check integrity */
    if (file == NULL)
        return -1;
    state = (gz_statep)file;
    if (state->mode != GZ_READ && state->mode != GZ_WRITE)
        return -1;

    /* check that there's no error */
    if (state->err != Z_OK && state->err != Z_BUF_ERROR)
        return -1;

    /* can only seek from start or relative to current position */
    if (whence != SEEK_SET && whence != SEEK_CUR)
        return -1;

    /* normalize offset to a SEEK_CUR specification */
    if (whence == SEEK_SET)
        offset -= state->x.pos;
    else if (state->seek)
        offset += state->skip;
    state->seek = 0;

    /* if within raw area while reading, just go there */
    if (state->mode == GZ_READ && state->how == COPY &&
            state->x.pos + offset >= 0) {
        ret = LSEEK(state->fd, offset - state->x.have, SEEK_CUR);
        if (ret == -1)
            return -1;
        state->x.have = 0;
        state->eof = 0;
        state->past = 0;
        state->seek = 0;
        gz_error(state, Z_OK, NULL);
        state->strm.avail_in = 0;
        state->x.pos += offset;
        return state->x.pos;
    }

    /* calculate skip amount, rewinding if needed for back seek when reading */
    if (offset < 0) {
        if (state->mode != GZ_READ)         /* writing -- can't go backwards */
            return -1;
        offset += state->x.pos;
        if (offset < 0)                     /* before start of file! */
            return -1;
        if (gzrewind(file) == -1)           /* rewind, then skip to offset */
            return -1;
    }

    /* if reading, skip what's in output buffer (one less gzgetc() check) */
    if (state->mode == GZ_READ) {
        n = GT_OFF(state->x.have) || (z_off64_t)state->x.have > offset ?
            (unsigned)offset : state->x.have;
        state->x.have -= n;
        state->x.next += n;
        state->x.pos += n;
        offset -= n;
    }

    /* request skip (if not zero) */
    if (offset) {
        state->seek = 1;
        state->skip = offset;
    }
    return state->x.pos + offset;
}

/* -- see zlib.h -- */
z_off_t ZEXPORT gzseek(file, offset, whence)
    gzFile file;
    z_off_t offset;
    int whence;
{
    z_off64_t ret;

    ret = gzseek64(file, (z_off64_t)offset, whence);
    return ret == (z_off_t)ret ? (z_off_t)ret : -1;
}

/* -- see zlib.h -- */
z_off64_t ZEXPORT gztell64(file)
    gzFile file;
{
    gz_statep state;

    /* get internal structure and check integrity */
    if (file == NULL)
        return -1;
    state = (gz_statep)file;
    if (state->mode != GZ_READ && state->mode != GZ_WRITE)
        return -1;

    /* return position */
    return state->x.pos + (state->seek ? state->skip : 0);
}

/* -- see zlib.h -- */
z_off_t ZEXPORT gztell(file)
    gzFile file;
{
    z_off64_t ret;

    ret = gztell64(file);
    return ret == (z_off_t)ret ? (z_off_t)ret : -1;
}

/* -- see zlib.h -- */
z_off64_t ZEXPORT gzoffset64(file)
    gzFile file;
{
    z_off64_t offset;
    gz_statep state;

    /* get internal structure and check integrity */
    if (file == NULL)
        return -1;
    state = (gz_statep)file;
    if (state->mode != GZ_READ && state->mode != GZ_WRITE)
        return -1;

    /* compute and return effective offset in file */
    offset = LSEEK(state->fd, 0, SEEK_CUR);
    if (offset == -1)
        return -1;
    if (state->mode == GZ_READ)             /* reading */
        offset -= state->strm.avail_in;     /* don't count buffered input */
    return offset;
}

/* -- see zlib.h -- */
z_off_t ZEXPORT gzoffset(file)
    gzFile file;
{
    z_off64_t ret;

    ret = gzoffset64(file);
    return ret == (z_off_t)ret ? (z_off_t)ret : -1;
}

/* -- see zlib.h -- */
int ZEXPORT gzeof(file)
    gzFile file;
{
    gz_statep state;

    /* get internal structure and check integrity */
    if (file == NULL)
        return 0;
    state = (gz_statep)file;
    if (state->mode != GZ_READ && state->mode != GZ_WRITE)
        return 0;

    /* return end-of-file state */
    return state->mode == GZ_READ ? state->past : 0;
}

/* -- see zlib.h -- */
const char * ZEXPORT gzerror(file, errnum)
    gzFile file;
    int *errnum;
{
    gz_statep state;

    /* get internal structure and check integrity */
    if (file == NULL)
        return NULL;
    state = (gz_statep)file;
    if (state->mode != GZ_READ && state->mode != GZ_WRITE)
        return NULL;

    /* return error information */
    if (errnum != NULL)
        *errnum = state->err;
    return state->err == Z_MEM_ERROR ? "out of memory" :
                                       (state->msg == NULL ? "" : state->msg);
}

/* -- see zlib.h -- */
void ZEXPORT gzclearerr(file)
    gzFile file;
{
    gz_statep state;

    /* get internal structure and check integrity */
    if (file == NULL)
        return;
    state = (gz_statep)file;
    if (state->mode != GZ_READ && state->mode != GZ_WRITE)
        return;

    /* clear error and end-of-file */
    if (state->mode == GZ_READ) {
        state->eof = 0;
        state->past = 0;
    }
    gz_error(state, Z_OK, NULL);
}

/* Create an error message in allocated memory and set state->err and
   state->msg accordingly.  Free any previous error message already there.  Do
   not try to free or allocate space if the error is Z_MEM_ERROR (out of
   memory).  Simply save the error message as a static string.  If there is an
   allocation failure constructing the error message, then convert the error to
   out of memory. */
void ZLIB_INTERNAL gz_error(state, err, msg)
    gz_statep state;
    int err;
    const char *msg;
{
    /* free previously allocated message and clear */
    if (state->msg != NULL) {
        if (state->err != Z_MEM_ERROR)
            free(state->msg);
        state->msg = NULL;
    }

    /* if fatal, set state->x.have to 0 so that the gzgetc() macro fails */
    if (err != Z_OK && err != Z_BUF_ERROR)
        state->x.have = 0;

    /* set error code, and if no message, then done */
    state->err = err;
    if (msg == NULL)
        return;

    /* for an out of memory error, return literal string when requested */
    if (err == Z_MEM_ERROR)
        return;

    /* construct error message with path */
    if ((state->msg = (char *)malloc(strlen(state->path) + strlen(msg) + 3)) ==
            NULL) {
        state->err = Z_MEM_ERROR;
        return;
    }
#if !defined(NO_snprintf) && !defined(NO_vsnprintf)
    snprintf(state->msg, strlen(state->path) + strlen(msg) + 3,
             "%s%s%s", state->path, ": ", msg);
#else
    strcpy(state->msg, state->path);
    strcat(state->msg, ": ");
    strcat(state->msg, msg);
#endif
    return;
}

#ifndef INT_MAX
/* portably return maximum value for an int (when limits.h presumed not
   available) -- we need to do this to cover cases where 2's complement not
   used, since C standard permits 1's complement and sign-bit representations,
   otherwise we could just use ((unsigned)-1) >> 1 */
unsigned ZLIB_INTERNAL gz_intmax()
{
    unsigned p, q;

    p = 1;
    do {
        q = p;
        p <<= 1;
        p++;
    } while (p > q);
    return q >> 1;
}
#endif

/***********************************************************************
ZLIB\GZREAD.C
***********************************************************************/
/* gzread.c -- zlib functions for reading gzip files
 * Copyright (C) 2004, 2005, 2010, 2011, 2012, 2013 Mark Adler
 * For conditions of distribution and use, see copyright notice in zlib.h
 */


/* Local functions */
local int gz_load OF((gz_statep, unsigned char *, unsigned, unsigned *));
local int gz_avail OF((gz_statep));
local int gz_look OF((gz_statep));
local int gz_decomp OF((gz_statep));
local int gz_fetch OF((gz_statep));
local int gz_skip OF((gz_statep, z_off64_t));

/* Use read() to load a buffer -- return -1 on error, otherwise 0.  Read from
   state->fd, and update state->eof, state->err, and state->msg as appropriate.
   This function needs to loop on read(), since read() is not guaranteed to
   read the number of bytes requested, depending on the type of descriptor. */
local int gz_load(state, buf, len, have)
    gz_statep state;
    unsigned char *buf;
    unsigned len;
    unsigned *have;
{
    int ret;

    *have = 0;
    do {
        ret = _read(state->fd, buf + *have, len - *have);
        if (ret <= 0)
            break;
        *have += ret;
    } while (*have < len);
    if (ret < 0) {
        gz_error(state, Z_ERRNO, zstrerror());
        return -1;
    }
    if (ret == 0)
        state->eof = 1;
    return 0;
}

/* Load up input buffer and set eof flag if last data loaded -- return -1 on
   error, 0 otherwise.  Note that the eof flag is set when the end of the input
   file is reached, even though there may be unused data in the buffer.  Once
   that data has been used, no more attempts will be made to read the file.
   If strm->avail_in != 0, then the current data is moved to the beginning of
   the input buffer, and then the remainder of the buffer is loaded with the
   available data from the input file. */
local int gz_avail(state)
    gz_statep state;
{
    unsigned got;
    z_streamp strm = &(state->strm);

    if (state->err != Z_OK && state->err != Z_BUF_ERROR)
        return -1;
    if (state->eof == 0) {
        if (strm->avail_in) {       /* copy what's there to the start */
            unsigned char *p = state->in;
            unsigned const char *q = strm->next_in;
            unsigned n = strm->avail_in;
            do {
                *p++ = *q++;
            } while (--n);
        }
        if (gz_load(state, state->in + strm->avail_in,
                    state->size - strm->avail_in, &got) == -1)
            return -1;
        strm->avail_in += got;
        strm->next_in = state->in;
    }
    return 0;
}

/* Look for gzip header, set up for inflate or copy.  state->x.have must be 0.
   If this is the first time in, allocate required memory.  state->how will be
   left unchanged if there is no more input data available, will be set to COPY
   if there is no gzip header and direct copying will be performed, or it will
   be set to GZIP for decompression.  If direct copying, then leftover input
   data from the input buffer will be copied to the output buffer.  In that
   case, all further file reads will be directly to either the output buffer or
   a user buffer.  If decompressing, the inflate state will be initialized.
   gz_look() will return 0 on success or -1 on failure. */
local int gz_look(state)
    gz_statep state;
{
    z_streamp strm = &(state->strm);

    /* allocate read buffers and inflate memory */
    if (state->size == 0) {
        /* allocate buffers */
        state->in = (unsigned char *)malloc(state->want);
        state->out = (unsigned char *)malloc(state->want << 1);
        if (state->in == NULL || state->out == NULL) {
            if (state->out != NULL)
                free(state->out);
            if (state->in != NULL)
                free(state->in);
            gz_error(state, Z_MEM_ERROR, "out of memory");
            return -1;
        }
        state->size = state->want;

        /* allocate inflate memory */
        state->strm.zalloc = Z_NULL;
        state->strm.zfree = Z_NULL;
        state->strm.opaque = Z_NULL;
        state->strm.avail_in = 0;
        state->strm.next_in = Z_NULL;
        if (inflateInit2(&(state->strm), 15 + 16) != Z_OK) {    /* gunzip */
            free(state->out);
            free(state->in);
            state->size = 0;
            gz_error(state, Z_MEM_ERROR, "out of memory");
            return -1;
        }
    }

    /* get at least the magic bytes in the input buffer */
    if (strm->avail_in < 2) {
        if (gz_avail(state) == -1)
            return -1;
        if (strm->avail_in == 0)
            return 0;
    }

    /* look for gzip magic bytes -- if there, do gzip decoding (note: there is
       a logical dilemma here when considering the case of a partially written
       gzip file, to wit, if a single 31 byte is written, then we cannot tell
       whether this is a single-byte file, or just a partially written gzip
       file -- for here we assume that if a gzip file is being written, then
       the header will be written in a single operation, so that reading a
       single byte is sufficient indication that it is not a gzip file) */
    if (strm->avail_in > 1 &&
            strm->next_in[0] == 31 && strm->next_in[1] == 139) {
        inflateReset(strm);
        state->how = GZIP;
        state->direct = 0;
        return 0;
    }

    /* no gzip header -- if we were decoding gzip before, then this is trailing
       garbage.  Ignore the trailing garbage and finish. */
    if (state->direct == 0) {
        strm->avail_in = 0;
        state->eof = 1;
        state->x.have = 0;
        return 0;
    }

    /* doing raw i/o, copy any leftover input to output -- this assumes that
       the output buffer is larger than the input buffer, which also assures
       space for gzungetc() */
    state->x.next = state->out;
    if (strm->avail_in) {
        memcpy(state->x.next, strm->next_in, strm->avail_in);
        state->x.have = strm->avail_in;
        strm->avail_in = 0;
    }
    state->how = COPY;
    state->direct = 1;
    return 0;
}

/* Decompress from input to the provided next_out and avail_out in the state.
   On return, state->x.have and state->x.next point to the just decompressed
   data.  If the gzip stream completes, state->how is reset to LOOK to look for
   the next gzip stream or raw data, once state->x.have is depleted.  Returns 0
   on success, -1 on failure. */
local int gz_decomp(state)
    gz_statep state;
{
    int ret = Z_OK;
    unsigned had;
    z_streamp strm = &(state->strm);

    /* fill output buffer up to end of deflate stream */
    had = strm->avail_out;
    do {
        /* get more input for inflate() */
        if (strm->avail_in == 0 && gz_avail(state) == -1)
            return -1;
        if (strm->avail_in == 0) {
            gz_error(state, Z_BUF_ERROR, "unexpected end of file");
            break;
        }

        /* decompress and handle errors */
        ret = inflate(strm, Z_NO_FLUSH);
        if (ret == Z_STREAM_ERROR || ret == Z_NEED_DICT) {
            gz_error(state, Z_STREAM_ERROR,
                     "internal error: inflate stream corrupt");
            return -1;
        }
        if (ret == Z_MEM_ERROR) {
            gz_error(state, Z_MEM_ERROR, "out of memory");
            return -1;
        }
        if (ret == Z_DATA_ERROR) {              /* deflate stream invalid */
            gz_error(state, Z_DATA_ERROR,
                     strm->msg == NULL ? "compressed data error" : strm->msg);
            return -1;
        }
    } while (strm->avail_out && ret != Z_STREAM_END);

    /* update available output */
    state->x.have = had - strm->avail_out;
    state->x.next = strm->next_out - state->x.have;

    /* if the gzip stream completed successfully, look for another */
    if (ret == Z_STREAM_END)
        state->how = LOOK;

    /* good decompression */
    return 0;
}

/* Fetch data and put it in the output buffer.  Assumes state->x.have is 0.
   Data is either copied from the input file or decompressed from the input
   file depending on state->how.  If state->how is LOOK, then a gzip header is
   looked for to determine whether to copy or decompress.  Returns -1 on error,
   otherwise 0.  gz_fetch() will leave state->how as COPY or GZIP unless the
   end of the input file has been reached and all data has been processed.  */
local int gz_fetch(state)
    gz_statep state;
{
    z_streamp strm = &(state->strm);

    do {
        switch(state->how) {
        case LOOK:      /* -> LOOK, COPY (only if never GZIP), or GZIP */
            if (gz_look(state) == -1)
                return -1;
            if (state->how == LOOK)
                return 0;
            break;
        case COPY:      /* -> COPY */
            if (gz_load(state, state->out, state->size << 1, &(state->x.have))
                    == -1)
                return -1;
            state->x.next = state->out;
            return 0;
        case GZIP:      /* -> GZIP or LOOK (if end of gzip stream) */
            strm->avail_out = state->size << 1;
            strm->next_out = state->out;
            if (gz_decomp(state) == -1)
                return -1;
        }
    } while (state->x.have == 0 && (!state->eof || strm->avail_in));
    return 0;
}

/* Skip len uncompressed bytes of output.  Return -1 on error, 0 on success. */
local int gz_skip(state, len)
    gz_statep state;
    z_off64_t len;
{
    unsigned n;

    /* skip over len bytes or reach end-of-file, whichever comes first */
    while (len)
        /* skip over whatever is in output buffer */
        if (state->x.have) {
            n = GT_OFF(state->x.have) || (z_off64_t)state->x.have > len ?
                (unsigned)len : state->x.have;
            state->x.have -= n;
            state->x.next += n;
            state->x.pos += n;
            len -= n;
        }

        /* output buffer empty -- return if we're at the end of the input */
        else if (state->eof && state->strm.avail_in == 0)
            break;

        /* need more data to skip -- load up output buffer */
        else {
            /* get more output, looking for header if required */
            if (gz_fetch(state) == -1)
                return -1;
        }
    return 0;
}

/* -- see zlib.h -- */
int ZEXPORT gzread(file, buf, len)
    gzFile file;
    voidp buf;
    unsigned len;
{
    unsigned got, n;
    gz_statep state;
    z_streamp strm;

    /* get internal structure */
    if (file == NULL)
        return -1;
    state = (gz_statep)file;
    strm = &(state->strm);

    /* check that we're reading and that there's no (serious) error */
    if (state->mode != GZ_READ ||
            (state->err != Z_OK && state->err != Z_BUF_ERROR))
        return -1;

    /* since an int is returned, make sure len fits in one, otherwise return
       with an error (this avoids the flaw in the interface) */
    if ((int)len < 0) {
        gz_error(state, Z_DATA_ERROR, "requested length does not fit in int");
        return -1;
    }

    /* if len is zero, avoid unnecessary operations */
    if (len == 0)
        return 0;

    /* process a skip request */
    if (state->seek) {
        state->seek = 0;
        if (gz_skip(state, state->skip) == -1)
            return -1;
    }

    /* get len bytes to buf, or less than len if at the end */
    got = 0;
    do {
        /* first just try copying data from the output buffer */
        if (state->x.have) {
            n = state->x.have > len ? len : state->x.have;
            memcpy(buf, state->x.next, n);
            state->x.next += n;
            state->x.have -= n;
        }

        /* output buffer empty -- return if we're at the end of the input */
        else if (state->eof && strm->avail_in == 0) {
            state->past = 1;        /* tried to read past end */
            break;
        }

        /* need output data -- for small len or new stream load up our output
           buffer */
        else if (state->how == LOOK || len < (state->size << 1)) {
            /* get more output, looking for header if required */
            if (gz_fetch(state) == -1)
                return -1;
            continue;       /* no progress yet -- go back to copy above */
            /* the copy above assures that we will leave with space in the
               output buffer, allowing at least one gzungetc() to succeed */
        }

        /* large len -- read directly into user buffer */
        else if (state->how == COPY) {      /* read directly */
            if (gz_load(state, (unsigned char *)buf, len, &n) == -1)
                return -1;
        }

        /* large len -- decompress directly into user buffer */
        else {  /* state->how == GZIP */
            strm->avail_out = len;
            strm->next_out = (unsigned char *)buf;
            if (gz_decomp(state) == -1)
                return -1;
            n = state->x.have;
            state->x.have = 0;
        }

        /* update progress */
        len -= n;
        buf = (char *)buf + n;
        got += n;
        state->x.pos += n;
    } while (len);

    /* return number of bytes read into user buffer (will fit in int) */
    return (int)got;
}

/* -- see zlib.h -- */
#ifdef Z_PREFIX_SET
#  undef z_gzgetc
#else
#  undef gzgetc
#endif
int ZEXPORT gzgetc(file)
    gzFile file;
{
    int ret;
    unsigned char buf[1];
    gz_statep state;

    /* get internal structure */
    if (file == NULL)
        return -1;
    state = (gz_statep)file;

    /* check that we're reading and that there's no (serious) error */
    if (state->mode != GZ_READ ||
        (state->err != Z_OK && state->err != Z_BUF_ERROR))
        return -1;

    /* try output buffer (no need to check for skip request) */
    if (state->x.have) {
        state->x.have--;
        state->x.pos++;
        return *(state->x.next)++;
    }

    /* nothing there -- try gzread() */
    ret = gzread(file, buf, 1);
    return ret < 1 ? -1 : buf[0];
}

int ZEXPORT gzgetc_(file)
gzFile file;
{
    return gzgetc(file);
}

/* -- see zlib.h -- */
int ZEXPORT gzungetc(c, file)
    int c;
    gzFile file;
{
    gz_statep state;

    /* get internal structure */
    if (file == NULL)
        return -1;
    state = (gz_statep)file;

    /* check that we're reading and that there's no (serious) error */
    if (state->mode != GZ_READ ||
        (state->err != Z_OK && state->err != Z_BUF_ERROR))
        return -1;

    /* process a skip request */
    if (state->seek) {
        state->seek = 0;
        if (gz_skip(state, state->skip) == -1)
            return -1;
    }

    /* can't push EOF */
    if (c < 0)
        return -1;

    /* if output buffer empty, put byte at end (allows more pushing) */
    if (state->x.have == 0) {
        state->x.have = 1;
        state->x.next = state->out + (state->size << 1) - 1;
        state->x.next[0] = c;
        state->x.pos--;
        state->past = 0;
        return c;
    }

    /* if no room, give up (must have already done a gzungetc()) */
    if (state->x.have == (state->size << 1)) {
        gz_error(state, Z_DATA_ERROR, "out of room to push characters");
        return -1;
    }

    /* slide output data if needed and insert byte before existing data */
    if (state->x.next == state->out) {
        unsigned char *src = state->out + state->x.have;
        unsigned char *dest = state->out + (state->size << 1);
        while (src > state->out)
            *--dest = *--src;
        state->x.next = dest;
    }
    state->x.have++;
    state->x.next--;
    state->x.next[0] = c;
    state->x.pos--;
    state->past = 0;
    return c;
}

/* -- see zlib.h -- */
char * ZEXPORT gzgets(file, buf, len)
    gzFile file;
    char *buf;
    int len;
{
    unsigned left, n;
    char *str;
    unsigned char *eol;
    gz_statep state;

    /* check parameters and get internal structure */
    if (file == NULL || buf == NULL || len < 1)
        return NULL;
    state = (gz_statep)file;

    /* check that we're reading and that there's no (serious) error */
    if (state->mode != GZ_READ ||
        (state->err != Z_OK && state->err != Z_BUF_ERROR))
        return NULL;

    /* process a skip request */
    if (state->seek) {
        state->seek = 0;
        if (gz_skip(state, state->skip) == -1)
            return NULL;
    }

    /* copy output bytes up to new line or len - 1, whichever comes first --
       append a terminating zero to the string (we don't check for a zero in
       the contents, let the user worry about that) */
    str = buf;
    left = (unsigned)len - 1;
    if (left) do {
        /* assure that something is in the output buffer */
        if (state->x.have == 0 && gz_fetch(state) == -1)
            return NULL;                /* error */
        if (state->x.have == 0) {       /* end of file */
            state->past = 1;            /* read past end */
            break;                      /* return what we have */
        }

        /* look for end-of-line in current output buffer */
        n = state->x.have > left ? left : state->x.have;
        eol = (unsigned char *)memchr(state->x.next, '\n', n);
        if (eol != NULL)
            n = (unsigned)(eol - state->x.next) + 1;

        /* copy through end-of-line, or remainder if not found */
        memcpy(buf, state->x.next, n);
        state->x.have -= n;
        state->x.next += n;
        state->x.pos += n;
        left -= n;
        buf += n;
    } while (left && eol == NULL);

    /* return terminated string, or if nothing, end of file */
    if (buf == str)
        return NULL;
    buf[0] = 0;
    return str;
}

/* -- see zlib.h -- */
int ZEXPORT gzdirect(file)
    gzFile file;
{
    gz_statep state;

    /* get internal structure */
    if (file == NULL)
        return 0;
    state = (gz_statep)file;

    /* if the state is not known, but we can find out, then do so (this is
       mainly for right after a gzopen() or gzdopen()) */
    if (state->mode == GZ_READ && state->how == LOOK && state->x.have == 0)
        (void)gz_look(state);

    /* return 1 if transparent, 0 if processing a gzip stream */
    return state->direct;
}

/* -- see zlib.h -- */
int ZEXPORT gzclose_r(file)
    gzFile file;
{
    int ret, err;
    gz_statep state;

    /* get internal structure */
    if (file == NULL)
        return Z_STREAM_ERROR;
    state = (gz_statep)file;

    /* check that we're reading */
    if (state->mode != GZ_READ)
        return Z_STREAM_ERROR;

    /* free memory and close file */
    if (state->size) {
        inflateEnd(&(state->strm));
        free(state->out);
        free(state->in);
    }
    err = state->err == Z_BUF_ERROR ? Z_BUF_ERROR : Z_OK;
    gz_error(state, Z_OK, NULL);
    free(state->path);
    ret = _close(state->fd);
    free(state);
    return ret ? Z_ERRNO : err;
}

/***********************************************************************
ZLIB\GZWRITE.C
***********************************************************************/
/* gzwrite.c -- zlib functions for writing gzip files
 * Copyright (C) 2004, 2005, 2010, 2011, 2012, 2013 Mark Adler
 * For conditions of distribution and use, see copyright notice in zlib.h
 */


/* Local functions */
local int gz_init OF((gz_statep));
local int gz_comp OF((gz_statep, int));
local int gz_zero OF((gz_statep, z_off64_t));

/* Initialize state for writing a gzip file.  Mark initialization by setting
   state->size to non-zero.  Return -1 on failure or 0 on success. */
local int gz_init(state)
    gz_statep state;
{
    int ret;
    z_streamp strm = &(state->strm);

    /* allocate input buffer */
    state->in = (unsigned char *)malloc(state->want);
    if (state->in == NULL) {
        gz_error(state, Z_MEM_ERROR, "out of memory");
        return -1;
    }

    /* only need output buffer and deflate state if compressing */
    if (!state->direct) {
        /* allocate output buffer */
        state->out = (unsigned char *)malloc(state->want);
        if (state->out == NULL) {
            free(state->in);
            gz_error(state, Z_MEM_ERROR, "out of memory");
            return -1;
        }

        /* allocate deflate memory, set up for gzip compression */
        strm->zalloc = Z_NULL;
        strm->zfree = Z_NULL;
        strm->opaque = Z_NULL;
        ret = deflateInit2(strm, state->level, Z_DEFLATED,
                           MAX_WBITS + 16, DEF_MEM_LEVEL, state->strategy);
        if (ret != Z_OK) {
            free(state->out);
            free(state->in);
            gz_error(state, Z_MEM_ERROR, "out of memory");
            return -1;
        }
    }

    /* mark state as initialized */
    state->size = state->want;

    /* initialize write buffer if compressing */
    if (!state->direct) {
        strm->avail_out = state->size;
        strm->next_out = state->out;
        state->x.next = strm->next_out;
    }
    return 0;
}

/* Compress whatever is at avail_in and next_in and write to the output file.
   Return -1 if there is an error writing to the output file, otherwise 0.
   flush is assumed to be a valid deflate() flush value.  If flush is Z_FINISH,
   then the deflate() state is reset to start a new gzip stream.  If gz->direct
   is true, then simply write to the output file without compressing, and
   ignore flush. */
local int gz_comp(state, flush)
    gz_statep state;
    int flush;
{
    int ret, got;
    unsigned have;
    z_streamp strm = &(state->strm);

    /* allocate memory if this is the first time through */
    if (state->size == 0 && gz_init(state) == -1)
        return -1;

    /* write directly if requested */
    if (state->direct) {
        got = _write(state->fd, strm->next_in, strm->avail_in);
        if (got < 0 || (unsigned)got != strm->avail_in) {
            gz_error(state, Z_ERRNO, zstrerror());
            return -1;
        }
        strm->avail_in = 0;
        return 0;
    }

    /* run deflate() on provided input until it produces no more output */
    ret = Z_OK;
    do {
        /* write out current buffer contents if full, or if flushing, but if
           doing Z_FINISH then don't write until we get to Z_STREAM_END */
        if (strm->avail_out == 0 || (flush != Z_NO_FLUSH &&
            (flush != Z_FINISH || ret == Z_STREAM_END))) {
            have = (unsigned)(strm->next_out - state->x.next);
            if (have && ((got = _write(state->fd, state->x.next, have)) < 0 ||
                         (unsigned)got != have)) {
                gz_error(state, Z_ERRNO, zstrerror());
                return -1;
            }
            if (strm->avail_out == 0) {
                strm->avail_out = state->size;
                strm->next_out = state->out;
            }
            state->x.next = strm->next_out;
        }

        /* compress */
        have = strm->avail_out;
        ret = deflate(strm, flush);
        if (ret == Z_STREAM_ERROR) {
            gz_error(state, Z_STREAM_ERROR,
                      "internal error: deflate stream corrupt");
            return -1;
        }
        have -= strm->avail_out;
    } while (have);

    /* if that completed a deflate stream, allow another to start */
    if (flush == Z_FINISH)
        deflateReset(strm);

    /* all done, no errors */
    return 0;
}

/* Compress len zeros to output.  Return -1 on error, 0 on success. */
local int gz_zero(state, len)
    gz_statep state;
    z_off64_t len;
{
    int first;
    unsigned n;
    z_streamp strm = &(state->strm);

    /* consume whatever's left in the input buffer */
    if (strm->avail_in && gz_comp(state, Z_NO_FLUSH) == -1)
        return -1;

    /* compress len zeros (len guaranteed > 0) */
    first = 1;
    while (len) {
        n = GT_OFF(state->size) || (z_off64_t)state->size > len ?
            (unsigned)len : state->size;
        if (first) {
            memset(state->in, 0, n);
            first = 0;
        }
        strm->avail_in = n;
        strm->next_in = state->in;
        state->x.pos += n;
        if (gz_comp(state, Z_NO_FLUSH) == -1)
            return -1;
        len -= n;
    }
    return 0;
}

/* -- see zlib.h -- */
int ZEXPORT gzwrite(file, buf, len)
    gzFile file;
    voidpc buf;
    unsigned len;
{
    unsigned put = len;
    gz_statep state;
    z_streamp strm;

    /* get internal structure */
    if (file == NULL)
        return 0;
    state = (gz_statep)file;
    strm = &(state->strm);

    /* check that we're writing and that there's no error */
    if (state->mode != GZ_WRITE || state->err != Z_OK)
        return 0;

    /* since an int is returned, make sure len fits in one, otherwise return
       with an error (this avoids the flaw in the interface) */
    if ((int)len < 0) {
        gz_error(state, Z_DATA_ERROR, "requested length does not fit in int");
        return 0;
    }

    /* if len is zero, avoid unnecessary operations */
    if (len == 0)
        return 0;

    /* allocate memory if this is the first time through */
    if (state->size == 0 && gz_init(state) == -1)
        return 0;

    /* check for seek request */
    if (state->seek) {
        state->seek = 0;
        if (gz_zero(state, state->skip) == -1)
            return 0;
    }

    /* for small len, copy to input buffer, otherwise compress directly */
    if (len < state->size) {
        /* copy to input buffer, compress when full */
        do {
            unsigned have, copy;

            if (strm->avail_in == 0)
                strm->next_in = state->in;
            have = (unsigned)((strm->next_in + strm->avail_in) - state->in);
            copy = state->size - have;
            if (copy > len)
                copy = len;
            memcpy(state->in + have, buf, copy);
            strm->avail_in += copy;
            state->x.pos += copy;
            buf = (const char *)buf + copy;
            len -= copy;
            if (len && gz_comp(state, Z_NO_FLUSH) == -1)
                return 0;
        } while (len);
    }
    else {
        /* consume whatever's left in the input buffer */
        if (strm->avail_in && gz_comp(state, Z_NO_FLUSH) == -1)
            return 0;

        /* directly compress user buffer to file */
        strm->avail_in = len;
        strm->next_in = (z_const Bytef *)buf;
        state->x.pos += len;
        if (gz_comp(state, Z_NO_FLUSH) == -1)
            return 0;
    }

    /* input was all buffered or compressed (put will fit in int) */
    return (int)put;
}

/* -- see zlib.h -- */
int ZEXPORT gzputc(file, c)
    gzFile file;
    int c;
{
    unsigned have;
    unsigned char buf[1];
    gz_statep state;
    z_streamp strm;

    /* get internal structure */
    if (file == NULL)
        return -1;
    state = (gz_statep)file;
    strm = &(state->strm);

    /* check that we're writing and that there's no error */
    if (state->mode != GZ_WRITE || state->err != Z_OK)
        return -1;

    /* check for seek request */
    if (state->seek) {
        state->seek = 0;
        if (gz_zero(state, state->skip) == -1)
            return -1;
    }

    /* try writing to input buffer for speed (state->size == 0 if buffer not
       initialized) */
    if (state->size) {
        if (strm->avail_in == 0)
            strm->next_in = state->in;
        have = (unsigned)((strm->next_in + strm->avail_in) - state->in);
        if (have < state->size) {
            state->in[have] = c;
            strm->avail_in++;
            state->x.pos++;
            return c & 0xff;
        }
    }

    /* no room in buffer or not initialized, use gz_write() */
    buf[0] = c;
    if (gzwrite(file, buf, 1) != 1)
        return -1;
    return c & 0xff;
}

/* -- see zlib.h -- */
int ZEXPORT gzputs(file, str)
    gzFile file;
    const char *str;
{
    int ret;
    unsigned len;

    /* write string */
    len = (unsigned)strlen(str);
    ret = gzwrite(file, str, len);
    return ret == 0 && len != 0 ? -1 : ret;
}

#if defined(STDC) || defined(Z_HAVE_STDARG_H)

/* -- see zlib.h -- */
int ZEXPORTVA gzvprintf(gzFile file, const char *format, va_list va)
{
    int size, len;
    gz_statep state;
    z_streamp strm;

    /* get internal structure */
    if (file == NULL)
        return -1;
    state = (gz_statep)file;
    strm = &(state->strm);

    /* check that we're writing and that there's no error */
    if (state->mode != GZ_WRITE || state->err != Z_OK)
        return 0;

    /* make sure we have some buffer space */
    if (state->size == 0 && gz_init(state) == -1)
        return 0;

    /* check for seek request */
    if (state->seek) {
        state->seek = 0;
        if (gz_zero(state, state->skip) == -1)
            return 0;
    }

    /* consume whatever's left in the input buffer */
    if (strm->avail_in && gz_comp(state, Z_NO_FLUSH) == -1)
        return 0;

    /* do the printf() into the input buffer, put length in len */
    size = (int)(state->size);
    state->in[size - 1] = 0;
#ifdef NO_vsnprintf
#  ifdef HAS_vsprintf_void
    (void)vsprintf((char *)(state->in), format, va);
    for (len = 0; len < size; len++)
        if (state->in[len] == 0) break;
#  else
    len = vsprintf((char *)(state->in), format, va);
#  endif
#else
#  ifdef HAS_vsnprintf_void
    (void)vsnprintf((char *)(state->in), size, format, va);
    len = strlen((char *)(state->in));
#  else
    len = vsnprintf((char *)(state->in), size, format, va);
#  endif
#endif

    /* check that printf() results fit in buffer */
    if (len <= 0 || len >= (int)size || state->in[size - 1] != 0)
        return 0;

    /* update buffer and position, defer compression until needed */
    strm->avail_in = (unsigned)len;
    strm->next_in = state->in;
    state->x.pos += len;
    return len;
}

int ZEXPORTVA gzprintf(gzFile file, const char *format, ...)
{
    va_list va;
    int ret;

    va_start(va, format);
    ret = gzvprintf(file, format, va);
    va_end(va);
    return ret;
}

#else /* !STDC && !Z_HAVE_STDARG_H */

/* -- see zlib.h -- */
int ZEXPORTVA gzprintf (file, format, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10,
                       a11, a12, a13, a14, a15, a16, a17, a18, a19, a20)
    gzFile file;
    const char *format;
    int a1, a2, a3, a4, a5, a6, a7, a8, a9, a10,
        a11, a12, a13, a14, a15, a16, a17, a18, a19, a20;
{
    int size, len;
    gz_statep state;
    z_streamp strm;

    /* get internal structure */
    if (file == NULL)
        return -1;
    state = (gz_statep)file;
    strm = &(state->strm);

    /* check that can really pass pointer in ints */
    if (sizeof(int) != sizeof(void *))
        return 0;

    /* check that we're writing and that there's no error */
    if (state->mode != GZ_WRITE || state->err != Z_OK)
        return 0;

    /* make sure we have some buffer space */
    if (state->size == 0 && gz_init(state) == -1)
        return 0;

    /* check for seek request */
    if (state->seek) {
        state->seek = 0;
        if (gz_zero(state, state->skip) == -1)
            return 0;
    }

    /* consume whatever's left in the input buffer */
    if (strm->avail_in && gz_comp(state, Z_NO_FLUSH) == -1)
        return 0;

    /* do the printf() into the input buffer, put length in len */
    size = (int)(state->size);
    state->in[size - 1] = 0;
#ifdef NO_snprintf
#  ifdef HAS_sprintf_void
    sprintf((char *)(state->in), format, a1, a2, a3, a4, a5, a6, a7, a8,
            a9, a10, a11, a12, a13, a14, a15, a16, a17, a18, a19, a20);
    for (len = 0; len < size; len++)
        if (state->in[len] == 0) break;
#  else
    len = sprintf((char *)(state->in), format, a1, a2, a3, a4, a5, a6, a7, a8,
                  a9, a10, a11, a12, a13, a14, a15, a16, a17, a18, a19, a20);
#  endif
#else
#  ifdef HAS_snprintf_void
	snprintf((char *)(state->in), size, format, a1, a2, a3, a4, a5, a6, a7, a8,
             a9, a10, a11, a12, a13, a14, a15, a16, a17, a18, a19, a20);
    len = strlen((char *)(state->in));
#  else
    len = snprintf((char *)(state->in), size, format, a1, a2, a3, a4, a5, a6,
                   a7, a8, a9, a10, a11, a12, a13, a14, a15, a16, a17, a18,
                   a19, a20);
#  endif
#endif

    /* check that printf() results fit in buffer */
    if (len <= 0 || len >= (int)size || state->in[size - 1] != 0)
        return 0;

    /* update buffer and position, defer compression until needed */
    strm->avail_in = (unsigned)len;
    strm->next_in = state->in;
    state->x.pos += len;
    return len;
}

#endif

/* -- see zlib.h -- */
int ZEXPORT gzflush(file, flush)
    gzFile file;
    int flush;
{
    gz_statep state;

    /* get internal structure */
    if (file == NULL)
        return -1;
    state = (gz_statep)file;

    /* check that we're writing and that there's no error */
    if (state->mode != GZ_WRITE || state->err != Z_OK)
        return Z_STREAM_ERROR;

    /* check flush parameter */
    if (flush < 0 || flush > Z_FINISH)
        return Z_STREAM_ERROR;

    /* check for seek request */
    if (state->seek) {
        state->seek = 0;
        if (gz_zero(state, state->skip) == -1)
            return -1;
    }

    /* compress remaining data with requested flush */
    gz_comp(state, flush);
    return state->err;
}

/* -- see zlib.h -- */
int ZEXPORT gzsetparams(file, level, strategy)
    gzFile file;
    int level;
    int strategy;
{
    gz_statep state;
    z_streamp strm;

    /* get internal structure */
    if (file == NULL)
        return Z_STREAM_ERROR;
    state = (gz_statep)file;
    strm = &(state->strm);

    /* check that we're writing and that there's no error */
    if (state->mode != GZ_WRITE || state->err != Z_OK)
        return Z_STREAM_ERROR;

    /* if no change is requested, then do nothing */
    if (level == state->level && strategy == state->strategy)
        return Z_OK;

    /* check for seek request */
    if (state->seek) {
        state->seek = 0;
        if (gz_zero(state, state->skip) == -1)
            return -1;
    }

    /* change compression parameters for subsequent input */
    if (state->size) {
        /* flush previous input with previous parameters before changing */
        if (strm->avail_in && gz_comp(state, Z_PARTIAL_FLUSH) == -1)
            return state->err;
        deflateParams(strm, level, strategy);
    }
    state->level = level;
    state->strategy = strategy;
    return Z_OK;
}

/* -- see zlib.h -- */
int ZEXPORT gzclose_w(file)
    gzFile file;
{
    int ret = Z_OK;
    gz_statep state;

    /* get internal structure */
    if (file == NULL)
        return Z_STREAM_ERROR;
    state = (gz_statep)file;

    /* check that we're writing */
    if (state->mode != GZ_WRITE)
        return Z_STREAM_ERROR;

    /* check for seek request */
    if (state->seek) {
        state->seek = 0;
        if (gz_zero(state, state->skip) == -1)
            ret = state->err;
    }

    /* flush, free memory, and close file */
    if (gz_comp(state, Z_FINISH) == -1)
        ret = state->err;
    if (state->size) {
        if (!state->direct) {
            (void)deflateEnd(&(state->strm));
            free(state->out);
        }
        free(state->in);
    }
    gz_error(state, Z_OK, NULL);
    free(state->path);
    if (_close(state->fd) == -1)
        ret = Z_ERRNO;
    free(state);
    return ret;
}

/***********************************************************************
ZLIB\INFBACK.C
***********************************************************************/
/* infback.c -- inflate using a call-back interface
 * Copyright (C) 1995-2011 Mark Adler
 * For conditions of distribution and use, see copyright notice in zlib.h
 */

/*
   This code is largely copied from inflate.c.  Normally either infback.o or
   inflate.o would be linked into an application--not both.  The interface
   with inffast.c is retained so that optimized assembler-coded versions of
   inflate_fast() can be used with either inflate.c or infback.c.
 */


/* function prototypes */
local void fixedtables OF((struct inflate_state FAR *state));

/*
   strm provides memory allocation functions in zalloc and zfree, or
   Z_NULL to use the library memory allocation functions.

   windowBits is in the range 8..15, and window is a user-supplied
   window and output buffer that is 2**windowBits bytes.
 */
int ZEXPORT inflateBackInit_(strm, windowBits, window, version, stream_size)
z_streamp strm;
int windowBits;
unsigned char FAR *window;
const char *version;
int stream_size;
{
    struct inflate_state FAR *state;

    if (version == Z_NULL || version[0] != ZLIB_VERSION[0] ||
        stream_size != (int)(sizeof(z_stream)))
        return Z_VERSION_ERROR;
    if (strm == Z_NULL || window == Z_NULL ||
        windowBits < 8 || windowBits > 15)
        return Z_STREAM_ERROR;
    strm->msg = Z_NULL;                 /* in case we return an error */
    if (strm->zalloc == (alloc_func)0) {
#ifdef Z_SOLO
        return Z_STREAM_ERROR;
#else
        strm->zalloc = zcalloc;
        strm->opaque = (voidpf)0;
#endif
    }
    if (strm->zfree == (free_func)0)
#ifdef Z_SOLO
        return Z_STREAM_ERROR;
#else
    strm->zfree = zcfree;
#endif
    state = (struct inflate_state FAR *)ZALLOC(strm, 1,
                                               sizeof(struct inflate_state));
    if (state == Z_NULL) return Z_MEM_ERROR;
    Tracev((stderr, "inflate: allocated\n"));
    strm->state = (struct internal_state FAR *)state;
    state->dmax = 32768U;
    state->wbits = windowBits;
    state->wsize = 1U << windowBits;
    state->window = window;
    state->wnext = 0;
    state->whave = 0;
    return Z_OK;
}

/*
   Return state with length and distance decoding tables and index sizes set to
   fixed code decoding.  Normally this returns fixed tables from inffixed.h.
   If BUILDFIXED is defined, then instead this routine builds the tables the
   first time it's called, and returns those tables the first time and
   thereafter.  This reduces the size of the code by about 2K bytes, in
   exchange for a little execution time.  However, BUILDFIXED should not be
   used for threaded applications, since the rewriting of the tables and virgin
   may not be thread-safe.
 */
local void fixedtables(state)
struct inflate_state FAR *state;
{
#ifdef BUILDFIXED
    static int virgin = 1;
    static code *lenfix, *distfix;
    static code fixed[544];

    /* build fixed huffman tables if first call (may not be thread safe) */
    if (virgin) {
        unsigned sym, bits;
        static code *next;

        /* literal/length table */
        sym = 0;
        while (sym < 144) state->lens[sym++] = 8;
        while (sym < 256) state->lens[sym++] = 9;
        while (sym < 280) state->lens[sym++] = 7;
        while (sym < 288) state->lens[sym++] = 8;
        next = fixed;
        lenfix = next;
        bits = 9;
        inflate_table(LENS, state->lens, 288, &(next), &(bits), state->work);

        /* distance table */
        sym = 0;
        while (sym < 32) state->lens[sym++] = 5;
        distfix = next;
        bits = 5;
        inflate_table(DISTS, state->lens, 32, &(next), &(bits), state->work);

        /* do this just once */
        virgin = 0;
    }
#else /* !BUILDFIXED */
#   include "inffixed.h"
#endif /* BUILDFIXED */
    state->lencode = lenfix;
    state->lenbits = 9;
    state->distcode = distfix;
    state->distbits = 5;
}

/* Macros for inflateBack(): */

/* Load returned state from inflate_fast() */
#define LOAD() \
    do { \
        put = strm->next_out; \
        left = strm->avail_out; \
        next = strm->next_in; \
        have = strm->avail_in; \
        hold = state->hold; \
        bits = state->bits; \
    } while (0)

/* Set state from registers for inflate_fast() */
#define RESTORE() \
    do { \
        strm->next_out = put; \
        strm->avail_out = left; \
        strm->next_in = next; \
        strm->avail_in = have; \
        state->hold = hold; \
        state->bits = bits; \
    } while (0)

/* Clear the input bit accumulator */
#define INITBITS() \
    do { \
        hold = 0; \
        bits = 0; \
    } while (0)

/* Assure that some input is available.  If input is requested, but denied,
   then return a Z_BUF_ERROR from inflateBack(). */
#define PULL() \
    do { \
        if (have == 0) { \
            have = in(in_desc, &next); \
            if (have == 0) { \
                next = Z_NULL; \
                ret = Z_BUF_ERROR; \
                goto inf_leave; \
            } \
        } \
    } while (0)

/* Get a byte of input into the bit accumulator, or return from inflateBack()
   with an error if there is no input available. */
#define PULLBYTE() \
    do { \
        PULL(); \
        have--; \
        hold += (unsigned long)(*next++) << bits; \
        bits += 8; \
    } while (0)

/* Assure that there are at least n bits in the bit accumulator.  If there is
   not enough available input to do that, then return from inflateBack() with
   an error. */
#define NEEDBITS(n) \
    do { \
        while (bits < (unsigned)(n)) \
            PULLBYTE(); \
    } while (0)

/* Return the low n bits of the bit accumulator (n < 16) */
#define BITS(n) \
    ((unsigned)hold & ((1U << (n)) - 1))

/* Remove n bits from the bit accumulator */
#define DROPBITS(n) \
    do { \
        hold >>= (n); \
        bits -= (unsigned)(n); \
    } while (0)

/* Remove zero to seven bits as needed to go to a byte boundary */
#define BYTEBITS() \
    do { \
        hold >>= bits & 7; \
        bits -= bits & 7; \
    } while (0)

/* Assure that some output space is available, by writing out the window
   if it's full.  If the write fails, return from inflateBack() with a
   Z_BUF_ERROR. */
#define ROOM() \
    do { \
        if (left == 0) { \
            put = state->window; \
            left = state->wsize; \
            state->whave = left; \
            if (out(out_desc, put, left)) { \
                ret = Z_BUF_ERROR; \
                goto inf_leave; \
            } \
        } \
    } while (0)

/*
   strm provides the memory allocation functions and window buffer on input,
   and provides information on the unused input on return.  For Z_DATA_ERROR
   returns, strm will also provide an error message.

   in() and out() are the call-back input and output functions.  When
   inflateBack() needs more input, it calls in().  When inflateBack() has
   filled the window with output, or when it completes with data in the
   window, it calls out() to write out the data.  The application must not
   change the provided input until in() is called again or inflateBack()
   returns.  The application must not change the window/output buffer until
   inflateBack() returns.

   in() and out() are called with a descriptor parameter provided in the
   inflateBack() call.  This parameter can be a structure that provides the
   information required to do the read or write, as well as accumulated
   information on the input and output such as totals and check values.

   in() should return zero on failure.  out() should return non-zero on
   failure.  If either in() or out() fails, than inflateBack() returns a
   Z_BUF_ERROR.  strm->next_in can be checked for Z_NULL to see whether it
   was in() or out() that caused in the error.  Otherwise,  inflateBack()
   returns Z_STREAM_END on success, Z_DATA_ERROR for an deflate format
   error, or Z_MEM_ERROR if it could not allocate memory for the state.
   inflateBack() can also return Z_STREAM_ERROR if the input parameters
   are not correct, i.e. strm is Z_NULL or the state was not initialized.
 */
int ZEXPORT inflateBack(strm, in, in_desc, out, out_desc)
z_streamp strm;
in_func in;
void FAR *in_desc;
out_func out;
void FAR *out_desc;
{
    struct inflate_state FAR *state;
    z_const unsigned char FAR *next;    /* next input */
    unsigned char FAR *put;     /* next output */
    unsigned have, left;        /* available input and output */
    unsigned long hold;         /* bit buffer */
    unsigned bits;              /* bits in bit buffer */
    unsigned copy;              /* number of stored or match bytes to copy */
    unsigned char FAR *from;    /* where to copy match bytes from */
    code here;                  /* current decoding table entry */
    code last;                  /* parent table entry */
    unsigned len;               /* length to copy for repeats, bits to drop */
    int ret;                    /* return code */
    static const unsigned short order[19] = /* permutation of code lengths */
        {16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15};

    /* Check that the strm exists and that the state was initialized */
    if (strm == Z_NULL || strm->state == Z_NULL)
        return Z_STREAM_ERROR;
    state = (struct inflate_state FAR *)strm->state;

    /* Reset the state */
    strm->msg = Z_NULL;
    state->mode = TYPE;
    state->last = 0;
    state->whave = 0;
    next = strm->next_in;
    have = next != Z_NULL ? strm->avail_in : 0;
    hold = 0;
    bits = 0;
    put = state->window;
    left = state->wsize;

    /* Inflate until end of block marked as last */
    for (;;)
        switch (state->mode) {
        case TYPE:
            /* determine and dispatch block type */
            if (state->last) {
                BYTEBITS();
                state->mode = DONE;
                break;
            }
            NEEDBITS(3);
            state->last = BITS(1);
            DROPBITS(1);
            switch (BITS(2)) {
            case 0:                             /* stored block */
                Tracev((stderr, "inflate:     stored block%s\n",
                        state->last ? " (last)" : ""));
                state->mode = STORED;
                break;
            case 1:                             /* fixed block */
                fixedtables(state);
                Tracev((stderr, "inflate:     fixed codes block%s\n",
                        state->last ? " (last)" : ""));
                state->mode = LEN;              /* decode codes */
                break;
            case 2:                             /* dynamic block */
                Tracev((stderr, "inflate:     dynamic codes block%s\n",
                        state->last ? " (last)" : ""));
                state->mode = TABLE;
                break;
            case 3:
                strm->msg = (char *)"invalid block type";
                state->mode = BAD;
            }
            DROPBITS(2);
            break;

        case STORED:
            /* get and verify stored block length */
            BYTEBITS();                         /* go to byte boundary */
            NEEDBITS(32);
            if ((hold & 0xffff) != ((hold >> 16) ^ 0xffff)) {
                strm->msg = (char *)"invalid stored block lengths";
                state->mode = BAD;
                break;
            }
            state->length = (unsigned)hold & 0xffff;
            Tracev((stderr, "inflate:       stored length %u\n",
                    state->length));
            INITBITS();

            /* copy stored block from input to output */
            while (state->length != 0) {
                copy = state->length;
                PULL();
                ROOM();
                if (copy > have) copy = have;
                if (copy > left) copy = left;
                zmemcpy(put, next, copy);
                have -= copy;
                next += copy;
                left -= copy;
                put += copy;
                state->length -= copy;
            }
            Tracev((stderr, "inflate:       stored end\n"));
            state->mode = TYPE;
            break;

        case TABLE:
            /* get dynamic table entries descriptor */
            NEEDBITS(14);
            state->nlen = BITS(5) + 257;
            DROPBITS(5);
            state->ndist = BITS(5) + 1;
            DROPBITS(5);
            state->ncode = BITS(4) + 4;
            DROPBITS(4);
#ifndef PKZIP_BUG_WORKAROUND
            if (state->nlen > 286 || state->ndist > 30) {
                strm->msg = (char *)"too many length or distance symbols";
                state->mode = BAD;
                break;
            }
#endif
            Tracev((stderr, "inflate:       table sizes ok\n"));

            /* get code length code lengths (not a typo) */
            state->have = 0;
            while (state->have < state->ncode) {
                NEEDBITS(3);
                state->lens[order[state->have++]] = (unsigned short)BITS(3);
                DROPBITS(3);
            }
            while (state->have < 19)
                state->lens[order[state->have++]] = 0;
            state->next = state->codes;
            state->lencode = (code const FAR *)(state->next);
            state->lenbits = 7;
            ret = inflate_table(CODES, state->lens, 19, &(state->next),
                                &(state->lenbits), state->work);
            if (ret) {
                strm->msg = (char *)"invalid code lengths set";
                state->mode = BAD;
                break;
            }
            Tracev((stderr, "inflate:       code lengths ok\n"));

            /* get length and distance code code lengths */
            state->have = 0;
            while (state->have < state->nlen + state->ndist) {
                for (;;) {
                    here = state->lencode[BITS(state->lenbits)];
                    if ((unsigned)(here.bits) <= bits) break;
                    PULLBYTE();
                }
                if (here.val < 16) {
                    DROPBITS(here.bits);
                    state->lens[state->have++] = here.val;
                }
                else {
                    if (here.val == 16) {
                        NEEDBITS(here.bits + 2);
                        DROPBITS(here.bits);
                        if (state->have == 0) {
                            strm->msg = (char *)"invalid bit length repeat";
                            state->mode = BAD;
                            break;
                        }
                        len = (unsigned)(state->lens[state->have - 1]);
                        copy = 3 + BITS(2);
                        DROPBITS(2);
                    }
                    else if (here.val == 17) {
                        NEEDBITS(here.bits + 3);
                        DROPBITS(here.bits);
                        len = 0;
                        copy = 3 + BITS(3);
                        DROPBITS(3);
                    }
                    else {
                        NEEDBITS(here.bits + 7);
                        DROPBITS(here.bits);
                        len = 0;
                        copy = 11 + BITS(7);
                        DROPBITS(7);
                    }
                    if (state->have + copy > state->nlen + state->ndist) {
                        strm->msg = (char *)"invalid bit length repeat";
                        state->mode = BAD;
                        break;
                    }
                    while (copy--)
                        state->lens[state->have++] = (unsigned short)len;
                }
            }

            /* handle error breaks in while */
            if (state->mode == BAD) break;

            /* check for end-of-block code (better have one) */
            if (state->lens[256] == 0) {
                strm->msg = (char *)"invalid code -- missing end-of-block";
                state->mode = BAD;
                break;
            }

            /* build code tables -- note: do not change the lenbits or distbits
               values here (9 and 6) without reading the comments in inftrees.h
               concerning the ENOUGH constants, which depend on those values */
            state->next = state->codes;
            state->lencode = (code const FAR *)(state->next);
            state->lenbits = 9;
            ret = inflate_table(LENS, state->lens, state->nlen, &(state->next),
                                &(state->lenbits), state->work);
            if (ret) {
                strm->msg = (char *)"invalid literal/lengths set";
                state->mode = BAD;
                break;
            }
            state->distcode = (code const FAR *)(state->next);
            state->distbits = 6;
            ret = inflate_table(DISTS, state->lens + state->nlen, state->ndist,
                            &(state->next), &(state->distbits), state->work);
            if (ret) {
                strm->msg = (char *)"invalid distances set";
                state->mode = BAD;
                break;
            }
            Tracev((stderr, "inflate:       codes ok\n"));
            state->mode = LEN;

        case LEN:
            /* use inflate_fast() if we have enough input and output */
            if (have >= 6 && left >= 258) {
                RESTORE();
                if (state->whave < state->wsize)
                    state->whave = state->wsize - left;
                inflate_fast(strm, state->wsize);
                LOAD();
                break;
            }

            /* get a literal, length, or end-of-block code */
            for (;;) {
                here = state->lencode[BITS(state->lenbits)];
                if ((unsigned)(here.bits) <= bits) break;
                PULLBYTE();
            }
            if (here.op && (here.op & 0xf0) == 0) {
                last = here;
                for (;;) {
                    here = state->lencode[last.val +
                            (BITS(last.bits + last.op) >> last.bits)];
                    if ((unsigned)(last.bits + here.bits) <= bits) break;
                    PULLBYTE();
                }
                DROPBITS(last.bits);
            }
            DROPBITS(here.bits);
            state->length = (unsigned)here.val;

            /* process literal */
            if (here.op == 0) {
                Tracevv((stderr, here.val >= 0x20 && here.val < 0x7f ?
                        "inflate:         literal '%c'\n" :
                        "inflate:         literal 0x%02x\n", here.val));
                ROOM();
                *put++ = (unsigned char)(state->length);
                left--;
                state->mode = LEN;
                break;
            }

            /* process end of block */
            if (here.op & 32) {
                Tracevv((stderr, "inflate:         end of block\n"));
                state->mode = TYPE;
                break;
            }

            /* invalid code */
            if (here.op & 64) {
                strm->msg = (char *)"invalid literal/length code";
                state->mode = BAD;
                break;
            }

            /* length code -- get extra bits, if any */
            state->extra = (unsigned)(here.op) & 15;
            if (state->extra != 0) {
                NEEDBITS(state->extra);
                state->length += BITS(state->extra);
                DROPBITS(state->extra);
            }
            Tracevv((stderr, "inflate:         length %u\n", state->length));

            /* get distance code */
            for (;;) {
                here = state->distcode[BITS(state->distbits)];
                if ((unsigned)(here.bits) <= bits) break;
                PULLBYTE();
            }
            if ((here.op & 0xf0) == 0) {
                last = here;
                for (;;) {
                    here = state->distcode[last.val +
                            (BITS(last.bits + last.op) >> last.bits)];
                    if ((unsigned)(last.bits + here.bits) <= bits) break;
                    PULLBYTE();
                }
                DROPBITS(last.bits);
            }
            DROPBITS(here.bits);
            if (here.op & 64) {
                strm->msg = (char *)"invalid distance code";
                state->mode = BAD;
                break;
            }
            state->offset = (unsigned)here.val;

            /* get distance extra bits, if any */
            state->extra = (unsigned)(here.op) & 15;
            if (state->extra != 0) {
                NEEDBITS(state->extra);
                state->offset += BITS(state->extra);
                DROPBITS(state->extra);
            }
            if (state->offset > state->wsize - (state->whave < state->wsize ?
                                                left : 0)) {
                strm->msg = (char *)"invalid distance too far back";
                state->mode = BAD;
                break;
            }
            Tracevv((stderr, "inflate:         distance %u\n", state->offset));

            /* copy match from window to output */
            do {
                ROOM();
                copy = state->wsize - state->offset;
                if (copy < left) {
                    from = put + copy;
                    copy = left - copy;
                }
                else {
                    from = put - state->offset;
                    copy = left;
                }
                if (copy > state->length) copy = state->length;
                state->length -= copy;
                left -= copy;
                do {
                    *put++ = *from++;
                } while (--copy);
            } while (state->length != 0);
            break;

        case DONE:
            /* inflate stream terminated properly -- write leftover output */
            ret = Z_STREAM_END;
            if (left < state->wsize) {
                if (out(out_desc, state->window, state->wsize - left))
                    ret = Z_BUF_ERROR;
            }
            goto inf_leave;

        case BAD:
            ret = Z_DATA_ERROR;
            goto inf_leave;

        default:                /* can't happen, but makes compilers happy */
            ret = Z_STREAM_ERROR;
            goto inf_leave;
        }

    /* Return unused input */
  inf_leave:
    strm->next_in = next;
    strm->avail_in = have;
    return ret;
}

int ZEXPORT inflateBackEnd(strm)
z_streamp strm;
{
    if (strm == Z_NULL || strm->state == Z_NULL || strm->zfree == (free_func)0)
        return Z_STREAM_ERROR;
    ZFREE(strm, strm->state);
    strm->state = Z_NULL;
    Tracev((stderr, "inflate: end\n"));
    return Z_OK;
}

/***********************************************************************
ZLIB\INFFAST.C
***********************************************************************/
/* inffast.c -- fast decoding
 * Copyright (C) 1995-2008, 2010, 2013 Mark Adler
 * For conditions of distribution and use, see copyright notice in zlib.h
 */


#ifndef ASMINF

/* Allow machine dependent optimization for post-increment or pre-increment.
   Based on testing to date,
   Pre-increment preferred for:
   - PowerPC G3 (Adler)
   - MIPS R5000 (Randers-Pehrson)
   Post-increment preferred for:
   - none
   No measurable difference:
   - Pentium III (Anderson)
   - M68060 (Nikl)
 */
#ifdef POSTINC
#  define OFF 0
#  define PUP(a) *(a)++
#else
#  define OFF 1
#  define PUP(a) *++(a)
#endif

/*
   Decode literal, length, and distance codes and write out the resulting
   literal and match bytes until either not enough input or output is
   available, an end-of-block is encountered, or a data error is encountered.
   When large enough input and output buffers are supplied to inflate(), for
   example, a 16K input buffer and a 64K output buffer, more than 95% of the
   inflate execution time is spent in this routine.

   Entry assumptions:

        state->mode == LEN
        strm->avail_in >= 6
        strm->avail_out >= 258
        start >= strm->avail_out
        state->bits < 8

   On return, state->mode is one of:

        LEN -- ran out of enough output space or enough available input
        TYPE -- reached end of block code, inflate() to interpret next block
        BAD -- error in block data

   Notes:

    - The maximum input bits used by a length/distance pair is 15 bits for the
      length code, 5 bits for the length extra, 15 bits for the distance code,
      and 13 bits for the distance extra.  This totals 48 bits, or six bytes.
      Therefore if strm->avail_in >= 6, then there is enough input to avoid
      checking for available input while decoding.

    - The maximum bytes that a single length/distance pair can output is 258
      bytes, which is the maximum length that can be coded.  inflate_fast()
      requires strm->avail_out >= 258 for each loop to avoid checking for
      output space.
 */
void ZLIB_INTERNAL inflate_fast(strm, start)
z_streamp strm;
unsigned start;         /* inflate()'s starting value for strm->avail_out */
{
    struct inflate_state FAR *state;
    z_const unsigned char FAR *in;      /* local strm->next_in */
    z_const unsigned char FAR *last;    /* have enough input while in < last */
    unsigned char FAR *out;     /* local strm->next_out */
    unsigned char FAR *beg;     /* inflate()'s initial strm->next_out */
    unsigned char FAR *end;     /* while out < end, enough space available */
#ifdef INFLATE_STRICT
    unsigned dmax;              /* maximum distance from zlib header */
#endif
    unsigned wsize;             /* window size or zero if not using window */
    unsigned whave;             /* valid bytes in the window */
    unsigned wnext;             /* window write index */
    unsigned char FAR *window;  /* allocated sliding window, if wsize != 0 */
    unsigned long hold;         /* local strm->hold */
    unsigned bits;              /* local strm->bits */
    code const FAR *lcode;      /* local strm->lencode */
    code const FAR *dcode;      /* local strm->distcode */
    unsigned lmask;             /* mask for first level of length codes */
    unsigned dmask;             /* mask for first level of distance codes */
    code here;                  /* retrieved table entry */
    unsigned op;                /* code bits, operation, extra bits, or */
                                /*  window position, window bytes to copy */
    unsigned len;               /* match length, unused bytes */
    unsigned dist;              /* match distance */
    unsigned char FAR *from;    /* where to copy match from */

    /* copy state to local variables */
    state = (struct inflate_state FAR *)strm->state;
    in = strm->next_in - OFF;
    last = in + (strm->avail_in - 5);
    out = strm->next_out - OFF;
    beg = out - (start - strm->avail_out);
    end = out + (strm->avail_out - 257);
#ifdef INFLATE_STRICT
    dmax = state->dmax;
#endif
    wsize = state->wsize;
    whave = state->whave;
    wnext = state->wnext;
    window = state->window;
    hold = state->hold;
    bits = state->bits;
    lcode = state->lencode;
    dcode = state->distcode;
    lmask = (1U << state->lenbits) - 1;
    dmask = (1U << state->distbits) - 1;

    /* decode literals and length/distances until end-of-block or not enough
       input data or output space */
    do {
        if (bits < 15) {
            hold += (unsigned long)(PUP(in)) << bits;
            bits += 8;
            hold += (unsigned long)(PUP(in)) << bits;
            bits += 8;
        }
        here = lcode[hold & lmask];
      dolen:
        op = (unsigned)(here.bits);
        hold >>= op;
        bits -= op;
        op = (unsigned)(here.op);
        if (op == 0) {                          /* literal */
            Tracevv((stderr, here.val >= 0x20 && here.val < 0x7f ?
                    "inflate:         literal '%c'\n" :
                    "inflate:         literal 0x%02x\n", here.val));
            PUP(out) = (unsigned char)(here.val);
        }
        else if (op & 16) {                     /* length base */
            len = (unsigned)(here.val);
            op &= 15;                           /* number of extra bits */
            if (op) {
                if (bits < op) {
                    hold += (unsigned long)(PUP(in)) << bits;
                    bits += 8;
                }
                len += (unsigned)hold & ((1U << op) - 1);
                hold >>= op;
                bits -= op;
            }
            Tracevv((stderr, "inflate:         length %u\n", len));
            if (bits < 15) {
                hold += (unsigned long)(PUP(in)) << bits;
                bits += 8;
                hold += (unsigned long)(PUP(in)) << bits;
                bits += 8;
            }
            here = dcode[hold & dmask];
          dodist:
            op = (unsigned)(here.bits);
            hold >>= op;
            bits -= op;
            op = (unsigned)(here.op);
            if (op & 16) {                      /* distance base */
                dist = (unsigned)(here.val);
                op &= 15;                       /* number of extra bits */
                if (bits < op) {
                    hold += (unsigned long)(PUP(in)) << bits;
                    bits += 8;
                    if (bits < op) {
                        hold += (unsigned long)(PUP(in)) << bits;
                        bits += 8;
                    }
                }
                dist += (unsigned)hold & ((1U << op) - 1);
#ifdef INFLATE_STRICT
                if (dist > dmax) {
                    strm->msg = (char *)"invalid distance too far back";
                    state->mode = BAD;
                    break;
                }
#endif
                hold >>= op;
                bits -= op;
                Tracevv((stderr, "inflate:         distance %u\n", dist));
                op = (unsigned)(out - beg);     /* max distance in output */
                if (dist > op) {                /* see if copy from window */
                    op = dist - op;             /* distance back in window */
                    if (op > whave) {
                        if (state->sane) {
                            strm->msg =
                                (char *)"invalid distance too far back";
                            state->mode = BAD;
                            break;
                        }
#ifdef INFLATE_ALLOW_INVALID_DISTANCE_TOOFAR_ARRR
                        if (len <= op - whave) {
                            do {
                                PUP(out) = 0;
                            } while (--len);
                            continue;
                        }
                        len -= op - whave;
                        do {
                            PUP(out) = 0;
                        } while (--op > whave);
                        if (op == 0) {
                            from = out - dist;
                            do {
                                PUP(out) = PUP(from);
                            } while (--len);
                            continue;
                        }
#endif
                    }
                    from = window - OFF;
                    if (wnext == 0) {           /* very common case */
                        from += wsize - op;
                        if (op < len) {         /* some from window */
                            len -= op;
                            do {
                                PUP(out) = PUP(from);
                            } while (--op);
                            from = out - dist;  /* rest from output */
                        }
                    }
                    else if (wnext < op) {      /* wrap around window */
                        from += wsize + wnext - op;
                        op -= wnext;
                        if (op < len) {         /* some from end of window */
                            len -= op;
                            do {
                                PUP(out) = PUP(from);
                            } while (--op);
                            from = window - OFF;
                            if (wnext < len) {  /* some from start of window */
                                op = wnext;
                                len -= op;
                                do {
                                    PUP(out) = PUP(from);
                                } while (--op);
                                from = out - dist;      /* rest from output */
                            }
                        }
                    }
                    else {                      /* contiguous in window */
                        from += wnext - op;
                        if (op < len) {         /* some from window */
                            len -= op;
                            do {
                                PUP(out) = PUP(from);
                            } while (--op);
                            from = out - dist;  /* rest from output */
                        }
                    }
                    while (len > 2) {
                        PUP(out) = PUP(from);
                        PUP(out) = PUP(from);
                        PUP(out) = PUP(from);
                        len -= 3;
                    }
                    if (len) {
                        PUP(out) = PUP(from);
                        if (len > 1)
                            PUP(out) = PUP(from);
                    }
                }
                else {
                    from = out - dist;          /* copy direct from output */
                    do {                        /* minimum length is three */
                        PUP(out) = PUP(from);
                        PUP(out) = PUP(from);
                        PUP(out) = PUP(from);
                        len -= 3;
                    } while (len > 2);
                    if (len) {
                        PUP(out) = PUP(from);
                        if (len > 1)
                            PUP(out) = PUP(from);
                    }
                }
            }
            else if ((op & 64) == 0) {          /* 2nd level distance code */
                here = dcode[here.val + (hold & ((1U << op) - 1))];
                goto dodist;
            }
            else {
                strm->msg = (char *)"invalid distance code";
                state->mode = BAD;
                break;
            }
        }
        else if ((op & 64) == 0) {              /* 2nd level length code */
            here = lcode[here.val + (hold & ((1U << op) - 1))];
            goto dolen;
        }
        else if (op & 32) {                     /* end-of-block */
            Tracevv((stderr, "inflate:         end of block\n"));
            state->mode = TYPE;
            break;
        }
        else {
            strm->msg = (char *)"invalid literal/length code";
            state->mode = BAD;
            break;
        }
    } while (in < last && out < end);

    /* return unused bytes (on entry, bits < 8, so in won't go too far back) */
    len = bits >> 3;
    in -= len;
    bits -= len << 3;
    hold &= (1U << bits) - 1;

    /* update state and return */
    strm->next_in = in + OFF;
    strm->next_out = out + OFF;
    strm->avail_in = (unsigned)(in < last ? 5 + (last - in) : 5 - (in - last));
    strm->avail_out = (unsigned)(out < end ?
                                 257 + (end - out) : 257 - (out - end));
    state->hold = hold;
    state->bits = bits;
    return;
}

/*
   inflate_fast() speedups that turned out slower (on a PowerPC G3 750CXe):
   - Using bit fields for code structure
   - Different op definition to avoid & for extra bits (do & for table bits)
   - Three separate decoding do-loops for direct, window, and wnext == 0
   - Special case for distance > 1 copies to do overlapped load and store copy
   - Explicit branch predictions (based on measured branch probabilities)
   - Deferring match copy and interspersed it with decoding subsequent codes
   - Swapping literal/length else
   - Swapping window/direct else
   - Larger unrolled copy loops (three is about right)
   - Moving len -= 3 statement into middle of loop
 */

#endif /* !ASMINF */

/***********************************************************************
ZLIB\INFLATE.C
***********************************************************************/
/* inflate.c -- zlib decompression
 * Copyright (C) 1995-2012 Mark Adler
 * For conditions of distribution and use, see copyright notice in zlib.h
 */

/*
 * Change history:
 *
 * 1.2.beta0    24 Nov 2002
 * - First version -- complete rewrite of inflate to simplify code, avoid
 *   creation of window when not needed, minimize use of window when it is
 *   needed, make inffast.c even faster, implement gzip decoding, and to
 *   improve code readability and style over the previous zlib inflate code
 *
 * 1.2.beta1    25 Nov 2002
 * - Use pointers for available input and output checking in inffast.c
 * - Remove input and output counters in inffast.c
 * - Change inffast.c entry and loop from avail_in >= 7 to >= 6
 * - Remove unnecessary second byte pull from length extra in inffast.c
 * - Unroll direct copy to three copies per loop in inffast.c
 *
 * 1.2.beta2    4 Dec 2002
 * - Change external routine names to reduce potential conflicts
 * - Correct filename to inffixed.h for fixed tables in inflate.c
 * - Make hbuf[] unsigned char to match parameter type in inflate.c
 * - Change strm->next_out[-state->offset] to *(strm->next_out - state->offset)
 *   to avoid negation problem on Alphas (64 bit) in inflate.c
 *
 * 1.2.beta3    22 Dec 2002
 * - Add comments on state->bits assertion in inffast.c
 * - Add comments on op field in inftrees.h
 * - Fix bug in reuse of allocated window after inflateReset()
 * - Remove bit fields--back to byte structure for speed
 * - Remove distance extra == 0 check in inflate_fast()--only helps for lengths
 * - Change post-increments to pre-increments in inflate_fast(), PPC biased?
 * - Add compile time option, POSTINC, to use post-increments instead (Intel?)
 * - Make MATCH copy in inflate() much faster for when inflate_fast() not used
 * - Use local copies of stream next and avail values, as well as local bit
 *   buffer and bit count in inflate()--for speed when inflate_fast() not used
 *
 * 1.2.beta4    1 Jan 2003
 * - Split ptr - 257 statements in inflate_table() to avoid compiler warnings
 * - Move a comment on output buffer sizes from inffast.c to inflate.c
 * - Add comments in inffast.c to introduce the inflate_fast() routine
 * - Rearrange window copies in inflate_fast() for speed and simplification
 * - Unroll last copy for window match in inflate_fast()
 * - Use local copies of window variables in inflate_fast() for speed
 * - Pull out common wnext == 0 case for speed in inflate_fast()
 * - Make op and len in inflate_fast() unsigned for consistency
 * - Add FAR to lcode and dcode declarations in inflate_fast()
 * - Simplified bad distance check in inflate_fast()
 * - Added inflateBackInit(), inflateBack(), and inflateBackEnd() in new
 *   source file infback.c to provide a call-back interface to inflate for
 *   programs like gzip and unzip -- uses window as output buffer to avoid
 *   window copying
 *
 * 1.2.beta5    1 Jan 2003
 * - Improved inflateBack() interface to allow the caller to provide initial
 *   input in strm.
 * - Fixed stored blocks bug in inflateBack()
 *
 * 1.2.beta6    4 Jan 2003
 * - Added comments in inffast.c on effectiveness of POSTINC
 * - Typecasting all around to reduce compiler warnings
 * - Changed loops from while (1) or do {} while (1) to for (;;), again to
 *   make compilers happy
 * - Changed type of window in inflateBackInit() to unsigned char *
 *
 * 1.2.beta7    27 Jan 2003
 * - Changed many types to unsigned or unsigned short to avoid warnings
 * - Added inflateCopy() function
 *
 * 1.2.0        9 Mar 2003
 * - Changed inflateBack() interface to provide separate opaque descriptors
 *   for the in() and out() functions
 * - Changed inflateBack() argument and in_func typedef to swap the length
 *   and buffer address return values for the input function
 * - Check next_in and next_out for Z_NULL on entry to inflate()
 *
 * The history for versions after 1.2.0 are in ChangeLog in zlib distribution.
 */


#ifdef MAKEFIXED
#  ifndef BUILDFIXED
#    define BUILDFIXED
#  endif
#endif

/* function prototypes */
local void fixedtables OF((struct inflate_state FAR *state));
local int updatewindow OF((z_streamp strm, const unsigned char FAR *end,
                           unsigned copy));
#ifdef BUILDFIXED
   void makefixed OF((void));
#endif
local unsigned syncsearch OF((unsigned FAR *have, const unsigned char FAR *buf,
                              unsigned len));

int ZEXPORT inflateResetKeep(strm)
z_streamp strm;
{
    struct inflate_state FAR *state;

    if (strm == Z_NULL || strm->state == Z_NULL) return Z_STREAM_ERROR;
    state = (struct inflate_state FAR *)strm->state;
    strm->total_in = strm->total_out = state->total = 0;
    strm->msg = Z_NULL;
    if (state->wrap)        /* to support ill-conceived Java test suite */
        strm->adler = state->wrap & 1;
    state->mode = HEAD;
    state->last = 0;
    state->havedict = 0;
    state->dmax = 32768U;
    state->head = Z_NULL;
    state->hold = 0;
    state->bits = 0;
    state->lencode = state->distcode = state->next = state->codes;
    state->sane = 1;
    state->back = -1;
    Tracev((stderr, "inflate: reset\n"));
    return Z_OK;
}

int ZEXPORT inflateReset(strm)
z_streamp strm;
{
    struct inflate_state FAR *state;

    if (strm == Z_NULL || strm->state == Z_NULL) return Z_STREAM_ERROR;
    state = (struct inflate_state FAR *)strm->state;
    state->wsize = 0;
    state->whave = 0;
    state->wnext = 0;
    return inflateResetKeep(strm);
}

int ZEXPORT inflateReset2(strm, windowBits)
z_streamp strm;
int windowBits;
{
    int wrap;
    struct inflate_state FAR *state;

    /* get the state */
    if (strm == Z_NULL || strm->state == Z_NULL) return Z_STREAM_ERROR;
    state = (struct inflate_state FAR *)strm->state;

    /* extract wrap request from windowBits parameter */
    if (windowBits < 0) {
        wrap = 0;
        windowBits = -windowBits;
    }
    else {
        wrap = (windowBits >> 4) + 1;
#ifdef GUNZIP
        if (windowBits < 48)
            windowBits &= 15;
#endif
    }

    /* set number of window bits, free window if different */
    if (windowBits && (windowBits < 8 || windowBits > 15))
        return Z_STREAM_ERROR;
    if (state->window != Z_NULL && state->wbits != (unsigned)windowBits) {
        ZFREE(strm, state->window);
        state->window = Z_NULL;
    }

    /* update state and reset the rest of it */
    state->wrap = wrap;
    state->wbits = (unsigned)windowBits;
    return inflateReset(strm);
}

int ZEXPORT inflateInit2_(strm, windowBits, version, stream_size)
z_streamp strm;
int windowBits;
const char *version;
int stream_size;
{
    int ret;
    struct inflate_state FAR *state;

    if (version == Z_NULL || version[0] != ZLIB_VERSION[0] ||
        stream_size != (int)(sizeof(z_stream)))
        return Z_VERSION_ERROR;
    if (strm == Z_NULL) return Z_STREAM_ERROR;
    strm->msg = Z_NULL;                 /* in case we return an error */
    if (strm->zalloc == (alloc_func)0) {
#ifdef Z_SOLO
        return Z_STREAM_ERROR;
#else
        strm->zalloc = zcalloc;
        strm->opaque = (voidpf)0;
#endif
    }
    if (strm->zfree == (free_func)0)
#ifdef Z_SOLO
        return Z_STREAM_ERROR;
#else
        strm->zfree = zcfree;
#endif
    state = (struct inflate_state FAR *)
            ZALLOC(strm, 1, sizeof(struct inflate_state));
    if (state == Z_NULL) return Z_MEM_ERROR;
    Tracev((stderr, "inflate: allocated\n"));
    strm->state = (struct internal_state FAR *)state;
    state->window = Z_NULL;
    ret = inflateReset2(strm, windowBits);
    if (ret != Z_OK) {
        ZFREE(strm, state);
        strm->state = Z_NULL;
    }
    return ret;
}

int ZEXPORT inflateInit_(strm, version, stream_size)
z_streamp strm;
const char *version;
int stream_size;
{
    return inflateInit2_(strm, DEF_WBITS, version, stream_size);
}

int ZEXPORT inflatePrime(strm, bits, value)
z_streamp strm;
int bits;
int value;
{
    struct inflate_state FAR *state;

    if (strm == Z_NULL || strm->state == Z_NULL) return Z_STREAM_ERROR;
    state = (struct inflate_state FAR *)strm->state;
    if (bits < 0) {
        state->hold = 0;
        state->bits = 0;
        return Z_OK;
    }
    if (bits > 16 || state->bits + bits > 32) return Z_STREAM_ERROR;
    value &= (1L << bits) - 1;
    state->hold += value << state->bits;
    state->bits += bits;
    return Z_OK;
}

/*
   Return state with length and distance decoding tables and index sizes set to
   fixed code decoding.  Normally this returns fixed tables from inffixed.h.
   If BUILDFIXED is defined, then instead this routine builds the tables the
   first time it's called, and returns those tables the first time and
   thereafter.  This reduces the size of the code by about 2K bytes, in
   exchange for a little execution time.  However, BUILDFIXED should not be
   used for threaded applications, since the rewriting of the tables and virgin
   may not be thread-safe.
 */
local void fixedtables(state)
struct inflate_state FAR *state;
{
#ifdef BUILDFIXED
    static int virgin = 1;
    static code *lenfix, *distfix;
    static code fixed[544];

    /* build fixed huffman tables if first call (may not be thread safe) */
    if (virgin) {
        unsigned sym, bits;
        static code *next;

        /* literal/length table */
        sym = 0;
        while (sym < 144) state->lens[sym++] = 8;
        while (sym < 256) state->lens[sym++] = 9;
        while (sym < 280) state->lens[sym++] = 7;
        while (sym < 288) state->lens[sym++] = 8;
        next = fixed;
        lenfix = next;
        bits = 9;
        inflate_table(LENS, state->lens, 288, &(next), &(bits), state->work);

        /* distance table */
        sym = 0;
        while (sym < 32) state->lens[sym++] = 5;
        distfix = next;
        bits = 5;
        inflate_table(DISTS, state->lens, 32, &(next), &(bits), state->work);

        /* do this just once */
        virgin = 0;
    }
#else /* !BUILDFIXED */
#   include "inffixed.h"
#endif /* BUILDFIXED */
    state->lencode = lenfix;
    state->lenbits = 9;
    state->distcode = distfix;
    state->distbits = 5;
}

#ifdef MAKEFIXED

/*
   Write out the inffixed.h that is #include'd above.  Defining MAKEFIXED also
   defines BUILDFIXED, so the tables are built on the fly.  makefixed() writes
   those tables to stdout, which would be piped to inffixed.h.  A small program
   can simply call makefixed to do this:

    void makefixed(void);

    int main(void)
    {
        makefixed();
        return 0;
    }

   Then that can be linked with zlib built with MAKEFIXED defined and run:

    a.out > inffixed.h
 */
void makefixed()
{
    unsigned low, size;
    struct inflate_state state;

    fixedtables(&state);
    puts("    /* inffixed.h -- table for decoding fixed codes");
    puts("     * Generated automatically by makefixed().");
    puts("     */");
    puts("");
    puts("    /* WARNING: this file should *not* be used by applications.");
    puts("       It is part of the implementation of this library and is");
    puts("       subject to change. Applications should only use zlib.h.");
    puts("     */");
    puts("");
    size = 1U << 9;
    printf("    static const code lenfix[%u] = {", size);
    low = 0;
    for (;;) {
        if ((low % 7) == 0) printf("\n        ");
        printf("{%u,%u,%d}", (low & 127) == 99 ? 64 : state.lencode[low].op,
               state.lencode[low].bits, state.lencode[low].val);
        if (++low == size) break;
        putchar(',');
    }
    puts("\n    };");
    size = 1U << 5;
    printf("\n    static const code distfix[%u] = {", size);
    low = 0;
    for (;;) {
        if ((low % 6) == 0) printf("\n        ");
        printf("{%u,%u,%d}", state.distcode[low].op, state.distcode[low].bits,
               state.distcode[low].val);
        if (++low == size) break;
        putchar(',');
    }
    puts("\n    };");
}
#endif /* MAKEFIXED */

/*
   Update the window with the last wsize (normally 32K) bytes written before
   returning.  If window does not exist yet, create it.  This is only called
   when a window is already in use, or when output has been written during this
   inflate call, but the end of the deflate stream has not been reached yet.
   It is also called to create a window for dictionary data when a dictionary
   is loaded.

   Providing output buffers larger than 32K to inflate() should provide a speed
   advantage, since only the last 32K of output is copied to the sliding window
   upon return from inflate(), and since all distances after the first 32K of
   output will fall in the output data, making match copies simpler and faster.
   The advantage may be dependent on the size of the processor's data caches.
 */
local int updatewindow(strm, end, copy)
z_streamp strm;
const Bytef *end;
unsigned copy;
{
    struct inflate_state FAR *state;
    unsigned dist;

    state = (struct inflate_state FAR *)strm->state;

    /* if it hasn't been done already, allocate space for the window */
    if (state->window == Z_NULL) {
        state->window = (unsigned char FAR *)
                        ZALLOC(strm, 1U << state->wbits,
                               sizeof(unsigned char));
        if (state->window == Z_NULL) return 1;
    }

    /* if window not in use yet, initialize */
    if (state->wsize == 0) {
        state->wsize = 1U << state->wbits;
        state->wnext = 0;
        state->whave = 0;
    }

    /* copy state->wsize or less output bytes into the circular window */
    if (copy >= state->wsize) {
        zmemcpy(state->window, end - state->wsize, state->wsize);
        state->wnext = 0;
        state->whave = state->wsize;
    }
    else {
        dist = state->wsize - state->wnext;
        if (dist > copy) dist = copy;
        zmemcpy(state->window + state->wnext, end - copy, dist);
        copy -= dist;
        if (copy) {
            zmemcpy(state->window, end - copy, copy);
            state->wnext = copy;
            state->whave = state->wsize;
        }
        else {
            state->wnext += dist;
            if (state->wnext == state->wsize) state->wnext = 0;
            if (state->whave < state->wsize) state->whave += dist;
        }
    }
    return 0;
}

/* Macros for inflate(): */

/* check function to use adler32() for zlib or crc32() for gzip */
#ifdef GUNZIP
#  define UPDATE(check, buf, len) \
    (state->flags ? crc32(check, buf, len) : adler32(check, buf, len))
#else
#  define UPDATE(check, buf, len) adler32(check, buf, len)
#endif

/* check macros for header crc */
#ifdef GUNZIP
#  define CRC2(check, word) \
    do { \
        hbuf[0] = (unsigned char)(word); \
        hbuf[1] = (unsigned char)((word) >> 8); \
        check = crc32(check, hbuf, 2); \
    } while (0)

#  define CRC4(check, word) \
    do { \
        hbuf[0] = (unsigned char)(word); \
        hbuf[1] = (unsigned char)((word) >> 8); \
        hbuf[2] = (unsigned char)((word) >> 16); \
        hbuf[3] = (unsigned char)((word) >> 24); \
        check = crc32(check, hbuf, 4); \
    } while (0)
#endif

/* Load registers with state in inflate() for speed */
#define LOAD() \
    do { \
        put = strm->next_out; \
        left = strm->avail_out; \
        next = strm->next_in; \
        have = strm->avail_in; \
        hold = state->hold; \
        bits = state->bits; \
    } while (0)

/* Restore state from registers in inflate() */
#define RESTORE() \
    do { \
        strm->next_out = put; \
        strm->avail_out = left; \
        strm->next_in = next; \
        strm->avail_in = have; \
        state->hold = hold; \
        state->bits = bits; \
    } while (0)

/* Clear the input bit accumulator */
#define INITBITS() \
    do { \
        hold = 0; \
        bits = 0; \
    } while (0)

/* Get a byte of input into the bit accumulator, or return from inflate()
   if there is no input available. */
#define PULLBYTE() \
    do { \
        if (have == 0) goto inf_leave; \
        have--; \
        hold += (unsigned long)(*next++) << bits; \
        bits += 8; \
    } while (0)

/* Assure that there are at least n bits in the bit accumulator.  If there is
   not enough available input to do that, then return from inflate(). */
#define NEEDBITS(n) \
    do { \
        while (bits < (unsigned)(n)) \
            PULLBYTE(); \
    } while (0)

/* Return the low n bits of the bit accumulator (n < 16) */
#define BITS(n) \
    ((unsigned)hold & ((1U << (n)) - 1))

/* Remove n bits from the bit accumulator */
#define DROPBITS(n) \
    do { \
        hold >>= (n); \
        bits -= (unsigned)(n); \
    } while (0)

/* Remove zero to seven bits as needed to go to a byte boundary */
#define BYTEBITS() \
    do { \
        hold >>= bits & 7; \
        bits -= bits & 7; \
    } while (0)

/*
   inflate() uses a state machine to process as much input data and generate as
   much output data as possible before returning.  The state machine is
   structured roughly as follows:

    for (;;) switch (state) {
    ...
    case STATEn:
        if (not enough input data or output space to make progress)
            return;
        ... make progress ...
        state = STATEm;
        break;
    ...
    }

   so when inflate() is called again, the same case is attempted again, and
   if the appropriate resources are provided, the machine proceeds to the
   next state.  The NEEDBITS() macro is usually the way the state evaluates
   whether it can proceed or should return.  NEEDBITS() does the return if
   the requested bits are not available.  The typical use of the BITS macros
   is:

        NEEDBITS(n);
        ... do something with BITS(n) ...
        DROPBITS(n);

   where NEEDBITS(n) either returns from inflate() if there isn't enough
   input left to load n bits into the accumulator, or it continues.  BITS(n)
   gives the low n bits in the accumulator.  When done, DROPBITS(n) drops
   the low n bits off the accumulator.  INITBITS() clears the accumulator
   and sets the number of available bits to zero.  BYTEBITS() discards just
   enough bits to put the accumulator on a byte boundary.  After BYTEBITS()
   and a NEEDBITS(8), then BITS(8) would return the next byte in the stream.

   NEEDBITS(n) uses PULLBYTE() to get an available byte of input, or to return
   if there is no input available.  The decoding of variable length codes uses
   PULLBYTE() directly in order to pull just enough bytes to decode the next
   code, and no more.

   Some states loop until they get enough input, making sure that enough
   state information is maintained to continue the loop where it left off
   if NEEDBITS() returns in the loop.  For example, want, need, and keep
   would all have to actually be part of the saved state in case NEEDBITS()
   returns:

    case STATEw:
        while (want < need) {
            NEEDBITS(n);
            keep[want++] = BITS(n);
            DROPBITS(n);
        }
        state = STATEx;
    case STATEx:

   As shown above, if the next state is also the next case, then the break
   is omitted.

   A state may also return if there is not enough output space available to
   complete that state.  Those states are copying stored data, writing a
   literal byte, and copying a matching string.

   When returning, a "goto inf_leave" is used to update the total counters,
   update the check value, and determine whether any progress has been made
   during that inflate() call in order to return the proper return code.
   Progress is defined as a change in either strm->avail_in or strm->avail_out.
   When there is a window, goto inf_leave will update the window with the last
   output written.  If a goto inf_leave occurs in the middle of decompression
   and there is no window currently, goto inf_leave will create one and copy
   output to the window for the next call of inflate().

   In this implementation, the flush parameter of inflate() only affects the
   return code (per zlib.h).  inflate() always writes as much as possible to
   strm->next_out, given the space available and the provided input--the effect
   documented in zlib.h of Z_SYNC_FLUSH.  Furthermore, inflate() always defers
   the allocation of and copying into a sliding window until necessary, which
   provides the effect documented in zlib.h for Z_FINISH when the entire input
   stream available.  So the only thing the flush parameter actually does is:
   when flush is set to Z_FINISH, inflate() cannot return Z_OK.  Instead it
   will return Z_BUF_ERROR if it has not reached the end of the stream.
 */

int ZEXPORT inflate(strm, flush)
z_streamp strm;
int flush;
{
    struct inflate_state FAR *state;
    z_const unsigned char FAR *next;    /* next input */
    unsigned char FAR *put;     /* next output */
    unsigned have, left;        /* available input and output */
    unsigned long hold;         /* bit buffer */
    unsigned bits;              /* bits in bit buffer */
    unsigned in, out;           /* save starting available input and output */
    unsigned copy;              /* number of stored or match bytes to copy */
    unsigned char FAR *from;    /* where to copy match bytes from */
    code here;                  /* current decoding table entry */
    code last;                  /* parent table entry */
    unsigned len;               /* length to copy for repeats, bits to drop */
    int ret;                    /* return code */
#ifdef GUNZIP
    unsigned char hbuf[4];      /* buffer for gzip header crc calculation */
#endif
    static const unsigned short order[19] = /* permutation of code lengths */
        {16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15};

    if (strm == Z_NULL || strm->state == Z_NULL || strm->next_out == Z_NULL ||
        (strm->next_in == Z_NULL && strm->avail_in != 0))
        return Z_STREAM_ERROR;

    state = (struct inflate_state FAR *)strm->state;
    if (state->mode == TYPE) state->mode = TYPEDO;      /* skip check */
    LOAD();
    in = have;
    out = left;
    ret = Z_OK;
    for (;;)
        switch (state->mode) {
        case HEAD:
            if (state->wrap == 0) {
                state->mode = TYPEDO;
                break;
            }
            NEEDBITS(16);
#ifdef GUNZIP
            if ((state->wrap & 2) && hold == 0x8b1f) {  /* gzip header */
                state->check = crc32(0L, Z_NULL, 0);
                CRC2(state->check, hold);
                INITBITS();
                state->mode = FLAGS;
                break;
            }
            state->flags = 0;           /* expect zlib header */
            if (state->head != Z_NULL)
                state->head->done = -1;
            if (!(state->wrap & 1) ||   /* check if zlib header allowed */
#else
            if (
#endif
                ((BITS(8) << 8) + (hold >> 8)) % 31) {
                strm->msg = (char *)"incorrect header check";
                state->mode = BAD;
                break;
            }
            if (BITS(4) != Z_DEFLATED) {
                strm->msg = (char *)"unknown compression method";
                state->mode = BAD;
                break;
            }
            DROPBITS(4);
            len = BITS(4) + 8;
            if (state->wbits == 0)
                state->wbits = len;
            else if (len > state->wbits) {
                strm->msg = (char *)"invalid window size";
                state->mode = BAD;
                break;
            }
            state->dmax = 1U << len;
            Tracev((stderr, "inflate:   zlib header ok\n"));
            strm->adler = state->check = adler32(0L, Z_NULL, 0);
            state->mode = hold & 0x200 ? DICTID : TYPE;
            INITBITS();
            break;
#ifdef GUNZIP
        case FLAGS:
            NEEDBITS(16);
            state->flags = (int)(hold);
            if ((state->flags & 0xff) != Z_DEFLATED) {
                strm->msg = (char *)"unknown compression method";
                state->mode = BAD;
                break;
            }
            if (state->flags & 0xe000) {
                strm->msg = (char *)"unknown header flags set";
                state->mode = BAD;
                break;
            }
            if (state->head != Z_NULL)
                state->head->text = (int)((hold >> 8) & 1);
            if (state->flags & 0x0200) CRC2(state->check, hold);
            INITBITS();
            state->mode = TIME;
        case TIME:
            NEEDBITS(32);
            if (state->head != Z_NULL)
                state->head->time = hold;
            if (state->flags & 0x0200) CRC4(state->check, hold);
            INITBITS();
            state->mode = OS;
        case OS:
            NEEDBITS(16);
            if (state->head != Z_NULL) {
                state->head->xflags = (int)(hold & 0xff);
                state->head->os = (int)(hold >> 8);
            }
            if (state->flags & 0x0200) CRC2(state->check, hold);
            INITBITS();
            state->mode = EXLEN;
        case EXLEN:
            if (state->flags & 0x0400) {
                NEEDBITS(16);
                state->length = (unsigned)(hold);
                if (state->head != Z_NULL)
                    state->head->extra_len = (unsigned)hold;
                if (state->flags & 0x0200) CRC2(state->check, hold);
                INITBITS();
            }
            else if (state->head != Z_NULL)
                state->head->extra = Z_NULL;
            state->mode = EXTRA;
        case EXTRA:
            if (state->flags & 0x0400) {
                copy = state->length;
                if (copy > have) copy = have;
                if (copy) {
                    if (state->head != Z_NULL &&
                        state->head->extra != Z_NULL) {
                        len = state->head->extra_len - state->length;
                        zmemcpy(state->head->extra + len, next,
                                len + copy > state->head->extra_max ?
                                state->head->extra_max - len : copy);
                    }
                    if (state->flags & 0x0200)
                        state->check = crc32(state->check, next, copy);
                    have -= copy;
                    next += copy;
                    state->length -= copy;
                }
                if (state->length) goto inf_leave;
            }
            state->length = 0;
            state->mode = NAME;
        case NAME:
            if (state->flags & 0x0800) {
                if (have == 0) goto inf_leave;
                copy = 0;
                do {
                    len = (unsigned)(next[copy++]);
                    if (state->head != Z_NULL &&
                            state->head->name != Z_NULL &&
                            state->length < state->head->name_max)
                        state->head->name[state->length++] = len;
                } while (len && copy < have);
                if (state->flags & 0x0200)
                    state->check = crc32(state->check, next, copy);
                have -= copy;
                next += copy;
                if (len) goto inf_leave;
            }
            else if (state->head != Z_NULL)
                state->head->name = Z_NULL;
            state->length = 0;
            state->mode = COMMENT;
        case COMMENT:
            if (state->flags & 0x1000) {
                if (have == 0) goto inf_leave;
                copy = 0;
                do {
                    len = (unsigned)(next[copy++]);
                    if (state->head != Z_NULL &&
                            state->head->comment != Z_NULL &&
                            state->length < state->head->comm_max)
                        state->head->comment[state->length++] = len;
                } while (len && copy < have);
                if (state->flags & 0x0200)
                    state->check = crc32(state->check, next, copy);
                have -= copy;
                next += copy;
                if (len) goto inf_leave;
            }
            else if (state->head != Z_NULL)
                state->head->comment = Z_NULL;
            state->mode = HCRC;
        case HCRC:
            if (state->flags & 0x0200) {
                NEEDBITS(16);
                if (hold != (state->check & 0xffff)) {
                    strm->msg = (char *)"header crc mismatch";
                    state->mode = BAD;
                    break;
                }
                INITBITS();
            }
            if (state->head != Z_NULL) {
                state->head->hcrc = (int)((state->flags >> 9) & 1);
                state->head->done = 1;
            }
            strm->adler = state->check = crc32(0L, Z_NULL, 0);
            state->mode = TYPE;
            break;
#endif
        case DICTID:
            NEEDBITS(32);
            strm->adler = state->check = ZSWAP32(hold);
            INITBITS();
            state->mode = DICT;
        case DICT:
            if (state->havedict == 0) {
                RESTORE();
                return Z_NEED_DICT;
            }
            strm->adler = state->check = adler32(0L, Z_NULL, 0);
            state->mode = TYPE;
        case TYPE:
            if (flush == Z_BLOCK || flush == Z_TREES) goto inf_leave;
        case TYPEDO:
            if (state->last) {
                BYTEBITS();
                state->mode = CHECK;
                break;
            }
            NEEDBITS(3);
            state->last = BITS(1);
            DROPBITS(1);
            switch (BITS(2)) {
            case 0:                             /* stored block */
                Tracev((stderr, "inflate:     stored block%s\n",
                        state->last ? " (last)" : ""));
                state->mode = STORED;
                break;
            case 1:                             /* fixed block */
                fixedtables(state);
                Tracev((stderr, "inflate:     fixed codes block%s\n",
                        state->last ? " (last)" : ""));
                state->mode = LEN_;             /* decode codes */
                if (flush == Z_TREES) {
                    DROPBITS(2);
                    goto inf_leave;
                }
                break;
            case 2:                             /* dynamic block */
                Tracev((stderr, "inflate:     dynamic codes block%s\n",
                        state->last ? " (last)" : ""));
                state->mode = TABLE;
                break;
            case 3:
                strm->msg = (char *)"invalid block type";
                state->mode = BAD;
            }
            DROPBITS(2);
            break;
        case STORED:
            BYTEBITS();                         /* go to byte boundary */
            NEEDBITS(32);
            if ((hold & 0xffff) != ((hold >> 16) ^ 0xffff)) {
                strm->msg = (char *)"invalid stored block lengths";
                state->mode = BAD;
                break;
            }
            state->length = (unsigned)hold & 0xffff;
            Tracev((stderr, "inflate:       stored length %u\n",
                    state->length));
            INITBITS();
            state->mode = COPY_;
            if (flush == Z_TREES) goto inf_leave;
        case COPY_:
            state->mode = COPY;
        case COPY:
            copy = state->length;
            if (copy) {
                if (copy > have) copy = have;
                if (copy > left) copy = left;
                if (copy == 0) goto inf_leave;
                zmemcpy(put, next, copy);
                have -= copy;
                next += copy;
                left -= copy;
                put += copy;
                state->length -= copy;
                break;
            }
            Tracev((stderr, "inflate:       stored end\n"));
            state->mode = TYPE;
            break;
        case TABLE:
            NEEDBITS(14);
            state->nlen = BITS(5) + 257;
            DROPBITS(5);
            state->ndist = BITS(5) + 1;
            DROPBITS(5);
            state->ncode = BITS(4) + 4;
            DROPBITS(4);
#ifndef PKZIP_BUG_WORKAROUND
            if (state->nlen > 286 || state->ndist > 30) {
                strm->msg = (char *)"too many length or distance symbols";
                state->mode = BAD;
                break;
            }
#endif
            Tracev((stderr, "inflate:       table sizes ok\n"));
            state->have = 0;
            state->mode = LENLENS;
        case LENLENS:
            while (state->have < state->ncode) {
                NEEDBITS(3);
                state->lens[order[state->have++]] = (unsigned short)BITS(3);
                DROPBITS(3);
            }
            while (state->have < 19)
                state->lens[order[state->have++]] = 0;
            state->next = state->codes;
            state->lencode = (const code FAR *)(state->next);
            state->lenbits = 7;
            ret = inflate_table(CODES, state->lens, 19, &(state->next),
                                &(state->lenbits), state->work);
            if (ret) {
                strm->msg = (char *)"invalid code lengths set";
                state->mode = BAD;
                break;
            }
            Tracev((stderr, "inflate:       code lengths ok\n"));
            state->have = 0;
            state->mode = CODELENS;
        case CODELENS:
            while (state->have < state->nlen + state->ndist) {
                for (;;) {
                    here = state->lencode[BITS(state->lenbits)];
                    if ((unsigned)(here.bits) <= bits) break;
                    PULLBYTE();
                }
                if (here.val < 16) {
                    DROPBITS(here.bits);
                    state->lens[state->have++] = here.val;
                }
                else {
                    if (here.val == 16) {
                        NEEDBITS(here.bits + 2);
                        DROPBITS(here.bits);
                        if (state->have == 0) {
                            strm->msg = (char *)"invalid bit length repeat";
                            state->mode = BAD;
                            break;
                        }
                        len = state->lens[state->have - 1];
                        copy = 3 + BITS(2);
                        DROPBITS(2);
                    }
                    else if (here.val == 17) {
                        NEEDBITS(here.bits + 3);
                        DROPBITS(here.bits);
                        len = 0;
                        copy = 3 + BITS(3);
                        DROPBITS(3);
                    }
                    else {
                        NEEDBITS(here.bits + 7);
                        DROPBITS(here.bits);
                        len = 0;
                        copy = 11 + BITS(7);
                        DROPBITS(7);
                    }
                    if (state->have + copy > state->nlen + state->ndist) {
                        strm->msg = (char *)"invalid bit length repeat";
                        state->mode = BAD;
                        break;
                    }
                    while (copy--)
                        state->lens[state->have++] = (unsigned short)len;
                }
            }

            /* handle error breaks in while */
            if (state->mode == BAD) break;

            /* check for end-of-block code (better have one) */
            if (state->lens[256] == 0) {
                strm->msg = (char *)"invalid code -- missing end-of-block";
                state->mode = BAD;
                break;
            }

            /* build code tables -- note: do not change the lenbits or distbits
               values here (9 and 6) without reading the comments in inftrees.h
               concerning the ENOUGH constants, which depend on those values */
            state->next = state->codes;
            state->lencode = (const code FAR *)(state->next);
            state->lenbits = 9;
            ret = inflate_table(LENS, state->lens, state->nlen, &(state->next),
                                &(state->lenbits), state->work);
            if (ret) {
                strm->msg = (char *)"invalid literal/lengths set";
                state->mode = BAD;
                break;
            }
            state->distcode = (const code FAR *)(state->next);
            state->distbits = 6;
            ret = inflate_table(DISTS, state->lens + state->nlen, state->ndist,
                            &(state->next), &(state->distbits), state->work);
            if (ret) {
                strm->msg = (char *)"invalid distances set";
                state->mode = BAD;
                break;
            }
            Tracev((stderr, "inflate:       codes ok\n"));
            state->mode = LEN_;
            if (flush == Z_TREES) goto inf_leave;
        case LEN_:
            state->mode = LEN;
        case LEN:
            if (have >= 6 && left >= 258) {
                RESTORE();
                inflate_fast(strm, out);
                LOAD();
                if (state->mode == TYPE)
                    state->back = -1;
                break;
            }
            state->back = 0;
            for (;;) {
                here = state->lencode[BITS(state->lenbits)];
                if ((unsigned)(here.bits) <= bits) break;
                PULLBYTE();
            }
            if (here.op && (here.op & 0xf0) == 0) {
                last = here;
                for (;;) {
                    here = state->lencode[last.val +
                            (BITS(last.bits + last.op) >> last.bits)];
                    if ((unsigned)(last.bits + here.bits) <= bits) break;
                    PULLBYTE();
                }
                DROPBITS(last.bits);
                state->back += last.bits;
            }
            DROPBITS(here.bits);
            state->back += here.bits;
            state->length = (unsigned)here.val;
            if ((int)(here.op) == 0) {
                Tracevv((stderr, here.val >= 0x20 && here.val < 0x7f ?
                        "inflate:         literal '%c'\n" :
                        "inflate:         literal 0x%02x\n", here.val));
                state->mode = LIT;
                break;
            }
            if (here.op & 32) {
                Tracevv((stderr, "inflate:         end of block\n"));
                state->back = -1;
                state->mode = TYPE;
                break;
            }
            if (here.op & 64) {
                strm->msg = (char *)"invalid literal/length code";
                state->mode = BAD;
                break;
            }
            state->extra = (unsigned)(here.op) & 15;
            state->mode = LENEXT;
        case LENEXT:
            if (state->extra) {
                NEEDBITS(state->extra);
                state->length += BITS(state->extra);
                DROPBITS(state->extra);
                state->back += state->extra;
            }
            Tracevv((stderr, "inflate:         length %u\n", state->length));
            state->was = state->length;
            state->mode = DIST;
        case DIST:
            for (;;) {
                here = state->distcode[BITS(state->distbits)];
                if ((unsigned)(here.bits) <= bits) break;
                PULLBYTE();
            }
            if ((here.op & 0xf0) == 0) {
                last = here;
                for (;;) {
                    here = state->distcode[last.val +
                            (BITS(last.bits + last.op) >> last.bits)];
                    if ((unsigned)(last.bits + here.bits) <= bits) break;
                    PULLBYTE();
                }
                DROPBITS(last.bits);
                state->back += last.bits;
            }
            DROPBITS(here.bits);
            state->back += here.bits;
            if (here.op & 64) {
                strm->msg = (char *)"invalid distance code";
                state->mode = BAD;
                break;
            }
            state->offset = (unsigned)here.val;
            state->extra = (unsigned)(here.op) & 15;
            state->mode = DISTEXT;
        case DISTEXT:
            if (state->extra) {
                NEEDBITS(state->extra);
                state->offset += BITS(state->extra);
                DROPBITS(state->extra);
                state->back += state->extra;
            }
#ifdef INFLATE_STRICT
            if (state->offset > state->dmax) {
                strm->msg = (char *)"invalid distance too far back";
                state->mode = BAD;
                break;
            }
#endif
            Tracevv((stderr, "inflate:         distance %u\n", state->offset));
            state->mode = MATCH;
        case MATCH:
            if (left == 0) goto inf_leave;
            copy = out - left;
            if (state->offset > copy) {         /* copy from window */
                copy = state->offset - copy;
                if (copy > state->whave) {
                    if (state->sane) {
                        strm->msg = (char *)"invalid distance too far back";
                        state->mode = BAD;
                        break;
                    }
#ifdef INFLATE_ALLOW_INVALID_DISTANCE_TOOFAR_ARRR
                    Trace((stderr, "inflate.c too far\n"));
                    copy -= state->whave;
                    if (copy > state->length) copy = state->length;
                    if (copy > left) copy = left;
                    left -= copy;
                    state->length -= copy;
                    do {
                        *put++ = 0;
                    } while (--copy);
                    if (state->length == 0) state->mode = LEN;
                    break;
#endif
                }
                if (copy > state->wnext) {
                    copy -= state->wnext;
                    from = state->window + (state->wsize - copy);
                }
                else
                    from = state->window + (state->wnext - copy);
                if (copy > state->length) copy = state->length;
            }
            else {                              /* copy from output */
                from = put - state->offset;
                copy = state->length;
            }
            if (copy > left) copy = left;
            left -= copy;
            state->length -= copy;
            do {
                *put++ = *from++;
            } while (--copy);
            if (state->length == 0) state->mode = LEN;
            break;
        case LIT:
            if (left == 0) goto inf_leave;
            *put++ = (unsigned char)(state->length);
            left--;
            state->mode = LEN;
            break;
        case CHECK:
            if (state->wrap) {
                NEEDBITS(32);
                out -= left;
                strm->total_out += out;
                state->total += out;
                if (out)
                    strm->adler = state->check =
                        UPDATE(state->check, put - out, out);
                out = left;
                if ((
#ifdef GUNZIP
                     state->flags ? hold :
#endif
                     ZSWAP32(hold)) != state->check) {
                    strm->msg = (char *)"incorrect data check";
                    state->mode = BAD;
                    break;
                }
                INITBITS();
                Tracev((stderr, "inflate:   check matches trailer\n"));
            }
#ifdef GUNZIP
            state->mode = LENGTH;
        case LENGTH:
            if (state->wrap && state->flags) {
                NEEDBITS(32);
                if (hold != (state->total & 0xffffffffUL)) {
                    strm->msg = (char *)"incorrect length check";
                    state->mode = BAD;
                    break;
                }
                INITBITS();
                Tracev((stderr, "inflate:   length matches trailer\n"));
            }
#endif
            state->mode = DONE;
        case DONE:
            ret = Z_STREAM_END;
            goto inf_leave;
        case BAD:
            ret = Z_DATA_ERROR;
            goto inf_leave;
        case MEM:
            return Z_MEM_ERROR;
        case SYNC:
        default:
            return Z_STREAM_ERROR;
        }

    /*
       Return from inflate(), updating the total counts and the check value.
       If there was no progress during the inflate() call, return a buffer
       error.  Call updatewindow() to create and/or update the window state.
       Note: a memory error from inflate() is non-recoverable.
     */
  inf_leave:
    RESTORE();
    if (state->wsize || (out != strm->avail_out && state->mode < BAD &&
            (state->mode < CHECK || flush != Z_FINISH)))
        if (updatewindow(strm, strm->next_out, out - strm->avail_out)) {
            state->mode = MEM;
            return Z_MEM_ERROR;
        }
    in -= strm->avail_in;
    out -= strm->avail_out;
    strm->total_in += in;
    strm->total_out += out;
    state->total += out;
    if (state->wrap && out)
        strm->adler = state->check =
            UPDATE(state->check, strm->next_out - out, out);
    strm->data_type = state->bits + (state->last ? 64 : 0) +
                      (state->mode == TYPE ? 128 : 0) +
                      (state->mode == LEN_ || state->mode == COPY_ ? 256 : 0);
    if (((in == 0 && out == 0) || flush == Z_FINISH) && ret == Z_OK)
        ret = Z_BUF_ERROR;
    return ret;
}

int ZEXPORT inflateEnd(strm)
z_streamp strm;
{
    struct inflate_state FAR *state;
    if (strm == Z_NULL || strm->state == Z_NULL || strm->zfree == (free_func)0)
        return Z_STREAM_ERROR;
    state = (struct inflate_state FAR *)strm->state;
    if (state->window != Z_NULL) ZFREE(strm, state->window);
    ZFREE(strm, strm->state);
    strm->state = Z_NULL;
    Tracev((stderr, "inflate: end\n"));
    return Z_OK;
}

int ZEXPORT inflateGetDictionary(strm, dictionary, dictLength)
z_streamp strm;
Bytef *dictionary;
uInt *dictLength;
{
    struct inflate_state FAR *state;

    /* check state */
    if (strm == Z_NULL || strm->state == Z_NULL) return Z_STREAM_ERROR;
    state = (struct inflate_state FAR *)strm->state;

    /* copy dictionary */
    if (state->whave && dictionary != Z_NULL) {
        zmemcpy(dictionary, state->window + state->wnext,
                state->whave - state->wnext);
        zmemcpy(dictionary + state->whave - state->wnext,
                state->window, state->wnext);
    }
    if (dictLength != Z_NULL)
        *dictLength = state->whave;
    return Z_OK;
}

int ZEXPORT inflateSetDictionary(strm, dictionary, dictLength)
z_streamp strm;
const Bytef *dictionary;
uInt dictLength;
{
    struct inflate_state FAR *state;
    unsigned long dictid;
    int ret;

    /* check state */
    if (strm == Z_NULL || strm->state == Z_NULL) return Z_STREAM_ERROR;
    state = (struct inflate_state FAR *)strm->state;
    if (state->wrap != 0 && state->mode != DICT)
        return Z_STREAM_ERROR;

    /* check for correct dictionary identifier */
    if (state->mode == DICT) {
        dictid = adler32(0L, Z_NULL, 0);
        dictid = adler32(dictid, dictionary, dictLength);
        if (dictid != state->check)
            return Z_DATA_ERROR;
    }

    /* copy dictionary to window using updatewindow(), which will amend the
       existing dictionary if appropriate */
    ret = updatewindow(strm, dictionary + dictLength, dictLength);
    if (ret) {
        state->mode = MEM;
        return Z_MEM_ERROR;
    }
    state->havedict = 1;
    Tracev((stderr, "inflate:   dictionary set\n"));
    return Z_OK;
}

int ZEXPORT inflateGetHeader(strm, head)
z_streamp strm;
gz_headerp head;
{
    struct inflate_state FAR *state;

    /* check state */
    if (strm == Z_NULL || strm->state == Z_NULL) return Z_STREAM_ERROR;
    state = (struct inflate_state FAR *)strm->state;
    if ((state->wrap & 2) == 0) return Z_STREAM_ERROR;

    /* save header structure */
    state->head = head;
    head->done = 0;
    return Z_OK;
}

/*
   Search buf[0..len-1] for the pattern: 0, 0, 0xff, 0xff.  Return when found
   or when out of input.  When called, *have is the number of pattern bytes
   found in order so far, in 0..3.  On return *have is updated to the new
   state.  If on return *have equals four, then the pattern was found and the
   return value is how many bytes were read including the last byte of the
   pattern.  If *have is less than four, then the pattern has not been found
   yet and the return value is len.  In the latter case, syncsearch() can be
   called again with more data and the *have state.  *have is initialized to
   zero for the first call.
 */
local unsigned syncsearch(have, buf, len)
unsigned FAR *have;
const unsigned char FAR *buf;
unsigned len;
{
    unsigned got;
    unsigned next;

    got = *have;
    next = 0;
    while (next < len && got < 4) {
        if ((int)(buf[next]) == (got < 2 ? 0 : 0xff))
            got++;
        else if (buf[next])
            got = 0;
        else
            got = 4 - got;
        next++;
    }
    *have = got;
    return next;
}

int ZEXPORT inflateSync(strm)
z_streamp strm;
{
    unsigned len;               /* number of bytes to look at or looked at */
    unsigned long in, out;      /* temporary to save total_in and total_out */
    unsigned char buf[4];       /* to restore bit buffer to byte string */
    struct inflate_state FAR *state;

    /* check parameters */
    if (strm == Z_NULL || strm->state == Z_NULL) return Z_STREAM_ERROR;
    state = (struct inflate_state FAR *)strm->state;
    if (strm->avail_in == 0 && state->bits < 8) return Z_BUF_ERROR;

    /* if first time, start search in bit buffer */
    if (state->mode != SYNC) {
        state->mode = SYNC;
        state->hold <<= state->bits & 7;
        state->bits -= state->bits & 7;
        len = 0;
        while (state->bits >= 8) {
            buf[len++] = (unsigned char)(state->hold);
            state->hold >>= 8;
            state->bits -= 8;
        }
        state->have = 0;
        syncsearch(&(state->have), buf, len);
    }

    /* search available input */
    len = syncsearch(&(state->have), strm->next_in, strm->avail_in);
    strm->avail_in -= len;
    strm->next_in += len;
    strm->total_in += len;

    /* return no joy or set up to restart inflate() on a new block */
    if (state->have != 4) return Z_DATA_ERROR;
    in = strm->total_in;  out = strm->total_out;
    inflateReset(strm);
    strm->total_in = in;  strm->total_out = out;
    state->mode = TYPE;
    return Z_OK;
}

/*
   Returns true if inflate is currently at the end of a block generated by
   Z_SYNC_FLUSH or Z_FULL_FLUSH. This function is used by one PPP
   implementation to provide an additional safety check. PPP uses
   Z_SYNC_FLUSH but removes the length bytes of the resulting empty stored
   block. When decompressing, PPP checks that at the end of input packet,
   inflate is waiting for these length bytes.
 */
int ZEXPORT inflateSyncPoint(strm)
z_streamp strm;
{
    struct inflate_state FAR *state;

    if (strm == Z_NULL || strm->state == Z_NULL) return Z_STREAM_ERROR;
    state = (struct inflate_state FAR *)strm->state;
    return state->mode == STORED && state->bits == 0;
}

int ZEXPORT inflateCopy(dest, source)
z_streamp dest;
z_streamp source;
{
    struct inflate_state FAR *state;
    struct inflate_state FAR *copy;
    unsigned char FAR *window;
    unsigned wsize;

    /* check input */
    if (dest == Z_NULL || source == Z_NULL || source->state == Z_NULL ||
        source->zalloc == (alloc_func)0 || source->zfree == (free_func)0)
        return Z_STREAM_ERROR;
    state = (struct inflate_state FAR *)source->state;

    /* allocate space */
    copy = (struct inflate_state FAR *)
           ZALLOC(source, 1, sizeof(struct inflate_state));
    if (copy == Z_NULL) return Z_MEM_ERROR;
    window = Z_NULL;
    if (state->window != Z_NULL) {
        window = (unsigned char FAR *)
                 ZALLOC(source, 1U << state->wbits, sizeof(unsigned char));
        if (window == Z_NULL) {
            ZFREE(source, copy);
            return Z_MEM_ERROR;
        }
    }

    /* copy state */
    zmemcpy((voidpf)dest, (voidpf)source, sizeof(z_stream));
    zmemcpy((voidpf)copy, (voidpf)state, sizeof(struct inflate_state));
    if (state->lencode >= state->codes &&
        state->lencode <= state->codes + ENOUGH - 1) {
        copy->lencode = copy->codes + (state->lencode - state->codes);
        copy->distcode = copy->codes + (state->distcode - state->codes);
    }
    copy->next = copy->codes + (state->next - state->codes);
    if (window != Z_NULL) {
        wsize = 1U << state->wbits;
        zmemcpy(window, state->window, wsize);
    }
    copy->window = window;
    dest->state = (struct internal_state FAR *)copy;
    return Z_OK;
}

int ZEXPORT inflateUndermine(strm, subvert)
z_streamp strm;
int subvert;
{
    struct inflate_state FAR *state;

    if (strm == Z_NULL || strm->state == Z_NULL) return Z_STREAM_ERROR;
    state = (struct inflate_state FAR *)strm->state;
    state->sane = !subvert;
#ifdef INFLATE_ALLOW_INVALID_DISTANCE_TOOFAR_ARRR
    return Z_OK;
#else
    state->sane = 1;
    return Z_DATA_ERROR;
#endif
}

long ZEXPORT inflateMark(strm)
z_streamp strm;
{
    struct inflate_state FAR *state;

    if (strm == Z_NULL || strm->state == Z_NULL) return -1L << 16;
    state = (struct inflate_state FAR *)strm->state;
    return ((long)(state->back) << 16) +
        (state->mode == COPY ? state->length :
            (state->mode == MATCH ? state->was - state->length : 0));
}

/***********************************************************************
ZLIB\INFTREES.C
***********************************************************************/
/* inftrees.c -- generate Huffman trees for efficient decoding
 * Copyright (C) 1995-2013 Mark Adler
 * For conditions of distribution and use, see copyright notice in zlib.h
 */


#define MAXBITS 15

const char inflate_copyright[] =
   " inflate 1.2.8 Copyright 1995-2013 Mark Adler ";
/*
  If you use the zlib library in a product, an acknowledgment is welcome
  in the documentation of your product. If for some reason you cannot
  include such an acknowledgment, I would appreciate that you keep this
  copyright string in the executable of your product.
 */

/*
   Build a set of tables to decode the provided canonical Huffman code.
   The code lengths are lens[0..codes-1].  The result starts at *table,
   whose indices are 0..2^bits-1.  work is a writable array of at least
   lens shorts, which is used as a work area.  type is the type of code
   to be generated, CODES, LENS, or DISTS.  On return, zero is success,
   -1 is an invalid code, and +1 means that ENOUGH isn't enough.  table
   on return points to the next available entry's address.  bits is the
   requested root table index bits, and on return it is the actual root
   table index bits.  It will differ if the request is greater than the
   longest code or if it is less than the shortest code.
 */
int ZLIB_INTERNAL inflate_table(type, lens, codes, table, bits, work)
codetype type;
unsigned short FAR *lens;
unsigned codes;
code FAR * FAR *table;
unsigned FAR *bits;
unsigned short FAR *work;
{
    unsigned len;               /* a code's length in bits */
    unsigned sym;               /* index of code symbols */
    unsigned min, max;          /* minimum and maximum code lengths */
    unsigned root;              /* number of index bits for root table */
    unsigned curr;              /* number of index bits for current table */
    unsigned drop;              /* code bits to drop for sub-table */
    int left;                   /* number of prefix codes available */
    unsigned used;              /* code entries in table used */
    unsigned huff;              /* Huffman code */
    unsigned incr;              /* for incrementing code, index */
    unsigned fill;              /* index for replicating entries */
    unsigned low;               /* low bits for current root entry */
    unsigned mask;              /* mask for low root bits */
    code here;                  /* table entry for duplication */
    code FAR *next;             /* next available space in table */
    const unsigned short FAR *base;     /* base value table to use */
    const unsigned short FAR *extra;    /* extra bits table to use */
    int end;                    /* use base and extra for symbol > end */
    unsigned short count[MAXBITS+1];    /* number of codes of each length */
    unsigned short offs[MAXBITS+1];     /* offsets in table for each length */
    static const unsigned short lbase[31] = { /* Length codes 257..285 base */
        3, 4, 5, 6, 7, 8, 9, 10, 11, 13, 15, 17, 19, 23, 27, 31,
        35, 43, 51, 59, 67, 83, 99, 115, 131, 163, 195, 227, 258, 0, 0};
    static const unsigned short lext[31] = { /* Length codes 257..285 extra */
        16, 16, 16, 16, 16, 16, 16, 16, 17, 17, 17, 17, 18, 18, 18, 18,
        19, 19, 19, 19, 20, 20, 20, 20, 21, 21, 21, 21, 16, 72, 78};
    static const unsigned short dbase[32] = { /* Distance codes 0..29 base */
        1, 2, 3, 4, 5, 7, 9, 13, 17, 25, 33, 49, 65, 97, 129, 193,
        257, 385, 513, 769, 1025, 1537, 2049, 3073, 4097, 6145,
        8193, 12289, 16385, 24577, 0, 0};
    static const unsigned short dext[32] = { /* Distance codes 0..29 extra */
        16, 16, 16, 16, 17, 17, 18, 18, 19, 19, 20, 20, 21, 21, 22, 22,
        23, 23, 24, 24, 25, 25, 26, 26, 27, 27,
        28, 28, 29, 29, 64, 64};

    /*
       Process a set of code lengths to create a canonical Huffman code.  The
       code lengths are lens[0..codes-1].  Each length corresponds to the
       symbols 0..codes-1.  The Huffman code is generated by first sorting the
       symbols by length from short to long, and retaining the symbol order
       for codes with equal lengths.  Then the code starts with all zero bits
       for the first code of the shortest length, and the codes are integer
       increments for the same length, and zeros are appended as the length
       increases.  For the deflate format, these bits are stored backwards
       from their more natural integer increment ordering, and so when the
       decoding tables are built in the large loop below, the integer codes
       are incremented backwards.

       This routine assumes, but does not check, that all of the entries in
       lens[] are in the range 0..MAXBITS.  The caller must assure this.
       1..MAXBITS is interpreted as that code length.  zero means that that
       symbol does not occur in this code.

       The codes are sorted by computing a count of codes for each length,
       creating from that a table of starting indices for each length in the
       sorted table, and then entering the symbols in order in the sorted
       table.  The sorted table is work[], with that space being provided by
       the caller.

       The length counts are used for other purposes as well, i.e. finding
       the minimum and maximum length codes, determining if there are any
       codes at all, checking for a valid set of lengths, and looking ahead
       at length counts to determine sub-table sizes when building the
       decoding tables.
     */

    /* accumulate lengths for codes (assumes lens[] all in 0..MAXBITS) */
    for (len = 0; len <= MAXBITS; len++)
        count[len] = 0;
    for (sym = 0; sym < codes; sym++)
        count[lens[sym]]++;

    /* bound code lengths, force root to be within code lengths */
    root = *bits;
    for (max = MAXBITS; max >= 1; max--)
        if (count[max] != 0) break;
    if (root > max) root = max;
    if (max == 0) {                     /* no symbols to code at all */
        here.op = (unsigned char)64;    /* invalid code marker */
        here.bits = (unsigned char)1;
        here.val = (unsigned short)0;
        *(*table)++ = here;             /* make a table to force an error */
        *(*table)++ = here;
        *bits = 1;
        return 0;     /* no symbols, but wait for decoding to report error */
    }
    for (min = 1; min < max; min++)
        if (count[min] != 0) break;
    if (root < min) root = min;

    /* check for an over-subscribed or incomplete set of lengths */
    left = 1;
    for (len = 1; len <= MAXBITS; len++) {
        left <<= 1;
        left -= count[len];
        if (left < 0) return -1;        /* over-subscribed */
    }
    if (left > 0 && (type == CODES || max != 1))
        return -1;                      /* incomplete set */

    /* generate offsets into symbol table for each length for sorting */
    offs[1] = 0;
    for (len = 1; len < MAXBITS; len++)
        offs[len + 1] = offs[len] + count[len];

    /* sort symbols by length, by symbol order within each length */
    for (sym = 0; sym < codes; sym++)
        if (lens[sym] != 0) work[offs[lens[sym]]++] = (unsigned short)sym;

    /*
       Create and fill in decoding tables.  In this loop, the table being
       filled is at next and has curr index bits.  The code being used is huff
       with length len.  That code is converted to an index by dropping drop
       bits off of the bottom.  For codes where len is less than drop + curr,
       those top drop + curr - len bits are incremented through all values to
       fill the table with replicated entries.

       root is the number of index bits for the root table.  When len exceeds
       root, sub-tables are created pointed to by the root entry with an index
       of the low root bits of huff.  This is saved in low to check for when a
       new sub-table should be started.  drop is zero when the root table is
       being filled, and drop is root when sub-tables are being filled.

       When a new sub-table is needed, it is necessary to look ahead in the
       code lengths to determine what size sub-table is needed.  The length
       counts are used for this, and so count[] is decremented as codes are
       entered in the tables.

       used keeps track of how many table entries have been allocated from the
       provided *table space.  It is checked for LENS and DIST tables against
       the constants ENOUGH_LENS and ENOUGH_DISTS to guard against changes in
       the initial root table size constants.  See the comments in inftrees.h
       for more information.

       sym increments through all symbols, and the loop terminates when
       all codes of length max, i.e. all codes, have been processed.  This
       routine permits incomplete codes, so another loop after this one fills
       in the rest of the decoding tables with invalid code markers.
     */

    /* set up for code type */
    switch (type) {
    case CODES:
        base = extra = work;    /* dummy value--not used */
        end = 19;
        break;
    case LENS:
        base = lbase;
        base -= 257;
        extra = lext;
        extra -= 257;
        end = 256;
        break;
    default:            /* DISTS */
        base = dbase;
        extra = dext;
        end = -1;
    }

    /* initialize state for loop */
    huff = 0;                   /* starting code */
    sym = 0;                    /* starting code symbol */
    len = min;                  /* starting code length */
    next = *table;              /* current table to fill in */
    curr = root;                /* current table index bits */
    drop = 0;                   /* current bits to drop from code for index */
    low = (unsigned)(-1);       /* trigger new sub-table when len > root */
    used = 1U << root;          /* use root table entries */
    mask = used - 1;            /* mask for comparing low */

    /* check available table space */
    if ((type == LENS && used > ENOUGH_LENS) ||
        (type == DISTS && used > ENOUGH_DISTS))
        return 1;

    /* process all codes and make table entries */
    for (;;) {
        /* create table entry */
        here.bits = (unsigned char)(len - drop);
        if ((int)(work[sym]) < end) {
            here.op = (unsigned char)0;
            here.val = work[sym];
        }
        else if ((int)(work[sym]) > end) {
            here.op = (unsigned char)(extra[work[sym]]);
            here.val = base[work[sym]];
        }
        else {
            here.op = (unsigned char)(32 + 64);         /* end of block */
            here.val = 0;
        }

        /* replicate for those indices with low len bits equal to huff */
        incr = 1U << (len - drop);
        fill = 1U << curr;
        min = fill;                 /* save offset to next table */
        do {
            fill -= incr;
            next[(huff >> drop) + fill] = here;
        } while (fill != 0);

        /* backwards increment the len-bit code huff */
        incr = 1U << (len - 1);
        while (huff & incr)
            incr >>= 1;
        if (incr != 0) {
            huff &= incr - 1;
            huff += incr;
        }
        else
            huff = 0;

        /* go to next symbol, update count, len */
        sym++;
        if (--(count[len]) == 0) {
            if (len == max) break;
            len = lens[work[sym]];
        }

        /* create new sub-table if needed */
        if (len > root && (huff & mask) != low) {
            /* if first time, transition to sub-tables */
            if (drop == 0)
                drop = root;

            /* increment past last table */
            next += min;            /* here min is 1 << curr */

            /* determine length of next table */
            curr = len - drop;
            left = (int)(1 << curr);
            while (curr + drop < max) {
                left -= count[curr + drop];
                if (left <= 0) break;
                curr++;
                left <<= 1;
            }

            /* check for enough space */
            used += 1U << curr;
            if ((type == LENS && used > ENOUGH_LENS) ||
                (type == DISTS && used > ENOUGH_DISTS))
                return 1;

            /* point entry in root table to sub-table */
            low = huff & mask;
            (*table)[low].op = (unsigned char)curr;
            (*table)[low].bits = (unsigned char)root;
            (*table)[low].val = (unsigned short)(next - *table);
        }
    }

    /* fill in remaining table entry if code is incomplete (guaranteed to have
       at most one remaining entry, since if the code is incomplete, the
       maximum code length that was allowed to get this far is one bit) */
    if (huff != 0) {
        here.op = (unsigned char)64;            /* invalid code marker */
        here.bits = (unsigned char)(len - drop);
        here.val = (unsigned short)0;
        next[huff] = here;
    }

    /* set return parameters */
    *table += used;
    *bits = root;
    return 0;
}

/***********************************************************************
ZLIB\TREES.C
***********************************************************************/
/* trees.c -- output deflated data using Huffman coding
 * Copyright (C) 1995-2012 Jean-loup Gailly
 * detect_data_type() function provided freely by Cosmin Truta, 2006
 * For conditions of distribution and use, see copyright notice in zlib.h
 */

/*
 *  ALGORITHM
 *
 *      The "deflation" process uses several Huffman trees. The more
 *      common source values are represented by shorter bit sequences.
 *
 *      Each code tree is stored in a compressed form which is itself
 * a Huffman encoding of the lengths of all the code strings (in
 * ascending order by source values).  The actual code strings are
 * reconstructed from the lengths in the inflate process, as described
 * in the deflate specification.
 *
 *  REFERENCES
 *
 *      Deutsch, L.P.,"'Deflate' Compressed Data Format Specification".
 *      Available in ftp.uu.net:/pub/archiving/zip/doc/deflate-1.1.doc
 *
 *      Storer, James A.
 *          Data Compression:  Methods and Theory, pp. 49-50.
 *          Computer Science Press, 1988.  ISBN 0-7167-8156-5.
 *
 *      Sedgewick, R.
 *          Algorithms, p290.
 *          Addison-Wesley, 1983. ISBN 0-201-06672-6.
 */

/* @(#) $Id$ */

/* #define GEN_TREES_H */


#ifdef DEBUG
#  include <ctype.h>
#endif

/* ===========================================================================
 * Constants
 */

#define MAX_BL_BITS 7
/* Bit length codes must not exceed MAX_BL_BITS bits */

#define END_BLOCK 256
/* end of block literal code */

#define REP_3_6      16
/* repeat previous bit length 3-6 times (2 bits of repeat count) */

#define REPZ_3_10    17
/* repeat a zero length 3-10 times  (3 bits of repeat count) */

#define REPZ_11_138  18
/* repeat a zero length 11-138 times  (7 bits of repeat count) */

local const int extra_lbits[LENGTH_CODES] /* extra bits for each length code */
   = {0,0,0,0,0,0,0,0,1,1,1,1,2,2,2,2,3,3,3,3,4,4,4,4,5,5,5,5,0};

local const int extra_dbits[D_CODES] /* extra bits for each distance code */
   = {0,0,0,0,1,1,2,2,3,3,4,4,5,5,6,6,7,7,8,8,9,9,10,10,11,11,12,12,13,13};

local const int extra_blbits[BL_CODES]/* extra bits for each bit length code */
   = {0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2,3,7};

local const uch bl_order[BL_CODES]
   = {16,17,18,0,8,7,9,6,10,5,11,4,12,3,13,2,14,1,15};
/* The lengths of the bit length codes are sent in order of decreasing
 * probability, to avoid transmitting the lengths for unused bit length codes.
 */

/* ===========================================================================
 * Local data. These are initialized only once.
 */

#define DIST_CODE_LEN  512 /* see definition of array dist_code below */

#if defined(GEN_TREES_H) || !defined(STDC)
/* non ANSI compilers may not accept trees.h */

local ct_data static_ltree[L_CODES+2];
/* The static literal tree. Since the bit lengths are imposed, there is no
 * need for the L_CODES extra codes used during heap construction. However
 * The codes 286 and 287 are needed to build a canonical tree (see _tr_init
 * below).
 */

local ct_data static_dtree[D_CODES];
/* The static distance tree. (Actually a trivial tree since all codes use
 * 5 bits.)
 */

uch _dist_code[DIST_CODE_LEN];
/* Distance codes. The first 256 values correspond to the distances
 * 3 .. 258, the last 256 values correspond to the top 8 bits of
 * the 15 bit distances.
 */

uch _length_code[MAX_MATCH-MIN_MATCH+1];
/* length code for each normalized match length (0 == MIN_MATCH) */

local int base_length[LENGTH_CODES];
/* First normalized length for each code (0 = MIN_MATCH) */

local int base_dist[D_CODES];
/* First normalized distance for each code (0 = distance of 1) */

#else
#  include "trees.h"
#endif /* GEN_TREES_H */

struct static_tree_desc_s {
    const ct_data *static_tree;  /* static tree or NULL */
    const intf *extra_bits;      /* extra bits for each code or NULL */
    int     extra_base;          /* base index for extra_bits */
    int     elems;               /* max number of elements in the tree */
    int     max_length;          /* max bit length for the codes */
};

local static_tree_desc  static_l_desc =
{static_ltree, extra_lbits, LITERALS+1, L_CODES, MAX_BITS};

local static_tree_desc  static_d_desc =
{static_dtree, extra_dbits, 0,          D_CODES, MAX_BITS};

local static_tree_desc  static_bl_desc =
{(const ct_data *)0, extra_blbits, 0,   BL_CODES, MAX_BL_BITS};

/* ===========================================================================
 * Local (static) routines in this file.
 */

local void tr_static_init OF((void));
local void init_block     OF((deflate_state *s));
local void pqdownheap     OF((deflate_state *s, ct_data *tree, int k));
local void gen_bitlen     OF((deflate_state *s, tree_desc *desc));
local void gen_codes      OF((ct_data *tree, int max_code, ushf *bl_count));
local void build_tree     OF((deflate_state *s, tree_desc *desc));
local void scan_tree      OF((deflate_state *s, ct_data *tree, int max_code));
local void send_tree      OF((deflate_state *s, ct_data *tree, int max_code));
local int  build_bl_tree  OF((deflate_state *s));
local void send_all_trees OF((deflate_state *s, int lcodes, int dcodes,
                              int blcodes));
local void compress_block OF((deflate_state *s, const ct_data *ltree,
                              const ct_data *dtree));
local int  detect_data_type OF((deflate_state *s));
local unsigned bi_reverse OF((unsigned value, int length));
local void bi_windup      OF((deflate_state *s));
local void bi_flush       OF((deflate_state *s));
local void copy_block     OF((deflate_state *s, charf *buf, unsigned len,
                              int header));

#ifdef GEN_TREES_H
local void gen_trees_header OF((void));
#endif

#ifndef DEBUG
#  define send_code(s, c, tree) send_bits(s, tree[c].Code, tree[c].Len)
   /* Send a code of the given tree. c and tree must not have side effects */

#else /* DEBUG */
#  define send_code(s, c, tree) \
     { if (z_verbose>2) fprintf(stderr,"\ncd %3d ",(c)); \
       send_bits(s, tree[c].Code, tree[c].Len); }
#endif

/* ===========================================================================
 * Output a short LSB first on the stream.
 * IN assertion: there is enough room in pendingBuf.
 */
#define put_short(s, w) { \
    put_byte(s, (uch)((w) & 0xff)); \
    put_byte(s, (uch)((ush)(w) >> 8)); \
}

/* ===========================================================================
 * Send a value on a given number of bits.
 * IN assertion: length <= 16 and value fits in length bits.
 */
#ifdef DEBUG
local void send_bits      OF((deflate_state *s, int value, int length));

local void send_bits(s, value, length)
    deflate_state *s;
    int value;  /* value to send */
    int length; /* number of bits */
{
    Tracevv((stderr," l %2d v %4x ", length, value));
    Assert(length > 0 && length <= 15, "invalid length");
    s->bits_sent += (ulg)length;

    /* If not enough room in bi_buf, use (valid) bits from bi_buf and
     * (16 - bi_valid) bits from value, leaving (width - (16-bi_valid))
     * unused bits in value.
     */
    if (s->bi_valid > (int)Buf_size - length) {
        s->bi_buf |= (ush)value << s->bi_valid;
        put_short(s, s->bi_buf);
        s->bi_buf = (ush)value >> (Buf_size - s->bi_valid);
        s->bi_valid += length - Buf_size;
    } else {
        s->bi_buf |= (ush)value << s->bi_valid;
        s->bi_valid += length;
    }
}
#else /* !DEBUG */

#define send_bits(s, value, length) \
{ int len = length;\
  if (s->bi_valid > (int)Buf_size - len) {\
    int val = value;\
    s->bi_buf |= (ush)val << s->bi_valid;\
    put_short(s, s->bi_buf);\
    s->bi_buf = (ush)val >> (Buf_size - s->bi_valid);\
    s->bi_valid += len - Buf_size;\
  } else {\
    s->bi_buf |= (ush)(value) << s->bi_valid;\
    s->bi_valid += len;\
  }\
}
#endif /* DEBUG */


/* the arguments must not have side effects */

/* ===========================================================================
 * Initialize the various 'constant' tables.
 */
local void tr_static_init()
{
#if defined(GEN_TREES_H) || !defined(STDC)
    static int static_init_done = 0;
    int n;        /* iterates over tree elements */
    int bits;     /* bit counter */
    int length;   /* length value */
    int code;     /* code value */
    int dist;     /* distance index */
    ush bl_count[MAX_BITS+1];
    /* number of codes at each bit length for an optimal tree */

    if (static_init_done) return;

    /* For some embedded targets, global variables are not initialized: */
#ifdef NO_INIT_GLOBAL_POINTERS
    static_l_desc.static_tree = static_ltree;
    static_l_desc.extra_bits = extra_lbits;
    static_d_desc.static_tree = static_dtree;
    static_d_desc.extra_bits = extra_dbits;
    static_bl_desc.extra_bits = extra_blbits;
#endif

    /* Initialize the mapping length (0..255) -> length code (0..28) */
    length = 0;
    for (code = 0; code < LENGTH_CODES-1; code++) {
        base_length[code] = length;
        for (n = 0; n < (1<<extra_lbits[code]); n++) {
            _length_code[length++] = (uch)code;
        }
    }
    Assert (length == 256, "tr_static_init: length != 256");
    /* Note that the length 255 (match length 258) can be represented
     * in two different ways: code 284 + 5 bits or code 285, so we
     * overwrite length_code[255] to use the best encoding:
     */
    _length_code[length-1] = (uch)code;

    /* Initialize the mapping dist (0..32K) -> dist code (0..29) */
    dist = 0;
    for (code = 0 ; code < 16; code++) {
        base_dist[code] = dist;
        for (n = 0; n < (1<<extra_dbits[code]); n++) {
            _dist_code[dist++] = (uch)code;
        }
    }
    Assert (dist == 256, "tr_static_init: dist != 256");
    dist >>= 7; /* from now on, all distances are divided by 128 */
    for ( ; code < D_CODES; code++) {
        base_dist[code] = dist << 7;
        for (n = 0; n < (1<<(extra_dbits[code]-7)); n++) {
            _dist_code[256 + dist++] = (uch)code;
        }
    }
    Assert (dist == 256, "tr_static_init: 256+dist != 512");

    /* Construct the codes of the static literal tree */
    for (bits = 0; bits <= MAX_BITS; bits++) bl_count[bits] = 0;
    n = 0;
    while (n <= 143) static_ltree[n++].Len = 8, bl_count[8]++;
    while (n <= 255) static_ltree[n++].Len = 9, bl_count[9]++;
    while (n <= 279) static_ltree[n++].Len = 7, bl_count[7]++;
    while (n <= 287) static_ltree[n++].Len = 8, bl_count[8]++;
    /* Codes 286 and 287 do not exist, but we must include them in the
     * tree construction to get a canonical Huffman tree (longest code
     * all ones)
     */
    gen_codes((ct_data *)static_ltree, L_CODES+1, bl_count);

    /* The static distance tree is trivial: */
    for (n = 0; n < D_CODES; n++) {
        static_dtree[n].Len = 5;
        static_dtree[n].Code = bi_reverse((unsigned)n, 5);
    }
    static_init_done = 1;

#  ifdef GEN_TREES_H
    gen_trees_header();
#  endif
#endif /* defined(GEN_TREES_H) || !defined(STDC) */
}

/* ===========================================================================
 * Genererate the file trees.h describing the static trees.
 */
#ifdef GEN_TREES_H
#  ifndef DEBUG
#    include <stdio.h>
#  endif

#  define SEPARATOR(i, last, width) \
      ((i) == (last)? "\n};\n\n" :    \
       ((i) % (width) == (width)-1 ? ",\n" : ", "))

void gen_trees_header()
{
    FILE *header = fopen("trees.h", "w");
    int i;

    Assert (header != NULL, "Can't open trees.h");
    fprintf(header,
            "/* header created automatically with -DGEN_TREES_H */\n\n");

    fprintf(header, "local const ct_data static_ltree[L_CODES+2] = {\n");
    for (i = 0; i < L_CODES+2; i++) {
        fprintf(header, "{{%3u},{%3u}}%s", static_ltree[i].Code,
                static_ltree[i].Len, SEPARATOR(i, L_CODES+1, 5));
    }

    fprintf(header, "local const ct_data static_dtree[D_CODES] = {\n");
    for (i = 0; i < D_CODES; i++) {
        fprintf(header, "{{%2u},{%2u}}%s", static_dtree[i].Code,
                static_dtree[i].Len, SEPARATOR(i, D_CODES-1, 5));
    }

    fprintf(header, "const uch ZLIB_INTERNAL _dist_code[DIST_CODE_LEN] = {\n");
    for (i = 0; i < DIST_CODE_LEN; i++) {
        fprintf(header, "%2u%s", _dist_code[i],
                SEPARATOR(i, DIST_CODE_LEN-1, 20));
    }

    fprintf(header,
        "const uch ZLIB_INTERNAL _length_code[MAX_MATCH-MIN_MATCH+1]= {\n");
    for (i = 0; i < MAX_MATCH-MIN_MATCH+1; i++) {
        fprintf(header, "%2u%s", _length_code[i],
                SEPARATOR(i, MAX_MATCH-MIN_MATCH, 20));
    }

    fprintf(header, "local const int base_length[LENGTH_CODES] = {\n");
    for (i = 0; i < LENGTH_CODES; i++) {
        fprintf(header, "%1u%s", base_length[i],
                SEPARATOR(i, LENGTH_CODES-1, 20));
    }

    fprintf(header, "local const int base_dist[D_CODES] = {\n");
    for (i = 0; i < D_CODES; i++) {
        fprintf(header, "%5u%s", base_dist[i],
                SEPARATOR(i, D_CODES-1, 10));
    }

    fclose(header);
}
#endif /* GEN_TREES_H */

/* ===========================================================================
 * Initialize the tree data structures for a new zlib stream.
 */
void ZLIB_INTERNAL _tr_init(s)
    deflate_state *s;
{
    tr_static_init();

    s->l_desc.dyn_tree = s->dyn_ltree;
    s->l_desc.stat_desc = &static_l_desc;

    s->d_desc.dyn_tree = s->dyn_dtree;
    s->d_desc.stat_desc = &static_d_desc;

    s->bl_desc.dyn_tree = s->bl_tree;
    s->bl_desc.stat_desc = &static_bl_desc;

    s->bi_buf = 0;
    s->bi_valid = 0;
#ifdef DEBUG
    s->compressed_len = 0L;
    s->bits_sent = 0L;
#endif

    /* Initialize the first block of the first file: */
    init_block(s);
}

/* ===========================================================================
 * Initialize a new block.
 */
local void init_block(s)
    deflate_state *s;
{
    int n; /* iterates over tree elements */

    /* Initialize the trees. */
    for (n = 0; n < L_CODES;  n++) s->dyn_ltree[n].Freq = 0;
    for (n = 0; n < D_CODES;  n++) s->dyn_dtree[n].Freq = 0;
    for (n = 0; n < BL_CODES; n++) s->bl_tree[n].Freq = 0;

    s->dyn_ltree[END_BLOCK].Freq = 1;
    s->opt_len = s->static_len = 0L;
    s->last_lit = s->matches = 0;
}

#define SMALLEST 1
/* Index within the heap array of least frequent node in the Huffman tree */


/* ===========================================================================
 * Remove the smallest element from the heap and recreate the heap with
 * one less element. Updates heap and heap_len.
 */
#define pqremove(s, tree, top) \
{\
    top = s->heap[SMALLEST]; \
    s->heap[SMALLEST] = s->heap[s->heap_len--]; \
    pqdownheap(s, tree, SMALLEST); \
}

/* ===========================================================================
 * Compares to subtrees, using the tree depth as tie breaker when
 * the subtrees have equal frequency. This minimizes the worst case length.
 */
#define smaller(tree, n, m, depth) \
   (tree[n].Freq < tree[m].Freq || \
   (tree[n].Freq == tree[m].Freq && depth[n] <= depth[m]))

/* ===========================================================================
 * Restore the heap property by moving down the tree starting at node k,
 * exchanging a node with the smallest of its two sons if necessary, stopping
 * when the heap property is re-established (each father smaller than its
 * two sons).
 */
local void pqdownheap(s, tree, k)
    deflate_state *s;
    ct_data *tree;  /* the tree to restore */
    int k;               /* node to move down */
{
    int v = s->heap[k];
    int j = k << 1;  /* left son of k */
    while (j <= s->heap_len) {
        /* Set j to the smallest of the two sons: */
        if (j < s->heap_len &&
            smaller(tree, s->heap[j+1], s->heap[j], s->depth)) {
            j++;
        }
        /* Exit if v is smaller than both sons */
        if (smaller(tree, v, s->heap[j], s->depth)) break;

        /* Exchange v with the smallest son */
        s->heap[k] = s->heap[j];  k = j;

        /* And continue down the tree, setting j to the left son of k */
        j <<= 1;
    }
    s->heap[k] = v;
}

/* ===========================================================================
 * Compute the optimal bit lengths for a tree and update the total bit length
 * for the current block.
 * IN assertion: the fields freq and dad are set, heap[heap_max] and
 *    above are the tree nodes sorted by increasing frequency.
 * OUT assertions: the field len is set to the optimal bit length, the
 *     array bl_count contains the frequencies for each bit length.
 *     The length opt_len is updated; static_len is also updated if stree is
 *     not null.
 */
local void gen_bitlen(s, desc)
    deflate_state *s;
    tree_desc *desc;    /* the tree descriptor */
{
    ct_data *tree        = desc->dyn_tree;
    int max_code         = desc->max_code;
    const ct_data *stree = desc->stat_desc->static_tree;
    const intf *extra    = desc->stat_desc->extra_bits;
    int base             = desc->stat_desc->extra_base;
    int max_length       = desc->stat_desc->max_length;
    int h;              /* heap index */
    int n, m;           /* iterate over the tree elements */
    int bits;           /* bit length */
    int xbits;          /* extra bits */
    ush f;              /* frequency */
    int overflow = 0;   /* number of elements with bit length too large */

    for (bits = 0; bits <= MAX_BITS; bits++) s->bl_count[bits] = 0;

    /* In a first pass, compute the optimal bit lengths (which may
     * overflow in the case of the bit length tree).
     */
    tree[s->heap[s->heap_max]].Len = 0; /* root of the heap */

    for (h = s->heap_max+1; h < HEAP_SIZE; h++) {
        n = s->heap[h];
        bits = tree[tree[n].Dad].Len + 1;
        if (bits > max_length) bits = max_length, overflow++;
        tree[n].Len = (ush)bits;
        /* We overwrite tree[n].Dad which is no longer needed */

        if (n > max_code) continue; /* not a leaf node */

        s->bl_count[bits]++;
        xbits = 0;
        if (n >= base) xbits = extra[n-base];
        f = tree[n].Freq;
        s->opt_len += (ulg)f * (bits + xbits);
        if (stree) s->static_len += (ulg)f * (stree[n].Len + xbits);
    }
    if (overflow == 0) return;

    Trace((stderr,"\nbit length overflow\n"));
    /* This happens for example on obj2 and pic of the Calgary corpus */

    /* Find the first bit length which could increase: */
    do {
        bits = max_length-1;
        while (s->bl_count[bits] == 0) bits--;
        s->bl_count[bits]--;      /* move one leaf down the tree */
        s->bl_count[bits+1] += 2; /* move one overflow item as its brother */
        s->bl_count[max_length]--;
        /* The brother of the overflow item also moves one step up,
         * but this does not affect bl_count[max_length]
         */
        overflow -= 2;
    } while (overflow > 0);

    /* Now recompute all bit lengths, scanning in increasing frequency.
     * h is still equal to HEAP_SIZE. (It is simpler to reconstruct all
     * lengths instead of fixing only the wrong ones. This idea is taken
     * from 'ar' written by Haruhiko Okumura.)
     */
    for (bits = max_length; bits != 0; bits--) {
        n = s->bl_count[bits];
        while (n != 0) {
            m = s->heap[--h];
            if (m > max_code) continue;
            if ((unsigned) tree[m].Len != (unsigned) bits) {
                Trace((stderr,"code %d bits %d->%d\n", m, tree[m].Len, bits));
                s->opt_len += ((long)bits - (long)tree[m].Len)
                              *(long)tree[m].Freq;
                tree[m].Len = (ush)bits;
            }
            n--;
        }
    }
}

/* ===========================================================================
 * Generate the codes for a given tree and bit counts (which need not be
 * optimal).
 * IN assertion: the array bl_count contains the bit length statistics for
 * the given tree and the field len is set for all tree elements.
 * OUT assertion: the field code is set for all tree elements of non
 *     zero code length.
 */
local void gen_codes (tree, max_code, bl_count)
    ct_data *tree;             /* the tree to decorate */
    int max_code;              /* largest code with non zero frequency */
    ushf *bl_count;            /* number of codes at each bit length */
{
    ush next_code[MAX_BITS+1]; /* next code value for each bit length */
    ush code = 0;              /* running code value */
    int bits;                  /* bit index */
    int n;                     /* code index */

    /* The distribution counts are first used to generate the code values
     * without bit reversal.
     */
    for (bits = 1; bits <= MAX_BITS; bits++) {
        next_code[bits] = code = (code + bl_count[bits-1]) << 1;
    }
    /* Check that the bit counts in bl_count are consistent. The last code
     * must be all ones.
     */
    Assert (code + bl_count[MAX_BITS]-1 == (1<<MAX_BITS)-1,
            "inconsistent bit counts");
    Tracev((stderr,"\ngen_codes: max_code %d ", max_code));

    for (n = 0;  n <= max_code; n++) {
        int len = tree[n].Len;
        if (len == 0) continue;
        /* Now reverse the bits */
        tree[n].Code = bi_reverse(next_code[len]++, len);

        Tracecv(tree != static_ltree, (stderr,"\nn %3d %c l %2d c %4x (%x) ",
             n, (isgraph(n) ? n : ' '), len, tree[n].Code, next_code[len]-1));
    }
}

/* ===========================================================================
 * Construct one Huffman tree and assigns the code bit strings and lengths.
 * Update the total bit length for the current block.
 * IN assertion: the field freq is set for all tree elements.
 * OUT assertions: the fields len and code are set to the optimal bit length
 *     and corresponding code. The length opt_len is updated; static_len is
 *     also updated if stree is not null. The field max_code is set.
 */
local void build_tree(s, desc)
    deflate_state *s;
    tree_desc *desc; /* the tree descriptor */
{
    ct_data *tree         = desc->dyn_tree;
    const ct_data *stree  = desc->stat_desc->static_tree;
    int elems             = desc->stat_desc->elems;
    int n, m;          /* iterate over heap elements */
    int max_code = -1; /* largest code with non zero frequency */
    int node;          /* new node being created */

    /* Construct the initial heap, with least frequent element in
     * heap[SMALLEST]. The sons of heap[n] are heap[2*n] and heap[2*n+1].
     * heap[0] is not used.
     */
    s->heap_len = 0, s->heap_max = HEAP_SIZE;

    for (n = 0; n < elems; n++) {
        if (tree[n].Freq != 0) {
            s->heap[++(s->heap_len)] = max_code = n;
            s->depth[n] = 0;
        } else {
            tree[n].Len = 0;
        }
    }

    /* The pkzip format requires that at least one distance code exists,
     * and that at least one bit should be sent even if there is only one
     * possible code. So to avoid special checks later on we force at least
     * two codes of non zero frequency.
     */
    while (s->heap_len < 2) {
        node = s->heap[++(s->heap_len)] = (max_code < 2 ? ++max_code : 0);
        tree[node].Freq = 1;
        s->depth[node] = 0;
        s->opt_len--; if (stree) s->static_len -= stree[node].Len;
        /* node is 0 or 1 so it does not have extra bits */
    }
    desc->max_code = max_code;

    /* The elements heap[heap_len/2+1 .. heap_len] are leaves of the tree,
     * establish sub-heaps of increasing lengths:
     */
    for (n = s->heap_len/2; n >= 1; n--) pqdownheap(s, tree, n);

    /* Construct the Huffman tree by repeatedly combining the least two
     * frequent nodes.
     */
    node = elems;              /* next internal node of the tree */
    do {
        pqremove(s, tree, n);  /* n = node of least frequency */
        m = s->heap[SMALLEST]; /* m = node of next least frequency */

        s->heap[--(s->heap_max)] = n; /* keep the nodes sorted by frequency */
        s->heap[--(s->heap_max)] = m;

        /* Create a new node father of n and m */
        tree[node].Freq = tree[n].Freq + tree[m].Freq;
        s->depth[node] = (uch)((s->depth[n] >= s->depth[m] ?
                                s->depth[n] : s->depth[m]) + 1);
        tree[n].Dad = tree[m].Dad = (ush)node;
#ifdef DUMP_BL_TREE
        if (tree == s->bl_tree) {
            fprintf(stderr,"\nnode %d(%d), sons %d(%d) %d(%d)",
                    node, tree[node].Freq, n, tree[n].Freq, m, tree[m].Freq);
        }
#endif
        /* and insert the new node in the heap */
        s->heap[SMALLEST] = node++;
        pqdownheap(s, tree, SMALLEST);

    } while (s->heap_len >= 2);

    s->heap[--(s->heap_max)] = s->heap[SMALLEST];

    /* At this point, the fields freq and dad are set. We can now
     * generate the bit lengths.
     */
    gen_bitlen(s, (tree_desc *)desc);

    /* The field len is now set, we can generate the bit codes */
    gen_codes ((ct_data *)tree, max_code, s->bl_count);
}

/* ===========================================================================
 * Scan a literal or distance tree to determine the frequencies of the codes
 * in the bit length tree.
 */
local void scan_tree (s, tree, max_code)
    deflate_state *s;
    ct_data *tree;   /* the tree to be scanned */
    int max_code;    /* and its largest code of non zero frequency */
{
    int n;                     /* iterates over all tree elements */
    int prevlen = -1;          /* last emitted length */
    int curlen;                /* length of current code */
    int nextlen = tree[0].Len; /* length of next code */
    int count = 0;             /* repeat count of the current code */
    int max_count = 7;         /* max repeat count */
    int min_count = 4;         /* min repeat count */

    if (nextlen == 0) max_count = 138, min_count = 3;
    tree[max_code+1].Len = (ush)0xffff; /* guard */

    for (n = 0; n <= max_code; n++) {
        curlen = nextlen; nextlen = tree[n+1].Len;
        if (++count < max_count && curlen == nextlen) {
            continue;
        } else if (count < min_count) {
            s->bl_tree[curlen].Freq += count;
        } else if (curlen != 0) {
            if (curlen != prevlen) s->bl_tree[curlen].Freq++;
            s->bl_tree[REP_3_6].Freq++;
        } else if (count <= 10) {
            s->bl_tree[REPZ_3_10].Freq++;
        } else {
            s->bl_tree[REPZ_11_138].Freq++;
        }
        count = 0; prevlen = curlen;
        if (nextlen == 0) {
            max_count = 138, min_count = 3;
        } else if (curlen == nextlen) {
            max_count = 6, min_count = 3;
        } else {
            max_count = 7, min_count = 4;
        }
    }
}

/* ===========================================================================
 * Send a literal or distance tree in compressed form, using the codes in
 * bl_tree.
 */
local void send_tree (s, tree, max_code)
    deflate_state *s;
    ct_data *tree; /* the tree to be scanned */
    int max_code;       /* and its largest code of non zero frequency */
{
    int n;                     /* iterates over all tree elements */
    int prevlen = -1;          /* last emitted length */
    int curlen;                /* length of current code */
    int nextlen = tree[0].Len; /* length of next code */
    int count = 0;             /* repeat count of the current code */
    int max_count = 7;         /* max repeat count */
    int min_count = 4;         /* min repeat count */

    /* tree[max_code+1].Len = -1; */  /* guard already set */
    if (nextlen == 0) max_count = 138, min_count = 3;

    for (n = 0; n <= max_code; n++) {
        curlen = nextlen; nextlen = tree[n+1].Len;
        if (++count < max_count && curlen == nextlen) {
            continue;
        } else if (count < min_count) {
            do { send_code(s, curlen, s->bl_tree); } while (--count != 0);

        } else if (curlen != 0) {
            if (curlen != prevlen) {
                send_code(s, curlen, s->bl_tree); count--;
            }
            Assert(count >= 3 && count <= 6, " 3_6?");
            send_code(s, REP_3_6, s->bl_tree); send_bits(s, count-3, 2);

        } else if (count <= 10) {
            send_code(s, REPZ_3_10, s->bl_tree); send_bits(s, count-3, 3);

        } else {
            send_code(s, REPZ_11_138, s->bl_tree); send_bits(s, count-11, 7);
        }
        count = 0; prevlen = curlen;
        if (nextlen == 0) {
            max_count = 138, min_count = 3;
        } else if (curlen == nextlen) {
            max_count = 6, min_count = 3;
        } else {
            max_count = 7, min_count = 4;
        }
    }
}

/* ===========================================================================
 * Construct the Huffman tree for the bit lengths and return the index in
 * bl_order of the last bit length code to send.
 */
local int build_bl_tree(s)
    deflate_state *s;
{
    int max_blindex;  /* index of last bit length code of non zero freq */

    /* Determine the bit length frequencies for literal and distance trees */
    scan_tree(s, (ct_data *)s->dyn_ltree, s->l_desc.max_code);
    scan_tree(s, (ct_data *)s->dyn_dtree, s->d_desc.max_code);

    /* Build the bit length tree: */
    build_tree(s, (tree_desc *)(&(s->bl_desc)));
    /* opt_len now includes the length of the tree representations, except
     * the lengths of the bit lengths codes and the 5+5+4 bits for the counts.
     */

    /* Determine the number of bit length codes to send. The pkzip format
     * requires that at least 4 bit length codes be sent. (appnote.txt says
     * 3 but the actual value used is 4.)
     */
    for (max_blindex = BL_CODES-1; max_blindex >= 3; max_blindex--) {
        if (s->bl_tree[bl_order[max_blindex]].Len != 0) break;
    }
    /* Update opt_len to include the bit length tree and counts */
    s->opt_len += 3*(max_blindex+1) + 5+5+4;
    Tracev((stderr, "\ndyn trees: dyn %ld, stat %ld",
            s->opt_len, s->static_len));

    return max_blindex;
}

/* ===========================================================================
 * Send the header for a block using dynamic Huffman trees: the counts, the
 * lengths of the bit length codes, the literal tree and the distance tree.
 * IN assertion: lcodes >= 257, dcodes >= 1, blcodes >= 4.
 */
local void send_all_trees(s, lcodes, dcodes, blcodes)
    deflate_state *s;
    int lcodes, dcodes, blcodes; /* number of codes for each tree */
{
    int rank;                    /* index in bl_order */

    Assert (lcodes >= 257 && dcodes >= 1 && blcodes >= 4, "not enough codes");
    Assert (lcodes <= L_CODES && dcodes <= D_CODES && blcodes <= BL_CODES,
            "too many codes");
    Tracev((stderr, "\nbl counts: "));
    send_bits(s, lcodes-257, 5); /* not +255 as stated in appnote.txt */
    send_bits(s, dcodes-1,   5);
    send_bits(s, blcodes-4,  4); /* not -3 as stated in appnote.txt */
    for (rank = 0; rank < blcodes; rank++) {
        Tracev((stderr, "\nbl code %2d ", bl_order[rank]));
        send_bits(s, s->bl_tree[bl_order[rank]].Len, 3);
    }
    Tracev((stderr, "\nbl tree: sent %ld", s->bits_sent));

    send_tree(s, (ct_data *)s->dyn_ltree, lcodes-1); /* literal tree */
    Tracev((stderr, "\nlit tree: sent %ld", s->bits_sent));

    send_tree(s, (ct_data *)s->dyn_dtree, dcodes-1); /* distance tree */
    Tracev((stderr, "\ndist tree: sent %ld", s->bits_sent));
}

/* ===========================================================================
 * Send a stored block
 */
void ZLIB_INTERNAL _tr_stored_block(s, buf, stored_len, last)
    deflate_state *s;
    charf *buf;       /* input block */
    ulg stored_len;   /* length of input block */
    int last;         /* one if this is the last block for a file */
{
    send_bits(s, (STORED_BLOCK<<1)+last, 3);    /* send block type */
#ifdef DEBUG
    s->compressed_len = (s->compressed_len + 3 + 7) & (ulg)~7L;
    s->compressed_len += (stored_len + 4) << 3;
#endif
    copy_block(s, buf, (unsigned)stored_len, 1); /* with header */
}

/* ===========================================================================
 * Flush the bits in the bit buffer to pending output (leaves at most 7 bits)
 */
void ZLIB_INTERNAL _tr_flush_bits(s)
    deflate_state *s;
{
    bi_flush(s);
}

/* ===========================================================================
 * Send one empty static block to give enough lookahead for inflate.
 * This takes 10 bits, of which 7 may remain in the bit buffer.
 */
void ZLIB_INTERNAL _tr_align(s)
    deflate_state *s;
{
    send_bits(s, STATIC_TREES<<1, 3);
    send_code(s, END_BLOCK, static_ltree);
#ifdef DEBUG
    s->compressed_len += 10L; /* 3 for block type, 7 for EOB */
#endif
    bi_flush(s);
}

/* ===========================================================================
 * Determine the best encoding for the current block: dynamic trees, static
 * trees or store, and output the encoded block to the zip file.
 */
void ZLIB_INTERNAL _tr_flush_block(s, buf, stored_len, last)
    deflate_state *s;
    charf *buf;       /* input block, or NULL if too old */
    ulg stored_len;   /* length of input block */
    int last;         /* one if this is the last block for a file */
{
    ulg opt_lenb, static_lenb; /* opt_len and static_len in bytes */
    int max_blindex = 0;  /* index of last bit length code of non zero freq */

    /* Build the Huffman trees unless a stored block is forced */
    if (s->level > 0) {

        /* Check if the file is binary or text */
        if (s->strm->data_type == Z_UNKNOWN)
            s->strm->data_type = detect_data_type(s);

        /* Construct the literal and distance trees */
        build_tree(s, (tree_desc *)(&(s->l_desc)));
        Tracev((stderr, "\nlit data: dyn %ld, stat %ld", s->opt_len,
                s->static_len));

        build_tree(s, (tree_desc *)(&(s->d_desc)));
        Tracev((stderr, "\ndist data: dyn %ld, stat %ld", s->opt_len,
                s->static_len));
        /* At this point, opt_len and static_len are the total bit lengths of
         * the compressed block data, excluding the tree representations.
         */

        /* Build the bit length tree for the above two trees, and get the index
         * in bl_order of the last bit length code to send.
         */
        max_blindex = build_bl_tree(s);

        /* Determine the best encoding. Compute the block lengths in bytes. */
        opt_lenb = (s->opt_len+3+7)>>3;
        static_lenb = (s->static_len+3+7)>>3;

        Tracev((stderr, "\nopt %lu(%lu) stat %lu(%lu) stored %lu lit %u ",
                opt_lenb, s->opt_len, static_lenb, s->static_len, stored_len,
                s->last_lit));

        if (static_lenb <= opt_lenb) opt_lenb = static_lenb;

    } else {
        Assert(buf != (char*)0, "lost buf");
        opt_lenb = static_lenb = stored_len + 5; /* force a stored block */
    }

#ifdef FORCE_STORED
    if (buf != (char*)0) { /* force stored block */
#else
    if (stored_len+4 <= opt_lenb && buf != (char*)0) {
                       /* 4: two words for the lengths */
#endif
        /* The test buf != NULL is only necessary if LIT_BUFSIZE > WSIZE.
         * Otherwise we can't have processed more than WSIZE input bytes since
         * the last block flush, because compression would have been
         * successful. If LIT_BUFSIZE <= WSIZE, it is never too late to
         * transform a block into a stored block.
         */
        _tr_stored_block(s, buf, stored_len, last);

#ifdef FORCE_STATIC
    } else if (static_lenb >= 0) { /* force static trees */
#else
    } else if (s->strategy == Z_FIXED || static_lenb == opt_lenb) {
#endif
        send_bits(s, (STATIC_TREES<<1)+last, 3);
        compress_block(s, (const ct_data *)static_ltree,
                       (const ct_data *)static_dtree);
#ifdef DEBUG
        s->compressed_len += 3 + s->static_len;
#endif
    } else {
        send_bits(s, (DYN_TREES<<1)+last, 3);
        send_all_trees(s, s->l_desc.max_code+1, s->d_desc.max_code+1,
                       max_blindex+1);
        compress_block(s, (const ct_data *)s->dyn_ltree,
                       (const ct_data *)s->dyn_dtree);
#ifdef DEBUG
        s->compressed_len += 3 + s->opt_len;
#endif
    }
    Assert (s->compressed_len == s->bits_sent, "bad compressed size");
    /* The above check is made mod 2^32, for files larger than 512 MB
     * and uLong implemented on 32 bits.
     */
    init_block(s);

    if (last) {
        bi_windup(s);
#ifdef DEBUG
        s->compressed_len += 7;  /* align on byte boundary */
#endif
    }
    Tracev((stderr,"\ncomprlen %lu(%lu) ", s->compressed_len>>3,
           s->compressed_len-7*last));
}

/* ===========================================================================
 * Save the match info and tally the frequency counts. Return true if
 * the current block must be flushed.
 */
int ZLIB_INTERNAL _tr_tally (s, dist, lc)
    deflate_state *s;
    unsigned dist;  /* distance of matched string */
    unsigned lc;    /* match length-MIN_MATCH or unmatched char (if dist==0) */
{
    s->d_buf[s->last_lit] = (ush)dist;
    s->l_buf[s->last_lit++] = (uch)lc;
    if (dist == 0) {
        /* lc is the unmatched char */
        s->dyn_ltree[lc].Freq++;
    } else {
        s->matches++;
        /* Here, lc is the match length - MIN_MATCH */
        dist--;             /* dist = match distance - 1 */
        Assert((ush)dist < (ush)MAX_DIST(s) &&
               (ush)lc <= (ush)(MAX_MATCH-MIN_MATCH) &&
               (ush)d_code(dist) < (ush)D_CODES,  "_tr_tally: bad match");

        s->dyn_ltree[_length_code[lc]+LITERALS+1].Freq++;
        s->dyn_dtree[d_code(dist)].Freq++;
    }

#ifdef TRUNCATE_BLOCK
    /* Try to guess if it is profitable to stop the current block here */
    if ((s->last_lit & 0x1fff) == 0 && s->level > 2) {
        /* Compute an upper bound for the compressed length */
        ulg out_length = (ulg)s->last_lit*8L;
        ulg in_length = (ulg)((long)s->strstart - s->block_start);
        int dcode;
        for (dcode = 0; dcode < D_CODES; dcode++) {
            out_length += (ulg)s->dyn_dtree[dcode].Freq *
                (5L+extra_dbits[dcode]);
        }
        out_length >>= 3;
        Tracev((stderr,"\nlast_lit %u, in %ld, out ~%ld(%ld%%) ",
               s->last_lit, in_length, out_length,
               100L - out_length*100L/in_length));
        if (s->matches < s->last_lit/2 && out_length < in_length/2) return 1;
    }
#endif
    return (s->last_lit == s->lit_bufsize-1);
    /* We avoid equality with lit_bufsize because of wraparound at 64K
     * on 16 bit machines and because stored blocks are restricted to
     * 64K-1 bytes.
     */
}

/* ===========================================================================
 * Send the block data compressed using the given Huffman trees
 */
local void compress_block(s, ltree, dtree)
    deflate_state *s;
    const ct_data *ltree; /* literal tree */
    const ct_data *dtree; /* distance tree */
{
    unsigned dist;      /* distance of matched string */
    int lc;             /* match length or unmatched char (if dist == 0) */
    unsigned lx = 0;    /* running index in l_buf */
    unsigned code;      /* the code to send */
    int extra;          /* number of extra bits to send */

    if (s->last_lit != 0) do {
        dist = s->d_buf[lx];
        lc = s->l_buf[lx++];
        if (dist == 0) {
            send_code(s, lc, ltree); /* send a literal byte */
            Tracecv(isgraph(lc), (stderr," '%c' ", lc));
        } else {
            /* Here, lc is the match length - MIN_MATCH */
            code = _length_code[lc];
            send_code(s, code+LITERALS+1, ltree); /* send the length code */
            extra = extra_lbits[code];
            if (extra != 0) {
                lc -= base_length[code];
                send_bits(s, lc, extra);       /* send the extra length bits */
            }
            dist--; /* dist is now the match distance - 1 */
            code = d_code(dist);
            Assert (code < D_CODES, "bad d_code");

            send_code(s, code, dtree);       /* send the distance code */
            extra = extra_dbits[code];
            if (extra != 0) {
                dist -= base_dist[code];
                send_bits(s, dist, extra);   /* send the extra distance bits */
            }
        } /* literal or match pair ? */

        /* Check that the overlay between pending_buf and d_buf+l_buf is ok: */
        Assert((uInt)(s->pending) < s->lit_bufsize + 2*lx,
               "pendingBuf overflow");

    } while (lx < s->last_lit);

    send_code(s, END_BLOCK, ltree);
}

/* ===========================================================================
 * Check if the data type is TEXT or BINARY, using the following algorithm:
 * - TEXT if the two conditions below are satisfied:
 *    a) There are no non-portable control characters belonging to the
 *       "black list" (0..6, 14..25, 28..31).
 *    b) There is at least one printable character belonging to the
 *       "white list" (9 {TAB}, 10 {LF}, 13 {CR}, 32..255).
 * - BINARY otherwise.
 * - The following partially-portable control characters form a
 *   "gray list" that is ignored in this detection algorithm:
 *   (7 {BEL}, 8 {BS}, 11 {VT}, 12 {FF}, 26 {SUB}, 27 {ESC}).
 * IN assertion: the fields Freq of dyn_ltree are set.
 */
local int detect_data_type(s)
    deflate_state *s;
{
    /* black_mask is the bit mask of black-listed bytes
     * set bits 0..6, 14..25, and 28..31
     * 0xf3ffc07f = binary 11110011111111111100000001111111
     */
    unsigned long black_mask = 0xf3ffc07fUL;
    int n;

    /* Check for non-textual ("black-listed") bytes. */
    for (n = 0; n <= 31; n++, black_mask >>= 1)
        if ((black_mask & 1) && (s->dyn_ltree[n].Freq != 0))
            return Z_BINARY;

    /* Check for textual ("white-listed") bytes. */
    if (s->dyn_ltree[9].Freq != 0 || s->dyn_ltree[10].Freq != 0
            || s->dyn_ltree[13].Freq != 0)
        return Z_TEXT;
    for (n = 32; n < LITERALS; n++)
        if (s->dyn_ltree[n].Freq != 0)
            return Z_TEXT;

    /* There are no "black-listed" or "white-listed" bytes:
     * this stream either is empty or has tolerated ("gray-listed") bytes only.
     */
    return Z_BINARY;
}

/* ===========================================================================
 * Reverse the first len bits of a code, using straightforward code (a faster
 * method would use a table)
 * IN assertion: 1 <= len <= 15
 */
local unsigned bi_reverse(code, len)
    unsigned code; /* the value to invert */
    int len;       /* its bit length */
{
    register unsigned res = 0;
    do {
        res |= code & 1;
        code >>= 1, res <<= 1;
    } while (--len > 0);
    return res >> 1;
}

/* ===========================================================================
 * Flush the bit buffer, keeping at most 7 bits in it.
 */
local void bi_flush(s)
    deflate_state *s;
{
    if (s->bi_valid == 16) {
        put_short(s, s->bi_buf);
        s->bi_buf = 0;
        s->bi_valid = 0;
    } else if (s->bi_valid >= 8) {
        put_byte(s, (Byte)s->bi_buf);
        s->bi_buf >>= 8;
        s->bi_valid -= 8;
    }
}

/* ===========================================================================
 * Flush the bit buffer and align the output on a byte boundary
 */
local void bi_windup(s)
    deflate_state *s;
{
    if (s->bi_valid > 8) {
        put_short(s, s->bi_buf);
    } else if (s->bi_valid > 0) {
        put_byte(s, (Byte)s->bi_buf);
    }
    s->bi_buf = 0;
    s->bi_valid = 0;
#ifdef DEBUG
    s->bits_sent = (s->bits_sent+7) & ~7;
#endif
}

/* ===========================================================================
 * Copy a stored block, storing first the length and its
 * one's complement if requested.
 */
local void copy_block(s, buf, len, header)
    deflate_state *s;
    charf    *buf;    /* the input data */
    unsigned len;     /* its length */
    int      header;  /* true if block header must be written */
{
    bi_windup(s);        /* align on byte boundary */

    if (header) {
        put_short(s, (ush)len);
        put_short(s, (ush)~len);
#ifdef DEBUG
        s->bits_sent += 2*16;
#endif
    }
#ifdef DEBUG
    s->bits_sent += (ulg)len<<3;
#endif
    while (len--) {
        put_byte(s, *buf++);
    }
}

/***********************************************************************
ZLIB\ZUTIL.C
***********************************************************************/
/* zutil.c -- target dependent utility functions for the compression library
 * Copyright (C) 1995-2005, 2010, 2011, 2012 Jean-loup Gailly.
 * For conditions of distribution and use, see copyright notice in zlib.h
 */

/* @(#) $Id$ */

#ifndef Z_SOLO
#  include "gzguts.h"
#endif

#ifndef NO_DUMMY_DECL
struct internal_state      {int dummy;}; /* for buggy compilers */
#endif

z_const char * const z_errmsg[10] = {
"need dictionary",     /* Z_NEED_DICT       2  */
"stream end",          /* Z_STREAM_END      1  */
"",                    /* Z_OK              0  */
"file error",          /* Z_ERRNO         (-1) */
"stream error",        /* Z_STREAM_ERROR  (-2) */
"data error",          /* Z_DATA_ERROR    (-3) */
"insufficient memory", /* Z_MEM_ERROR     (-4) */
"buffer error",        /* Z_BUF_ERROR     (-5) */
"incompatible version",/* Z_VERSION_ERROR (-6) */
""};


const char * ZEXPORT zlibVersion()
{
    return ZLIB_VERSION;
}

uLong ZEXPORT zlibCompileFlags()
{
    uLong flags;

    flags = 0;
    switch ((int)(sizeof(uInt))) {
    case 2:     break;
    case 4:     flags += 1;     break;
    case 8:     flags += 2;     break;
    default:    flags += 3;
    }
    switch ((int)(sizeof(uLong))) {
    case 2:     break;
    case 4:     flags += 1 << 2;        break;
    case 8:     flags += 2 << 2;        break;
    default:    flags += 3 << 2;
    }
    switch ((int)(sizeof(voidpf))) {
    case 2:     break;
    case 4:     flags += 1 << 4;        break;
    case 8:     flags += 2 << 4;        break;
    default:    flags += 3 << 4;
    }
    switch ((int)(sizeof(z_off_t))) {
    case 2:     break;
    case 4:     flags += 1 << 6;        break;
    case 8:     flags += 2 << 6;        break;
    default:    flags += 3 << 6;
    }
#ifdef DEBUG
    flags += 1 << 8;
#endif
#if defined(ASMV) || defined(ASMINF)
    flags += 1 << 9;
#endif
#ifdef ZLIB_WINAPI
    flags += 1 << 10;
#endif
#ifdef BUILDFIXED
    flags += 1 << 12;
#endif
#ifdef DYNAMIC_CRC_TABLE
    flags += 1 << 13;
#endif
#ifdef NO_GZCOMPRESS
    flags += 1L << 16;
#endif
#ifdef NO_GZIP
    flags += 1L << 17;
#endif
#ifdef PKZIP_BUG_WORKAROUND
    flags += 1L << 20;
#endif
#ifdef FASTEST
    flags += 1L << 21;
#endif
#if defined(STDC) || defined(Z_HAVE_STDARG_H)
#  ifdef NO_vsnprintf
    flags += 1L << 25;
#    ifdef HAS_vsprintf_void
    flags += 1L << 26;
#    endif
#  else
#    ifdef HAS_vsnprintf_void
    flags += 1L << 26;
#    endif
#  endif
#else
    flags += 1L << 24;
#  ifdef NO_snprintf
    flags += 1L << 25;
#    ifdef HAS_sprintf_void
    flags += 1L << 26;
#    endif
#  else
#    ifdef HAS_snprintf_void
    flags += 1L << 26;
#    endif
#  endif
#endif
    return flags;
}

#ifdef DEBUG

#  ifndef verbose
#    define verbose 0
#  endif
int ZLIB_INTERNAL z_verbose = verbose;

void ZLIB_INTERNAL z_error (m)
    char *m;
{
    fprintf(stderr, "%s\n", m);
    exit(1);
}
#endif

/* exported to allow conversion of error code to string for compress() and
 * uncompress()
 */
const char * ZEXPORT zError(err)
    int err;
{
    return ERR_MSG(err);
}

#if defined(_WIN32_WCE)
    /* The Microsoft C Run-Time Library for Windows CE doesn't have
     * errno.  We define it as a global variable to simplify porting.
     * Its value is always 0 and should not be used.
     */
    int errno = 0;
#endif

#ifndef HAVE_MEMCPY

void ZLIB_INTERNAL zmemcpy(dest, source, len)
    Bytef* dest;
    const Bytef* source;
    uInt  len;
{
    if (len == 0) return;
    do {
        *dest++ = *source++; /* ??? to be unrolled */
    } while (--len != 0);
}

int ZLIB_INTERNAL zmemcmp(s1, s2, len)
    const Bytef* s1;
    const Bytef* s2;
    uInt  len;
{
    uInt j;

    for (j = 0; j < len; j++) {
        if (s1[j] != s2[j]) return 2*(s1[j] > s2[j])-1;
    }
    return 0;
}

void ZLIB_INTERNAL zmemzero(dest, len)
    Bytef* dest;
    uInt  len;
{
    if (len == 0) return;
    do {
        *dest++ = 0;  /* ??? to be unrolled */
    } while (--len != 0);
}
#endif

#ifndef Z_SOLO

#ifdef SYS16BIT

#ifdef __TURBOC__
/* Turbo C in 16-bit mode */

#  define MY_ZCALLOC

/* Turbo C malloc() does not allow dynamic allocation of 64K bytes
 * and farmalloc(64K) returns a pointer with an offset of 8, so we
 * must fix the pointer. Warning: the pointer must be put back to its
 * original form in order to free it, use zcfree().
 */

#define MAX_PTR 10
/* 10*64K = 640K */

local int next_ptr = 0;

typedef struct ptr_table_s {
    voidpf org_ptr;
    voidpf new_ptr;
} ptr_table;

local ptr_table table[MAX_PTR];
/* This table is used to remember the original form of pointers
 * to large buffers (64K). Such pointers are normalized with a zero offset.
 * Since MSDOS is not a preemptive multitasking OS, this table is not
 * protected from concurrent access. This hack doesn't work anyway on
 * a protected system like OS/2. Use Microsoft C instead.
 */

voidpf ZLIB_INTERNAL zcalloc (voidpf opaque, unsigned items, unsigned size)
{
    voidpf buf = opaque; /* just to make some compilers happy */
    ulg bsize = (ulg)items*size;

    /* If we allocate less than 65520 bytes, we assume that farmalloc
     * will return a usable pointer which doesn't have to be normalized.
     */
    if (bsize < 65520L) {
        buf = farmalloc(bsize);
        if (*(ush*)&buf != 0) return buf;
    } else {
        buf = farmalloc(bsize + 16L);
    }
    if (buf == NULL || next_ptr >= MAX_PTR) return NULL;
    table[next_ptr].org_ptr = buf;

    /* Normalize the pointer to seg:0 */
    *((ush*)&buf+1) += ((ush)((uch*)buf-0) + 15) >> 4;
    *(ush*)&buf = 0;
    table[next_ptr++].new_ptr = buf;
    return buf;
}

void ZLIB_INTERNAL zcfree (voidpf opaque, voidpf ptr)
{
    int n;
    if (*(ush*)&ptr != 0) { /* object < 64K */
        farfree(ptr);
        return;
    }
    /* Find the original pointer */
    for (n = 0; n < next_ptr; n++) {
        if (ptr != table[n].new_ptr) continue;

        farfree(table[n].org_ptr);
        while (++n < next_ptr) {
            table[n-1] = table[n];
        }
        next_ptr--;
        return;
    }
    ptr = opaque; /* just to make some compilers happy */
    Assert(0, "zcfree: ptr not found");
}

#endif /* __TURBOC__ */


#ifdef M_I86
/* Microsoft C in 16-bit mode */

#  define MY_ZCALLOC

#if (!defined(_MSC_VER) || (_MSC_VER <= 600))
#  define _halloc  halloc
#  define _hfree   hfree
#endif

voidpf ZLIB_INTERNAL zcalloc (voidpf opaque, uInt items, uInt size)
{
    if (opaque) opaque = 0; /* to make compiler happy */
    return _halloc((long)items, size);
}

void ZLIB_INTERNAL zcfree (voidpf opaque, voidpf ptr)
{
    if (opaque) opaque = 0; /* to make compiler happy */
    _hfree(ptr);
}

#endif /* M_I86 */

#endif /* SYS16BIT */


#ifndef MY_ZCALLOC /* Any system without a special alloc function */

#ifndef STDC
extern voidp  malloc OF((uInt size));
extern voidp  calloc OF((uInt items, uInt size));
extern void   free   OF((voidpf ptr));
#endif

voidpf ZLIB_INTERNAL zcalloc (opaque, items, size)
    voidpf opaque;
    unsigned items;
    unsigned size;
{
    if (opaque) items += size - size; /* make compiler happy */
    return sizeof(uInt) > 2 ? (voidpf)malloc(items * size) :
                              (voidpf)calloc(items, size);
}

void ZLIB_INTERNAL zcfree (opaque, ptr)
    voidpf opaque;
    voidpf ptr;
{
    free(ptr);
    if (opaque) return; /* make compiler happy */
}

#endif /* MY_ZCALLOC */

#endif /* !Z_SOLO */
