pipeline EnginePipeline
{
    [Pinned]
    [Packed]
    input world rootVert;
    
    [Pinned]
    [InterfaceBlockIndex: "0"]
    input world modelTransform;
   
    [Pinned]
    [InterfaceBlockIndex: "1"]
    input world viewUniform;
    
    [Pinned]
    [InterfaceBlockIndex: "2"]
    input world perInstanceUniform;
    
    world vs;
    world tcs;
    world perCornerPoint;
    world perPatch;
    world tes;
    world fs;
    
    require @tes vec4 projCoord; 
    require @tcs vec2 tessLevelInner;
    require @tcs vec4 tessLevelOutter;
    extern @vs Uniform<perInstanceUniform> instanceUniformBlock;
    extern @(fs*, tcs*, tes*, perPatch*) Uniform<perInstanceUniform> instanceUniformBlock;
    
    import(perInstanceUniform->vs) uniformImport() { return instanceUniformBlock; }
    import(perInstanceUniform->fs) uniformImport() { return instanceUniformBlock; }
    import(perInstanceUniform->tcs) uniformImport() { return instanceUniformBlock; }
    import(perInstanceUniform->tes) uniformImport() { return instanceUniformBlock; }
    import(perInstanceUniform->perPatch) uniformImport() { return instanceUniformBlock; }
    

    extern @vs Uniform<viewUniform> viewUniformBlock;
    extern @(fs*, tcs*, tes*, perPatch*) Uniform<viewUniform> viewUniformBlock;
    
    import(viewUniform->vs) uniformImport() { return viewUniformBlock; }
    import(viewUniform->fs) uniformImport() { return viewUniformBlock; }
    import(viewUniform->tcs) uniformImport() { return viewUniformBlock; }
    import(viewUniform->tes) uniformImport() { return viewUniformBlock; }
    import(viewUniform->perPatch) uniformImport() { return viewUniformBlock; }
    
    
    extern @vs Uniform<modelTransform> modelUniformBlock;
    extern @(fs*, tcs*, tes*, perPatch*) Uniform<modelTransform> modelUniformBlock;
    
    import(modelTransform->vs) uniformImport() { return modelUniformBlock; }
    import(modelTransform->tcs) uniformImport() { return modelUniformBlock; }
    import(modelTransform->tes) uniformImport() { return modelUniformBlock; }
    import(modelTransform->perPatch) uniformImport() { return modelUniformBlock; }
    
    import(modelTransform->fs) uniformImport() { return modelUniformBlock; }
    
    extern @vs rootVert vertAttribs;
    import(rootVert->vs) vertexImport() { return vertAttribs; }
    
    // implicit import operator vs->perCornerPoint
    extern @perCornerPoint vs[] vs_tcs;
    [PerCornerIterator]
    extern @perCornerPoint int sysLocalIterator;
    import (vs->perCornerPoint) standardImport()
    {
        return vs_tcs[sysLocalIterator];
    } 
    
    // implicit import operator tes->fs
    extern @fs tes tes_fs;
    import(tes->fs) standardImport()
    {
        return tes_fs;
    } 
    
    //extern @fs vs vertexOutputBlock;
    //import(vs->fs) standardImport() { return vertexOutputBlock; }
    
    stage vs : VertexShader
    {
        VertexInput: vertAttribs;
        //Position: projCoord;
        World: vs;
    }
    stage fs : FragmentShader
    {
        World: fs;
        VSInput: vertexOutputBlock;
    }
    
    extern @tcs vs[] vs_tcs;
    extern @perPatch vs[] vs_tcs;
    [InvocationID]
    extern @tcs vs invocationId;
    import(vs->tcs) indexImport(int id)
    {
        return vs_tcs[id];
    }
    import(vs->perPatch) indexImport(int id)
    {
        return vs_tcs[id];
    }
    extern @tes tcs[] tcs_tes;
    import(tcs->tes) indexImport(int id)
    {
        return tcs_tes[id];
    }
    extern @tes Patch<perPatch> perPatch_tes;
    import (perPatch->tes) standardImport()
    {
        return perPatch_tes;
    }
    
    extern @tes Patch<perCornerPoint[3]> perCorner_tes;
    [TessCoord]
    extern @tes vec3 tessCoord;
    import(perCornerPoint->tes) standardImport()
    {
        return perCorner_tes[0] * tessCoord.x +
               perCorner_tes[1] * tessCoord.y +
               perCorner_tes[2] * tessCoord.z;
    }
    
    stage TCS : HullShader
    {
        PatchWorld: perPatch;
        ControlPointWorld: tcs;
        CornerPointWorld: perCornerPoint;
        ControlPointCount: 1;
        Domain: triangles;
        TessLevelOutter: tessLevelOutter;
        TessLevelInner: tessLevelInner;
    }
    
    stage TES : DomainShader
    {
        World : tes;
        Position : projCoord;
        Domain: triangles;
    }
}

module MeshVertex
{
    public @rootVert vec3 vertPos;
    public @rootVert vec3 vertTangent;
    public @rootVert vec3 vertNormal;
    public @rootVert vec2 vertUV0;
}

module SurfacePattern
{
    require @viewUniform sampler2D testSampler;
    public vec3 albedo = vec3(0.9, 0.45, 0.05) + texture(testSampler, vec2(0.0)).xyz;
    public vec3 normal = vec3(0.0, 0.0, 1.0)+ texture(testSampler, vec2(3.0)).xyz;
    public float specular = 1.0;
    public float roughness = 0.5;
    public float metallic = 0.4;
}

shader StaticMeshForwardLighting
{
    public using SystemUniforms;
    public using MeshVertex;
    public inline vec2 vertUV = vertUV0;
    public using PN_Tessellation;
    public using VertexTransform;
    public using SurfacePattern;
    vec3 lightParam = vec3(roughness, metallic, specular);
    using transformedNormal = TangentSpaceTransform(normal);
    using lighting = Lighting(transformedNormal.normal);
    public out @fs vec4 outputColor = vec4(lighting.result, 1.0);
}

module SystemUniforms
{
    public @viewUniform mat4 viewTransform;
    public @viewUniform mat4 viewProjectionTransform;
    public @viewUniform mat4 invViewTransform;
    public @viewUniform mat4 invViewProjTransform;
    public @viewUniform vec3 cameraPos;
    [Binding:"1"]
    public @viewUniform sampler2D testSampler;
    public vec3 lightDir = vec3(1.0, 1.0, 0.0);
    public vec3 lightColor = vec3(1.5, 1.5, 1.5);
}

module VertexTransform
{
    require vec3 objPos;
    require vec3 vertTangent;
    require vec3 vertNormal;
    require mat4 viewProjectionTransform;
    @modelTransform mat4 modelMatrix; 
    @modelTransform mat4 normalMatrix;
    
    vec4 position = modelMatrix * vec4(objPos, 1); 
    public @tes vec4 projCoord = viewProjectionTransform * position;
    public vec3 pos = position.xyz;
    public vec3 vNormal = (normalMatrix * vec4(vertNormal, 0.0)).xyz;
    public vec3 vTangent = (normalMatrix * vec4(vertTangent, 0.0)).xyz;
    public vec3 vBiTangent = cross(vTangent, vNormal);
}


module TangentSpaceTransform
{
    require vec3 normal_in;
    require vec3 vNormal;
    require vec3 vTangent;
    require vec3 vBiTangent;
    public vec3 normal = normalize(normal_in.x * vTangent 
        + normal_in.y * vBiTangent 
        + normal_in.z * vNormal);
}


float Pow4(float x)
{
    return (x*x)*(x*x);
}

vec2 LightingFuncGGX_FV(float dotLH, float roughness)
{
    float alpha = roughness*roughness;/*sf*/

    // F
    float F_a, F_b;
    float dotLH5 = Pow4(1.0-dotLH) * (1.0 - dotLH);
    F_a = 1.0;
    F_b = dotLH5;

    // V
    float vis;
    float k = alpha/2.0;
    float k2 = k*k;
    float invK2 = 1.0-k2;
    vis = 1.0/(dotLH*dotLH*invK2 + k2);

    return vec2(F_a*vis, F_b*vis);
}

float LightingFuncGGX_D(float dotNH, float roughness)
{
    float alpha = roughness*roughness;
    float alphaSqr = alpha*alpha;
    float pi = 3.14159;
    float denom = dotNH * dotNH *(alphaSqr-1.0) + 1.0;

    float D = alphaSqr/(pi * denom * denom);
    return D;
}

module PN_Tessellation
{
    require @vs vec3 vertPos;
    require @vs vec3 vertNormal;
    
    public @tcs vec4 tessLevelOutter = vec4(4, 4, 4, 0);
    public @tcs vec2 tessLevelInner = vec2(4.0);
    
    @tcs vec3 WorldPos_B030 = indexImport(vertPos, 0);
    @tcs vec3 WorldPos_B003 = indexImport(vertPos, 1);
    @tcs vec3 WorldPos_B300 = indexImport(vertPos, 2);

    // Edges are names according to the opposing vertex
    vec3 EdgeB300 = WorldPos_B003 - WorldPos_B030;
    vec3 EdgeB030 = WorldPos_B300 - WorldPos_B003;
    vec3 EdgeB003 = WorldPos_B030 - WorldPos_B300;

    // Generate two midpoints on each edge
    vec3 WorldPos_B021t = WorldPos_B030 + EdgeB300 / 3.0;
    vec3 WorldPos_B012t = WorldPos_B030 + EdgeB300 * 2.0 / 3.0;
    vec3 WorldPos_B102t = WorldPos_B003 + EdgeB030 / 3.0;
    vec3 WorldPos_B201t = WorldPos_B003 + EdgeB030 * 2.0 / 3.0;
    vec3 WorldPos_B210t = WorldPos_B300 + EdgeB003 / 3.0;
    vec3 WorldPos_B120t = WorldPos_B300 + EdgeB003 * 2.0 / 3.0;

    // Project each midpoint on the plane defined by the nearest vertex and its normal
    @tcs vec3 WorldPos_B021 = ProjectToPlane(WorldPos_B021t, WorldPos_B030,
                                          indexImport(vertNormal, 0));
    @tcs vec3 WorldPos_B012 = ProjectToPlane(WorldPos_B012t, WorldPos_B003,
                                         indexImport(vertNormal, 1));
    @tcs vec3 WorldPos_B102 = ProjectToPlane(WorldPos_B102t, WorldPos_B003,
                                         indexImport(vertNormal, 2));
    @tcs vec3 WorldPos_B201 = ProjectToPlane(WorldPos_B201t, WorldPos_B300,
                                         indexImport(vertNormal, 0));
    @tcs vec3 WorldPos_B210 = ProjectToPlane(WorldPos_B210t, WorldPos_B300,
                                         indexImport(vertNormal, 1));
    @tcs vec3 WorldPos_B120 = ProjectToPlane(WorldPos_B120t, WorldPos_B030,
                                         indexImport(vertNormal, 2));

    // Handle the center
    vec3 Center = (WorldPos_B003 + WorldPos_B030 + WorldPos_B300) / 3.0;
    vec3 WorldPos_B111t = (WorldPos_B021 + WorldPos_B012 + WorldPos_B102 +
                          WorldPos_B201 + WorldPos_B210 + WorldPos_B120) / 6.0;
    vec3 WorldPos_B111 = (WorldPos_B111t - Center) / 2.0;

    
    float u = tessCoord.x;
    float v = tessCoord.y;
    float w = tessCoord.z;

    float uPow3 = pow(u, 3);
    float vPow3 = pow(v, 3);
    float wPow3 = pow(w, 3);
    float uPow2 = pow(u, 2);
    float vPow2 = pow(v, 2);
    float wPow2 = pow(w, 2);

    public @tes vec3 objPos = indexImport(WorldPos_B300, 0) * wPow3 +
                    indexImport(WorldPos_B030, 0) * uPow3 +
                    indexImport(WorldPos_B003, 0) * vPow3 +
                    indexImport(WorldPos_B210, 0) * 3.0 * wPow2 * u +
                    indexImport(WorldPos_B120, 0) * 3.0 * w * uPow2 +
                    indexImport(WorldPos_B201, 0) * 3.0 * wPow2 * v +
                    indexImport(WorldPos_B021, 0) * 3.0 * uPow2 * v +
                    indexImport(WorldPos_B102, 0) * 3.0 * w * vPow2 +
                    indexImport(WorldPos_B012, 0) * 3.0 * u * vPow2 +
                    indexImport(WorldPos_B111, 0) * 6.0 * w * u * v;
}

vec3 ProjectToPlane(vec3 Point, vec3 PlanePoint, vec3 PlaneNormal)
{
    vec3 v = Point - PlanePoint;
    float Len = dot(v, PlaneNormal);
    vec3 d = Len * PlaneNormal;
    return (Point - d);
} 

module Lighting
{
    require vec3 normal;   
    require vec3 albedo;
    require vec3 lightParam;
    require vec3 pos;
    require vec3 lightDir;
    require vec3 lightColor;
    require vec3 cameraPos;
    float shadow = 1.0;
    float brightness = clamp(dot(lightDir, normal), 0.0, 1.0) * shadow;
    vec3 view = normalize(cameraPos - pos);
    inline float roughness_in = lightParam.x;
    inline float metallic_in = lightParam.y;
    inline float specular_in = lightParam.z;
    vec3 L = lightDir;
    vec3 H = normalize(view+L);
    float dotNL = clamp(dot(normal,L), 0.01, 0.99);
    float dotLH = clamp(dot(L,H), 0.01, 0.99);
    float dotNH = clamp(dot(normal,H), 0.01, 0.99);
    float highlight : phongStandard
    {
        float alpha = roughness_in*roughness_in;
        float p = 6.644/(alpha*alpha) - 6.644;
        float pi = 3.14159;
        return dotNL *exp2(p * dotNH - p) / (pi * (alpha*alpha)) * specular_in;
    }
    float highlight : GGXstandard
    {
        float D = LightingFuncGGX_D(dotNH,roughness_in);
        vec2 FV_helper = LightingFuncGGX_FV(dotLH,roughness_in);
        float FV = metallic_in*FV_helper.x + (1.0-metallic_in)*FV_helper.y;
        float specular = dotNL * D * FV * specular_in;
        return specular;
    }
    public vec3 result = lightColor * 
                        (albedo * (brightness + 0.7)*(1.0-metallic_in) + 
                        mix(albedo, vec3(1.0), 1.0 - metallic_in) * (highlight * shadow));
}
